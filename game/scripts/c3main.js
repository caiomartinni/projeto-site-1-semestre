// Generated by Construct, the game and animation creation tool
// Visit: https://www.construct.net

{
    let _t = function(t) {
        i = t;
    }, Et = function(t) {
        return t * h;
    }, Dt = function(t, i) {
        return Math.abs(t - i) <= s * Math.max(1, Math.abs(t), Math.abs(i));
    }, At = function() {
        var t = new i(4);
        return i != Float32Array && (t[1] = 0, t[2] = 0), t[0] = 1, t[3] = 1, t;
    }, Nt = function(t) {
        var s = new i(4);
        return s[0] = t[0], s[1] = t[1], s[2] = t[2], s[3] = t[3], s;
    }, Lt = function(t, s) {
        return t[0] = s[0], t[1] = s[1], t[2] = s[2], t[3] = s[3], t;
    }, Ot = function(t) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t;
    }, Rt = function(t, s, e, n) {
        var h = new i(4);
        return h[0] = t, h[1] = s, h[2] = e, h[3] = n, h;
    }, Pt = function(t, s, i, e, n) {
        return t[0] = s, t[1] = i, t[2] = e, t[3] = n, t;
    }, kt = function(t, s) {
        if (t === s) {
            var i = s[1];
            t[1] = s[2], t[2] = i;
        } else t[0] = s[0], t[1] = s[2], t[2] = s[1], t[3] = s[3];
        return t;
    }, Ft = function(t, s) {
        var i = s[0], e = s[1], n = s[2], h = s[3], r = i * h - n * e;
        return r ? (r = 1 / r, t[0] = h * r, t[1] = -e * r, t[2] = -n * r, t[3] = i * r, 
        t) : null;
    }, jt = function(t, s) {
        var i = s[0];
        return t[0] = s[3], t[1] = -s[1], t[2] = -s[2], t[3] = i, t;
    }, Bt = function(t) {
        return t[0] * t[3] - t[2] * t[1];
    }, zt = function(t, s, i) {
        var e = s[0], n = s[1], h = s[2], r = s[3], o = i[0], a = i[1], u = i[2], l = i[3];
        return t[0] = e * o + h * a, t[1] = n * o + r * a, t[2] = e * u + h * l, t[3] = n * u + r * l, 
        t;
    }, Ut = function(t, s, i) {
        var e = s[0], n = s[1], h = s[2], r = s[3], o = Math.sin(i), a = Math.cos(i);
        return t[0] = e * a + h * o, t[1] = n * a + r * o, t[2] = e * -o + h * a, t[3] = n * -o + r * a, 
        t;
    }, Wt = function(t, s, i) {
        var e = s[0], n = s[1], h = s[2], r = s[3], o = i[0], a = i[1];
        return t[0] = e * o, t[1] = n * o, t[2] = h * a, t[3] = r * a, t;
    }, Jt = function(t, s) {
        var i = Math.sin(s), e = Math.cos(s);
        return t[0] = e, t[1] = i, t[2] = -i, t[3] = e, t;
    }, Qt = function(t, s) {
        return t[0] = s[0], t[1] = 0, t[2] = 0, t[3] = s[1], t;
    }, Yt = function(t) {
        return "mat2(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")";
    }, Vt = function(t) {
        return Math.hypot(t[0], t[1], t[2], t[3]);
    }, Ht = function(t, s, i, e) {
        return t[2] = e[2] / e[0], i[0] = e[0], i[1] = e[1], i[3] = e[3] - t[2] * i[1], 
        [ t, s, i ];
    }, qt = function(t, s, i) {
        return t[0] = s[0] + i[0], t[1] = s[1] + i[1], t[2] = s[2] + i[2], t[3] = s[3] + i[3], 
        t;
    }, Xt = function(t, s, i) {
        return t[0] = s[0] - i[0], t[1] = s[1] - i[1], t[2] = s[2] - i[2], t[3] = s[3] - i[3], 
        t;
    }, Zt = function(t, s) {
        return t[0] === s[0] && t[1] === s[1] && t[2] === s[2] && t[3] === s[3];
    }, Kt = function(t, i) {
        var e = t[0], n = t[1], h = t[2], r = t[3], o = i[0], a = i[1], u = i[2], l = i[3];
        return Math.abs(e - o) <= s * Math.max(1, Math.abs(e), Math.abs(o)) && Math.abs(n - a) <= s * Math.max(1, Math.abs(n), Math.abs(a)) && Math.abs(h - u) <= s * Math.max(1, Math.abs(h), Math.abs(u)) && Math.abs(r - l) <= s * Math.max(1, Math.abs(r), Math.abs(l));
    }, $t = function(t, s, i) {
        return t[0] = s[0] * i, t[1] = s[1] * i, t[2] = s[2] * i, t[3] = s[3] * i, t;
    }, ts = function(t, s, i, e) {
        return t[0] = s[0] + i[0] * e, t[1] = s[1] + i[1] * e, t[2] = s[2] + i[2] * e, t[3] = s[3] + i[3] * e, 
        t;
    }, ss = function() {
        var t = new i(6);
        return i != Float32Array && (t[1] = 0, t[2] = 0, t[4] = 0, t[5] = 0), t[0] = 1, 
        t[3] = 1, t;
    }, is = function(t) {
        var s = new i(6);
        return s[0] = t[0], s[1] = t[1], s[2] = t[2], s[3] = t[3], s[4] = t[4], s[5] = t[5], 
        s;
    }, es = function(t, s) {
        return t[0] = s[0], t[1] = s[1], t[2] = s[2], t[3] = s[3], t[4] = s[4], t[5] = s[5], 
        t;
    }, ns = function(t) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t;
    }, hs = function(t, s, e, n, h, r) {
        var o = new i(6);
        return o[0] = t, o[1] = s, o[2] = e, o[3] = n, o[4] = h, o[5] = r, o;
    }, rs = function(t, s, i, e, n, h, r) {
        return t[0] = s, t[1] = i, t[2] = e, t[3] = n, t[4] = h, t[5] = r, t;
    }, os = function(t, s) {
        var i = s[0], e = s[1], n = s[2], h = s[3], r = s[4], o = s[5], a = i * h - e * n;
        return a ? (a = 1 / a, t[0] = h * a, t[1] = -e * a, t[2] = -n * a, t[3] = i * a, 
        t[4] = (n * o - h * r) * a, t[5] = (e * r - i * o) * a, t) : null;
    }, as = function(t) {
        return t[0] * t[3] - t[1] * t[2];
    }, us = function(t, s, i) {
        var e = s[0], n = s[1], h = s[2], r = s[3], o = s[4], a = s[5], u = i[0], l = i[1], c = i[2], f = i[3], d = i[4], p = i[5];
        return t[0] = e * u + h * l, t[1] = n * u + r * l, t[2] = e * c + h * f, t[3] = n * c + r * f, 
        t[4] = e * d + h * p + o, t[5] = n * d + r * p + a, t;
    }, ls = function(t, s, i) {
        var e = s[0], n = s[1], h = s[2], r = s[3], o = s[4], a = s[5], u = Math.sin(i), l = Math.cos(i);
        return t[0] = e * l + h * u, t[1] = n * l + r * u, t[2] = e * -u + h * l, t[3] = n * -u + r * l, 
        t[4] = o, t[5] = a, t;
    }, cs = function(t, s, i) {
        var e = s[0], n = s[1], h = s[2], r = s[3], o = s[4], a = s[5], u = i[0], l = i[1];
        return t[0] = e * u, t[1] = n * u, t[2] = h * l, t[3] = r * l, t[4] = o, t[5] = a, 
        t;
    }, fs = function(t, s, i) {
        var e = s[0], n = s[1], h = s[2], r = s[3], o = s[4], a = s[5], u = i[0], l = i[1];
        return t[0] = e, t[1] = n, t[2] = h, t[3] = r, t[4] = e * u + h * l + o, t[5] = n * u + r * l + a, 
        t;
    }, ds = function(t, s) {
        var i = Math.sin(s), e = Math.cos(s);
        return t[0] = e, t[1] = i, t[2] = -i, t[3] = e, t[4] = 0, t[5] = 0, t;
    }, ps = function(t, s) {
        return t[0] = s[0], t[1] = 0, t[2] = 0, t[3] = s[1], t[4] = 0, t[5] = 0, t;
    }, ms = function(t, s) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = s[0], t[5] = s[1], t;
    }, gs = function(t) {
        return "mat2d(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ")";
    }, ys = function(t) {
        return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], 1);
    }, Ms = function(t, s, i) {
        return t[0] = s[0] + i[0], t[1] = s[1] + i[1], t[2] = s[2] + i[2], t[3] = s[3] + i[3], 
        t[4] = s[4] + i[4], t[5] = s[5] + i[5], t;
    }, ws = function(t, s, i) {
        return t[0] = s[0] - i[0], t[1] = s[1] - i[1], t[2] = s[2] - i[2], t[3] = s[3] - i[3], 
        t[4] = s[4] - i[4], t[5] = s[5] - i[5], t;
    }, Ss = function(t, s, i) {
        return t[0] = s[0] * i, t[1] = s[1] * i, t[2] = s[2] * i, t[3] = s[3] * i, t[4] = s[4] * i, 
        t[5] = s[5] * i, t;
    }, bs = function(t, s, i, e) {
        return t[0] = s[0] + i[0] * e, t[1] = s[1] + i[1] * e, t[2] = s[2] + i[2] * e, t[3] = s[3] + i[3] * e, 
        t[4] = s[4] + i[4] * e, t[5] = s[5] + i[5] * e, t;
    }, Ts = function(t, s) {
        return t[0] === s[0] && t[1] === s[1] && t[2] === s[2] && t[3] === s[3] && t[4] === s[4] && t[5] === s[5];
    }, vs = function(t, i) {
        var e = t[0], n = t[1], h = t[2], r = t[3], o = t[4], a = t[5], u = i[0], l = i[1], c = i[2], f = i[3], d = i[4], p = i[5];
        return Math.abs(e - u) <= s * Math.max(1, Math.abs(e), Math.abs(u)) && Math.abs(n - l) <= s * Math.max(1, Math.abs(n), Math.abs(l)) && Math.abs(h - c) <= s * Math.max(1, Math.abs(h), Math.abs(c)) && Math.abs(r - f) <= s * Math.max(1, Math.abs(r), Math.abs(f)) && Math.abs(o - d) <= s * Math.max(1, Math.abs(o), Math.abs(d)) && Math.abs(a - p) <= s * Math.max(1, Math.abs(a), Math.abs(p));
    }, xs = function() {
        var t = new i(9);
        return i != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[5] = 0, t[6] = 0, t[7] = 0), 
        t[0] = 1, t[4] = 1, t[8] = 1, t;
    }, Is = function(t, s) {
        return t[0] = s[0], t[1] = s[1], t[2] = s[2], t[3] = s[4], t[4] = s[5], t[5] = s[6], 
        t[6] = s[8], t[7] = s[9], t[8] = s[10], t;
    }, Gs = function(t) {
        var s = new i(9);
        return s[0] = t[0], s[1] = t[1], s[2] = t[2], s[3] = t[3], s[4] = t[4], s[5] = t[5], 
        s[6] = t[6], s[7] = t[7], s[8] = t[8], s;
    }, Cs = function(t, s) {
        return t[0] = s[0], t[1] = s[1], t[2] = s[2], t[3] = s[3], t[4] = s[4], t[5] = s[5], 
        t[6] = s[6], t[7] = s[7], t[8] = s[8], t;
    }, _s = function(t, s, e, n, h, r, o, a, u) {
        var l = new i(9);
        return l[0] = t, l[1] = s, l[2] = e, l[3] = n, l[4] = h, l[5] = r, l[6] = o, l[7] = a, 
        l[8] = u, l;
    }, Es = function(t, s, i, e, n, h, r, o, a, u) {
        return t[0] = s, t[1] = i, t[2] = e, t[3] = n, t[4] = h, t[5] = r, t[6] = o, t[7] = a, 
        t[8] = u, t;
    }, Ds = function(t) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, 
        t[8] = 1, t;
    }, As = function(t, s) {
        if (t === s) {
            var i = s[1], e = s[2], n = s[5];
            t[1] = s[3], t[2] = s[6], t[3] = i, t[5] = s[7], t[6] = e, t[7] = n;
        } else t[0] = s[0], t[1] = s[3], t[2] = s[6], t[3] = s[1], t[4] = s[4], t[5] = s[7], 
        t[6] = s[2], t[7] = s[5], t[8] = s[8];
        return t;
    }, Ns = function(t, s) {
        var i = s[0], e = s[1], n = s[2], h = s[3], r = s[4], o = s[5], a = s[6], u = s[7], l = s[8], c = l * r - o * u, f = -l * h + o * a, d = u * h - r * a, p = i * c + e * f + n * d;
        return p ? (p = 1 / p, t[0] = c * p, t[1] = (-l * e + n * u) * p, t[2] = (o * e - n * r) * p, 
        t[3] = f * p, t[4] = (l * i - n * a) * p, t[5] = (-o * i + n * h) * p, t[6] = d * p, 
        t[7] = (-u * i + e * a) * p, t[8] = (r * i - e * h) * p, t) : null;
    }, Ls = function(t, s) {
        var i = s[0], e = s[1], n = s[2], h = s[3], r = s[4], o = s[5], a = s[6], u = s[7], l = s[8];
        return t[0] = r * l - o * u, t[1] = n * u - e * l, t[2] = e * o - n * r, t[3] = o * a - h * l, 
        t[4] = i * l - n * a, t[5] = n * h - i * o, t[6] = h * u - r * a, t[7] = e * a - i * u, 
        t[8] = i * r - e * h, t;
    }, Os = function(t) {
        var s = t[0], i = t[1], e = t[2], n = t[3], h = t[4], r = t[5], o = t[6], a = t[7], u = t[8];
        return s * (u * h - r * a) + i * (-u * n + r * o) + e * (a * n - h * o);
    }, Rs = function(t, s, i) {
        var e = s[0], n = s[1], h = s[2], r = s[3], o = s[4], a = s[5], u = s[6], l = s[7], c = s[8], f = i[0], d = i[1], p = i[2], m = i[3], g = i[4], y = i[5], M = i[6], w = i[7], S = i[8];
        return t[0] = f * e + d * r + p * u, t[1] = f * n + d * o + p * l, t[2] = f * h + d * a + p * c, 
        t[3] = m * e + g * r + y * u, t[4] = m * n + g * o + y * l, t[5] = m * h + g * a + y * c, 
        t[6] = M * e + w * r + S * u, t[7] = M * n + w * o + S * l, t[8] = M * h + w * a + S * c, 
        t;
    }, Ps = function(t, s, i) {
        var e = s[0], n = s[1], h = s[2], r = s[3], o = s[4], a = s[5], u = s[6], l = s[7], c = s[8], f = i[0], d = i[1];
        return t[0] = e, t[1] = n, t[2] = h, t[3] = r, t[4] = o, t[5] = a, t[6] = f * e + d * r + u, 
        t[7] = f * n + d * o + l, t[8] = f * h + d * a + c, t;
    }, ks = function(t, s, i) {
        var e = s[0], n = s[1], h = s[2], r = s[3], o = s[4], a = s[5], u = s[6], l = s[7], c = s[8], f = Math.sin(i), d = Math.cos(i);
        return t[0] = d * e + f * r, t[1] = d * n + f * o, t[2] = d * h + f * a, t[3] = d * r - f * e, 
        t[4] = d * o - f * n, t[5] = d * a - f * h, t[6] = u, t[7] = l, t[8] = c, t;
    }, Fs = function(t, s, i) {
        var e = i[0], n = i[1];
        return t[0] = e * s[0], t[1] = e * s[1], t[2] = e * s[2], t[3] = n * s[3], t[4] = n * s[4], 
        t[5] = n * s[5], t[6] = s[6], t[7] = s[7], t[8] = s[8], t;
    }, js = function(t, s) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = s[0], 
        t[7] = s[1], t[8] = 1, t;
    }, Bs = function(t, s) {
        var i = Math.sin(s), e = Math.cos(s);
        return t[0] = e, t[1] = i, t[2] = 0, t[3] = -i, t[4] = e, t[5] = 0, t[6] = 0, t[7] = 0, 
        t[8] = 1, t;
    }, zs = function(t, s) {
        return t[0] = s[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = s[1], t[5] = 0, t[6] = 0, 
        t[7] = 0, t[8] = 1, t;
    }, Us = function(t, s) {
        return t[0] = s[0], t[1] = s[1], t[2] = 0, t[3] = s[2], t[4] = s[3], t[5] = 0, t[6] = s[4], 
        t[7] = s[5], t[8] = 1, t;
    }, Ws = function(t, s) {
        var i = s[0], e = s[1], n = s[2], h = s[3], r = i + i, o = e + e, a = n + n, u = i * r, l = e * r, c = e * o, f = n * r, d = n * o, p = n * a, m = h * r, g = h * o, y = h * a;
        return t[0] = 1 - c - p, t[3] = l - y, t[6] = f + g, t[1] = l + y, t[4] = 1 - u - p, 
        t[7] = d - m, t[2] = f - g, t[5] = d + m, t[8] = 1 - u - c, t;
    }, Js = function(t, s) {
        var i = s[0], e = s[1], n = s[2], h = s[3], r = s[4], o = s[5], a = s[6], u = s[7], l = s[8], c = s[9], f = s[10], d = s[11], p = s[12], m = s[13], g = s[14], y = s[15], M = i * o - e * r, w = i * a - n * r, S = i * u - h * r, b = e * a - n * o, T = e * u - h * o, v = n * u - h * a, x = l * m - c * p, I = l * g - f * p, G = l * y - d * p, C = c * g - f * m, _ = c * y - d * m, E = f * y - d * g, D = M * E - w * _ + S * C + b * G - T * I + v * x;
        return D ? (D = 1 / D, t[0] = (o * E - a * _ + u * C) * D, t[1] = (a * G - r * E - u * I) * D, 
        t[2] = (r * _ - o * G + u * x) * D, t[3] = (n * _ - e * E - h * C) * D, t[4] = (i * E - n * G + h * I) * D, 
        t[5] = (e * G - i * _ - h * x) * D, t[6] = (m * v - g * T + y * b) * D, t[7] = (g * S - p * v - y * w) * D, 
        t[8] = (p * T - m * S + y * M) * D, t) : null;
    }, Qs = function(t, s, i) {
        return t[0] = 2 / s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = -2 / i, t[5] = 0, t[6] = -1, 
        t[7] = 1, t[8] = 1, t;
    }, Ys = function(t) {
        return "mat3(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ")";
    }, Vs = function(t) {
        return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8]);
    }, Hs = function(t, s, i) {
        return t[0] = s[0] + i[0], t[1] = s[1] + i[1], t[2] = s[2] + i[2], t[3] = s[3] + i[3], 
        t[4] = s[4] + i[4], t[5] = s[5] + i[5], t[6] = s[6] + i[6], t[7] = s[7] + i[7], 
        t[8] = s[8] + i[8], t;
    }, qs = function(t, s, i) {
        return t[0] = s[0] - i[0], t[1] = s[1] - i[1], t[2] = s[2] - i[2], t[3] = s[3] - i[3], 
        t[4] = s[4] - i[4], t[5] = s[5] - i[5], t[6] = s[6] - i[6], t[7] = s[7] - i[7], 
        t[8] = s[8] - i[8], t;
    }, Xs = function(t, s, i) {
        return t[0] = s[0] * i, t[1] = s[1] * i, t[2] = s[2] * i, t[3] = s[3] * i, t[4] = s[4] * i, 
        t[5] = s[5] * i, t[6] = s[6] * i, t[7] = s[7] * i, t[8] = s[8] * i, t;
    }, Zs = function(t, s, i, e) {
        return t[0] = s[0] + i[0] * e, t[1] = s[1] + i[1] * e, t[2] = s[2] + i[2] * e, t[3] = s[3] + i[3] * e, 
        t[4] = s[4] + i[4] * e, t[5] = s[5] + i[5] * e, t[6] = s[6] + i[6] * e, t[7] = s[7] + i[7] * e, 
        t[8] = s[8] + i[8] * e, t;
    }, Ks = function(t, s) {
        return t[0] === s[0] && t[1] === s[1] && t[2] === s[2] && t[3] === s[3] && t[4] === s[4] && t[5] === s[5] && t[6] === s[6] && t[7] === s[7] && t[8] === s[8];
    }, $s = function(t, i) {
        var e = t[0], n = t[1], h = t[2], r = t[3], o = t[4], a = t[5], u = t[6], l = t[7], c = t[8], f = i[0], d = i[1], p = i[2], m = i[3], g = i[4], y = i[5], M = i[6], w = i[7], S = i[8];
        return Math.abs(e - f) <= s * Math.max(1, Math.abs(e), Math.abs(f)) && Math.abs(n - d) <= s * Math.max(1, Math.abs(n), Math.abs(d)) && Math.abs(h - p) <= s * Math.max(1, Math.abs(h), Math.abs(p)) && Math.abs(r - m) <= s * Math.max(1, Math.abs(r), Math.abs(m)) && Math.abs(o - g) <= s * Math.max(1, Math.abs(o), Math.abs(g)) && Math.abs(a - y) <= s * Math.max(1, Math.abs(a), Math.abs(y)) && Math.abs(u - M) <= s * Math.max(1, Math.abs(u), Math.abs(M)) && Math.abs(l - w) <= s * Math.max(1, Math.abs(l), Math.abs(w)) && Math.abs(c - S) <= s * Math.max(1, Math.abs(c), Math.abs(S));
    }, ti = function() {
        var t = new i(16);
        return i != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[6] = 0, t[7] = 0, 
        t[8] = 0, t[9] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0), t[0] = 1, t[5] = 1, 
        t[10] = 1, t[15] = 1, t;
    }, si = function(t) {
        var s = new i(16);
        return s[0] = t[0], s[1] = t[1], s[2] = t[2], s[3] = t[3], s[4] = t[4], s[5] = t[5], 
        s[6] = t[6], s[7] = t[7], s[8] = t[8], s[9] = t[9], s[10] = t[10], s[11] = t[11], 
        s[12] = t[12], s[13] = t[13], s[14] = t[14], s[15] = t[15], s;
    }, ii = function(t, s) {
        return t[0] = s[0], t[1] = s[1], t[2] = s[2], t[3] = s[3], t[4] = s[4], t[5] = s[5], 
        t[6] = s[6], t[7] = s[7], t[8] = s[8], t[9] = s[9], t[10] = s[10], t[11] = s[11], 
        t[12] = s[12], t[13] = s[13], t[14] = s[14], t[15] = s[15], t;
    }, ei = function(t, s, e, n, h, r, o, a, u, l, c, f, d, p, m, g) {
        var y = new i(16);
        return y[0] = t, y[1] = s, y[2] = e, y[3] = n, y[4] = h, y[5] = r, y[6] = o, y[7] = a, 
        y[8] = u, y[9] = l, y[10] = c, y[11] = f, y[12] = d, y[13] = p, y[14] = m, y[15] = g, 
        y;
    }, ni = function(t, s, i, e, n, h, r, o, a, u, l, c, f, d, p, m, g) {
        return t[0] = s, t[1] = i, t[2] = e, t[3] = n, t[4] = h, t[5] = r, t[6] = o, t[7] = a, 
        t[8] = u, t[9] = l, t[10] = c, t[11] = f, t[12] = d, t[13] = p, t[14] = m, t[15] = g, 
        t;
    }, hi = function(t) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, 
        t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, 
        t;
    }, ri = function(t, s) {
        if (t === s) {
            var i = s[1], e = s[2], n = s[3], h = s[6], r = s[7], o = s[11];
            t[1] = s[4], t[2] = s[8], t[3] = s[12], t[4] = i, t[6] = s[9], t[7] = s[13], t[8] = e, 
            t[9] = h, t[11] = s[14], t[12] = n, t[13] = r, t[14] = o;
        } else t[0] = s[0], t[1] = s[4], t[2] = s[8], t[3] = s[12], t[4] = s[1], t[5] = s[5], 
        t[6] = s[9], t[7] = s[13], t[8] = s[2], t[9] = s[6], t[10] = s[10], t[11] = s[14], 
        t[12] = s[3], t[13] = s[7], t[14] = s[11], t[15] = s[15];
        return t;
    }, oi = function(t, s) {
        var i = s[0], e = s[1], n = s[2], h = s[3], r = s[4], o = s[5], a = s[6], u = s[7], l = s[8], c = s[9], f = s[10], d = s[11], p = s[12], m = s[13], g = s[14], y = s[15], M = i * o - e * r, w = i * a - n * r, S = i * u - h * r, b = e * a - n * o, T = e * u - h * o, v = n * u - h * a, x = l * m - c * p, I = l * g - f * p, G = l * y - d * p, C = c * g - f * m, _ = c * y - d * m, E = f * y - d * g, D = M * E - w * _ + S * C + b * G - T * I + v * x;
        return D ? (D = 1 / D, t[0] = (o * E - a * _ + u * C) * D, t[1] = (n * _ - e * E - h * C) * D, 
        t[2] = (m * v - g * T + y * b) * D, t[3] = (f * T - c * v - d * b) * D, t[4] = (a * G - r * E - u * I) * D, 
        t[5] = (i * E - n * G + h * I) * D, t[6] = (g * S - p * v - y * w) * D, t[7] = (l * v - f * S + d * w) * D, 
        t[8] = (r * _ - o * G + u * x) * D, t[9] = (e * G - i * _ - h * x) * D, t[10] = (p * T - m * S + y * M) * D, 
        t[11] = (c * S - l * T - d * M) * D, t[12] = (o * I - r * C - a * x) * D, t[13] = (i * C - e * I + n * x) * D, 
        t[14] = (m * w - p * b - g * M) * D, t[15] = (l * b - c * w + f * M) * D, t) : null;
    }, ai = function(t, s) {
        var i = s[0], e = s[1], n = s[2], h = s[3], r = s[4], o = s[5], a = s[6], u = s[7], l = s[8], c = s[9], f = s[10], d = s[11], p = s[12], m = s[13], g = s[14], y = s[15], M = i * o - e * r, w = i * a - n * r, S = i * u - h * r, b = e * a - n * o, T = e * u - h * o, v = n * u - h * a, x = l * m - c * p, I = l * g - f * p, G = l * y - d * p, C = c * g - f * m, _ = c * y - d * m, E = f * y - d * g;
        return t[0] = o * E - a * _ + u * C, t[1] = n * _ - e * E - h * C, t[2] = m * v - g * T + y * b, 
        t[3] = f * T - c * v - d * b, t[4] = a * G - r * E - u * I, t[5] = i * E - n * G + h * I, 
        t[6] = g * S - p * v - y * w, t[7] = l * v - f * S + d * w, t[8] = r * _ - o * G + u * x, 
        t[9] = e * G - i * _ - h * x, t[10] = p * T - m * S + y * M, t[11] = c * S - l * T - d * M, 
        t[12] = o * I - r * C - a * x, t[13] = i * C - e * I + n * x, t[14] = m * w - p * b - g * M, 
        t[15] = l * b - c * w + f * M, t;
    }, ui = function(t) {
        var s = t[0], i = t[1], e = t[2], n = t[3], h = t[4], r = t[5], o = t[6], a = t[7], u = t[8], l = t[9], c = t[10], f = t[11], d = t[12], p = t[13], m = t[14], g = s * r - i * h, y = s * o - e * h, M = i * o - e * r, w = u * p - l * d, S = u * m - c * d, b = l * m - c * p;
        return a * (s * b - i * S + e * w) - n * (h * b - r * S + o * w) + t[15] * (u * M - l * y + c * g) - f * (d * M - p * y + m * g);
    }, li = function(t, s, i) {
        var e = s[0], n = s[1], h = s[2], r = s[3], o = s[4], a = s[5], u = s[6], l = s[7], c = s[8], f = s[9], d = s[10], p = s[11], m = s[12], g = s[13], y = s[14], M = s[15], w = i[0], S = i[1], b = i[2], T = i[3];
        return t[0] = w * e + S * o + b * c + T * m, t[1] = w * n + S * a + b * f + T * g, 
        t[2] = w * h + S * u + b * d + T * y, t[3] = w * r + S * l + b * p + T * M, w = i[4], 
        S = i[5], b = i[6], T = i[7], t[4] = w * e + S * o + b * c + T * m, t[5] = w * n + S * a + b * f + T * g, 
        t[6] = w * h + S * u + b * d + T * y, t[7] = w * r + S * l + b * p + T * M, w = i[8], 
        S = i[9], b = i[10], T = i[11], t[8] = w * e + S * o + b * c + T * m, t[9] = w * n + S * a + b * f + T * g, 
        t[10] = w * h + S * u + b * d + T * y, t[11] = w * r + S * l + b * p + T * M, w = i[12], 
        S = i[13], b = i[14], T = i[15], t[12] = w * e + S * o + b * c + T * m, t[13] = w * n + S * a + b * f + T * g, 
        t[14] = w * h + S * u + b * d + T * y, t[15] = w * r + S * l + b * p + T * M, t;
    }, ci = function(t, s, i) {
        var e, n, h, r, o, a, u, l, c, f, d, p, m = i[0], g = i[1], y = i[2];
        return s === t ? (t[12] = s[0] * m + s[4] * g + s[8] * y + s[12], t[13] = s[1] * m + s[5] * g + s[9] * y + s[13], 
        t[14] = s[2] * m + s[6] * g + s[10] * y + s[14], t[15] = s[3] * m + s[7] * g + s[11] * y + s[15]) : (e = s[0], 
        n = s[1], h = s[2], r = s[3], o = s[4], a = s[5], u = s[6], l = s[7], c = s[8], 
        f = s[9], d = s[10], p = s[11], t[0] = e, t[1] = n, t[2] = h, t[3] = r, t[4] = o, 
        t[5] = a, t[6] = u, t[7] = l, t[8] = c, t[9] = f, t[10] = d, t[11] = p, t[12] = e * m + o * g + c * y + s[12], 
        t[13] = n * m + a * g + f * y + s[13], t[14] = h * m + u * g + d * y + s[14], t[15] = r * m + l * g + p * y + s[15]), 
        t;
    }, fi = function(t, s, i) {
        var e = i[0], n = i[1], h = i[2];
        return t[0] = s[0] * e, t[1] = s[1] * e, t[2] = s[2] * e, t[3] = s[3] * e, t[4] = s[4] * n, 
        t[5] = s[5] * n, t[6] = s[6] * n, t[7] = s[7] * n, t[8] = s[8] * h, t[9] = s[9] * h, 
        t[10] = s[10] * h, t[11] = s[11] * h, t[12] = s[12], t[13] = s[13], t[14] = s[14], 
        t[15] = s[15], t;
    }, di = function(t, i, e, n) {
        var h, r, o, a, u, l, c, f, d, p, m, g, y, M, w, S, b, T, v, x, I, G, C, _, E = n[0], D = n[1], A = n[2], N = Math.hypot(E, D, A);
        return N < s ? null : (E *= N = 1 / N, D *= N, A *= N, h = Math.sin(e), o = 1 - (r = Math.cos(e)), 
        a = i[0], u = i[1], l = i[2], c = i[3], f = i[4], d = i[5], p = i[6], m = i[7], 
        g = i[8], y = i[9], M = i[10], w = i[11], S = E * E * o + r, b = D * E * o + A * h, 
        T = A * E * o - D * h, v = E * D * o - A * h, x = D * D * o + r, I = A * D * o + E * h, 
        G = E * A * o + D * h, C = D * A * o - E * h, _ = A * A * o + r, t[0] = a * S + f * b + g * T, 
        t[1] = u * S + d * b + y * T, t[2] = l * S + p * b + M * T, t[3] = c * S + m * b + w * T, 
        t[4] = a * v + f * x + g * I, t[5] = u * v + d * x + y * I, t[6] = l * v + p * x + M * I, 
        t[7] = c * v + m * x + w * I, t[8] = a * G + f * C + g * _, t[9] = u * G + d * C + y * _, 
        t[10] = l * G + p * C + M * _, t[11] = c * G + m * C + w * _, i !== t && (t[12] = i[12], 
        t[13] = i[13], t[14] = i[14], t[15] = i[15]), t);
    }, pi = function(t, s, i) {
        var e = Math.sin(i), n = Math.cos(i), h = s[4], r = s[5], o = s[6], a = s[7], u = s[8], l = s[9], c = s[10], f = s[11];
        return s !== t && (t[0] = s[0], t[1] = s[1], t[2] = s[2], t[3] = s[3], t[12] = s[12], 
        t[13] = s[13], t[14] = s[14], t[15] = s[15]), t[4] = h * n + u * e, t[5] = r * n + l * e, 
        t[6] = o * n + c * e, t[7] = a * n + f * e, t[8] = u * n - h * e, t[9] = l * n - r * e, 
        t[10] = c * n - o * e, t[11] = f * n - a * e, t;
    }, mi = function(t, s, i) {
        var e = Math.sin(i), n = Math.cos(i), h = s[0], r = s[1], o = s[2], a = s[3], u = s[8], l = s[9], c = s[10], f = s[11];
        return s !== t && (t[4] = s[4], t[5] = s[5], t[6] = s[6], t[7] = s[7], t[12] = s[12], 
        t[13] = s[13], t[14] = s[14], t[15] = s[15]), t[0] = h * n - u * e, t[1] = r * n - l * e, 
        t[2] = o * n - c * e, t[3] = a * n - f * e, t[8] = h * e + u * n, t[9] = r * e + l * n, 
        t[10] = o * e + c * n, t[11] = a * e + f * n, t;
    }, gi = function(t, s, i) {
        var e = Math.sin(i), n = Math.cos(i), h = s[0], r = s[1], o = s[2], a = s[3], u = s[4], l = s[5], c = s[6], f = s[7];
        return s !== t && (t[8] = s[8], t[9] = s[9], t[10] = s[10], t[11] = s[11], t[12] = s[12], 
        t[13] = s[13], t[14] = s[14], t[15] = s[15]), t[0] = h * n + u * e, t[1] = r * n + l * e, 
        t[2] = o * n + c * e, t[3] = a * n + f * e, t[4] = u * n - h * e, t[5] = l * n - r * e, 
        t[6] = c * n - o * e, t[7] = f * n - a * e, t;
    }, yi = function(t, s) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, 
        t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = s[0], t[13] = s[1], t[14] = s[2], 
        t[15] = 1, t;
    }, Mi = function(t, s) {
        return t[0] = s[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = s[1], t[6] = 0, 
        t[7] = 0, t[8] = 0, t[9] = 0, t[10] = s[2], t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, 
        t[15] = 1, t;
    }, wi = function(t, i, e) {
        var n, h, r, o = e[0], a = e[1], u = e[2], l = Math.hypot(o, a, u);
        return l < s ? null : (o *= l = 1 / l, a *= l, u *= l, n = Math.sin(i), r = 1 - (h = Math.cos(i)), 
        t[0] = o * o * r + h, t[1] = a * o * r + u * n, t[2] = u * o * r - a * n, t[3] = 0, 
        t[4] = o * a * r - u * n, t[5] = a * a * r + h, t[6] = u * a * r + o * n, t[7] = 0, 
        t[8] = o * u * r + a * n, t[9] = a * u * r - o * n, t[10] = u * u * r + h, t[11] = 0, 
        t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t);
    }, Si = function(t, s) {
        var i = Math.sin(s), e = Math.cos(s);
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = e, t[6] = i, t[7] = 0, 
        t[8] = 0, t[9] = -i, t[10] = e, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, 
        t;
    }, bi = function(t, s) {
        var i = Math.sin(s), e = Math.cos(s);
        return t[0] = e, t[1] = 0, t[2] = -i, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, 
        t[8] = i, t[9] = 0, t[10] = e, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, 
        t;
    }, Ti = function(t, s) {
        var i = Math.sin(s), e = Math.cos(s);
        return t[0] = e, t[1] = i, t[2] = 0, t[3] = 0, t[4] = -i, t[5] = e, t[6] = 0, t[7] = 0, 
        t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, 
        t;
    }, vi = function(t, s, i) {
        var e = s[0], n = s[1], h = s[2], r = s[3], o = e + e, a = n + n, u = h + h, l = e * o, c = e * a, f = e * u, d = n * a, p = n * u, m = h * u, g = r * o, y = r * a, M = r * u;
        return t[0] = 1 - (d + m), t[1] = c + M, t[2] = f - y, t[3] = 0, t[4] = c - M, t[5] = 1 - (l + m), 
        t[6] = p + g, t[7] = 0, t[8] = f + y, t[9] = p - g, t[10] = 1 - (l + d), t[11] = 0, 
        t[12] = i[0], t[13] = i[1], t[14] = i[2], t[15] = 1, t;
    }, xi = function(t, s) {
        var e = new i(3), n = -s[0], h = -s[1], r = -s[2], o = s[3], a = s[4], u = s[5], l = s[6], c = s[7], f = n * n + h * h + r * r + o * o;
        return f > 0 ? (e[0] = 2 * (a * o + c * n + u * r - l * h) / f, e[1] = 2 * (u * o + c * h + l * n - a * r) / f, 
        e[2] = 2 * (l * o + c * r + a * h - u * n) / f) : (e[0] = 2 * (a * o + c * n + u * r - l * h), 
        e[1] = 2 * (u * o + c * h + l * n - a * r), e[2] = 2 * (l * o + c * r + a * h - u * n)), 
        vi(t, s, e), t;
    }, Ii = function(t, s) {
        return t[0] = s[12], t[1] = s[13], t[2] = s[14], t;
    }, Gi = function(t, s) {
        var i = s[0], e = s[1], n = s[2], h = s[4], r = s[5], o = s[6], a = s[8], u = s[9], l = s[10];
        return t[0] = Math.hypot(i, e, n), t[1] = Math.hypot(h, r, o), t[2] = Math.hypot(a, u, l), 
        t;
    }, Ci = function(t, s) {
        var e = new i(3);
        Gi(e, s);
        var n = 1 / e[0], h = 1 / e[1], r = 1 / e[2], o = s[0] * n, a = s[1] * h, u = s[2] * r, l = s[4] * n, c = s[5] * h, f = s[6] * r, d = s[8] * n, p = s[9] * h, m = s[10] * r, g = o + c + m, y = 0;
        return g > 0 ? (y = 2 * Math.sqrt(g + 1), t[3] = .25 * y, t[0] = (f - p) / y, t[1] = (d - u) / y, 
        t[2] = (a - l) / y) : o > c && o > m ? (y = 2 * Math.sqrt(1 + o - c - m), t[3] = (f - p) / y, 
        t[0] = .25 * y, t[1] = (a + l) / y, t[2] = (d + u) / y) : c > m ? (y = 2 * Math.sqrt(1 + c - o - m), 
        t[3] = (d - u) / y, t[0] = (a + l) / y, t[1] = .25 * y, t[2] = (f + p) / y) : (y = 2 * Math.sqrt(1 + m - o - c), 
        t[3] = (a - l) / y, t[0] = (d + u) / y, t[1] = (f + p) / y, t[2] = .25 * y), t;
    }, _i = function(t, s, i, e) {
        s[0] = e[12], s[1] = e[13], s[2] = e[14];
        var n = e[0], h = e[1], r = e[2], o = e[4], a = e[5], u = e[6], l = e[8], c = e[9], f = e[10];
        i[0] = Math.hypot(n, h, r), i[1] = Math.hypot(o, a, u), i[2] = Math.hypot(l, c, f);
        var d = 1 / i[0], p = 1 / i[1], m = 1 / i[2], g = n * d, y = h * p, M = r * m, w = o * d, S = a * p, b = u * m, T = l * d, v = c * p, x = f * m, I = g + S + x, G = 0;
        return I > 0 ? (G = 2 * Math.sqrt(I + 1), t[3] = .25 * G, t[0] = (b - v) / G, t[1] = (T - M) / G, 
        t[2] = (y - w) / G) : g > S && g > x ? (G = 2 * Math.sqrt(1 + g - S - x), t[3] = (b - v) / G, 
        t[0] = .25 * G, t[1] = (y + w) / G, t[2] = (T + M) / G) : S > x ? (G = 2 * Math.sqrt(1 + S - g - x), 
        t[3] = (T - M) / G, t[0] = (y + w) / G, t[1] = .25 * G, t[2] = (b + v) / G) : (G = 2 * Math.sqrt(1 + x - g - S), 
        t[3] = (y - w) / G, t[0] = (T + M) / G, t[1] = (b + v) / G, t[2] = .25 * G), t;
    }, Ei = function(t, s, i, e) {
        var n = s[0], h = s[1], r = s[2], o = s[3], a = n + n, u = h + h, l = r + r, c = n * a, f = n * u, d = n * l, p = h * u, m = h * l, g = r * l, y = o * a, M = o * u, w = o * l, S = e[0], b = e[1], T = e[2];
        return t[0] = (1 - (p + g)) * S, t[1] = (f + w) * S, t[2] = (d - M) * S, t[3] = 0, 
        t[4] = (f - w) * b, t[5] = (1 - (c + g)) * b, t[6] = (m + y) * b, t[7] = 0, t[8] = (d + M) * T, 
        t[9] = (m - y) * T, t[10] = (1 - (c + p)) * T, t[11] = 0, t[12] = i[0], t[13] = i[1], 
        t[14] = i[2], t[15] = 1, t;
    }, Di = function(t, s, i, e, n) {
        var h = s[0], r = s[1], o = s[2], a = s[3], u = h + h, l = r + r, c = o + o, f = h * u, d = h * l, p = h * c, m = r * l, g = r * c, y = o * c, M = a * u, w = a * l, S = a * c, b = e[0], T = e[1], v = e[2], x = n[0], I = n[1], G = n[2], C = (1 - (m + y)) * b, _ = (d + S) * b, E = (p - w) * b, D = (d - S) * T, A = (1 - (f + y)) * T, N = (g + M) * T, L = (p + w) * v, O = (g - M) * v, R = (1 - (f + m)) * v;
        return t[0] = C, t[1] = _, t[2] = E, t[3] = 0, t[4] = D, t[5] = A, t[6] = N, t[7] = 0, 
        t[8] = L, t[9] = O, t[10] = R, t[11] = 0, t[12] = i[0] + x - (C * x + D * I + L * G), 
        t[13] = i[1] + I - (_ * x + A * I + O * G), t[14] = i[2] + G - (E * x + N * I + R * G), 
        t[15] = 1, t;
    }, Ai = function(t, s) {
        var i = s[0], e = s[1], n = s[2], h = s[3], r = i + i, o = e + e, a = n + n, u = i * r, l = e * r, c = e * o, f = n * r, d = n * o, p = n * a, m = h * r, g = h * o, y = h * a;
        return t[0] = 1 - c - p, t[1] = l + y, t[2] = f - g, t[3] = 0, t[4] = l - y, t[5] = 1 - u - p, 
        t[6] = d + m, t[7] = 0, t[8] = f + g, t[9] = d - m, t[10] = 1 - u - c, t[11] = 0, 
        t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
    }, Ni = function(t, s, i, e, n, h, r) {
        var o = 1 / (i - s), a = 1 / (n - e), u = 1 / (h - r);
        return t[0] = 2 * h * o, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 2 * h * a, 
        t[6] = 0, t[7] = 0, t[8] = (i + s) * o, t[9] = (n + e) * a, t[10] = (r + h) * u, 
        t[11] = -1, t[12] = 0, t[13] = 0, t[14] = r * h * 2 * u, t[15] = 0, t;
    }, Li = function(t, s, i, e, n) {
        var h = 1 / Math.tan(s / 2);
        if (t[0] = h / i, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = h, t[6] = 0, t[7] = 0, 
        t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != n && n !== 1 / 0) {
            var r = 1 / (e - n);
            t[10] = (n + e) * r, t[14] = 2 * n * e * r;
        } else t[10] = -1, t[14] = -2 * e;
        return t;
    }, Oi = function(t, s, i, e, n) {
        var h = 1 / Math.tan(s / 2);
        if (t[0] = h / i, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = h, t[6] = 0, t[7] = 0, 
        t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != n && n !== 1 / 0) {
            var r = 1 / (e - n);
            t[10] = n * r, t[14] = n * e * r;
        } else t[10] = -1, t[14] = -e;
        return t;
    }, Ri = function(t, s, i, e) {
        var n = Math.tan(s.upDegrees * Math.PI / 180), h = Math.tan(s.downDegrees * Math.PI / 180), r = Math.tan(s.leftDegrees * Math.PI / 180), o = Math.tan(s.rightDegrees * Math.PI / 180), a = 2 / (r + o), u = 2 / (n + h);
        return t[0] = a, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = u, t[6] = 0, t[7] = 0, 
        t[8] = -(r - o) * a * .5, t[9] = (n - h) * u * .5, t[10] = e / (i - e), t[11] = -1, 
        t[12] = 0, t[13] = 0, t[14] = e * i / (i - e), t[15] = 0, t;
    }, Pi = function(t, s, i, e, n, h, r) {
        var o = 1 / (s - i), a = 1 / (e - n), u = 1 / (h - r);
        return t[0] = -2 * o, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * a, t[6] = 0, 
        t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * u, t[11] = 0, t[12] = (s + i) * o, t[13] = (n + e) * a, 
        t[14] = (r + h) * u, t[15] = 1, t;
    }, ki = function(t, s, i, e, n, h, r) {
        var o = 1 / (s - i), a = 1 / (e - n), u = 1 / (h - r);
        return t[0] = -2 * o, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * a, t[6] = 0, 
        t[7] = 0, t[8] = 0, t[9] = 0, t[10] = u, t[11] = 0, t[12] = (s + i) * o, t[13] = (n + e) * a, 
        t[14] = h * u, t[15] = 1, t;
    }, Fi = function(t, i, e, n) {
        var h, r, o, a, u, l, c, f, d, p, m = i[0], g = i[1], y = i[2], M = n[0], w = n[1], S = n[2], b = e[0], T = e[1], v = e[2];
        return Math.abs(m - b) < s && Math.abs(g - T) < s && Math.abs(y - v) < s ? hi(t) : (c = m - b, 
        f = g - T, d = y - v, h = w * (d *= p = 1 / Math.hypot(c, f, d)) - S * (f *= p), 
        r = S * (c *= p) - M * d, o = M * f - w * c, (p = Math.hypot(h, r, o)) ? (h *= p = 1 / p, 
        r *= p, o *= p) : (h = 0, r = 0, o = 0), a = f * o - d * r, u = d * h - c * o, l = c * r - f * h, 
        (p = Math.hypot(a, u, l)) ? (a *= p = 1 / p, u *= p, l *= p) : (a = 0, u = 0, l = 0), 
        t[0] = h, t[1] = a, t[2] = c, t[3] = 0, t[4] = r, t[5] = u, t[6] = f, t[7] = 0, 
        t[8] = o, t[9] = l, t[10] = d, t[11] = 0, t[12] = -(h * m + r * g + o * y), t[13] = -(a * m + u * g + l * y), 
        t[14] = -(c * m + f * g + d * y), t[15] = 1, t);
    }, ji = function(t, s, i, e) {
        var n = s[0], h = s[1], r = s[2], o = e[0], a = e[1], u = e[2], l = n - i[0], c = h - i[1], f = r - i[2], d = l * l + c * c + f * f;
        d > 0 && (l *= d = 1 / Math.sqrt(d), c *= d, f *= d);
        var p = a * f - u * c, m = u * l - o * f, g = o * c - a * l;
        return (d = p * p + m * m + g * g) > 0 && (p *= d = 1 / Math.sqrt(d), m *= d, g *= d), 
        t[0] = p, t[1] = m, t[2] = g, t[3] = 0, t[4] = c * g - f * m, t[5] = f * p - l * g, 
        t[6] = l * m - c * p, t[7] = 0, t[8] = l, t[9] = c, t[10] = f, t[11] = 0, t[12] = n, 
        t[13] = h, t[14] = r, t[15] = 1, t;
    }, Bi = function(t) {
        return "mat4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ", " + t[9] + ", " + t[10] + ", " + t[11] + ", " + t[12] + ", " + t[13] + ", " + t[14] + ", " + t[15] + ")";
    }, zi = function(t) {
        return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15]);
    }, Ui = function(t, s, i) {
        return t[0] = s[0] + i[0], t[1] = s[1] + i[1], t[2] = s[2] + i[2], t[3] = s[3] + i[3], 
        t[4] = s[4] + i[4], t[5] = s[5] + i[5], t[6] = s[6] + i[6], t[7] = s[7] + i[7], 
        t[8] = s[8] + i[8], t[9] = s[9] + i[9], t[10] = s[10] + i[10], t[11] = s[11] + i[11], 
        t[12] = s[12] + i[12], t[13] = s[13] + i[13], t[14] = s[14] + i[14], t[15] = s[15] + i[15], 
        t;
    }, Wi = function(t, s, i) {
        return t[0] = s[0] - i[0], t[1] = s[1] - i[1], t[2] = s[2] - i[2], t[3] = s[3] - i[3], 
        t[4] = s[4] - i[4], t[5] = s[5] - i[5], t[6] = s[6] - i[6], t[7] = s[7] - i[7], 
        t[8] = s[8] - i[8], t[9] = s[9] - i[9], t[10] = s[10] - i[10], t[11] = s[11] - i[11], 
        t[12] = s[12] - i[12], t[13] = s[13] - i[13], t[14] = s[14] - i[14], t[15] = s[15] - i[15], 
        t;
    }, Ji = function(t, s, i) {
        return t[0] = s[0] * i, t[1] = s[1] * i, t[2] = s[2] * i, t[3] = s[3] * i, t[4] = s[4] * i, 
        t[5] = s[5] * i, t[6] = s[6] * i, t[7] = s[7] * i, t[8] = s[8] * i, t[9] = s[9] * i, 
        t[10] = s[10] * i, t[11] = s[11] * i, t[12] = s[12] * i, t[13] = s[13] * i, t[14] = s[14] * i, 
        t[15] = s[15] * i, t;
    }, Qi = function(t, s, i, e) {
        return t[0] = s[0] + i[0] * e, t[1] = s[1] + i[1] * e, t[2] = s[2] + i[2] * e, t[3] = s[3] + i[3] * e, 
        t[4] = s[4] + i[4] * e, t[5] = s[5] + i[5] * e, t[6] = s[6] + i[6] * e, t[7] = s[7] + i[7] * e, 
        t[8] = s[8] + i[8] * e, t[9] = s[9] + i[9] * e, t[10] = s[10] + i[10] * e, t[11] = s[11] + i[11] * e, 
        t[12] = s[12] + i[12] * e, t[13] = s[13] + i[13] * e, t[14] = s[14] + i[14] * e, 
        t[15] = s[15] + i[15] * e, t;
    }, Yi = function(t, s) {
        return t[0] === s[0] && t[1] === s[1] && t[2] === s[2] && t[3] === s[3] && t[4] === s[4] && t[5] === s[5] && t[6] === s[6] && t[7] === s[7] && t[8] === s[8] && t[9] === s[9] && t[10] === s[10] && t[11] === s[11] && t[12] === s[12] && t[13] === s[13] && t[14] === s[14] && t[15] === s[15];
    }, Vi = function(t, i) {
        var e = t[0], n = t[1], h = t[2], r = t[3], o = t[4], a = t[5], u = t[6], l = t[7], c = t[8], f = t[9], d = t[10], p = t[11], m = t[12], g = t[13], y = t[14], M = t[15], w = i[0], S = i[1], b = i[2], T = i[3], v = i[4], x = i[5], I = i[6], G = i[7], C = i[8], _ = i[9], E = i[10], D = i[11], A = i[12], N = i[13], L = i[14], O = i[15];
        return Math.abs(e - w) <= s * Math.max(1, Math.abs(e), Math.abs(w)) && Math.abs(n - S) <= s * Math.max(1, Math.abs(n), Math.abs(S)) && Math.abs(h - b) <= s * Math.max(1, Math.abs(h), Math.abs(b)) && Math.abs(r - T) <= s * Math.max(1, Math.abs(r), Math.abs(T)) && Math.abs(o - v) <= s * Math.max(1, Math.abs(o), Math.abs(v)) && Math.abs(a - x) <= s * Math.max(1, Math.abs(a), Math.abs(x)) && Math.abs(u - I) <= s * Math.max(1, Math.abs(u), Math.abs(I)) && Math.abs(l - G) <= s * Math.max(1, Math.abs(l), Math.abs(G)) && Math.abs(c - C) <= s * Math.max(1, Math.abs(c), Math.abs(C)) && Math.abs(f - _) <= s * Math.max(1, Math.abs(f), Math.abs(_)) && Math.abs(d - E) <= s * Math.max(1, Math.abs(d), Math.abs(E)) && Math.abs(p - D) <= s * Math.max(1, Math.abs(p), Math.abs(D)) && Math.abs(m - A) <= s * Math.max(1, Math.abs(m), Math.abs(A)) && Math.abs(g - N) <= s * Math.max(1, Math.abs(g), Math.abs(N)) && Math.abs(y - L) <= s * Math.max(1, Math.abs(y), Math.abs(L)) && Math.abs(M - O) <= s * Math.max(1, Math.abs(M), Math.abs(O));
    }, Hi = function() {
        var t = new i(3);
        return i != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t;
    }, qi = function(t) {
        var s = new i(3);
        return s[0] = t[0], s[1] = t[1], s[2] = t[2], s;
    }, Xi = function(t) {
        var s = t[0], i = t[1], e = t[2];
        return Math.hypot(s, i, e);
    }, Zi = function(t, s, e) {
        var n = new i(3);
        return n[0] = t, n[1] = s, n[2] = e, n;
    }, Ki = function(t, s) {
        return t[0] = s[0], t[1] = s[1], t[2] = s[2], t;
    }, $i = function(t, s, i, e) {
        return t[0] = s, t[1] = i, t[2] = e, t;
    }, te = function(t, s, i) {
        return t[0] = s[0] + i[0], t[1] = s[1] + i[1], t[2] = s[2] + i[2], t;
    }, se = function(t, s, i) {
        return t[0] = s[0] - i[0], t[1] = s[1] - i[1], t[2] = s[2] - i[2], t;
    }, ie = function(t, s, i) {
        return t[0] = s[0] * i[0], t[1] = s[1] * i[1], t[2] = s[2] * i[2], t;
    }, ee = function(t, s, i) {
        return t[0] = s[0] / i[0], t[1] = s[1] / i[1], t[2] = s[2] / i[2], t;
    }, ne = function(t, s) {
        return t[0] = Math.ceil(s[0]), t[1] = Math.ceil(s[1]), t[2] = Math.ceil(s[2]), t;
    }, he = function(t, s) {
        return t[0] = Math.floor(s[0]), t[1] = Math.floor(s[1]), t[2] = Math.floor(s[2]), 
        t;
    }, re = function(t, s, i) {
        return t[0] = Math.min(s[0], i[0]), t[1] = Math.min(s[1], i[1]), t[2] = Math.min(s[2], i[2]), 
        t;
    }, oe = function(t, s, i) {
        return t[0] = Math.max(s[0], i[0]), t[1] = Math.max(s[1], i[1]), t[2] = Math.max(s[2], i[2]), 
        t;
    }, ae = function(t, s) {
        return t[0] = Math.round(s[0]), t[1] = Math.round(s[1]), t[2] = Math.round(s[2]), 
        t;
    }, ue = function(t, s, i) {
        return t[0] = s[0] * i, t[1] = s[1] * i, t[2] = s[2] * i, t;
    }, le = function(t, s, i, e) {
        return t[0] = s[0] + i[0] * e, t[1] = s[1] + i[1] * e, t[2] = s[2] + i[2] * e, t;
    }, ce = function(t, s) {
        var i = s[0] - t[0], e = s[1] - t[1], n = s[2] - t[2];
        return Math.hypot(i, e, n);
    }, fe = function(t, s) {
        var i = s[0] - t[0], e = s[1] - t[1], n = s[2] - t[2];
        return i * i + e * e + n * n;
    }, de = function(t) {
        var s = t[0], i = t[1], e = t[2];
        return s * s + i * i + e * e;
    }, pe = function(t, s) {
        return t[0] = -s[0], t[1] = -s[1], t[2] = -s[2], t;
    }, me = function(t, s) {
        return t[0] = 1 / s[0], t[1] = 1 / s[1], t[2] = 1 / s[2], t;
    }, ge = function(t, s) {
        var i = s[0], e = s[1], n = s[2], h = i * i + e * e + n * n;
        return h > 0 && (h = 1 / Math.sqrt(h)), t[0] = s[0] * h, t[1] = s[1] * h, t[2] = s[2] * h, 
        t;
    }, ye = function(t, s) {
        return t[0] * s[0] + t[1] * s[1] + t[2] * s[2];
    }, Me = function(t, s, i) {
        var e = s[0], n = s[1], h = s[2], r = i[0], o = i[1], a = i[2];
        return t[0] = n * a - h * o, t[1] = h * r - e * a, t[2] = e * o - n * r, t;
    }, we = function(t, s, i, e) {
        var n = s[0], h = s[1], r = s[2];
        return t[0] = n + e * (i[0] - n), t[1] = h + e * (i[1] - h), t[2] = r + e * (i[2] - r), 
        t;
    }, Se = function(t, s, i, e) {
        var n = Math.acos(Math.min(Math.max(ye(s, i), -1), 1)), h = Math.sin(n), r = Math.sin((1 - e) * n) / h, o = Math.sin(e * n) / h;
        return t[0] = r * s[0] + o * i[0], t[1] = r * s[1] + o * i[1], t[2] = r * s[2] + o * i[2], 
        t;
    }, be = function(t, s, i, e, n, h) {
        var r = h * h, o = r * (2 * h - 3) + 1, a = r * (h - 2) + h, u = r * (h - 1), l = r * (3 - 2 * h);
        return t[0] = s[0] * o + i[0] * a + e[0] * u + n[0] * l, t[1] = s[1] * o + i[1] * a + e[1] * u + n[1] * l, 
        t[2] = s[2] * o + i[2] * a + e[2] * u + n[2] * l, t;
    }, Te = function(t, s, i, e, n, h) {
        var r = 1 - h, o = r * r, a = h * h, u = o * r, l = 3 * h * o, c = 3 * a * r, f = a * h;
        return t[0] = s[0] * u + i[0] * l + e[0] * c + n[0] * f, t[1] = s[1] * u + i[1] * l + e[1] * c + n[1] * f, 
        t[2] = s[2] * u + i[2] * l + e[2] * c + n[2] * f, t;
    }, ve = function(t, s) {
        s = s || 1;
        var i = 2 * e() * Math.PI, n = 2 * e() - 1, h = Math.sqrt(1 - n * n) * s;
        return t[0] = Math.cos(i) * h, t[1] = Math.sin(i) * h, t[2] = n * s, t;
    }, xe = function(t, s, i) {
        var e = s[0], n = s[1], h = s[2], r = i[3] * e + i[7] * n + i[11] * h + i[15];
        return r = r || 1, t[0] = (i[0] * e + i[4] * n + i[8] * h + i[12]) / r, t[1] = (i[1] * e + i[5] * n + i[9] * h + i[13]) / r, 
        t[2] = (i[2] * e + i[6] * n + i[10] * h + i[14]) / r, t;
    }, Ie = function(t, s, i) {
        var e = s[0], n = s[1], h = s[2];
        return t[0] = e * i[0] + n * i[3] + h * i[6], t[1] = e * i[1] + n * i[4] + h * i[7], 
        t[2] = e * i[2] + n * i[5] + h * i[8], t;
    }, Ge = function(t, s, i) {
        var e = i[0], n = i[1], h = i[2], r = i[3], o = s[0], a = s[1], u = s[2], l = n * u - h * a, c = h * o - e * u, f = e * a - n * o, d = n * f - h * c, p = h * l - e * f, m = e * c - n * l, g = 2 * r;
        return l *= g, c *= g, f *= g, d *= 2, p *= 2, m *= 2, t[0] = o + l + d, t[1] = a + c + p, 
        t[2] = u + f + m, t;
    }, Ce = function(t, s, i, e) {
        var n = [], h = [];
        return n[0] = s[0] - i[0], n[1] = s[1] - i[1], n[2] = s[2] - i[2], h[0] = n[0], 
        h[1] = n[1] * Math.cos(e) - n[2] * Math.sin(e), h[2] = n[1] * Math.sin(e) + n[2] * Math.cos(e), 
        t[0] = h[0] + i[0], t[1] = h[1] + i[1], t[2] = h[2] + i[2], t;
    }, _e = function(t, s, i, e) {
        var n = [], h = [];
        return n[0] = s[0] - i[0], n[1] = s[1] - i[1], n[2] = s[2] - i[2], h[0] = n[2] * Math.sin(e) + n[0] * Math.cos(e), 
        h[1] = n[1], h[2] = n[2] * Math.cos(e) - n[0] * Math.sin(e), t[0] = h[0] + i[0], 
        t[1] = h[1] + i[1], t[2] = h[2] + i[2], t;
    }, Ee = function(t, s, i, e) {
        var n = [], h = [];
        return n[0] = s[0] - i[0], n[1] = s[1] - i[1], n[2] = s[2] - i[2], h[0] = n[0] * Math.cos(e) - n[1] * Math.sin(e), 
        h[1] = n[0] * Math.sin(e) + n[1] * Math.cos(e), h[2] = n[2], t[0] = h[0] + i[0], 
        t[1] = h[1] + i[1], t[2] = h[2] + i[2], t;
    }, De = function(t, s) {
        var i = t[0], e = t[1], n = t[2], h = s[0], r = s[1], o = s[2], a = Math.sqrt((i * i + e * e + n * n) * (h * h + r * r + o * o)), u = a && ye(t, s) / a;
        return Math.acos(Math.min(Math.max(u, -1), 1));
    }, Ae = function(t) {
        return t[0] = 0, t[1] = 0, t[2] = 0, t;
    }, Ne = function(t) {
        return "vec3(" + t[0] + ", " + t[1] + ", " + t[2] + ")";
    }, Le = function(t, s) {
        return t[0] === s[0] && t[1] === s[1] && t[2] === s[2];
    }, Oe = function(t, i) {
        var e = t[0], n = t[1], h = t[2], r = i[0], o = i[1], a = i[2];
        return Math.abs(e - r) <= s * Math.max(1, Math.abs(e), Math.abs(r)) && Math.abs(n - o) <= s * Math.max(1, Math.abs(n), Math.abs(o)) && Math.abs(h - a) <= s * Math.max(1, Math.abs(h), Math.abs(a));
    }, Re = function() {
        var t = new i(4);
        return i != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0), t;
    }, Pe = function(t) {
        var s = new i(4);
        return s[0] = t[0], s[1] = t[1], s[2] = t[2], s[3] = t[3], s;
    }, ke = function(t, s, e, n) {
        var h = new i(4);
        return h[0] = t, h[1] = s, h[2] = e, h[3] = n, h;
    }, Fe = function(t, s) {
        return t[0] = s[0], t[1] = s[1], t[2] = s[2], t[3] = s[3], t;
    }, je = function(t, s, i, e, n) {
        return t[0] = s, t[1] = i, t[2] = e, t[3] = n, t;
    }, Be = function(t, s, i) {
        return t[0] = s[0] + i[0], t[1] = s[1] + i[1], t[2] = s[2] + i[2], t[3] = s[3] + i[3], 
        t;
    }, ze = function(t, s, i) {
        return t[0] = s[0] - i[0], t[1] = s[1] - i[1], t[2] = s[2] - i[2], t[3] = s[3] - i[3], 
        t;
    }, Ue = function(t, s, i) {
        return t[0] = s[0] * i[0], t[1] = s[1] * i[1], t[2] = s[2] * i[2], t[3] = s[3] * i[3], 
        t;
    }, We = function(t, s, i) {
        return t[0] = s[0] / i[0], t[1] = s[1] / i[1], t[2] = s[2] / i[2], t[3] = s[3] / i[3], 
        t;
    }, Je = function(t, s) {
        return t[0] = Math.ceil(s[0]), t[1] = Math.ceil(s[1]), t[2] = Math.ceil(s[2]), t[3] = Math.ceil(s[3]), 
        t;
    }, Qe = function(t, s) {
        return t[0] = Math.floor(s[0]), t[1] = Math.floor(s[1]), t[2] = Math.floor(s[2]), 
        t[3] = Math.floor(s[3]), t;
    }, Ye = function(t, s, i) {
        return t[0] = Math.min(s[0], i[0]), t[1] = Math.min(s[1], i[1]), t[2] = Math.min(s[2], i[2]), 
        t[3] = Math.min(s[3], i[3]), t;
    }, Ve = function(t, s, i) {
        return t[0] = Math.max(s[0], i[0]), t[1] = Math.max(s[1], i[1]), t[2] = Math.max(s[2], i[2]), 
        t[3] = Math.max(s[3], i[3]), t;
    }, He = function(t, s) {
        return t[0] = Math.round(s[0]), t[1] = Math.round(s[1]), t[2] = Math.round(s[2]), 
        t[3] = Math.round(s[3]), t;
    }, qe = function(t, s, i) {
        return t[0] = s[0] * i, t[1] = s[1] * i, t[2] = s[2] * i, t[3] = s[3] * i, t;
    }, Xe = function(t, s, i, e) {
        return t[0] = s[0] + i[0] * e, t[1] = s[1] + i[1] * e, t[2] = s[2] + i[2] * e, t[3] = s[3] + i[3] * e, 
        t;
    }, Ze = function(t, s) {
        var i = s[0] - t[0], e = s[1] - t[1], n = s[2] - t[2], h = s[3] - t[3];
        return Math.hypot(i, e, n, h);
    }, Ke = function(t, s) {
        var i = s[0] - t[0], e = s[1] - t[1], n = s[2] - t[2], h = s[3] - t[3];
        return i * i + e * e + n * n + h * h;
    }, $e = function(t) {
        var s = t[0], i = t[1], e = t[2], n = t[3];
        return Math.hypot(s, i, e, n);
    }, tn = function(t) {
        var s = t[0], i = t[1], e = t[2], n = t[3];
        return s * s + i * i + e * e + n * n;
    }, sn = function(t, s) {
        return t[0] = -s[0], t[1] = -s[1], t[2] = -s[2], t[3] = -s[3], t;
    }, en = function(t, s) {
        return t[0] = 1 / s[0], t[1] = 1 / s[1], t[2] = 1 / s[2], t[3] = 1 / s[3], t;
    }, nn = function(t, s) {
        var i = s[0], e = s[1], n = s[2], h = s[3], r = i * i + e * e + n * n + h * h;
        return r > 0 && (r = 1 / Math.sqrt(r)), t[0] = i * r, t[1] = e * r, t[2] = n * r, 
        t[3] = h * r, t;
    }, hn = function(t, s) {
        return t[0] * s[0] + t[1] * s[1] + t[2] * s[2] + t[3] * s[3];
    }, rn = function(t, s, i, e) {
        var n = i[0] * e[1] - i[1] * e[0], h = i[0] * e[2] - i[2] * e[0], r = i[0] * e[3] - i[3] * e[0], o = i[1] * e[2] - i[2] * e[1], a = i[1] * e[3] - i[3] * e[1], u = i[2] * e[3] - i[3] * e[2], l = s[0], c = s[1], f = s[2], d = s[3];
        return t[0] = c * u - f * a + d * o, t[1] = -l * u + f * r - d * h, t[2] = l * a - c * r + d * n, 
        t[3] = -l * o + c * h - f * n, t;
    }, on = function(t, s, i, e) {
        var n = s[0], h = s[1], r = s[2], o = s[3];
        return t[0] = n + e * (i[0] - n), t[1] = h + e * (i[1] - h), t[2] = r + e * (i[2] - r), 
        t[3] = o + e * (i[3] - o), t;
    }, an = function(t, s) {
        var i, n, h, r, o, a;
        s = s || 1;
        do {
            o = (i = 2 * e() - 1) * i + (n = 2 * e() - 1) * n;
        } while (o >= 1);
        do {
            a = (h = 2 * e() - 1) * h + (r = 2 * e() - 1) * r;
        } while (a >= 1);
        var u = Math.sqrt((1 - o) / a);
        return t[0] = s * i, t[1] = s * n, t[2] = s * h * u, t[3] = s * r * u, t;
    }, un = function(t, s, i) {
        var e = s[0], n = s[1], h = s[2], r = s[3];
        return t[0] = i[0] * e + i[4] * n + i[8] * h + i[12] * r, t[1] = i[1] * e + i[5] * n + i[9] * h + i[13] * r, 
        t[2] = i[2] * e + i[6] * n + i[10] * h + i[14] * r, t[3] = i[3] * e + i[7] * n + i[11] * h + i[15] * r, 
        t;
    }, ln = function(t, s, i) {
        var e = s[0], n = s[1], h = s[2], r = i[0], o = i[1], a = i[2], u = i[3], l = u * e + o * h - a * n, c = u * n + a * e - r * h, f = u * h + r * n - o * e, d = -r * e - o * n - a * h;
        return t[0] = l * u + d * -r + c * -a - f * -o, t[1] = c * u + d * -o + f * -r - l * -a, 
        t[2] = f * u + d * -a + l * -o - c * -r, t[3] = s[3], t;
    }, cn = function(t) {
        return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0, t;
    }, fn = function(t) {
        return "vec4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")";
    }, dn = function(t, s) {
        return t[0] === s[0] && t[1] === s[1] && t[2] === s[2] && t[3] === s[3];
    }, pn = function(t, i) {
        var e = t[0], n = t[1], h = t[2], r = t[3], o = i[0], a = i[1], u = i[2], l = i[3];
        return Math.abs(e - o) <= s * Math.max(1, Math.abs(e), Math.abs(o)) && Math.abs(n - a) <= s * Math.max(1, Math.abs(n), Math.abs(a)) && Math.abs(h - u) <= s * Math.max(1, Math.abs(h), Math.abs(u)) && Math.abs(r - l) <= s * Math.max(1, Math.abs(r), Math.abs(l));
    }, mn = function() {
        var t = new i(4);
        return i != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t[3] = 1, t;
    }, gn = function(t) {
        return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t;
    }, yn = function(t, s, i) {
        i *= .5;
        var e = Math.sin(i);
        return t[0] = e * s[0], t[1] = e * s[1], t[2] = e * s[2], t[3] = Math.cos(i), t;
    }, Mn = function(t, i) {
        var e = 2 * Math.acos(i[3]), n = Math.sin(e / 2);
        return n > s ? (t[0] = i[0] / n, t[1] = i[1] / n, t[2] = i[2] / n) : (t[0] = 1, 
        t[1] = 0, t[2] = 0), e;
    }, wn = function(t, s) {
        var i = Y(t, s);
        return Math.acos(2 * i * i - 1);
    }, Sn = function(t, s, i) {
        var e = s[0], n = s[1], h = s[2], r = s[3], o = i[0], a = i[1], u = i[2], l = i[3];
        return t[0] = e * l + r * o + n * u - h * a, t[1] = n * l + r * a + h * o - e * u, 
        t[2] = h * l + r * u + e * a - n * o, t[3] = r * l - e * o - n * a - h * u, t;
    }, bn = function(t, s, i) {
        i *= .5;
        var e = s[0], n = s[1], h = s[2], r = s[3], o = Math.sin(i), a = Math.cos(i);
        return t[0] = e * a + r * o, t[1] = n * a + h * o, t[2] = h * a - n * o, t[3] = r * a - e * o, 
        t;
    }, Tn = function(t, s, i) {
        i *= .5;
        var e = s[0], n = s[1], h = s[2], r = s[3], o = Math.sin(i), a = Math.cos(i);
        return t[0] = e * a - h * o, t[1] = n * a + r * o, t[2] = h * a + e * o, t[3] = r * a - n * o, 
        t;
    }, vn = function(t, s, i) {
        i *= .5;
        var e = s[0], n = s[1], h = s[2], r = s[3], o = Math.sin(i), a = Math.cos(i);
        return t[0] = e * a + n * o, t[1] = n * a - e * o, t[2] = h * a + r * o, t[3] = r * a - h * o, 
        t;
    }, xn = function(t, s) {
        var i = s[0], e = s[1], n = s[2];
        return t[0] = i, t[1] = e, t[2] = n, t[3] = Math.sqrt(Math.abs(1 - i * i - e * e - n * n)), 
        t;
    }, In = function(t, s) {
        var i = s[0], e = s[1], n = s[2], h = s[3], r = Math.sqrt(i * i + e * e + n * n), o = Math.exp(h), a = r > 0 ? o * Math.sin(r) / r : 0;
        return t[0] = i * a, t[1] = e * a, t[2] = n * a, t[3] = o * Math.cos(r), t;
    }, Gn = function(t, s) {
        var i = s[0], e = s[1], n = s[2], h = s[3], r = Math.sqrt(i * i + e * e + n * n), o = r > 0 ? Math.atan2(r, h) / r : 0;
        return t[0] = i * o, t[1] = e * o, t[2] = n * o, t[3] = .5 * Math.log(i * i + e * e + n * n + h * h), 
        t;
    }, Cn = function(t, s, i) {
        return Gn(t, s), Q(t, t, i), In(t, t), t;
    }, _n = function(t, i, e, n) {
        var h, r, o, a, u, l = i[0], c = i[1], f = i[2], d = i[3], p = e[0], m = e[1], g = e[2], y = e[3];
        return (r = l * p + c * m + f * g + d * y) < 0 && (r = -r, p = -p, m = -m, g = -g, 
        y = -y), 1 - r > s ? (h = Math.acos(r), o = Math.sin(h), a = Math.sin((1 - n) * h) / o, 
        u = Math.sin(n * h) / o) : (a = 1 - n, u = n), t[0] = a * l + u * p, t[1] = a * c + u * m, 
        t[2] = a * f + u * g, t[3] = a * d + u * y, t;
    }, En = function(t) {
        var s = e(), i = e(), n = e(), h = Math.sqrt(1 - s), r = Math.sqrt(s);
        return t[0] = h * Math.sin(2 * Math.PI * i), t[1] = h * Math.cos(2 * Math.PI * i), 
        t[2] = r * Math.sin(2 * Math.PI * n), t[3] = r * Math.cos(2 * Math.PI * n), t;
    }, Dn = function(t, s) {
        var i = s[0], e = s[1], n = s[2], h = s[3], r = i * i + e * e + n * n + h * h, o = r ? 1 / r : 0;
        return t[0] = -i * o, t[1] = -e * o, t[2] = -n * o, t[3] = h * o, t;
    }, An = function(t, s) {
        return t[0] = -s[0], t[1] = -s[1], t[2] = -s[2], t[3] = s[3], t;
    }, Nn = function(t, s) {
        var i, e = s[0] + s[4] + s[8];
        if (e > 0) i = Math.sqrt(e + 1), t[3] = .5 * i, i = .5 / i, t[0] = (s[5] - s[7]) * i, 
        t[1] = (s[6] - s[2]) * i, t[2] = (s[1] - s[3]) * i; else {
            var n = 0;
            s[4] > s[0] && (n = 1), s[8] > s[3 * n + n] && (n = 2);
            var h = (n + 1) % 3, r = (n + 2) % 3;
            i = Math.sqrt(s[3 * n + n] - s[3 * h + h] - s[3 * r + r] + 1), t[n] = .5 * i, i = .5 / i, 
            t[3] = (s[3 * h + r] - s[3 * r + h]) * i, t[h] = (s[3 * h + n] + s[3 * n + h]) * i, 
            t[r] = (s[3 * r + n] + s[3 * n + r]) * i;
        }
        return t;
    }, Ln = function(t, s, i, e) {
        var h = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : n, r = Math.PI / 360;
        s *= r, e *= r, i *= r;
        var o = Math.sin(s), a = Math.cos(s), u = Math.sin(i), l = Math.cos(i), c = Math.sin(e), f = Math.cos(e);
        switch (h) {
          case "xyz":
            t[0] = o * l * f + a * u * c, t[1] = a * u * f - o * l * c, t[2] = a * l * c + o * u * f, 
            t[3] = a * l * f - o * u * c;
            break;

          case "xzy":
            t[0] = o * l * f - a * u * c, t[1] = a * u * f - o * l * c, t[2] = a * l * c + o * u * f, 
            t[3] = a * l * f + o * u * c;
            break;

          case "yxz":
            t[0] = o * l * f + a * u * c, t[1] = a * u * f - o * l * c, t[2] = a * l * c - o * u * f, 
            t[3] = a * l * f + o * u * c;
            break;

          case "yzx":
            t[0] = o * l * f + a * u * c, t[1] = a * u * f + o * l * c, t[2] = a * l * c - o * u * f, 
            t[3] = a * l * f - o * u * c;
            break;

          case "zxy":
            t[0] = o * l * f - a * u * c, t[1] = a * u * f + o * l * c, t[2] = a * l * c + o * u * f, 
            t[3] = a * l * f - o * u * c;
            break;

          case "zyx":
            t[0] = o * l * f - a * u * c, t[1] = a * u * f + o * l * c, t[2] = a * l * c - o * u * f, 
            t[3] = a * l * f + o * u * c;
            break;

          default:
            throw new Error("Unknown angle order " + h);
        }
        return t;
    }, On = function(t) {
        return "quat(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")";
    }, Rn = function(t, i) {
        return Math.abs(hn(t, i)) >= 1 - s;
    }, Pn = function() {
        var t = new i(8);
        return i != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[4] = 0, t[5] = 0, t[6] = 0, 
        t[7] = 0), t[3] = 1, t;
    }, kn = function(t) {
        var s = new i(8);
        return s[0] = t[0], s[1] = t[1], s[2] = t[2], s[3] = t[3], s[4] = t[4], s[5] = t[5], 
        s[6] = t[6], s[7] = t[7], s;
    }, Fn = function(t, s, e, n, h, r, o, a) {
        var u = new i(8);
        return u[0] = t, u[1] = s, u[2] = e, u[3] = n, u[4] = h, u[5] = r, u[6] = o, u[7] = a, 
        u;
    }, jn = function(t, s, e, n, h, r, o) {
        var a = new i(8);
        a[0] = t, a[1] = s, a[2] = e, a[3] = n;
        var u = .5 * h, l = .5 * r, c = .5 * o;
        return a[4] = u * n + l * e - c * s, a[5] = l * n + c * t - u * e, a[6] = c * n + u * s - l * t, 
        a[7] = -u * t - l * s - c * e, a;
    }, Bn = function(t, s, i) {
        var e = .5 * i[0], n = .5 * i[1], h = .5 * i[2], r = s[0], o = s[1], a = s[2], u = s[3];
        return t[0] = r, t[1] = o, t[2] = a, t[3] = u, t[4] = e * u + n * a - h * o, t[5] = n * u + h * r - e * a, 
        t[6] = h * u + e * o - n * r, t[7] = -e * r - n * o - h * a, t;
    }, zn = function(t, s) {
        return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = .5 * s[0], t[5] = .5 * s[1], 
        t[6] = .5 * s[2], t[7] = 0, t;
    }, Un = function(t, s) {
        return t[0] = s[0], t[1] = s[1], t[2] = s[2], t[3] = s[3], t[4] = 0, t[5] = 0, t[6] = 0, 
        t[7] = 0, t;
    }, Wn = function(t, s) {
        var e = mn();
        Ci(e, s);
        var n = new i(3);
        return Ii(n, s), Bn(t, e, n), t;
    }, Jn = function(t, s) {
        return t[0] = s[0], t[1] = s[1], t[2] = s[2], t[3] = s[3], t[4] = s[4], t[5] = s[5], 
        t[6] = s[6], t[7] = s[7], t;
    }, Qn = function(t) {
        return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0, 
        t;
    }, Yn = function(t, s, i, e, n, h, r, o, a) {
        return t[0] = s, t[1] = i, t[2] = e, t[3] = n, t[4] = h, t[5] = r, t[6] = o, t[7] = a, 
        t;
    }, Vn = function(t, s) {
        return t[0] = s[4], t[1] = s[5], t[2] = s[6], t[3] = s[7], t;
    }, Hn = function(t, s) {
        return t[4] = s[0], t[5] = s[1], t[6] = s[2], t[7] = s[3], t;
    }, qn = function(t, s) {
        var i = s[4], e = s[5], n = s[6], h = s[7], r = -s[0], o = -s[1], a = -s[2], u = s[3];
        return t[0] = 2 * (i * u + h * r + e * a - n * o), t[1] = 2 * (e * u + h * o + n * r - i * a), 
        t[2] = 2 * (n * u + h * a + i * o - e * r), t;
    }, Xn = function(t, s, i) {
        var e = s[0], n = s[1], h = s[2], r = s[3], o = .5 * i[0], a = .5 * i[1], u = .5 * i[2], l = s[4], c = s[5], f = s[6], d = s[7];
        return t[0] = e, t[1] = n, t[2] = h, t[3] = r, t[4] = r * o + n * u - h * a + l, 
        t[5] = r * a + h * o - e * u + c, t[6] = r * u + e * a - n * o + f, t[7] = -e * o - n * a - h * u + d, 
        t;
    }, Zn = function(t, s, i) {
        var e = -s[0], n = -s[1], h = -s[2], r = s[3], o = s[4], a = s[5], u = s[6], l = s[7], c = o * r + l * e + a * h - u * n, f = a * r + l * n + u * e - o * h, d = u * r + l * h + o * n - a * e, p = l * r - o * e - a * n - u * h;
        return bn(t, s, i), e = t[0], n = t[1], h = t[2], r = t[3], t[4] = c * r + p * e + f * h - d * n, 
        t[5] = f * r + p * n + d * e - c * h, t[6] = d * r + p * h + c * n - f * e, t[7] = p * r - c * e - f * n - d * h, 
        t;
    }, Kn = function(t, s, i) {
        var e = -s[0], n = -s[1], h = -s[2], r = s[3], o = s[4], a = s[5], u = s[6], l = s[7], c = o * r + l * e + a * h - u * n, f = a * r + l * n + u * e - o * h, d = u * r + l * h + o * n - a * e, p = l * r - o * e - a * n - u * h;
        return Tn(t, s, i), e = t[0], n = t[1], h = t[2], r = t[3], t[4] = c * r + p * e + f * h - d * n, 
        t[5] = f * r + p * n + d * e - c * h, t[6] = d * r + p * h + c * n - f * e, t[7] = p * r - c * e - f * n - d * h, 
        t;
    }, $n = function(t, s, i) {
        var e = -s[0], n = -s[1], h = -s[2], r = s[3], o = s[4], a = s[5], u = s[6], l = s[7], c = o * r + l * e + a * h - u * n, f = a * r + l * n + u * e - o * h, d = u * r + l * h + o * n - a * e, p = l * r - o * e - a * n - u * h;
        return vn(t, s, i), e = t[0], n = t[1], h = t[2], r = t[3], t[4] = c * r + p * e + f * h - d * n, 
        t[5] = f * r + p * n + d * e - c * h, t[6] = d * r + p * h + c * n - f * e, t[7] = p * r - c * e - f * n - d * h, 
        t;
    }, th = function(t, s, i) {
        var e = i[0], n = i[1], h = i[2], r = i[3], o = s[0], a = s[1], u = s[2], l = s[3];
        return t[0] = o * r + l * e + a * h - u * n, t[1] = a * r + l * n + u * e - o * h, 
        t[2] = u * r + l * h + o * n - a * e, t[3] = l * r - o * e - a * n - u * h, o = s[4], 
        a = s[5], u = s[6], l = s[7], t[4] = o * r + l * e + a * h - u * n, t[5] = a * r + l * n + u * e - o * h, 
        t[6] = u * r + l * h + o * n - a * e, t[7] = l * r - o * e - a * n - u * h, t;
    }, sh = function(t, s, i) {
        var e = s[0], n = s[1], h = s[2], r = s[3], o = i[0], a = i[1], u = i[2], l = i[3];
        return t[0] = e * l + r * o + n * u - h * a, t[1] = n * l + r * a + h * o - e * u, 
        t[2] = h * l + r * u + e * a - n * o, t[3] = r * l - e * o - n * a - h * u, o = i[4], 
        a = i[5], u = i[6], l = i[7], t[4] = e * l + r * o + n * u - h * a, t[5] = n * l + r * a + h * o - e * u, 
        t[6] = h * l + r * u + e * a - n * o, t[7] = r * l - e * o - n * a - h * u, t;
    }, ih = function(t, i, e, n) {
        if (Math.abs(n) < s) return Jn(t, i);
        var h = Math.hypot(e[0], e[1], e[2]);
        n *= .5;
        var r = Math.sin(n), o = r * e[0] / h, a = r * e[1] / h, u = r * e[2] / h, l = Math.cos(n), c = i[0], f = i[1], d = i[2], p = i[3];
        t[0] = c * l + p * o + f * u - d * a, t[1] = f * l + p * a + d * o - c * u, t[2] = d * l + p * u + c * a - f * o, 
        t[3] = p * l - c * o - f * a - d * u;
        var m = i[4], g = i[5], y = i[6], M = i[7];
        return t[4] = m * l + M * o + g * u - y * a, t[5] = g * l + M * a + y * o - m * u, 
        t[6] = y * l + M * u + m * a - g * o, t[7] = M * l - m * o - g * a - y * u, t;
    }, eh = function(t, s, i) {
        return t[0] = s[0] + i[0], t[1] = s[1] + i[1], t[2] = s[2] + i[2], t[3] = s[3] + i[3], 
        t[4] = s[4] + i[4], t[5] = s[5] + i[5], t[6] = s[6] + i[6], t[7] = s[7] + i[7], 
        t;
    }, nh = function(t, s, i) {
        var e = s[0], n = s[1], h = s[2], r = s[3], o = i[4], a = i[5], u = i[6], l = i[7], c = s[4], f = s[5], d = s[6], p = s[7], m = i[0], g = i[1], y = i[2], M = i[3];
        return t[0] = e * M + r * m + n * y - h * g, t[1] = n * M + r * g + h * m - e * y, 
        t[2] = h * M + r * y + e * g - n * m, t[3] = r * M - e * m - n * g - h * y, t[4] = e * l + r * o + n * u - h * a + c * M + p * m + f * y - d * g, 
        t[5] = n * l + r * a + h * o - e * u + f * M + p * g + d * m - c * y, t[6] = h * l + r * u + e * a - n * o + d * M + p * y + c * g - f * m, 
        t[7] = r * l - e * o - n * a - h * u + p * M - c * m - f * g - d * y, t;
    }, hh = function(t, s, i) {
        return t[0] = s[0] * i, t[1] = s[1] * i, t[2] = s[2] * i, t[3] = s[3] * i, t[4] = s[4] * i, 
        t[5] = s[5] * i, t[6] = s[6] * i, t[7] = s[7] * i, t;
    }, rh = function(t, s, i, e) {
        var n = 1 - e;
        return ot(s, i) < 0 && (e = -e), t[0] = s[0] * n + i[0] * e, t[1] = s[1] * n + i[1] * e, 
        t[2] = s[2] * n + i[2] * e, t[3] = s[3] * n + i[3] * e, t[4] = s[4] * n + i[4] * e, 
        t[5] = s[5] * n + i[5] * e, t[6] = s[6] * n + i[6] * e, t[7] = s[7] * n + i[7] * e, 
        t;
    }, oh = function(t, s) {
        var i = lt(s);
        return t[0] = -s[0] / i, t[1] = -s[1] / i, t[2] = -s[2] / i, t[3] = s[3] / i, t[4] = -s[4] / i, 
        t[5] = -s[5] / i, t[6] = -s[6] / i, t[7] = s[7] / i, t;
    }, ah = function(t, s) {
        return t[0] = -s[0], t[1] = -s[1], t[2] = -s[2], t[3] = s[3], t[4] = -s[4], t[5] = -s[5], 
        t[6] = -s[6], t[7] = s[7], t;
    }, uh = function(t, s) {
        var i = lt(s);
        if (i > 0) {
            i = Math.sqrt(i);
            var e = s[0] / i, n = s[1] / i, h = s[2] / i, r = s[3] / i, o = s[4], a = s[5], u = s[6], l = s[7], c = e * o + n * a + h * u + r * l;
            t[0] = e, t[1] = n, t[2] = h, t[3] = r, t[4] = (o - e * c) / i, t[5] = (a - n * c) / i, 
            t[6] = (u - h * c) / i, t[7] = (l - r * c) / i;
        }
        return t;
    }, lh = function(t) {
        return "quat2(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ")";
    }, ch = function(t, s) {
        return t[0] === s[0] && t[1] === s[1] && t[2] === s[2] && t[3] === s[3] && t[4] === s[4] && t[5] === s[5] && t[6] === s[6] && t[7] === s[7];
    }, fh = function(t, i) {
        var e = t[0], n = t[1], h = t[2], r = t[3], o = t[4], a = t[5], u = t[6], l = t[7], c = i[0], f = i[1], d = i[2], p = i[3], m = i[4], g = i[5], y = i[6], M = i[7];
        return Math.abs(e - c) <= s * Math.max(1, Math.abs(e), Math.abs(c)) && Math.abs(n - f) <= s * Math.max(1, Math.abs(n), Math.abs(f)) && Math.abs(h - d) <= s * Math.max(1, Math.abs(h), Math.abs(d)) && Math.abs(r - p) <= s * Math.max(1, Math.abs(r), Math.abs(p)) && Math.abs(o - m) <= s * Math.max(1, Math.abs(o), Math.abs(m)) && Math.abs(a - g) <= s * Math.max(1, Math.abs(a), Math.abs(g)) && Math.abs(u - y) <= s * Math.max(1, Math.abs(u), Math.abs(y)) && Math.abs(l - M) <= s * Math.max(1, Math.abs(l), Math.abs(M));
    }, dh = function() {
        var t = new i(2);
        return i != Float32Array && (t[0] = 0, t[1] = 0), t;
    }, ph = function(t) {
        var s = new i(2);
        return s[0] = t[0], s[1] = t[1], s;
    }, mh = function(t, s) {
        var e = new i(2);
        return e[0] = t, e[1] = s, e;
    }, gh = function(t, s) {
        return t[0] = s[0], t[1] = s[1], t;
    }, yh = function(t, s, i) {
        return t[0] = s, t[1] = i, t;
    }, Mh = function(t, s, i) {
        return t[0] = s[0] + i[0], t[1] = s[1] + i[1], t;
    }, wh = function(t, s, i) {
        return t[0] = s[0] - i[0], t[1] = s[1] - i[1], t;
    }, Sh = function(t, s, i) {
        return t[0] = s[0] * i[0], t[1] = s[1] * i[1], t;
    }, bh = function(t, s, i) {
        return t[0] = s[0] / i[0], t[1] = s[1] / i[1], t;
    }, Th = function(t, s) {
        return t[0] = Math.ceil(s[0]), t[1] = Math.ceil(s[1]), t;
    }, vh = function(t, s) {
        return t[0] = Math.floor(s[0]), t[1] = Math.floor(s[1]), t;
    }, xh = function(t, s, i) {
        return t[0] = Math.min(s[0], i[0]), t[1] = Math.min(s[1], i[1]), t;
    }, Ih = function(t, s, i) {
        return t[0] = Math.max(s[0], i[0]), t[1] = Math.max(s[1], i[1]), t;
    }, Gh = function(t, s) {
        return t[0] = Math.round(s[0]), t[1] = Math.round(s[1]), t;
    }, Ch = function(t, s, i) {
        return t[0] = s[0] * i, t[1] = s[1] * i, t;
    }, _h = function(t, s, i, e) {
        return t[0] = s[0] + i[0] * e, t[1] = s[1] + i[1] * e, t;
    }, Eh = function(t, s) {
        var i = s[0] - t[0], e = s[1] - t[1];
        return Math.hypot(i, e);
    }, Dh = function(t, s) {
        var i = s[0] - t[0], e = s[1] - t[1];
        return i * i + e * e;
    }, Ah = function(t) {
        var s = t[0], i = t[1];
        return Math.hypot(s, i);
    }, Nh = function(t) {
        var s = t[0], i = t[1];
        return s * s + i * i;
    }, Lh = function(t, s) {
        return t[0] = -s[0], t[1] = -s[1], t;
    }, Oh = function(t, s) {
        return t[0] = 1 / s[0], t[1] = 1 / s[1], t;
    }, Rh = function(t, s) {
        var i = s[0], e = s[1], n = i * i + e * e;
        return n > 0 && (n = 1 / Math.sqrt(n)), t[0] = s[0] * n, t[1] = s[1] * n, t;
    }, Ph = function(t, s) {
        return t[0] * s[0] + t[1] * s[1];
    }, kh = function(t, s, i) {
        var e = s[0] * i[1] - s[1] * i[0];
        return t[0] = t[1] = 0, t[2] = e, t;
    }, Fh = function(t, s, i, e) {
        var n = s[0], h = s[1];
        return t[0] = n + e * (i[0] - n), t[1] = h + e * (i[1] - h), t;
    }, jh = function(t, s) {
        s = s || 1;
        var i = 2 * e() * Math.PI;
        return t[0] = Math.cos(i) * s, t[1] = Math.sin(i) * s, t;
    }, Bh = function(t, s, i) {
        var e = s[0], n = s[1];
        return t[0] = i[0] * e + i[2] * n, t[1] = i[1] * e + i[3] * n, t;
    }, zh = function(t, s, i) {
        var e = s[0], n = s[1];
        return t[0] = i[0] * e + i[2] * n + i[4], t[1] = i[1] * e + i[3] * n + i[5], t;
    }, Uh = function(t, s, i) {
        var e = s[0], n = s[1];
        return t[0] = i[0] * e + i[3] * n + i[6], t[1] = i[1] * e + i[4] * n + i[7], t;
    }, Wh = function(t, s, i) {
        var e = s[0], n = s[1];
        return t[0] = i[0] * e + i[4] * n + i[12], t[1] = i[1] * e + i[5] * n + i[13], t;
    }, Jh = function(t, s, i, e) {
        var n = s[0] - i[0], h = s[1] - i[1], r = Math.sin(e), o = Math.cos(e);
        return t[0] = n * o - h * r + i[0], t[1] = n * r + h * o + i[1], t;
    }, Qh = function(t, s) {
        var i = t[0], e = t[1], n = s[0], h = s[1], r = Math.sqrt((i * i + e * e) * (n * n + h * h)), o = r && (i * n + e * h) / r;
        return Math.acos(Math.min(Math.max(o, -1), 1));
    }, Yh = function(t) {
        return t[0] = 0, t[1] = 0, t;
    }, Vh = function(t) {
        return "vec2(" + t[0] + ", " + t[1] + ")";
    }, Hh = function(t, s) {
        return t[0] === s[0] && t[1] === s[1];
    }, qh = function(t, i) {
        var e = t[0], n = t[1], h = i[0], r = i[1];
        return Math.abs(e - h) <= s * Math.max(1, Math.abs(e), Math.abs(h)) && Math.abs(n - r) <= s * Math.max(1, Math.abs(n), Math.abs(r));
    };
    s = 1e-6, i = "undefined" != typeof Float32Array ? Float32Array : Array, e = Math.random, 
    n = "zyx", h = Math.PI / 180, Math.hypot || (Math.hypot = function() {
        for (var t = 0, s = arguments.length; s--; ) t += arguments[s] * arguments[s];
        return Math.sqrt(t);
    }), r = {
        __proto__: null,
        EPSILON: s,
        get _$ARRAY_TYPE$_() {
            return i;
        },
        _$RANDOM$_: e,
        _$ANGLE_ORDER$_: n,
        _$setMatrixArrayType$_: _t,
        _$toRadian$_: Et,
        equals: Dt
    }, o = zt, a = Xt, u = Object.freeze({
        __proto__: null,
        create: At,
        clone: Nt,
        _$copy$_: Lt,
        identity: Ot,
        _$fromValues$_: Rt,
        set: Pt,
        _$transpose$_: kt,
        _$invert$_: Ft,
        _$adjoint$_: jt,
        _$determinant$_: Bt,
        multiply: zt,
        rotate: Ut,
        scale: Wt,
        _$fromRotation$_: Jt,
        _$fromScaling$_: Qt,
        _$str$_: Yt,
        _$frob$_: Vt,
        _$LDU$_: Ht,
        add: qt,
        _$subtract$_: Xt,
        _$exactEquals$_: Zt,
        equals: Kt,
        _$multiplyScalar$_: $t,
        _$multiplyScalarAndAdd$_: ts,
        mul: o,
        sub: a
    }), l = us, c = ws, f = Object.freeze({
        __proto__: null,
        create: ss,
        clone: is,
        _$copy$_: es,
        identity: ns,
        _$fromValues$_: hs,
        set: rs,
        _$invert$_: os,
        _$determinant$_: as,
        multiply: us,
        rotate: ls,
        scale: cs,
        translate: fs,
        _$fromRotation$_: ds,
        _$fromScaling$_: ps,
        _$fromTranslation$_: ms,
        _$str$_: gs,
        _$frob$_: ys,
        add: Ms,
        _$subtract$_: ws,
        _$multiplyScalar$_: Ss,
        _$multiplyScalarAndAdd$_: bs,
        _$exactEquals$_: Ts,
        equals: vs,
        mul: l,
        sub: c
    }), d = Rs, p = qs, m = Object.freeze({
        __proto__: null,
        create: xs,
        _$fromMat4$_: Is,
        clone: Gs,
        _$copy$_: Cs,
        _$fromValues$_: _s,
        set: Es,
        identity: Ds,
        _$transpose$_: As,
        _$invert$_: Ns,
        _$adjoint$_: Ls,
        _$determinant$_: Os,
        multiply: Rs,
        translate: Ps,
        rotate: ks,
        scale: Fs,
        _$fromTranslation$_: js,
        _$fromRotation$_: Bs,
        _$fromScaling$_: zs,
        _$fromMat2d$_: Us,
        _$fromQuat$_: Ws,
        _$normalFromMat4$_: Js,
        _$projection$_: Qs,
        _$str$_: Ys,
        _$frob$_: Vs,
        add: Hs,
        _$subtract$_: qs,
        _$multiplyScalar$_: Xs,
        _$multiplyScalarAndAdd$_: Zs,
        _$exactEquals$_: Ks,
        equals: $s,
        mul: d,
        sub: p
    }), g = Li, y = Pi, M = li, w = Wi, S = Object.freeze({
        __proto__: null,
        create: ti,
        clone: si,
        _$copy$_: ii,
        _$fromValues$_: ei,
        set: ni,
        identity: hi,
        _$transpose$_: ri,
        _$invert$_: oi,
        _$adjoint$_: ai,
        _$determinant$_: ui,
        multiply: li,
        translate: ci,
        scale: fi,
        rotate: di,
        _$rotateX$_: pi,
        _$rotateY$_: mi,
        _$rotateZ$_: gi,
        _$fromTranslation$_: yi,
        _$fromScaling$_: Mi,
        _$fromRotation$_: wi,
        _$fromXRotation$_: Si,
        _$fromYRotation$_: bi,
        _$fromZRotation$_: Ti,
        _$fromRotationTranslation$_: vi,
        _$fromQuat2$_: xi,
        _$getTranslation$_: Ii,
        _$getScaling$_: Gi,
        _$getRotation$_: Ci,
        _$decompose$_: _i,
        _$fromRotationTranslationScale$_: Ei,
        _$fromRotationTranslationScaleOrigin$_: Di,
        _$fromQuat$_: Ai,
        _$frustum$_: Ni,
        _$perspectiveNO$_: Li,
        perspective: g,
        _$perspectiveZO$_: Oi,
        _$perspectiveFromFieldOfView$_: Ri,
        _$orthoNO$_: Pi,
        _$ortho$_: y,
        _$orthoZO$_: ki,
        _$lookAt$_: Fi,
        _$targetTo$_: ji,
        _$str$_: Bi,
        _$frob$_: zi,
        add: Ui,
        _$subtract$_: Wi,
        _$multiplyScalar$_: Ji,
        _$multiplyScalarAndAdd$_: Qi,
        _$exactEquals$_: Yi,
        equals: Vi,
        mul: M,
        sub: w
    }), b = se, T = ie, v = ee, x = ce, I = fe, G = Xi, C = de, t = Hi(), _ = function(s, i, e, n, h, r) {
        var o, a;
        for (i || (i = 3), e || (e = 0), a = n ? Math.min(n * i + e, s.length) : s.length, 
        o = e; o < a; o += i) t[0] = s[o], t[1] = s[o + 1], t[2] = s[o + 2], h(t, t, r), 
        s[o] = t[0], s[o + 1] = t[1], s[o + 2] = t[2];
        return s;
    }, E = Object.freeze({
        __proto__: null,
        create: Hi,
        clone: qi,
        length: Xi,
        _$fromValues$_: Zi,
        _$copy$_: Ki,
        set: $i,
        add: te,
        _$subtract$_: se,
        multiply: ie,
        _$divide$_: ee,
        ceil: ne,
        floor: he,
        min: re,
        max: oe,
        round: ae,
        scale: ue,
        _$scaleAndAdd$_: le,
        _$distance$_: ce,
        _$squaredDistance$_: fe,
        _$squaredLength$_: de,
        _$negate$_: pe,
        inverse: me,
        normalize: ge,
        _$dot$_: ye,
        _$cross$_: Me,
        _$lerp$_: we,
        _$slerp$_: Se,
        _$hermite$_: be,
        _$bezier$_: Te,
        random: ve,
        _$transformMat4$_: xe,
        _$transformMat3$_: Ie,
        _$transformQuat$_: Ge,
        _$rotateX$_: Ce,
        _$rotateY$_: _e,
        _$rotateZ$_: Ee,
        angle: De,
        _$zero$_: Ae,
        _$str$_: Ne,
        _$exactEquals$_: Le,
        equals: Oe,
        sub: b,
        mul: T,
        div: v,
        _$dist$_: x,
        _$sqrDist$_: I,
        _$len$_: G,
        _$sqrLen$_: C,
        forEach: _
    }), D = ze, A = Ue, N = We, L = Ze, O = Ke, R = $e, P = tn, k = function() {
        var t = Re();
        return function(s, i, e, n, h, r) {
            var o, a;
            for (i || (i = 4), e || (e = 0), a = n ? Math.min(n * i + e, s.length) : s.length, 
            o = e; o < a; o += i) t[0] = s[o], t[1] = s[o + 1], t[2] = s[o + 2], t[3] = s[o + 3], 
            h(t, t, r), s[o] = t[0], s[o + 1] = t[1], s[o + 2] = t[2], s[o + 3] = t[3];
            return s;
        };
    }(), F = Object.freeze({
        __proto__: null,
        create: Re,
        clone: Pe,
        _$fromValues$_: ke,
        _$copy$_: Fe,
        set: je,
        add: Be,
        _$subtract$_: ze,
        multiply: Ue,
        _$divide$_: We,
        ceil: Je,
        floor: Qe,
        min: Ye,
        max: Ve,
        round: He,
        scale: qe,
        _$scaleAndAdd$_: Xe,
        _$distance$_: Ze,
        _$squaredDistance$_: Ke,
        length: $e,
        _$squaredLength$_: tn,
        _$negate$_: sn,
        inverse: en,
        normalize: nn,
        _$dot$_: hn,
        _$cross$_: rn,
        _$lerp$_: on,
        random: an,
        _$transformMat4$_: un,
        _$transformQuat$_: ln,
        _$zero$_: cn,
        _$str$_: fn,
        _$exactEquals$_: dn,
        equals: pn,
        sub: D,
        mul: A,
        div: N,
        _$dist$_: L,
        _$sqrDist$_: O,
        _$len$_: R,
        _$sqrLen$_: P,
        forEach: k
    }), j = Pe, B = ke, z = Fe, U = je, W = Be, J = Sn, Q = qe, Y = hn, V = on, q = H = $e, 
    Z = X = tn, K = nn, $ = dn, tt = function() {
        var t = Hi(), s = Zi(1, 0, 0), i = Zi(0, 1, 0);
        return function(e, n, h) {
            var r = ye(n, h);
            return r < -.999999 ? (Me(t, s, n), G(t) < 1e-6 && Me(t, i, n), ge(t, t), yn(e, t, Math.PI), 
            e) : r > .999999 ? (e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e) : (Me(t, n, h), e[0] = t[0], 
            e[1] = t[1], e[2] = t[2], e[3] = 1 + r, K(e, e));
        };
    }(), st = function() {
        var t = mn(), s = mn();
        return function(i, e, n, h, r, o) {
            return _n(t, e, r, o), _n(s, n, h, o), _n(i, t, s, 2 * o * (1 - o)), i;
        };
    }(), it = function() {
        var t = xs();
        return function(s, i, e, n) {
            return t[0] = e[0], t[3] = e[1], t[6] = e[2], t[1] = n[0], t[4] = n[1], t[7] = n[2], 
            t[2] = -i[0], t[5] = -i[1], t[8] = -i[2], K(s, Nn(s, t));
        };
    }(), et = Object.freeze({
        __proto__: null,
        create: mn,
        identity: gn,
        _$setAxisAngle$_: yn,
        _$getAxisAngle$_: Mn,
        _$getAngle$_: wn,
        multiply: Sn,
        _$rotateX$_: bn,
        _$rotateY$_: Tn,
        _$rotateZ$_: vn,
        _$calculateW$_: xn,
        exp: In,
        _$ln$_: Gn,
        pow: Cn,
        _$slerp$_: _n,
        random: En,
        _$invert$_: Dn,
        _$conjugate$_: An,
        _$fromMat3$_: Nn,
        _$fromEuler$_: Ln,
        _$str$_: On,
        clone: j,
        _$fromValues$_: B,
        _$copy$_: z,
        set: U,
        add: W,
        mul: J,
        scale: Q,
        _$dot$_: Y,
        _$lerp$_: V,
        length: H,
        _$len$_: q,
        _$squaredLength$_: X,
        _$sqrLen$_: Z,
        normalize: K,
        _$exactEquals$_: $,
        equals: Rn,
        _$rotationTo$_: tt,
        _$sqlerp$_: st,
        _$setAxes$_: it
    }), nt = z, ht = z, rt = nh, ot = Y, ut = at = H, ct = lt = X, ft = Object.freeze({
        __proto__: null,
        create: Pn,
        clone: kn,
        _$fromValues$_: Fn,
        _$fromRotationTranslationValues$_: jn,
        _$fromRotationTranslation$_: Bn,
        _$fromTranslation$_: zn,
        _$fromRotation$_: Un,
        _$fromMat4$_: Wn,
        _$copy$_: Jn,
        identity: Qn,
        set: Yn,
        _$getReal$_: nt,
        _$getDual$_: Vn,
        _$setReal$_: ht,
        _$setDual$_: Hn,
        _$getTranslation$_: qn,
        translate: Xn,
        _$rotateX$_: Zn,
        _$rotateY$_: Kn,
        _$rotateZ$_: $n,
        _$rotateByQuatAppend$_: th,
        _$rotateByQuatPrepend$_: sh,
        _$rotateAroundAxis$_: ih,
        add: eh,
        multiply: nh,
        mul: rt,
        scale: hh,
        _$dot$_: ot,
        _$lerp$_: rh,
        _$invert$_: oh,
        _$conjugate$_: ah,
        length: at,
        _$len$_: ut,
        _$squaredLength$_: lt,
        _$sqrLen$_: ct,
        normalize: uh,
        _$str$_: lh,
        _$exactEquals$_: ch,
        equals: fh
    }), dt = Ah, pt = wh, mt = Sh, gt = bh, yt = Eh, Mt = Dh, wt = Nh, St = function() {
        var t = dh();
        return function(s, i, e, n, h, r) {
            var o, a;
            for (i || (i = 2), e || (e = 0), a = n ? Math.min(n * i + e, s.length) : s.length, 
            o = e; o < a; o += i) t[0] = s[o], t[1] = s[o + 1], h(t, t, r), s[o] = t[0], s[o + 1] = t[1];
            return s;
        };
    }(), bt = Object.freeze({
        __proto__: null,
        create: dh,
        clone: ph,
        _$fromValues$_: mh,
        _$copy$_: gh,
        set: yh,
        add: Mh,
        _$subtract$_: wh,
        multiply: Sh,
        _$divide$_: bh,
        ceil: Th,
        floor: vh,
        min: xh,
        max: Ih,
        round: Gh,
        scale: Ch,
        _$scaleAndAdd$_: _h,
        _$distance$_: Eh,
        _$squaredDistance$_: Dh,
        length: Ah,
        _$squaredLength$_: Nh,
        _$negate$_: Lh,
        inverse: Oh,
        normalize: Rh,
        _$dot$_: Ph,
        _$cross$_: kh,
        _$lerp$_: Fh,
        random: jh,
        _$transformMat2$_: Bh,
        _$transformMat2d$_: zh,
        _$transformMat3$_: Uh,
        _$transformMat4$_: Wh,
        rotate: Jh,
        angle: Qh,
        _$zero$_: Yh,
        _$str$_: Vh,
        _$exactEquals$_: Hh,
        equals: qh,
        _$len$_: dt,
        sub: pt,
        mul: mt,
        div: gt,
        _$dist$_: yt,
        _$sqrDist$_: Mt,
        _$sqrLen$_: wt,
        forEach: St
    }), globalThis._$glMatrix$_ = r, globalThis._$glMatrix$_._$mat2$_ = u, globalThis._$glMatrix$_._$mat2d$_ = f, 
    globalThis._$glMatrix$_._$mat3$_ = m, globalThis._$glMatrix$_._$mat4$_ = S, globalThis._$glMatrix$_._$quat$_ = et, 
    globalThis._$glMatrix$_._$quat2$_ = ft, globalThis._$glMatrix$_._$vec2$_ = bt, globalThis._$glMatrix$_._$vec3$_ = E, 
    globalThis._$glMatrix$_._$vec4$_ = F;
}

var t, s, i, e, n, h, r, o, a, u, l, c, f, d, p, m, g, y, M, w, S, b, T, v, x, I, G, C, _, E, D, A, N, L, O, R, P, k, F, j, B, z, U, W, J, Q, Y, V, H, q, X, Z, K, $, tt, st, it, et, nt, ht, rt, ot, at, ut, lt, ct, ft, dt, pt, mt, gt, yt, Mt, wt, St, bt, Tt, vt, xt, It;

{
    let Xh = function(t, s, i) {
        i = i || 0;
        var e, n, h, r, o, a, u, l = [ 0, 0 ];
        return e = t[1][1] - t[0][1], n = t[0][0] - t[1][0], h = e * t[0][0] + n * t[0][1], 
        r = s[1][1] - s[0][1], o = s[0][0] - s[1][0], a = r * s[0][0] + o * s[0][1], Tr(u = e * o - r * n, 0, i) || (l[0] = (o * h - n * a) / u, 
        l[1] = (e * a - r * h) / u), l;
    }, Zh = function(t, s, i, e) {
        var n = s[0] - t[0], h = s[1] - t[1], r = e[0] - i[0], o = e[1] - i[1];
        if (r * h - o * n == 0) return !1;
        var a = (n * (i[1] - t[1]) + h * (t[0] - i[0])) / (r * h - o * n), u = (r * (t[1] - i[1]) + o * (i[0] - t[0])) / (o * n - r * h);
        return a >= 0 && a <= 1 && u >= 0 && u <= 1;
    }, Kh = function(t, s, i) {
        return (s[0] - t[0]) * (i[1] - t[1]) - (i[0] - t[0]) * (s[1] - t[1]);
    }, $h = function(t, s, i) {
        return Kh(t, s, i) > 0;
    }, tr = function(t, s, i) {
        return Kh(t, s, i) >= 0;
    }, sr = function(t, s, i) {
        return Kh(t, s, i) < 0;
    }, ir = function(t, s, i) {
        return Kh(t, s, i) <= 0;
    }, er = function(t, s, i, e) {
        if (e) {
            var n = Tt, h = vt;
            n[0] = s[0] - t[0], n[1] = s[1] - t[1], h[0] = i[0] - s[0], h[1] = i[1] - s[1];
            var r = n[0] * h[0] + n[1] * h[1], o = Math.sqrt(n[0] * n[0] + n[1] * n[1]), a = Math.sqrt(h[0] * h[0] + h[1] * h[1]);
            return Math.acos(r / (o * a)) < e;
        }
        return 0 === Kh(t, s, i);
    }, nr = function(t, s) {
        var i = s[0] - t[0], e = s[1] - t[1];
        return i * i + e * e;
    }, hr = function(t, s) {
        var i = t.length;
        return t[s < 0 ? s % i + i : s % i];
    }, rr = function(t) {
        t.length = 0;
    }, or = function(t, s, i, e) {
        for (var n = i; n < e; n++) t.push(s[n]);
    }, ar = function(t) {
        for (var s = 0, i = t, e = 1; e < t.length; ++e) (i[e][1] < i[s][1] || i[e][1] === i[s][1] && i[e][0] > i[s][0]) && (s = e);
        return !$h(hr(t, s - 1), hr(t, s), hr(t, s + 1)) && (ur(t), !0);
    }, ur = function(t) {
        for (var s = [], i = t.length, e = 0; e !== i; e++) s.push(t.pop());
        for (e = 0; e !== i; e++) t[e] = s[e];
    }, lr = function(t, s) {
        return sr(hr(t, s - 1), hr(t, s), hr(t, s + 1));
    }, cr = function(t, s, i) {
        var e, n, h = xt, r = It;
        if (tr(hr(t, s + 1), hr(t, s), hr(t, i)) && ir(hr(t, s - 1), hr(t, s), hr(t, i))) return !1;
        n = nr(hr(t, s), hr(t, i));
        for (var o = 0; o !== t.length; ++o) if ((o + 1) % t.length !== s && o !== s && tr(hr(t, s), hr(t, i), hr(t, o + 1)) && ir(hr(t, s), hr(t, i), hr(t, o)) && (h[0] = hr(t, s), 
        h[1] = hr(t, i), r[0] = hr(t, o), r[1] = hr(t, o + 1), e = Xh(h, r), nr(hr(t, s), e) < n)) return !1;
        return !0;
    }, fr = function(t, s, i) {
        for (var e = 0; e !== t.length; ++e) if (e !== s && e !== i && (e + 1) % t.length !== s && (e + 1) % t.length !== i && Zh(hr(t, s), hr(t, i), hr(t, e), hr(t, e + 1))) return !1;
        return !0;
    }, dr = function(t, s, i, e) {
        var n = e || [];
        if (rr(n), s < i) for (var h = s; h <= i; h++) n.push(t[h]); else {
            for (h = 0; h <= i; h++) n.push(t[h]);
            for (h = s; h < t.length; h++) n.push(t[h]);
        }
        return n;
    }, pr = function(t) {
        for (var s = [], i = [], e = [], n = [], h = Number.MAX_VALUE, r = 0; r < t.length; ++r) if (lr(t, r)) for (var o = 0; o < t.length; ++o) if (cr(t, r, o)) {
            i = pr(dr(t, r, o, n)), e = pr(dr(t, o, r, n));
            for (var a = 0; a < e.length; a++) i.push(e[a]);
            i.length < h && (s = i, h = i.length, s.push([ hr(t, r), hr(t, o) ]));
        }
        return s;
    }, mr = function(t) {
        var s = pr(t);
        return s.length > 0 ? gr(t, s) : [ t ];
    }, gr = function(t, s) {
        if (0 === s.length) return [ t ];
        if (s instanceof Array && s.length && s[0] instanceof Array && 2 === s[0].length && s[0][0] instanceof Array) {
            for (var i = [ t ], e = 0; e < s.length; e++) for (var n = s[e], h = 0; h < i.length; h++) {
                var r = gr(i[h], n);
                if (r) {
                    i.splice(h, 1), i.push(r[0], r[1]);
                    break;
                }
            }
            return i;
        }
        return n = s, e = t.indexOf(n[0]), h = t.indexOf(n[1]), -1 !== e && -1 !== h && [ dr(t, e, h), dr(t, h, e) ];
    }, yr = function(t) {
        var s, i = t;
        for (s = 0; s < i.length - 1; s++) for (var e = 0; e < s - 1; e++) if (Zh(i[s], i[s + 1], i[e], i[e + 1])) return !1;
        for (s = 1; s < i.length - 2; s++) if (Zh(i[0], i[i.length - 1], i[s], i[s + 1])) return !1;
        return !0;
    }, Mr = function(t, s, i, e, n) {
        n = n || 0;
        var h = s[1] - t[1], r = t[0] - s[0], o = h * t[0] + r * t[1], a = e[1] - i[1], u = i[0] - e[0], l = a * i[0] + u * i[1], c = h * u - a * r;
        return Tr(c, 0, n) ? [ 0, 0 ] : [ (u * o - r * l) / c, (h * l - a * o) / c ];
    }, wr = function(t, s, i, e, n, h, r) {
        h = h || 100, r = r || 0, n = n || 25, s = void 0 !== s ? s : [], i = i || [], e = e || [];
        var o = [ 0, 0 ], a = [ 0, 0 ], u = [ 0, 0 ], l = 0, c = 0, f = 0, d = 0, p = 0, m = 0, g = 0, y = [], M = [], w = t, S = t;
        if (S.length < 3) return s;
        if (++r > h) return console.warn("quickDecomp: max level (" + h + ") reached."), 
        s;
        for (var b = 0; b < t.length; ++b) if (lr(w, b)) {
            i.push(w[b]), l = c = Number.MAX_VALUE;
            for (var T = 0; T < t.length; ++T) $h(hr(w, b - 1), hr(w, b), hr(w, T)) && ir(hr(w, b - 1), hr(w, b), hr(w, T - 1)) && (u = Mr(hr(w, b - 1), hr(w, b), hr(w, T), hr(w, T - 1)), 
            sr(hr(w, b + 1), hr(w, b), u) && (f = nr(w[b], u)) < c && (c = f, a = u, m = T)), 
            $h(hr(w, b + 1), hr(w, b), hr(w, T + 1)) && ir(hr(w, b + 1), hr(w, b), hr(w, T)) && (u = Mr(hr(w, b + 1), hr(w, b), hr(w, T), hr(w, T + 1)), 
            $h(hr(w, b - 1), hr(w, b), u) && (f = nr(w[b], u)) < l && (l = f, o = u, p = T));
            if (m === (p + 1) % t.length) u[0] = (a[0] + o[0]) / 2, u[1] = (a[1] + o[1]) / 2, 
            e.push(u), b < p ? (or(y, w, b, p + 1), y.push(u), M.push(u), 0 !== m && or(M, w, m, w.length), 
            or(M, w, 0, b + 1)) : (0 !== b && or(y, w, b, w.length), or(y, w, 0, p + 1), y.push(u), 
            M.push(u), or(M, w, m, b + 1)); else {
                if (m > p && (p += t.length), d = Number.MAX_VALUE, p < m) return s;
                for (T = m; T <= p; ++T) tr(hr(w, b - 1), hr(w, b), hr(w, T)) && ir(hr(w, b + 1), hr(w, b), hr(w, T)) && (f = nr(hr(w, b), hr(w, T))) < d && fr(w, b, T) && (d = f, 
                g = T % t.length);
                b < g ? (or(y, w, b, g + 1), 0 !== g && or(M, w, g, S.length), or(M, w, 0, b + 1)) : (0 !== b && or(y, w, b, S.length), 
                or(y, w, 0, g + 1), or(M, w, g, b + 1));
            }
            return y.length < M.length ? (wr(y, s, i, e, n, h, r), wr(M, s, i, e, n, h, r)) : (wr(M, s, i, e, n, h, r), 
            wr(y, s, i, e, n, h, r)), s;
        }
        return s.push(t), s;
    }, Sr = function(t, s) {
        for (var i = 0, e = t.length - 1; t.length > 3 && e >= 0; --e) er(hr(t, e - 1), hr(t, e), hr(t, e + 1), s) && (t.splice(e % t.length, 1), 
        i++);
        return i;
    }, br = function(t, s) {
        for (var i = t.length - 1; i >= 1; --i) for (var e = t[i], n = i - 1; n >= 0; --n) vr(e, t[n], s) && t.splice(i, 1);
    }, Tr = function(t, s, i) {
        return i = i || 0, Math.abs(t - s) <= i;
    }, vr = function(t, s, i) {
        return Tr(t[0], s[0], i) && Tr(t[1], s[1], i);
    };
    Tt = [], vt = [], xt = [], It = [], self._$polyDecomp$_ = {
        _$decomp$_: mr,
        _$quickDecomp$_: wr,
        _$isSimple$_: yr,
        _$removeCollinearPoints$_: Sr,
        _$removeDuplicatePoints$_: br,
        _$makeCCW$_: ar
    };
}

{
    let xr = !1, Ir = !1, Gr = "dev";
    const Cr = Symbol("Construct internal API token");
    let _r = 14;
    const Er = self._$C3$_ = class {
        constructor() {
            throw TypeError("static class can't be instantiated");
        }
        static _$_GetInternalAPIToken$_() {
            if (_r <= 0) throw new Error("cannot obtain internal API token");
            return --_r, Cr;
        }
        static _$SetReady$_() {
            xr = !0;
        }
        static _$IsReady$_() {
            return xr;
        }
        static _$SetAppStarted$_() {
            Ir = !0;
        }
        static _$HasAppStarted$_() {
            return Ir;
        }
        static _$SetBuildMode$_(t) {
            Gr = t;
        }
        static _$GetBuildMode$_() {
            return Gr;
        }
        static _$IsReleaseBuild$_() {
            return "final" === Gr;
        }
    };
    Er._$isDebug$_ = !1, Er._$isDebugDefend$_ = !1, Er.hardwareConcurrency = navigator.hardwareConcurrency || 2, 
    self._$C3X$_ = {};
}

{
    const Dr = self._$C3$_;
    Dr._$QueryParser$_ = class {
        constructor(t) {
            this._$_queryString$_ = t, this._$_parameters$_ = new Map, this._$_Parse$_();
        }
        _$_Parse$_() {
            let t = this._$_queryString$_;
            (t.startsWith("?") || t.startsWith("#")) && (t = t.substr(1));
            const s = t.split("&");
            for (const t of s) this._$_ParseParameter$_(t);
        }
        _$_ParseParameter$_(t) {
            if (!t) return;
            if (!t.includes("=")) return void this._$_parameters$_.set(t, null);
            const s = t.indexOf("="), i = decodeURIComponent(t.substring(0, s)), e = decodeURIComponent(t.substring(s + 1));
            this._$_parameters$_.set(i, e);
        }
        _$LogAll$_() {
            for (const t of this._$_parameters$_) console.log("[QueryParser] Parameter '" + t[0] + "' = " + (null === t[1] ? "null" : "'" + t[1] + "'"));
        }
        _$Has$_(t) {
            return this._$_parameters$_.has(t);
        }
        _$Get$_(t) {
            const s = this._$_parameters$_.get(t);
            return void 0 === s ? null : s;
        }
        _$ClearHash$_() {
            history.replaceState("", document.title, location.pathname + location.search);
        }
        _$Reparse$_(t) {
            this._$_queryString$_ = t, this._$_parameters$_.clear(), this._$_Parse$_();
        }
    }, Dr._$QueryString$_ = new Dr._$QueryParser$_(location.search), Dr._$LocationHashString$_ = new Dr._$QueryParser$_(location.hash), 
    Dr._$QueryString$_._$Has$_("perf") && (Dr._$isPerformanceProfiling$_ = !0), "dev" !== Dr._$QueryString$_._$Get$_("mode") && Dr._$SetBuildMode$_("final");
}

{
    let Ar = function(t) {
        const s = parseFloat(t);
        return Or.get(s) || (s >= 13 ? "11" : "NT " + t);
    };
    0;
    const Nr = self._$C3$_, Lr = "(unknown)";
    Nr._$Platform$_ = {
        _$OS$_: Lr,
        _$OSVersion$_: Lr,
        _$Browser$_: Lr,
        _$BrowserVersion$_: Lr,
        _$BrowserVersionNumber$_: NaN,
        _$BrowserEngine$_: Lr,
        _$Context$_: "browser",
        _$IsDesktop$_: !0,
        _$IsMobile$_: !1,
        _$IsAppleOS$_: !1,
        _$IsIpadOS$_: !1,
        _$GetDetailedInfo$_: async () => {}
    };
    const Or = new Map([ [ 5, "2000" ], [ 5.1, "XP" ], [ 5.2, "XP" ], [ 6, "Vista" ], [ 6.1, "7" ], [ 6.2, "8" ], [ 6.3, "8.1" ], [ 10, "10" ] ]), Rr = navigator.userAgent, Pr = navigator.userAgentData;
    if (Pr && Pr.brands.length > 0) {
        let kr = function(t) {
            let s = "", i = "", e = "", n = "";
            for (const h of t) {
                const t = Fr.get(h.brand);
                !s && t && (s = t, i = h.version);
                const r = jr.get(h.brand);
                !e && r && (e = r, n = h.version);
            }
            s || "Chromium" !== e || (Nr._$Platform$_._$Browser$_ = "Chromium", Nr._$Platform$_._$BrowserVersion$_ = n), 
            Nr._$Platform$_._$Browser$_ = s || Lr, Nr._$Platform$_._$BrowserVersion$_ = i || Lr, 
            Nr._$Platform$_._$BrowserEngine$_ = e || Lr;
        };
        Nr._$Platform$_._$OS$_ = Pr.platform, Nr._$Platform$_._$IsMobile$_ = Pr.mobile, 
        Nr._$Platform$_._$IsDesktop$_ = !Nr._$Platform$_._$IsMobile$_;
        const Fr = new Map([ [ "Google Chrome", "Chrome" ], [ "Microsoft Edge", "Edge" ], [ "Opera", "Opera" ], [ "Opera GX", "Opera GX" ], [ "Mozilla Firefox", "Firefox" ], [ "Apple Safari", "Safari" ], [ "NW.js", "NW.js" ] ]), jr = new Map([ [ "Chromium", "Chromium" ], [ "Gecko", "Gecko" ], [ "WebKit", "WebKit" ] ]);
        kr(Pr.brands);
        let Br = !1;
        Nr._$Platform$_._$GetDetailedInfo$_ = async () => {
            if (!Br) try {
                const t = await navigator.userAgentData.getHighEntropyValues([ "platformVersion", "fullVersionList" ]);
                kr(t.fullVersionList), "Windows" === Nr._$Platform$_._$OS$_ ? Nr._$Platform$_._$OSVersion$_ = Ar(t.platformVersion) : Nr._$Platform$_._$OSVersion$_ = t.platformVersion, 
                Br = !0;
            } catch (t) {
                console.warn("Failed to get detailed user agent information: ", t);
            }
        };
    } else {
        let zr = function(t, s) {
            const i = Array.isArray(t) ? t : [ t ];
            for (const t of i) {
                const i = t.exec(Rr);
                if (i) {
                    s(i);
                    break;
                }
            }
        };
        zr(/windows\s+nt\s+([\d\.]+)/i, (t => {
            Nr._$Platform$_._$OS$_ = "Windows";
            const s = t[1];
            Nr._$Platform$_._$OSVersion$_ = Ar(s);
        })), zr(/mac\s+os\s+x\s+([\d\._]+)/i, (t => {
            Nr._$Platform$_._$OS$_ = "macOS", Nr._$Platform$_._$OSVersion$_ = t[1].replace(/_/g, ".");
        })), zr(/CrOS/, (() => {
            Nr._$Platform$_._$OS$_ = "Chrome OS";
        })), zr(/linux|openbsd|freebsd|netbsd/i, (() => {
            Nr._$Platform$_._$OS$_ = "Linux";
        })), zr(/android/i, (() => {
            Nr._$Platform$_._$OS$_ = "Android";
        })), zr(/android\s+([\d\.]+)/i, (t => {
            Nr._$Platform$_._$OS$_ = "Android", Nr._$Platform$_._$OSVersion$_ = t[1];
        })), Nr._$Platform$_._$OS$_ === Lr && (zr(/(iphone|ipod|ipad)/i, (t => {
            Nr._$Platform$_._$OS$_ = "iOS";
        })), zr([ /iphone\s+os\s+([\d\._]+)/i, /ipad[^)]*os\s+([\d\._]+)/i ], (t => {
            Nr._$Platform$_._$OS$_ = "iOS", Nr._$Platform$_._$OSVersion$_ = t[1].replace(/_/g, ".");
        })));
        const Ur = /chrome\//i.test(Rr), Wr = /chromium\//i.test(Rr), Jr = /edg\//i.test(Rr), Qr = /OPR\//.test(Rr), Yr = /nwjs/i.test(Rr), Vr = /safari\//i.test(Rr), Hr = /webkit/i.test(Rr);
        Jr || Qr || zr(/chrome\/([\d\.]+)/i, (t => {
            Nr._$Platform$_._$Browser$_ = "Chrome", Nr._$Platform$_._$BrowserVersion$_ = t[1], 
            Nr._$Platform$_._$BrowserEngine$_ = "Chromium";
        })), zr(/edg\/([\d\.]+)/i, (t => {
            Nr._$Platform$_._$Browser$_ = "Edge", Nr._$Platform$_._$BrowserVersion$_ = t[1], 
            Nr._$Platform$_._$BrowserEngine$_ = "Chromium";
        })), zr(/OPR\/([\d\.]+)/, (t => {
            Nr._$Platform$_._$Browser$_ = "Opera", Nr._$Platform$_._$BrowserVersion$_ = t[1], 
            Nr._$Platform$_._$BrowserEngine$_ = "Chromium";
        })), zr(/chromium\/([\d\.]+)/i, (t => {
            Nr._$Platform$_._$Browser$_ = "Chromium", Nr._$Platform$_._$BrowserVersion$_ = t[1], 
            Nr._$Platform$_._$BrowserEngine$_ = "Chromium";
        })), zr(/nwjs\/[0-9.]+/i, (t => {
            Nr._$Platform$_._$Browser$_ = "NW.js", Nr._$Platform$_._$BrowserVersion$_ = t[1], 
            Nr._$Platform$_._$BrowserEngine$_ = "Chromium", Nr._$Platform$_._$Context$_ = "nwjs";
        })), zr(/firefox\/([\d\.]+)/i, (t => {
            Nr._$Platform$_._$Browser$_ = "Firefox", Nr._$Platform$_._$BrowserVersion$_ = t[1], 
            Nr._$Platform$_._$BrowserEngine$_ = "Gecko";
        })), !Vr || Ur || Wr || Jr || Qr || Yr || (Nr._$Platform$_._$Browser$_ = "Safari", 
        Nr._$Platform$_._$BrowserEngine$_ = "WebKit", zr(/version\/([\d\.]+)/i, (t => {
            Nr._$Platform$_._$BrowserVersion$_ = t[1];
        })), zr(/crios\/([\d\.]+)/i, (t => {
            Nr._$Platform$_._$Browser$_ = "Chrome for iOS", Nr._$Platform$_._$BrowserVersion$_ = t[1];
        })), zr(/fxios\/([\d\.]+)/i, (t => {
            Nr._$Platform$_._$Browser$_ = "Firefox for iOS", Nr._$Platform$_._$BrowserVersion$_ = t[1];
        })), zr(/edgios\/([\d\.]+)/i, (t => {
            Nr._$Platform$_._$Browser$_ = "Edge for iOS", Nr._$Platform$_._$BrowserVersion$_ = t[1];
        }))), Nr._$Platform$_._$BrowserEngine$_ === Lr && Hr && (Nr._$Platform$_._$BrowserEngine$_ = "WebKit"), 
        "Android" === Nr._$Platform$_._$OS$_ && "Safari" === Nr._$Platform$_._$Browser$_ && (Nr._$Platform$_._$Browser$_ = "Stock");
        const qr = new Set([ "Windows", "macOS", "Linux", "Chrome OS" ]).has(Nr._$Platform$_._$OS$_) || "nwjs" === Nr._$Platform$_._$Context$_;
        Nr._$Platform$_._$IsDesktop$_ = qr, Nr._$Platform$_._$IsMobile$_ = !qr;
    }
    "Chrome" === Nr._$Platform$_._$Browser$_ && "browser" === Nr._$Platform$_._$Context$_ && /wv\)/.test(Rr) && (Nr._$Platform$_._$Context$_ = "webview"), 
    "nwjs" !== Nr._$Platform$_._$Context$_ && "undefined" != typeof window && (window.matchMedia && window.matchMedia("(display-mode: standalone)").matches || navigator.standalone) && (Nr._$Platform$_._$Context$_ = "webapp"), 
    Nr._$Platform$_._$BrowserVersionNumber$_ = parseFloat(Nr._$Platform$_._$BrowserVersion$_);
    "macOS" === Nr._$Platform$_._$OS$_ && navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && (Nr._$Platform$_._$OS$_ = "iOS", 
    Nr._$Platform$_._$OSVersion$_ = Nr._$Platform$_._$BrowserVersion$_, Nr._$Platform$_._$IsDesktop$_ = !1, 
    Nr._$Platform$_._$IsMobile$_ = !0, Nr._$Platform$_._$IsIpadOS$_ = !0), Nr._$Platform$_._$IsAppleOS$_ = "macOS" === Nr._$Platform$_._$OS$_ || "iOS" === Nr._$Platform$_._$OS$_;
}

{
    let Xr = function(t) {
        return new Promise(((s, i) => {
            t.onsuccess = () => s(t.result), t.onerror = () => i(t.error);
        }));
    }, Zr = function(t) {
        return new Promise(((s, i) => {
            t.oncomplete = () => s(), t.onerror = () => i(t.error), t.onabort = () => i(t.error);
        }));
    }, Kr = function(t, s) {
        return ao(t, s);
    }, $r = function(t, s) {
        return ao(t, s, !0);
    }, to = function(t) {
        so(t);
        let s = ho.get(t);
        return s instanceof Promise || (s = uo(t), ho.set(t, s), s.catch((s => ho.delete(t)))), 
        s;
    }, so = function(t) {
        if ("string" != typeof t) throw new TypeError("expected string");
    }, io = function(t, s) {
        const i = t.objectStore(no).openCursor();
        return new Promise((t => {
            const e = [];
            i.onsuccess = i => {
                const n = i.target.result;
                if (n) {
                    switch (s) {
                      case "entries":
                        e.push([ n.key, n.value ]);
                        break;

                      case "keys":
                        e.push(n.key);
                        break;

                      case "values":
                        e.push(n.value);
                    }
                    n.continue();
                } else t(e);
            };
        }));
    };
    0;
    const eo = 2, no = "keyvaluepairs", ho = new Map, ro = "undefined" != typeof IDBObjectStore && "function" == typeof IDBObjectStore.prototype.getAll, oo = "undefined" != typeof IDBObjectStore && "function" == typeof IDBObjectStore.prototype.getAllKeys;
    async function ao(t, s, i = !1, e = !0) {
        const n = await to(t);
        try {
            return s(n.transaction([ no ], i ? "readwrite" : "readonly"));
        } catch (n) {
            if (e && "InvalidStateError" === n.name) return ho.delete(t), ao(t, s, i, !1);
            throw n;
        }
    }
    async function uo(t) {
        so(t);
        const s = indexedDB.open(t, eo);
        return s.addEventListener("upgradeneeded", (s => {
            try {
                s.target.result.createObjectStore(no);
            } catch (s) {
                console.error(`Failed to create objectstore for database ${t}`, s);
            }
        })), Xr(s);
    }
    class lo {
        constructor(t) {
            so(t), this.name = t;
        }
        async ready() {
            await to(this.name);
        }
        set(t, s) {
            return so(t), $r(this.name, (async i => {
                const e = Xr(i.objectStore(no).put(s, t)), n = Zr(i);
                await Promise.all([ n, e ]);
            }));
        }
        get(t) {
            return so(t), Kr(this.name, (async s => {
                const i = Xr(s.objectStore(no).get(t)), e = Zr(s), [n, h] = await Promise.all([ e, i ]);
                return h;
            }));
        }
        delete(t) {
            return so(t), $r(this.name, (async s => {
                const i = Xr(s.objectStore(no).delete(t)), e = Zr(s);
                await Promise.all([ e, i ]);
            }));
        }
        clear() {
            return $r(this.name, (async t => {
                const s = Xr(t.objectStore(no).clear()), i = Zr(t);
                await Promise.all([ i, s ]);
            }));
        }
        keys() {
            return Kr(this.name, (async t => {
                let s;
                s = oo ? Xr(t.objectStore(no).getAllKeys()) : io(t, "keys");
                const i = Zr(t), [e, n] = await Promise.all([ i, s ]);
                return n;
            }));
        }
        values() {
            return Kr(this.name, (async t => {
                let s;
                s = ro ? Xr(t.objectStore(no).getAll()) : io(t, "values");
                const i = Zr(t), [e, n] = await Promise.all([ i, s ]);
                return n;
            }));
        }
        entries() {
            return Kr(this.name, (async t => {
                const s = io(t, "entries"), i = Zr(t), [e, n] = await Promise.all([ i, s ]);
                return n;
            }));
        }
    }
    self._$KVStorageContainer$_ = lo;
}

{
    let co = function(t) {
        throw new Error(`"${t}" is not implemented`);
    }, fo = function(t) {
        if ("function" == typeof t) throw new Error("localforage callback API is not implemented; please use the promise API instead");
    }, po = function(t) {
        return "object" == typeof t ? new Promise((s => {
            const {port1: i, port2: e} = new MessageChannel;
            e.onmessage = t => s(t.data), i.postMessage(t);
        })) : Promise.resolve(t);
    };
    0;
    const mo = self._$KVStorageContainer$_, go = [ /no available storage method found/i, /an attempt was made to break through the security policy of the user agent/i, /the user denied permission to access the database/i, /a mutation operation was attempted on a database that did not allow mutations/i, /idbfactory\.open\(\) called in an invalid security context/i ];
    class yo {
        constructor(t) {
            this._$_inst$_ = t, this._$_isInMemory$_ = !this._$_inst$_, this._$_isInMemory$_ || "undefined" != typeof indexedDB || (this._$_isInMemory$_ = !0, 
            console.warn("Unable to use local storage because IndexedDB API is not available")), 
            this._$_memoryStorage$_ = new Map;
        }
        _$_MaybeSwitchToMemoryFallback$_(t) {
            if (!this._$_isInMemory$_) for (const s of go) if (t && s.test(t.message)) {
                console.error("Unable to use local storage, reverting to in-memory store: ", t, t.message), 
                this._$_isInMemory$_ = !0;
                break;
            }
        }
        async _$_getItemFallback$_(t) {
            const s = this._$_memoryStorage$_.get(t), i = await po(s);
            return void 0 === i ? null : i;
        }
        async _$_setItemFallback$_(t, s) {
            s = await po(s), this._$_memoryStorage$_.set(t, s);
        }
        _$_removeItemFallback$_(t) {
            this._$_memoryStorage$_.delete(t);
        }
        _$_clearFallback$_() {
            this._$_memoryStorage$_.clear();
        }
        _$_keysFallback$_() {
            return Array.from(this._$_memoryStorage$_.keys());
        }
        _$IsInMemory$_() {
            return this._$_isInMemory$_;
        }
        _$GetMemoryStorage$_() {
            return this._$_memoryStorage$_;
        }
        _$SetMemoryStorage$_(t) {
            this._$_memoryStorage$_ = t;
        }
        async getItem(t, s) {
            if (fo(s), this._$_isInMemory$_) return await this._$_getItemFallback$_(t);
            let i;
            try {
                i = await this._$_inst$_.get(t);
            } catch (s) {
                return this._$_MaybeSwitchToMemoryFallback$_(s), this._$_isInMemory$_ ? await this._$_getItemFallback$_(t) : (console.error(`Error reading '${t}' from storage, returning null: `, s), 
                null);
            }
            return void 0 === i ? null : i;
        }
        async setItem(t, s, i) {
            if (fo(i), void 0 === s && (s = null), this._$_isInMemory$_) await this._$_setItemFallback$_(t, s); else try {
                await this._$_inst$_.set(t, s);
            } catch (i) {
                if (this._$_MaybeSwitchToMemoryFallback$_(i), !this._$_isInMemory$_) throw i;
                await this._$_setItemFallback$_(t, s);
            }
        }
        async removeItem(t, s) {
            if (fo(s), this._$_isInMemory$_) this._$_removeItemFallback$_(t); else try {
                await this._$_inst$_.delete(t);
            } catch (s) {
                this._$_MaybeSwitchToMemoryFallback$_(s), this._$_isInMemory$_ ? this._$_removeItemFallback$_(t) : console.error(`Error removing '${t}' from storage: `, s);
            }
        }
        async clear(t) {
            if (fo(t), this._$_isInMemory$_) this._$_clearFallback$_(); else try {
                await this._$_inst$_.clear();
            } catch (t) {
                this._$_MaybeSwitchToMemoryFallback$_(t), this._$_isInMemory$_ ? this._$_clearFallback$_() : console.error("Error clearing storage: ", t);
            }
        }
        async keys(t) {
            if (fo(t), this._$_isInMemory$_) return this._$_keysFallback$_();
            let s = [];
            try {
                s = await this._$_inst$_.keys();
            } catch (t) {
                if (this._$_MaybeSwitchToMemoryFallback$_(t), this._$_isInMemory$_) return this._$_keysFallback$_();
                console.error("Error getting storage keys: ", t);
            }
            return s;
        }
        ready(t) {
            return fo(t), this._$_isInMemory$_ ? Promise.resolve(!0) : this._$_inst$_.ready();
        }
        _$createInstance$_(t) {
            if (t._$forceInMemoryFallback$_) return new yo(null);
            {
                const s = t.name;
                if ("string" != typeof s) throw new TypeError("invalid store name");
                const i = new mo(s);
                return new yo(i);
            }
        }
        length(t) {
            co("localforage.length()");
        }
        key(t, s) {
            co("localforage.key()");
        }
        iterate(t, s) {
            co("localforage.iterate()");
        }
        _$setDriver$_(t) {
            co("localforage.setDriver()");
        }
        config(t) {
            co("localforage.config()");
        }
        _$defineDriver$_(t) {
            co("localforage.defineDriver()");
        }
        _$driver$_() {
            co("localforage.driver()");
        }
        supports(t) {
            co("localforage.supports()");
        }
        dropInstance() {
            co("localforage.dropInstance()");
        }
    }
    self.localforage = new yo(new mo("localforage"));
}

{
    const Mo = self._$C3$_;
    if (Mo._$Supports$_ = {}, Mo._$Supports$_._$WebAnimations$_ = (() => {
        try {
            if ("undefined" == typeof document) return !1;
            const t = document.createElement("div");
            return void 0 !== t.animate && void 0 !== t.animate([ {
                opacity: "0"
            }, {
                opacity: "1"
            } ], 1e3).reverse;
        } catch (t) {
            return !1;
        }
    })(), Mo._$Supports$_._$DialogElement$_ = "undefined" != typeof HTMLDialogElement, 
    Mo._$Supports$_._$RequestIdleCallback$_ = !!self.requestIdleCallback, Mo._$Supports$_.ImageBitmap = !!self.createImageBitmap, 
    Mo._$Supports$_.ImageBitmapOptions = !1, Mo._$Supports$_._$ImageBitmapOptionsResize$_ = !1, 
    Mo._$Supports$_.ImageBitmap) {
        try {
            self.createImageBitmap(new ImageData(32, 32), {
                premultiplyAlpha: "none"
            }).then((() => {
                Mo._$Supports$_.ImageBitmapOptions = !0;
            })).catch((() => {
                Mo._$Supports$_.ImageBitmapOptions = !1;
            }));
        } catch (wo) {
            Mo._$Supports$_.ImageBitmapOptions = !1;
        }
        try {
            self.createImageBitmap(new ImageData(32, 32), {
                resizeWidth: 10,
                resizeHeight: 10
            }).then((t => {
                Mo._$Supports$_._$ImageBitmapOptionsResize$_ = 10 === t.width && 10 === t.height;
            })).catch((() => {
                Mo._$Supports$_._$ImageBitmapOptionsResize$_ = !1;
            }));
        } catch (So) {
            Mo._$Supports$_._$ImageBitmapOptionsResize$_ = !1;
        }
    }
    if (Mo._$Supports$_._$ClipboardReadText$_ = !(!navigator.clipboard || !navigator.clipboard.readText), 
    Mo._$Supports$_._$PermissionsQuery$_ = !(!navigator.permissions || !navigator.permissions.query), 
    Mo._$Supports$_._$ClipboardPermissionsQuery$_ = !1, Mo._$Supports$_._$PermissionsQuery$_) {
        const bo = {
            name: "clipboard-read"
        };
        navigator.permissions.query(bo).then((() => {
            Mo._$Supports$_._$ClipboardPermissionsQuery$_ = !0;
        })).catch((() => {
            Mo._$Supports$_._$ClipboardPermissionsQuery$_ = !1;
        }));
    }
    Mo._$Supports$_._$AsyncClipboardApi$_ = !!(navigator.permissions && navigator.clipboard && self.ClipboardItem), 
    Mo._$Supports$_._$Proxies$_ = "undefined" != typeof Proxy, Mo._$Supports$_._$DownloadAttribute$_ = "undefined" != typeof document && void 0 !== document.createElement("a").download, 
    Mo._$Supports$_._$Fetch$_ = "function" == typeof fetch, Mo._$Supports$_._$PersistentStorage$_ = !!(self.isSecureContext && "Opera" !== Mo._$Platform$_._$Browser$_ && navigator.storage && navigator.storage.persist), 
    Mo._$Supports$_._$StorageQuotaEstimate$_ = !!(self.isSecureContext && navigator.storage && navigator.storage.estimate), 
    Mo._$Supports$_._$Fullscreen$_ = (() => {
        if ("undefined" == typeof document) return !1;
        if ("iOS" === Mo._$Platform$_._$OS$_) return !1;
        const t = document.documentElement;
        return !!(t.requestFullscreen || t.msRequestFullscreen || t.mozRequestFullScreen || t.webkitRequestFullscreen);
    })(), Mo._$Supports$_.ImageDecoder = void 0 !== self.ImageDecoder, Mo._$Supports$_._$WebCodecs$_ = !!self.VideoEncoder, 
    Mo._$Supports$_._$NativeFileSystemAPI$_ = !!self.showOpenFilePicker, Mo._$Supports$_._$QueryLocalFonts$_ = !!self.queryLocalFonts, 
    Mo._$Supports$_.UserActivation = !!navigator.userActivation, Mo._$Supports$_._$CanvasToBlobWebP$_ = !1, 
    (async () => {
        let t;
        "undefined" == typeof document ? t = new OffscreenCanvas(32, 32) : (t = document.createElement("canvas"), 
        t.width = 32, t.height = 32);
        const s = t.getContext("2d");
        s.fillStyle = "blue", s.fillRect(0, 0, 32, 32);
        let i = null;
        try {
            t.convertToBlob ? i = await t.convertToBlob({
                type: "image/webp",
                quality: 1
            }) : t.toBlob && (i = await new Promise((s => t.toBlob(s, "image/webp", 1)))), Mo._$Supports$_._$CanvasToBlobWebP$_ = i && "image/webp" === i.type;
        } catch (t) {
            Mo._$Supports$_._$CanvasToBlobWebP$_ = !1;
        }
    })();
}

{
    const To = self._$C3$_;
    if (!String.prototype.trimStart) {
        const vo = /^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*/;
        String.prototype.trimStart = function() {
            return this.replace(vo, "");
        };
    }
    if (!String.prototype.trimEnd) {
        const xo = /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*$/;
        String.prototype.trimEnd = function() {
            return this.replace(xo, "");
        };
    }
    if (String.prototype.replaceAll || (String.prototype.replaceAll = function(t, s) {
        return this.replace(new RegExp(To._$EscapeRegex$_(t), "g"), s);
    }), Array.prototype.values || (Array.prototype.values = function*() {
        for (const t of this) yield t;
    }), !Array.prototype.flat) {
        let Io = function(t, s) {
            return t.reduce(((t, i) => s > 0 && Array.isArray(i) ? (Array.prototype.push.apply(t, Io(i, s - 1)), 
            t) : (t.push(i), t)), []);
        };
        Array.prototype.flat = function(t = 1) {
            return Io(this, t);
        };
    }
    Array.prototype.at || (Array.prototype.at = function(t) {
        if ((t = Math.trunc(t) || 0) < 0 && (t += this.length), !(t < 0 || t >= this.length)) return this[t];
    }), String.prototype.at || (String.prototype.at = function(t) {
        if ((t = Math.trunc(t) || 0) < 0 && (t += this.length), !(t < 0 || t >= this.length)) return this[t];
    }), RegExp.escape || (RegExp.escape = function(t) {
        return String(t).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
    }), Set.prototype.isSubsetOf || (Set.prototype.isSubsetOf = function(t) {
        if (!(t instanceof Set)) throw new TypeError("argument must be a Set");
        for (const s of this) if (!t.has(s)) return !1;
        return !0;
    }), navigator.storage && !navigator.storage.estimate && navigator.webkitTemporaryStorage && navigator.webkitTemporaryStorage.queryUsageAndQuota && (navigator.storage.estimate = function() {
        return new Promise(((t, s) => navigator.webkitTemporaryStorage.queryUsageAndQuota(((s, i) => t({
            usage: s,
            quota: i
        })), s)));
    }), void 0 === self.isSecureContext && (self.isSecureContext = "https:" === location.protocol), 
    void 0 === self.globalThis && (self.globalThis = self);
}

{
    let Go = function(t) {
        let s = "Assertion failure: " + t + "\n\nStack trace:\n" + Co._$GetCallStack$_();
        console.error(s);
    };
    0;
    const Co = self._$C3$_;
    self.assert = function(t, s) {
        t || Go(s);
    };
}

{
    const _o = self._$C3$_, Eo = self._$C3X$_;
    _o._$IsNumber$_ = function(t) {
        return "number" == typeof t;
    }, _o._$IsFiniteNumber$_ = function(t) {
        return _o._$IsNumber$_(t) && isFinite(t);
    }, _o._$RequireNumber$_ = function(t) {
        if (!_o._$IsNumber$_(t)) throw new TypeError("expected number");
    }, _o._$RequireOptionalNumber$_ = function(t) {
        _o._$IsNullOrUndefined$_(t);
    }, _o._$RequireNumberInRange$_ = function(t, s, i) {
        if (!_o._$IsNumber$_(t) || isNaN(t) || s > t || i < t) throw new RangeError("number outside of range");
    }, _o._$RequireAllNumber$_ = function(...t) {
        for (let s of t) ;
    }, _o._$RequireFiniteNumber$_ = function(t) {
        if (!_o._$IsFiniteNumber$_(t)) throw new TypeError("expected finite number");
    }, _o._$RequireOptionalFiniteNumber$_ = function(t) {
        _o._$IsNullOrUndefined$_(t);
    }, _o._$RequireAllFiniteNumber$_ = function(...t) {
        for (let s of t) ;
    }, _o._$IsString$_ = function(t) {
        return "string" == typeof t;
    }, _o._$RequireString$_ = function(t) {
        if (!_o._$IsString$_(t)) throw new TypeError("expected string");
    }, _o._$RequireOptionalString$_ = function(t) {
        _o._$IsNullOrUndefined$_(t);
    }, _o._$RequireAllString$_ = function(...t) {
        for (let s of t) ;
    }, _o._$IsSimpleObject$_ = function(t) {
        if ("object" != typeof t || null === t) return !1;
        let s = Object.getPrototypeOf(t);
        return s ? s.constructor === Object : null === s;
    }, _o._$RequireSimpleObject$_ = function(t) {
        if (!_o._$IsSimpleObject$_(t)) throw new TypeError("expected simple object");
    }, _o._$RequireOptionalSimpleObject$_ = function(t) {
        if (!_o._$IsNullOrUndefined$_(t) && !_o._$IsSimpleObject$_(t)) throw new TypeError("expected simple object");
    }, _o._$IsObject$_ = function(t) {
        return "object" == typeof t && null !== t && !Array.isArray(t);
    }, _o._$RequireObject$_ = function(t) {
        if (!_o._$IsObject$_(t)) throw new TypeError("expected object");
    }, _o._$RequireOptionalObject$_ = function(t) {
        _o._$IsNullOrUndefined$_(t);
    }, _o._$RequireAllObject$_ = function(...t) {
        for (let s of t) ;
    }, _o._$IsFileLike$_ = function(t) {
        return _o._$WeakIsInstanceOf$_(t, Blob) && "string" == typeof t.name;
    }, _o._$RequireFileLike$_ = function(t) {
        if (!_o._$IsFileLike$_(t)) throw new TypeError("expected file");
    }, _o._$RequireOptionalFileLike$_ = function(t) {
        _o._$IsNullOrUndefined$_(t);
    }, _o._$IsArray$_ = function(t) {
        return Array.isArray(t);
    }, _o._$RequireArray$_ = function(t) {
        if (!_o._$IsArray$_(t)) throw new TypeError("expected array");
    }, _o._$RequireOptionalArray$_ = function(t) {
        _o._$IsNullOrUndefined$_(t);
    }, _o._$RequireAllArray$_ = function(...t) {
        for (let s of t) ;
    }, _o._$Is2DArray$_ = function(t) {
        return !(!_o._$IsArray$_(t) || t.length && !_o._$IsArray$_(t[0]));
    }, _o._$Require2DArray$_ = function(t) {
        if (!_o._$Is2DArray$_(t)) throw new TypeError("expected 2d array");
        for (let s of t) if (!_o._$IsArray$_(s)) throw new TypeError("expected 2d array");
    }, _o._$RequireOptional2DArray$_ = function(t) {
        _o._$IsNullOrUndefined$_(t);
    }, _o._$IsFunction$_ = function(t) {
        return "function" == typeof t;
    }, _o._$RequireFunction$_ = function(t, s) {
        if (!_o._$IsFunction$_(t)) throw new TypeError("expected function");
        if (!_o._$IsNullOrUndefined$_(s) && t !== s) throw new TypeError("expected same function reference");
    }, _o._$RequireOptionalFunction$_ = function(t) {
        _o._$IsNullOrUndefined$_(t);
    }, _o._$RequireAllFunction$_ = function(...t) {
        for (let s of t) ;
    }, _o._$RequireAnyFunction$_ = function(t, ...s) {
        if (!_o._$IsFunction$_(t)) throw new TypeError("expected function");
        if (!s.length) throw new Error("missing comparison functions");
        for (let i of s) if (!_o._$IsNullOrUndefined$_(i) && t === i) return;
        throw new TypeError("expected same function reference");
    }, _o._$RequireOptionalAllFunction$_ = function(...t) {
        if (!_o._$IsNullOrUndefined$_(t)) for (let s of t) ;
    }, _o._$IsInstanceOf$_ = function(t, s) {
        return t instanceof s;
    }, _o._$IsInstanceOfAny$_ = function(t, ...s) {
        for (let i of s) if (_o._$IsInstanceOf$_(t, i)) return !0;
        return !1;
    }, _o._$RequireInstanceOf$_ = function(t, s) {
        if (!_o._$IsInstanceOf$_(t, s)) throw new TypeError("unexpected type");
    }, _o._$RequireOptionalInstanceOf$_ = function(t, s) {
        _o._$IsNullOrUndefined$_(t);
    }, _o._$RequireAllInstanceOf$_ = function(t, ...s) {
        for (let t of s) ;
    }, _o._$RequireAnyInstanceOf$_ = function(t, ...s) {
        if (!_o._$IsInstanceOfAny$_(t, ...s)) throw new TypeError("unexpected type");
    }, _o._$RequireAnyOptionalInstanceOf$_ = function(t, ...s) {
        if (!_o._$IsNullOrUndefined$_(t) && !_o._$IsInstanceOfAny$_(t, ...s)) throw new TypeError("unexpected type");
    }, _o._$IsArrayOf$_ = function(t, s) {
        for (let i of t) if (!_o._$IsInstanceOf$_(i, s)) return !1;
        return !0;
    }, _o._$IsArrayOfFiniteNumbers$_ = function(t) {
        for (let s of t) if (!_o._$IsFiniteNumber$_(s)) return !1;
        return !0;
    }, _o._$RequireArrayOf$_ = function(t, s) {
        for (let s of t) ;
    }, _o._$RequireOptionalArrayOf$_ = function(t, s) {
        if (!_o._$IsNullOrUndefined$_(t)) for (let s of t) ;
    }, _o._$RequireOptionalArrayOfFunctions$_ = function(t, s) {
        if (!_o._$IsNullOrUndefined$_(t)) for (let s of t) ;
    }, _o._$RequireArrayOfAny$_ = function(t, ...s) {
        for (let s of t) ;
    }, _o._$RequireOptionalArrayOfAny$_ = function(t, ...s) {
        if (!_o._$IsNullOrUndefined$_(t)) for (let s of t) ;
    }, _o._$IsDOMNode$_ = function(t, s) {
        return !(_o._$IsNullOrUndefined$_(t) || !_o._$IsString$_(t.nodeName)) && (!s || _o._$equalsNoCase$_(t.nodeName, s));
    }, _o._$RequireDOMNode$_ = function(t, s) {
        if (_o._$IsNullOrUndefined$_(t) || !_o._$IsString$_(t.nodeName)) throw new TypeError("expected DOM node");
        if (s && !_o._$equalsNoCase$_(t.nodeName, s)) throw new TypeError(`expected DOM '${s}' node`);
    }, _o._$RequireOptionalDOMNode$_ = function(t, s) {
        _o._$IsNullOrUndefined$_(t);
    }, _o._$IsHTMLElement$_ = function(t, s) {
        return !(_o._$IsNullOrUndefined$_(t) || !_o._$IsString$_(t.tagName)) && (!s || _o._$equalsNoCase$_(t.tagName, s));
    }, _o._$RequireHTMLElement$_ = function(t, s) {
        if (_o._$IsNullOrUndefined$_(t) || !_o._$IsString$_(t.tagName)) throw new TypeError("expected HTML element");
        if (s && !_o._$equalsNoCase$_(t.tagName, s)) throw new TypeError(`expected HTML '${s}' element`);
    }, _o._$RequireOptionalHTMLElement$_ = function(t, s) {
        _o._$IsNullOrUndefined$_(t);
    }, _o._$IsDrawable$_ = function(t) {
        return _o._$IsHTMLElement$_(t, "img") || _o._$IsHTMLElement$_(t, "canvas") || _o._$IsHTMLElement$_(t, "video") || "undefined" != typeof OffscreenCanvas && t instanceof OffscreenCanvas || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap;
    }, _o._$RequireDrawable$_ = function(t) {
        if (!_o._$IsDrawable$_(t)) throw new TypeError("expected drawable");
    }, _o._$RequireOptionalDrawable$_ = function(t) {
        _o._$IsNullOrUndefined$_(t);
    }, _o._$IsDrawableOrImageData$_ = function(t) {
        return t instanceof ImageData || _o._$IsDrawable$_(t);
    }, _o._$RequireDrawableOrImageData$_ = function(t) {
        if (!_o._$IsDrawableOrImageData$_(t)) throw new TypeError("expected drawable or image data");
    }, _o._$RequireOptionalDrawableOrImageData$_ = function(t) {
        if (!_o._$IsNullOrUndefined$_(t) && !_o._$IsDrawableOrImageData$_(t)) throw new TypeError("expected drawable or image data");
    }, _o._$IsStringLike$_ = function(t) {
        return "string" == typeof t || _o._$HtmlString$_ && t instanceof _o._$HtmlString$_ || t instanceof _o._$BBString$_;
    }, _o._$RequireStringLike$_ = function(t) {
        if (!_o._$IsStringLike$_(t)) throw new TypeError("expected string-like");
    }, _o._$RequireOptionalStringLike$_ = function(t) {
        _o._$IsNullOrUndefined$_(t);
    }, _o._$RequireAllStringLike$_ = function(...t) {
        for (let s of t) ;
    }, _o._$RequireOverride$_ = function() {
        throw new Error("must be overridden");
    }, _o._$NotYetImplemented$_ = function() {
        throw new Error("not yet implemented");
    }, _o._$IsGeneratorFunction$_ = function(t) {
        return t.constructor === function*() {}.constructor;
    }, _o._$RequireGeneratorFunction$_ = function(t) {
        if (!_o._$IsGeneratorFunction$_(t)) throw new Error("expected generator function");
    }, _o._$IsIterable$_ = function(t) {
        return "function" === t[Symbol.iterator];
    }, _o._$RequireIterable$_ = function(t) {
        if (!_o._$IsIterable$_(t)) throw new Error("expected iterable");
    }, _o._$IsDefined$_ = function(t) {
        return !_o._$IsNullOrUndefined$_(t);
    }, _o._$IsNullOrUndefined$_ = function(t) {
        return null == t;
    }, _o._$AreArrayElementsOfSameType$_ = function(t) {
        let s = t[0].constructor;
        for (let i of t) if (i.constructor !== s) return !1;
        return s;
    }, _o._$AreArrayElementsOfType$_ = function(t, s) {
        for (let i of t) if (!(i instanceof s)) return !1;
        return !0;
    };
    const Do = Object.getPrototypeOf(Uint8Array);
    _o._$IsTypedArray$_ = function(t) {
        return _o._$IsInstanceOf$_(t, Do);
    }, _o._$RequireTypedArray$_ = function(t) {}, _o._$WeakRequireTypedArray$_ = function(t) {
        _o._$WeakRequireInstanceOf$_(t, Do);
    }, _o._$WeakRequireAnyInstanceOf$_ = function(t, ...s) {
        if (!_o._$WeakIsAnyInstanceOf$_(t, ...s)) throw new TypeError("unexpected type");
    }, _o._$WeakIsAnyInstanceOf$_ = function(t, ...s) {
        for (const i of s) if (_o._$WeakIsInstanceOf$_(t, i)) return !0;
        return !1;
    }, _o._$WeakRequireInstanceOf$_ = function(t, s) {
        if (!_o._$WeakIsInstanceOf$_(t, s)) throw new TypeError("unexpected type");
    }, _o._$WeakIsInstanceOf$_ = function(t, s) {
        for (;t = Object.getPrototypeOf(t); ) if (t.constructor.name === s.name) return !0;
        return !1;
    }, Eo._$RequireNumber$_ = _o._$RequireNumber$_, Eo._$RequireOptionalNumber$_ = _o._$RequireOptionalNumber$_, 
    Eo._$RequireFiniteNumber$_ = _o._$RequireFiniteNumber$_, Eo._$RequireOptionalFiniteNumber$_ = _o._$RequireOptionalFiniteNumber$_, 
    Eo._$RequireString$_ = _o._$RequireString$_, Eo._$RequireOptionalString$_ = _o._$RequireOptionalString$_, 
    Eo._$RequireObject$_ = _o._$RequireObject$_, Eo._$RequireOptionalObject$_ = _o._$RequireOptionalObject$_, 
    Eo._$RequireArray$_ = _o._$RequireArray$_, Eo._$RequireOptionalArray$_ = _o._$RequireOptionalArray$_, 
    Eo._$RequireFunction$_ = _o._$RequireFunction$_, Eo._$RequireOptionalFunction$_ = _o._$RequireOptionalFunction$_, 
    Eo._$RequireInstanceOf$_ = _o._$RequireInstanceOf$_, Eo._$RequireOptionalInstanceOf$_ = _o._$RequireOptionalInstanceOf$_, 
    Eo._$IsNullOrUndefined$_ = _o._$IsNullOrUndefined$_;
}

{
    let Ao = function(t, s) {
        let i = Po.getType(t), e = Po.getType(s);
        return "null" === i || "null" === e || "undefined" !== i && "undefined" !== e && i === e;
    }, No = function(t) {
        console.warn("[Defence] " + t + " @", Po._$GetCallStack$_());
    }, Lo = function() {
        if (Jo = -1, jo.size > 0 || Bo.size > 0) {
            let t = [ ...new Set([ ...jo.keys() ].map((t => Po.getName(t)))) ].join(",");
            console.warn(`An object derived from DefendedBase was not protected with debugDefend(). This will disable some checks. See the coding guidelines! Possible affected class names: ${t}`), 
            jo.clear(), Bo.clear();
        }
    }, Oo = function(t) {
        let s = new Set;
        for (let i in t) s.add(i);
        return s;
    }, Ro = function(t, s) {
        let i = Oo(s), e = Qo.get(t);
        if (e) {
            let s = [];
            for (let t of e.values()) i.has(t) ? i.delete(t) : s.push(t);
            Po._$appendArray$_(s, [ ...i ]), s.length && console.warn(`[Defence] '${Po.getName(t)}' constructor creates inconsistent properties: ${s.join(", ")}`);
        } else Qo.set(t, i);
    };
    0;
    const Po = self._$C3$_, ko = new Map;
    let Fo;
    Po._$ColorLog$_ = function(t, s) {
        console.log(`%c${t}`, `font-weight: bold; color:${s}`);
    }, Po._$RafLog$_ = function(t, ...s) {
        ko.has(t) || ko.set(t, -1), -1 === ko.get(t) && ko.set(t, requestAnimationFrame((() => {
            console.log(`%c${t}`, "font-weight: bold", ...s), ko.set(t, -1);
        })));
    }, Po._$StartMeasure$_ = function(t) {
        performance.mark(t), Fo || (Fo = new Map), Fo.has(t) || Fo.set(t, {
            _$current$_: 0,
            total: 0,
            _$average$_: 0,
            _$calls$_: 1,
            toString: function() {
                return `${t} :: current => ${this._$current$_.toPrecision(3)} :: average => ${this._$average$_.toPrecision(3)} :: calls => ${this._$calls$_}`;
            }
        });
    }, Po._$EndMeasure$_ = function(t) {
        performance.measure(`measure-${t}`, t);
        const s = performance.getEntriesByName(`measure-${t}`)[0], i = Fo.get(t);
        i._$current$_ = s.duration, i.total += i._$current$_, i._$average$_ = i.total / i._$calls$_, 
        console.log(i.toString()), i._$calls$_++, performance.clearMarks(t), performance.clearMeasures(`measure-${t}`);
    }, Po._$GetCallStack$_ = function() {
        return (new Error).stack;
    }, Po._$Debugger$_ = function() {}, Po.cast = function(t, s) {
        return t && t instanceof s ? t : null;
    }, Po.getName = function(t) {
        return void 0 === t ? "undefined" : null === t ? "null" : "boolean" == typeof t ? "<boolean>" : Po._$IsNumber$_(t) ? "<number>" : Po._$IsString$_(t) ? "<string>" : Po._$IsArray$_(t) ? "<array>" : "symbol" == typeof t ? "<" + t.toString() + ">" : Po._$IsFunction$_(t) ? t.name && "Function" !== t.name ? t.name : "<anonymous function>" : "object" == typeof t ? t.constructor && t.constructor.name && "Object" !== t.constructor.name ? t.constructor.name : "<anonymous object>" : "<unknown>";
    }, Po.getType = function(t) {
        return null === t ? "null" : Array.isArray(t) ? "array" : typeof t;
    }, Po.range = function*(t, s) {
        if (!isFinite(Math.abs(t - s))) throw new Error("Invalid parameters");
        if (t > s) for (let i = t - 1; i >= s; i--) yield i; else for (let i = t; i < s; i++) yield i;
    };
    let jo = new Map, Bo = new Map, zo = new WeakMap, Uo = new WeakMap;
    Po._$DefendHandler$_ = {};
    const Wo = new Set([ "then", "splice" ]);
    Po._$DefendHandler$_.get = function(t, s) {
        return s in t || "symbol" == typeof s || Wo.has(s) || No(`Accessed missing property '${s}' from defended object '${Po.getName(t)}', returning undefined`), 
        Uo.has(t) && "symbol" != typeof s && !Wo.has(s) && No(`Accessed property '${s}' on a released object '${Po.getName(t)}'\nObject was originally released at: ${Uo.get(t)})\nCall stack at access: `), 
        t[s];
    }, Po._$DefendHandler$_.set = function(t, s, i) {
        return s in t || jo.has(t) || No(`Set non-existent property '${s}' to '${i}' on defended object '${Po.getName(t)}'`), 
        Ao(t[s], i) || jo.has(t) || No(`Set '${Po.getType(t[s])}' property '${s}' to type '${Po.getType(i)}' on defended object '${Po.getName(t)}'`), 
        Uo.has(t) && No(`Set property '${s}' on a released object '${Po.getName(t)}'\nObject was originally released at: ${Uo.get(t)})\nCall stack at access: `), 
        t[s] = i, !0;
    }, Po._$DefendHandler$_.deleteProperty = function(t, s) {
        throw new ReferenceError(`Cannot delete property '${s}' from defended object '${Po.getName(t)}'`);
    }, Po._$DefendHandler$_.defineProperty = function(t, s, i) {
        throw new ReferenceError(`Cannot define property '${s}' on defended object '${Po.getName(t)}'`);
    }, Po._$DefendHandler$_.enumerate = function(t) {
        throw new ReferenceError(`Cannot enumerate defended object '${Po.getName(t)}'`);
    };
    let Jo = -1;
    Po._$DefendedBase$_ = class {
        constructor() {
            if (!Po._$isDebugDefend$_ || !Po._$Supports$_._$Proxies$_) return;
            let t = new.target, s = Object.create(t.prototype), i = new Proxy(s, Po._$DefendHandler$_);
            return jo.set(s, i), Bo.set(i, s), zo.set(i, s), -1 === Jo && (Jo = requestAnimationFrame(Lo)), 
            i;
        }
    }, Po._$debugDefend$_ = function(t) {
        if (Po._$isDebugDefend$_ && Po._$Supports$_._$Proxies$_ && t instanceof Po._$DefendedBase$_) {
            if (!Bo.has(t)) return t;
            let s = Bo.get(t);
            return Bo.delete(t), jo.delete(s), t;
        }
        return Po._$isDebug$_ ? Object.seal(t) : t;
    }, Po._$New$_ = function(t, ...s) {
        let i;
        try {
            i = new t(...s);
        } catch (t) {
            throw Bo.clear(), jo.clear(), t;
        }
        return Po._$isDebugDefend$_ && Ro(t, i), Po._$debugDefend$_(i);
    }, Po._$Release$_ = function(t) {
        let s = zo.get(t);
        s && Uo.set(s, Po._$GetCallStack$_());
    }, Po._$WasReleased$_ = function(t) {
        let s = zo.get(t);
        return !!s && !!Uo.get(s);
    };
    let Qo = new Map;
    Po._$PerfMark$_ = class {
        constructor(t) {
            this._$_name$_ = "", t && this.start(t);
        }
        start(t) {
            Po._$isPerformanceProfiling$_ && (this._$_name$_ = t, performance.mark(this._$_name$_ + "-Start"));
        }
        end() {
            Po._$isPerformanceProfiling$_ && (performance.mark(this._$_name$_ + "-End"), performance.measure(this._$_name$_, this._$_name$_ + "-Start", this._$_name$_ + "-End"));
        }
        next(t) {
            Po._$isPerformanceProfiling$_ && (this.end(), this._$_name$_ = t, performance.mark(this._$_name$_ + "-Start"));
        }
    };
}

{
    let Yo = function(t) {
        return 0 === t && 1 / t < 0;
    };
    0;
    const Vo = self._$C3$_, Ho = 2 * Math.PI, qo = Math.PI / 180, Xo = 180 / Math.PI;
    Vo.wrap = function(t, s, i) {
        t = Math.floor(t), s = Math.floor(s);
        const e = (i = Math.floor(i)) - s;
        if (0 === e) return i;
        if (t < s) {
            const n = i - (s - t) % e;
            return n === i ? 0 : n;
        }
        return s + (t - s) % e;
    }, Vo._$mapToRange$_ = function(t, s, i, e, n) {
        const h = i - s;
        return 0 === h && 0 === e ? t : (t - s) * (n - e) / h + e;
    }, Vo.normalize = function(t, s, i) {
        return s - i == 0 ? 1 : (t - s) / (i - s);
    }, Vo._$clamp$_ = function(t, s, i) {
        return t < s ? s : t > i ? i : t;
    }, Vo._$clampAngle$_ = function(t) {
        return (t %= Ho) < 0 && (t += Ho), t;
    }, Vo._$toRadians$_ = function(t) {
        return t * qo;
    }, Vo._$toDegrees$_ = function(t) {
        return t * Xo;
    }, Vo._$hypot2DFast$_ = function(t, s) {
        return Math.sqrt(t * t + s * s);
    }, Vo._$hypot3DFast$_ = function(t, s, i) {
        return Math.sqrt(t * t + s * s + i * i);
    }, Vo._$distanceTo$_ = function(t, s, i, e) {
        return Vo._$hypot2DFast$_(i - t, e - s);
    }, Vo._$distanceSquared$_ = function(t, s, i, e) {
        const n = i - t, h = e - s;
        return n * n + h * h;
    }, Vo._$angleTo$_ = function(t, s, i, e) {
        return Math.atan2(e - s, i - t);
    }, Vo._$angleDiff$_ = function(t, s) {
        if (t === s) return 0;
        let i = Math.sin(t), e = Math.cos(t), n = i * Math.sin(s) + e * Math.cos(s);
        return n >= 1 ? 0 : n <= -1 ? Math.PI : Math.acos(n);
    }, Vo._$angleRotate$_ = function(t, s, i) {
        let e = Math.sin(t), n = Math.cos(t), h = Math.sin(s), r = Math.cos(s);
        return Math.acos(e * h + n * r) > i ? n * h - e * r > 0 ? Vo._$clampAngle$_(t + i) : Vo._$clampAngle$_(t - i) : Vo._$clampAngle$_(s);
    }, Vo._$angleClockwise$_ = function(t, s) {
        let i = Math.sin(t);
        return Math.cos(t) * Math.sin(s) - i * Math.cos(s) <= 0;
    }, Vo._$angleLerp$_ = function(t, s, i, e = 0) {
        let n = Vo._$angleDiff$_(t, s);
        const h = Ho * e;
        return Vo._$angleClockwise$_(s, t) ? Vo._$clampAngle$_(t + (n + h) * i) : Vo._$clampAngle$_(t - (n + h) * i);
    }, Vo._$angleLerpClockwise$_ = function(t, s, i, e = 0) {
        const n = Vo._$angleDiff$_(t, s), h = Ho * e;
        return Vo._$angleClockwise$_(s, t) ? Vo._$clampAngle$_(t + (n + h) * i) : Vo._$clampAngle$_(t + (Ho - n + h) * i);
    }, Vo._$angleLerpAntiClockwise$_ = function(t, s, i, e = 0) {
        const n = Vo._$angleDiff$_(t, s), h = Ho * e;
        return Vo._$angleClockwise$_(s, t) ? Vo._$clampAngle$_(t - (-Ho + n - h) * i) : Vo._$clampAngle$_(t - (n + h) * i);
    }, Vo._$angleReflect$_ = function(t, s) {
        const i = Vo._$angleDiff$_(t, s);
        return Vo._$angleClockwise$_(t, s) ? Vo._$clampAngle$_(s - i) : Vo._$clampAngle$_(s + i);
    }, Vo._$lerp$_ = function(t, s, i) {
        return t + i * (s - t);
    }, Vo._$unlerp$_ = function(t, s, i) {
        return t === s ? 0 : (i - t) / (s - t);
    }, Vo._$relerp$_ = function(t, s, i, e, n) {
        return Vo._$lerp$_(e, n, Vo._$unlerp$_(t, s, i));
    }, Vo._$qarp$_ = function(t, s, i, e) {
        return Vo._$lerp$_(Vo._$lerp$_(t, s, e), Vo._$lerp$_(s, i, e), e);
    }, Vo._$cubic$_ = function(t, s, i, e, n) {
        return Vo._$lerp$_(Vo._$qarp$_(t, s, i, n), Vo._$qarp$_(s, i, e, n), n);
    }, Vo._$cosp$_ = function(t, s, i) {
        return (t + s + (t - s) * Math.cos(i * Math.PI)) / 2;
    }, Vo._$isPOT$_ = function(t) {
        return t > 0 && !(t - 1 & t);
    }, Vo._$nextHighestPowerOfTwo$_ = function(t) {
        --t;
        for (let s = 1; s < 32; s <<= 1) t |= t >> s;
        return t + 1;
    }, Vo._$roundToNearestFraction$_ = function(t, s) {
        return Math.round(t * s) / s;
    }, Vo._$floorToNearestFraction$_ = function(t, s) {
        return Math.floor(t * s) / s;
    }, Vo._$roundToDp$_ = function(t, s) {
        s = Math.max(Math.floor(s), 0);
        const i = Math.pow(10, s);
        return Math.round(t * i) / i;
    }, Vo._$countDecimals$_ = function(t) {
        return Math.floor(t) !== t && t.toString().split(".")[1].length || 0;
    }, Vo.toFixed = function(t, s) {
        let i = t.toFixed(s), e = i.length - 1;
        for (;e >= 0 && "0" === i.charAt(e); --e) ;
        return e >= 0 && "." === i.charAt(e) && --e, e < 0 ? i : i.substr(0, e + 1);
    }, Vo._$PackRGB$_ = function(t, s, i) {
        return Vo._$clamp$_(t, 0, 255) | Vo._$clamp$_(s, 0, 255) << 8 | Vo._$clamp$_(i, 0, 255) << 16;
    };
    Vo._$PackRGBAEx$_ = function(t, s, i, e) {
        return (t = Vo._$clamp$_(Math.floor(1024 * t), -8192, 8191)) < 0 && (t += 16384), 
        (s = Vo._$clamp$_(Math.floor(1024 * s), -8192, 8191)) < 0 && (s += 16384), (i = Vo._$clamp$_(Math.floor(1024 * i), -8192, 8191)) < 0 && (i += 16384), 
        -(16384 * t * 16384 * 1024 + 16384 * s * 1024 + 1024 * i + (e = Vo._$clamp$_(Math.floor(1023 * e), 0, 1023)));
    }, Vo._$PackRGBEx$_ = function(t, s, i) {
        return Vo._$PackRGBAEx$_(t, s, i, 1);
    }, Vo._$GetRValue$_ = function(t) {
        if (t >= 0) return (255 & t) / 255;
        {
            let s = Math.floor(-t / 274877906944);
            return s > 8191 && (s -= 16384), s / 1024;
        }
    }, Vo._$GetGValue$_ = function(t) {
        if (t >= 0) return ((65280 & t) >> 8) / 255;
        {
            let s = Math.floor(-t % 274877906944 / 16777216);
            return s > 8191 && (s -= 16384), s / 1024;
        }
    }, Vo._$GetBValue$_ = function(t) {
        if (t >= 0) return ((16711680 & t) >> 16) / 255;
        {
            let s = Math.floor(-t % 16777216 / 1024);
            return s > 8191 && (s -= 16384), s / 1024;
        }
    }, Vo._$GetAValue$_ = function(t) {
        return Yo(t) ? 0 : t >= 0 ? 1 : Math.floor(-t % 1024) / 1023;
    }, Vo._$greatestCommonDivisor$_ = function(t, s) {
        for (t = Math.floor(t), s = Math.floor(s); 0 !== s; ) {
            let i = s;
            s = t % s, t = i;
        }
        return t;
    };
    const Zo = [ [ 3, 2 ], [ 4, 3 ], [ 5, 4 ], [ 5, 3 ], [ 6, 5 ], [ 14, 9 ], [ 16, 9 ], [ 16, 10 ], [ 21, 9 ] ];
    Vo._$getAspectRatio$_ = function(t, s) {
        if ((t = Math.floor(t)) === (s = Math.floor(s))) return [ 1, 1 ];
        for (let i of Zo) {
            let e = t / i[0] * i[1];
            if (Math.abs(s - e) < 1) return i.slice(0);
            if (e = t / i[1] * i[0], Math.abs(s - e) < 1) return [ i[1], i[0] ];
        }
        let i = Vo._$greatestCommonDivisor$_(t, s);
        return [ t / i, s / i ];
    }, Vo._$segmentsIntersect$_ = function(t, s, i, e, n, h, r, o) {
        const a = Math.min(t, i), u = Math.max(t, i), l = Math.min(n, r), c = Math.max(n, r);
        if (u < l || a > c) return !1;
        const f = Math.min(s, e), d = Math.max(s, e), p = Math.min(h, o), m = Math.max(h, o);
        if (d < p || f > m) return !1;
        const g = n - t + r - i, y = h - s + o - e, M = i - t, w = e - s, S = r - n, b = o - h, T = Math.abs(w * S - b * M), v = S * y - b * g;
        if (Math.abs(v) > T) return !1;
        const x = M * y - w * g;
        return Math.abs(x) <= T;
    }, Vo._$segmentsIntersectPreCalc$_ = function(t, s, i, e, n, h, r, o, a, u, l, c) {
        const f = Math.min(a, l), d = Math.max(a, l);
        if (h < f || n > d) return !1;
        const p = Math.min(u, c), m = Math.max(u, c);
        if (o < p || r > m) return !1;
        const g = a - t + l - i, y = u - s + c - e, M = i - t, w = e - s, S = l - a, b = c - u, T = Math.abs(w * S - b * M), v = S * y - b * g;
        if (Math.abs(v) > T) return !1;
        const x = M * y - w * g;
        return Math.abs(x) <= T;
    }, Vo._$segmentIntersectsQuad$_ = function(t, s, i, e, n) {
        const h = Math.min(t, i), r = Math.max(t, i), o = Math.min(s, e), a = Math.max(s, e), u = n._$getTlx$_(), l = n._$getTly$_(), c = n._$getTrx$_(), f = n._$getTry$_(), d = n._$getBrx$_(), p = n._$getBry$_(), m = n._$getBlx$_(), g = n._$getBly$_();
        return Vo._$segmentsIntersectPreCalc$_(t, s, i, e, h, r, o, a, u, l, c, f) || Vo._$segmentsIntersectPreCalc$_(t, s, i, e, h, r, o, a, c, f, d, p) || Vo._$segmentsIntersectPreCalc$_(t, s, i, e, h, r, o, a, d, p, m, g) || Vo._$segmentsIntersectPreCalc$_(t, s, i, e, h, r, o, a, m, g, u, l);
    }, Vo._$segmentIntersectsAnyN$_ = function(t, s, i, e, n) {
        const h = Math.min(t, i), r = Math.max(t, i), o = Math.min(s, e), a = Math.max(s, e);
        let u = 0;
        for (let l = n.length - 4; u <= l; u += 2) if (Vo._$segmentsIntersectPreCalc$_(t, s, i, e, h, r, o, a, n[u], n[u + 1], n[u + 2], n[u + 3])) return !0;
        return Vo._$segmentsIntersectPreCalc$_(t, s, i, e, h, r, o, a, n[u], n[u + 1], n[0], n[1]);
    };
    Vo._$rayIntersect$_ = function(t, s, i, e, n, h, r, o) {
        const a = i - t, u = o - h, l = a * u - (e - s) * (r - n);
        if (0 === l) return 2;
        const c = ((s - e) * (r - t) + a * (o - s)) / l;
        return 0 < c && c < 1.000001 ? (u * (r - t) + (n - r) * (o - s)) / l : 2;
    }, Vo._$rayIntersectExtended$_ = function(t, s, i, e, n, h, r, o, a) {
        const u = (r - n) * a, l = (o - h) * a;
        return Vo._$rayIntersect$_(t, s, i, e, n - u, h - l, r + u, o + l);
    }, Vo._$isPointInTriangleInclusive$_ = function(t, s, i, e, n, h, r, o) {
        const a = n - i, u = h - e, l = r - i, c = o - e, f = t - i, d = s - e, p = a * a + u * u, m = a * l + u * c, g = a * f + u * d, y = l * l + c * c, M = l * f + c * d, w = 1 / (p * y - m * m), S = (y * g - m * M) * w, b = (p * M - m * g) * w;
        return S >= 0 && b >= 0 && S + b <= 1;
    }, Vo._$triangleCartesianToBarycentric$_ = function(t, s, i, e, n, h, r, o) {
        const a = n - i, u = h - e, l = r - i, c = o - e, f = t - i, d = s - e, p = a * a + u * u, m = a * l + u * c, g = l * l + c * c, y = f * a + d * u, M = f * l + d * c, w = p * g - m * m, S = (g * y - m * M) / w, b = (p * M - m * y) / w;
        return [ 1 - S - b, S, b ];
    }, Vo._$triangleBarycentricToCartesian3d$_ = function(t, s, i, e, n, h, r, o, a, u, l, c) {
        return [ t * e + s * r + i * u, t * n + s * o + i * l, t * h + s * a + i * c ];
    };
}

{
    const Ko = self._$C3$_;
    let $o = null, ta = "";
    if ("undefined" != typeof document) {
        $o = document;
        const ra = document.querySelector("base");
        ta = ra && ra.hasAttribute("href") ? ra.getAttribute("href") : "", ta && (ta.startsWith("/") && (ta = ta.substr(1)), 
        ta.endsWith("/") || (ta += "/"));
    }
    Ko._$GetBaseHref$_ = function() {
        return ta;
    }, Ko._$GetBaseURL$_ = function() {
        if (!$o) return "";
        const t = $o.location;
        return Ko._$GetPathFromURL$_(t.origin + t.pathname) + ta;
    }, Ko._$GetPathFromURL$_ = function(t) {
        if (!t.length) return t;
        if (t.endsWith("/") || t.endsWith("\\")) return t;
        const s = Math.max(t.lastIndexOf("/"), t.lastIndexOf("\\"));
        return -1 === s ? "" : t.substr(0, s + 1);
    }, Ko._$GetFilenameFromURL$_ = function(t) {
        if (!t.length) return t;
        if (t.endsWith("/") || t.endsWith("\\")) return "";
        const s = Math.max(t.lastIndexOf("/"), t.lastIndexOf("\\"));
        return -1 === s ? t : t.substr(s + 1);
    }, Ko._$GetFileExtension$_ = function(t) {
        let s = t.lastIndexOf(".");
        return s < 1 ? "" : t.substr(s);
    }, Ko._$SetFileExtension$_ = function(t, s) {
        const i = t.lastIndexOf(".");
        return -1 === i ? t + "." + s : t.substr(0, i + 1) + s;
    }, Ko._$GetFileNamePart$_ = function(t) {
        let s = t.lastIndexOf(".");
        return s < 1 ? t : t.substr(0, s);
    }, Ko._$NormalizeFileSeparator$_ = function(t) {
        return t.replace(/\\/g, "/");
    }, Ko._$IsFileExtension$_ = function(t, s) {
        return s === (t ? Ko._$GetFileExtension$_(t).slice(1) : "");
    }, Ko._$FileNameEquals$_ = function(t, s) {
        let i, e;
        return Ko._$IsFileLike$_(t) && (i = Ko._$GetFileNamePart$_(t.name)), Ko._$IsString$_(t) && (i = Ko._$GetFileNamePart$_(t)), 
        Ko._$IsFileLike$_(s) && (e = Ko._$GetFileNamePart$_(s.name)), Ko._$IsString$_(s) && (e = Ko._$GetFileNamePart$_(s)), 
        i === e;
    }, Ko._$ParseFilePath$_ = function(t) {
        t = Ko._$NormalizeFileSeparator$_(t);
        let s = /^\w\:\//.exec(t);
        s ? (s = s[0], "/" !== (t = t.slice(3))[0] && (t = "/" + t)) : s = "", (t = t.replace(/\/{2,}/g, "/")).length > 1 && "/" === t.slice(-1) && (t = t.slice(0, -1));
        const i = t.lastIndexOf("/") + 1;
        let e, n = "", h = t, r = "";
        i > 0 && (n = t.slice(0, i), h = t.slice(i)), e = h;
        const o = h.lastIndexOf(".");
        return o > 0 && (r = h.slice(o), e = h.slice(0, -r.length)), {
            dir: n,
            _$base$_: h,
            name: e,
            root: s,
            ext: r,
            _$full$_: s + n + h
        };
    }, Ko._$Wait$_ = function(t, s) {
        return new Promise(((i, e) => {
            self.setTimeout(i, t, s);
        }));
    }, Ko._$swallowException$_ = function(t) {
        try {
            t();
        } catch (t) {
            Ko._$isDebug$_ && console.warn("Swallowed exception: ", t);
        }
    }, Ko._$noop$_ = function() {}, Ko._$equalsNoCase$_ = function(t, s) {
        return "string" == typeof t && "string" == typeof s && (t === s || t.normalize().toLowerCase() === s.normalize().toLowerCase());
    }, Ko._$equalsCase$_ = function(t, s) {
        return "string" == typeof t && "string" == typeof s && (t === s || t.normalize() === s.normalize());
    }, Ko._$typedArraySet16$_ = function(t, s, i) {
        t[i++] = s[0], t[i++] = s[1], t[i++] = s[2], t[i++] = s[3], t[i++] = s[4], t[i++] = s[5], 
        t[i++] = s[6], t[i++] = s[7], t[i++] = s[8], t[i++] = s[9], t[i++] = s[10], t[i++] = s[11], 
        t[i++] = s[12], t[i++] = s[13], t[i++] = s[14], t[i] = s[15];
    }, Ko._$truncateArray$_ = function(t, s) {
        t.length = s;
    }, Ko._$clearArray$_ = function(t) {
        t && 0 !== t.length && Ko._$truncateArray$_(t, 0);
    }, Ko._$clear2DArray$_ = function(t) {
        if (t) {
            for (let s = 0; s < t.length; s++) {
                let i = t[s];
                Ko._$truncateArray$_(i, 0);
            }
            Ko._$truncateArray$_(t, 0);
        }
    }, Ko._$extendArray$_ = function(t, s, i) {
        s |= 0;
        const e = t.length;
        if (!(s <= e)) for (let n = e; n < s; ++n) t.push(i);
    }, Ko._$resizeArray$_ = function(t, s, i) {
        s |= 0;
        const e = t.length;
        s < e ? Ko._$truncateArray$_(t, s) : s > e && Ko._$extendArray$_(t, s, i);
    }, Ko._$shallowAssignArray$_ = function(t, s) {
        Ko._$clearArray$_(t), Ko._$appendArray$_(t, s);
    }, Ko._$appendArray$_ = function(t, s) {
        if (s.length < 1e4) t.push(...s); else for (let i = 0, e = s.length; i < e; ++i) t.push(s[i]);
    }, Ko._$arrayRemove$_ = function(t, s) {
        if ((s = Math.floor(s)) < 0 || s >= t.length) return;
        let i = t.length - 1;
        for (let e = s; e < i; ++e) t[e] = t[e + 1];
        Ko._$truncateArray$_(t, i);
    }, Ko._$arrayFindRemove$_ = function(t, s) {
        let i = t.indexOf(s);
        i >= 0 && t.splice(i, 1);
    }, Ko._$arraysEqual$_ = function(t, s) {
        let i = t.length;
        if (s.length !== i) return !1;
        for (let e = 0; e < i; ++e) if (t[e] !== s[e]) return !1;
        return !0;
    }, Ko._$arrayFilterOut$_ = function(t, s) {
        let i = [], e = 0;
        for (let n = 0, h = t.length; n < h; ++n) {
            let h = t[n];
            s(h) ? i.push(h) : (t[e] = h, ++e);
        }
        return Ko._$truncateArray$_(t, e), i;
    }, Ko._$arrayRemoveAllInSet$_ = function(t, s) {
        const i = t.length;
        let e = 0;
        for (let i = 0, n = t.length; i < n; ++i) {
            let n = t[i];
            s.has(n) || (t[e++] = n);
        }
        return Ko._$truncateArray$_(t, e), i - e;
    }, Ko._$isArrayIndexInBounds$_ = function(t, s) {
        return t === Math.floor(t) && t >= 0 && t < s.length;
    }, Ko._$validateArrayIndex$_ = function(t, s) {
        if (!Ko._$isArrayIndexInBounds$_(t, s)) throw new RangeError("array index out of bounds");
    }, Ko._$cloneArray$_ = function(t) {
        return t.slice();
    }, Ko._$deepCloneArray$_ = function(t, s) {
        let i = [];
        for (let e of t) if (Ko._$IsObject$_(e)) {
            let t = s(e);
            if (!t) throw new Error("missing clone");
            if (t.constructor !== e.constructor) throw new Error("object is not a clone");
            i.push(t);
        } else Ko._$IsArray$_(e) ? i.push(Ko._$deepCloneArray$_(e, s)) : i.push(e);
        return i;
    }, Ko._$clone2DArray$_ = function(t) {
        let s = [];
        for (let i of t) s.push(i.slice());
        return s;
    }, Ko._$splitStringAndNormalize$_ = function(t, s = " ") {
        return t ? t.split(s).map((t => t.trim())).filter((t => !!t)) : [];
    }, Ko._$filterSet$_ = function(t, s, i) {
        const e = new Set;
        for (const n of t.values()) s(n) && (i ? e.add(i(n)) : e.add(n));
        return e;
    }, Ko._$mergeSets$_ = function(t, s) {
        return t.union ? t.union(s) : new Set([ ...t, ...s ]);
    }, Ko._$mergeSetsInPlace$_ = function(t, s) {
        for (const i of s) t.add(i);
        return t;
    }, Ko._$first$_ = function(t) {
        for (let s of t) return s;
        return null;
    }, Ko.xor = function(t, s) {
        return !t != !s;
    }, Ko.compare = function(t, s, i) {
        switch (s) {
          case 0:
            return t === i;

          case 1:
            return t !== i;

          case 2:
            return t < i;

          case 3:
            return t <= i;

          case 4:
            return t > i;

          case 5:
            return t >= i;

          default:
            return !1;
        }
    }, Ko._$hasAnyOwnProperty$_ = function(t) {
        for (let s in t) if (t.hasOwnProperty(s)) return !0;
        return !1;
    }, Ko._$PromiseAllWithProgress$_ = function(t, s) {
        return t.length ? new Promise(((i, e) => {
            const n = [];
            let h = 0, r = !1;
            for (let o = 0, a = t.length; o < a; ++o) n.push(void 0), t[o].then((e => {
                r || (n[o] = e, ++h, h === t.length ? i(n) : s(h, t.length));
            })).catch((t => {
                r = !0, e(t);
            }));
        })) : Promise.resolve([]);
    };
    let sa = [];
    Ko._$AddLibraryMemoryCallback$_ = function(t) {
        sa.push(t);
    }, Ko._$GetEstimatedLibraryMemoryUsage$_ = function() {
        let t = 0;
        for (let s of sa) t += s();
        return Math.floor(t);
    };
    let ia = 1;
    const ea = new Map, na = new MessageChannel;
    na.port2.onmessage = function(t) {
        const s = t.data, i = ea.get(s);
        ea.delete(s), i && i(performance.now());
    }, Ko._$RequestUnlimitedAnimationFrame$_ = function(t) {
        const s = ia++;
        return ea.set(s, t), na.port1.postMessage(s), s;
    }, Ko._$CancelUnlimitedAnimationFrame$_ = function(t) {
        ea.delete(t);
    }, Ko._$PostTask$_ = Ko._$RequestUnlimitedAnimationFrame$_, Ko._$WaitForNextTask$_ = function() {
        return new Promise((t => Ko._$PostTask$_(t)));
    };
    const ha = new Set;
    Ko._$RequestPostAnimationFrame$_ = function(t) {
        const s = self.requestAnimationFrame((async i => {
            await Ko._$WaitForNextTask$_(), ha.has(s) && (ha.delete(s), t(i));
        }));
        return ha.add(s), s;
    }, Ko._$CancelPostAnimationFrame$_ = function(t) {
        ha.has(t) && (self.cancelAnimationFrame(t), ha.delete(t));
    };
}

{
    const oa = self._$C3$_;
    oa._$IsAbsoluteURL$_ = function(t) {
        return /^(?:[a-z\-]+:)?\/\//.test(t) || "data:" === t.substr(0, 5) || "blob:" === t.substr(0, 5);
    }, oa._$IsRelativeURL$_ = function(t) {
        return !oa._$IsAbsoluteURL$_(t);
    }, oa._$ThrowIfNotOk$_ = function(t) {
        if (!t.ok) throw new Error(`fetch '${t.url}' response returned ${t.status} ${t.statusText}`);
    }, oa._$FetchOk$_ = function(t, s) {
        return fetch(t, s).then((t => (oa._$ThrowIfNotOk$_(t), t)));
    }, oa._$FetchText$_ = function(t) {
        return oa._$FetchOk$_(t).then((t => t.text()));
    }, oa._$FetchJson$_ = function(t) {
        return oa._$FetchOk$_(t).then((t => t.json()));
    }, oa._$FetchBlob$_ = function(t) {
        return oa._$FetchOk$_(t).then((t => t.blob()));
    }, oa._$FetchArrayBuffer$_ = function(t) {
        return oa._$FetchOk$_(t).then((t => t.arrayBuffer()));
    }, oa._$FetchImage$_ = function(t) {
        return new Promise(((s, i) => {
            const e = new Image;
            e.onload = () => s(e), e.onerror = t => i(t), e.src = t;
        }));
    }, oa._$BlobToArrayBuffer$_ = function(t) {
        return "function" == typeof t.arrayBuffer ? t.arrayBuffer() : new Promise(((s, i) => {
            const e = new FileReader;
            e.onload = () => s(e.result), e.onerror = () => i(e.error), e.readAsArrayBuffer(t);
        }));
    }, oa._$BlobToString$_ = function(t) {
        return "function" == typeof t.text ? t.text() : new Promise(((s, i) => {
            const e = new FileReader;
            e.onload = () => s(e.result), e.onerror = () => i(e.error), e.readAsText(t);
        }));
    }, oa._$BlobToJson$_ = function(t) {
        return oa._$BlobToString$_(t).then((t => JSON.parse(t)));
    }, oa._$BlobToImage$_ = async function(t, s) {
        let i = URL.createObjectURL(t);
        try {
            const t = await oa._$FetchImage$_(i);
            return URL.revokeObjectURL(i), i = "", s && "function" == typeof t.decode && await t.decode(), 
            t;
        } finally {
            i && URL.revokeObjectURL(i);
        }
    }, oa._$CreateCanvas$_ = function(t, s) {
        if ("undefined" != typeof document && "function" == typeof document.createElement) {
            const i = document.createElement("canvas");
            return i.width = t, i.height = s, i;
        }
        return new OffscreenCanvas(t, s);
    }, oa._$CanvasToBlob$_ = function(t, s, i) {
        if ("number" != typeof i && (i = 1), s = s || "image/png", i = oa._$clamp$_(i, 0, 1), 
        t.convertToBlob) return t.convertToBlob({
            type: s,
            quality: i
        });
        if (t.toBlob) return new Promise((e => t.toBlob(e, s, i)));
        throw new Error("could not convert canvas to blob");
    }, oa._$DrawableToBlob$_ = function(t, s, i) {
        const e = oa._$CreateCanvas$_(t.width, t.height);
        return e.getContext("2d").drawImage(t, 0, 0), oa._$CanvasToBlob$_(e, s, i);
    }, oa._$ImageDataToBlob$_ = function(t, s, i) {
        if (oa._$Supports$_.ImageBitmapOptions) return createImageBitmap(t, {
            premultiplyAlpha: "none"
        }).then((t => oa._$DrawableToBlob$_(t, s, i)));
        if (oa._$Supports$_.ImageBitmap) return createImageBitmap(t).then((t => oa._$DrawableToBlob$_(t, s, i)));
        {
            const e = oa._$CreateCanvas$_(t.width, t.height);
            return e.getContext("2d").putImageData(t, 0, 0), oa._$CanvasToBlob$_(e, s, i);
        }
    }, oa._$CopySet$_ = function(t, s) {
        t.clear();
        for (const i of s) t.add(i);
    }, oa._$MapToObject$_ = function(t) {
        const s = Object.create(null);
        for (const [i, e] of t.entries()) s[i] = e;
        return s;
    }, oa._$ObjectToMap$_ = function(t, s) {
        s.clear();
        for (const [i, e] of Object.entries(t)) s.set(i, e);
    }, oa._$ToSuperJSON$_ = function t(s) {
        if ("object" == typeof s && null !== s) {
            if (s instanceof Set) return {
                _c3type_: "set",
                data: [ ...s ].map((s => t(s)))
            };
            if (s instanceof Map) return {
                _c3type_: "map",
                data: [ ...s ].map((s => [ s[0], t(s[1]) ]))
            };
            {
                const i = Object.create(null);
                for (const [e, n] of Object.entries(s)) i[e] = t(n);
                return i;
            }
        }
        return s;
    }, oa._$FromSuperJSON$_ = function t(s) {
        if ("object" == typeof s & null !== s) {
            if ("set" === s._c3type_) return new Set(s.data.map((s => t(s))));
            if ("map" === s._c3type_) return new Map(s.data.map((s => [ s[0], t(s[1]) ])));
            {
                const i = Object.create(null);
                for (const [e, n] of Object.entries(s)) i[e] = t(n);
                return i;
            }
        }
        return s;
    }, oa._$CSSToCamelCase$_ = function(t) {
        if (t.startsWith("--")) return t;
        let s = "", i = !1, e = 0;
        for (const n of t) "-" === n ? e > 0 && (i = !0) : i ? (s += n.toUpperCase(), i = !1) : s += n, 
        ++e;
        return s;
    }, oa._$IsIterator$_ = function(t) {
        return "object" == typeof t && "function" == typeof t.next;
    }, oa._$MakeFilledArray$_ = function(t, s) {
        const i = [];
        if ("function" == typeof s) for (let e = 0; e < t; ++e) i.push(s()); else for (let e = 0; e < t; ++e) i.push(s);
        return i;
    };
}

{
    let aa = function(t) {
        return 0 === t.length ? "00" : 1 === t.length ? "0" + t : t;
    }, ua = function(t, s, i) {
        return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + 6 * (s - t) * i : i < .5 ? s : i < 2 / 3 ? t + (s - t) * (2 / 3 - i) * 6 : t;
    };
    0;
    const la = self._$C3$_, ca = /([0-9.]+),([0-9.]+)\%?,([0-9.]+)\%?/i, fa = /([0-9.]+),([0-9.]+)\%?,([0-9.]+)\%?,([0-9.])/i;
    la._$Color$_ = class {
        constructor(t, s, i, e) {
            this._$_r$_ = NaN, this._$_g$_ = NaN, this._$_b$_ = NaN, this._$_a$_ = NaN, this._$_r$_ = 0, 
            this._$_g$_ = 0, this._$_b$_ = 0, this._$_a$_ = 0, t instanceof la._$Color$_ ? this.set(t) : this._$setRgba$_(t || 0, s || 0, i || 0, e || 0);
        }
        _$setRgb$_(t, s, i) {
            return this._$_r$_ = +t, this._$_g$_ = +s, this._$_b$_ = +i, this._$clamp$_(), this;
        }
        _$setRgba$_(t, s, i, e) {
            return this._$_r$_ = +t, this._$_g$_ = +s, this._$_b$_ = +i, this._$_a$_ = +e, this._$clamp$_(), 
            this;
        }
        set(t) {
            return this._$_r$_ = t._$_r$_, this._$_g$_ = t._$_g$_, this._$_b$_ = t._$_b$_, this._$_a$_ = t._$_a$_, 
            this;
        }
        _$copy$_(t) {
            return this.set(t);
        }
        add(t) {
            this._$_r$_ += t._$_r$_, this._$_g$_ += t._$_g$_, this._$_b$_ += t._$_b$_, this._$_a$_ += t._$_a$_, 
            this._$clamp$_();
        }
        _$addRgb$_(t, s, i, e = 0) {
            this._$_r$_ += +t, this._$_g$_ += +s, this._$_b$_ += +i, this._$_a$_ += +e, this._$clamp$_();
        }
        _$diff$_(t) {
            this._$setR$_(Math.max(this._$_r$_, t._$_r$_) - Math.min(this._$_r$_, t._$_r$_)), 
            this._$setG$_(Math.max(this._$_g$_, t._$_g$_) - Math.min(this._$_g$_, t._$_g$_)), 
            this._$setB$_(Math.max(this._$_b$_, t._$_b$_) - Math.min(this._$_b$_, t._$_b$_)), 
            this._$setA$_(Math.max(this._$_a$_, t._$_a$_) - Math.min(this._$_a$_, t._$_a$_)), 
            this._$clamp$_();
        }
        _$copyRgb$_(t) {
            this._$_r$_ = t._$_r$_, this._$_g$_ = t._$_g$_, this._$_b$_ = t._$_b$_;
        }
        _$setR$_(t) {
            this._$_r$_ = la._$clamp$_(+t, 0, 1);
        }
        _$getR$_() {
            return this._$_r$_;
        }
        _$setG$_(t) {
            this._$_g$_ = la._$clamp$_(+t, 0, 1);
        }
        _$getG$_() {
            return this._$_g$_;
        }
        _$setB$_(t) {
            this._$_b$_ = la._$clamp$_(+t, 0, 1);
        }
        _$getB$_() {
            return this._$_b$_;
        }
        _$setA$_(t) {
            this._$_a$_ = la._$clamp$_(+t, 0, 1);
        }
        _$getA$_() {
            return this._$_a$_;
        }
        clone() {
            return la._$New$_(la._$Color$_, this._$_r$_, this._$_g$_, this._$_b$_, this._$_a$_);
        }
        toArray() {
            return [ this._$_r$_, this._$_g$_, this._$_b$_, this._$_a$_ ];
        }
        _$toTypedArray$_() {
            return new Float64Array(this.toArray());
        }
        _$writeToTypedArray$_(t, s) {
            t[s++] = this._$_r$_, t[s++] = this._$_g$_, t[s++] = this._$_b$_, t[s] = this._$_a$_;
        }
        _$writeRGBToTypedArray$_(t, s) {
            t[s++] = this._$_r$_, t[s++] = this._$_g$_, t[s] = this._$_b$_;
        }
        equals(t) {
            return this._$_r$_ === t._$_r$_ && this._$_g$_ === t._$_g$_ && this._$_b$_ === t._$_b$_ && this._$_a$_ === t._$_a$_;
        }
        _$equalsIgnoringAlpha$_(t) {
            return this._$_r$_ === t._$_r$_ && this._$_g$_ === t._$_g$_ && this._$_b$_ === t._$_b$_;
        }
        _$equalsRgb$_(t, s, i) {
            return this._$_r$_ === t && this._$_g$_ === s && this._$_b$_ === i;
        }
        _$equalsRgba$_(t, s, i, e) {
            return this._$_r$_ === t && this._$_g$_ === s && this._$_b$_ === i && this._$_a$_ === e;
        }
        _$equalsF32Array$_(t, s) {
            return t[s] === Math.fround(this._$_r$_) && t[s + 1] === Math.fround(this._$_g$_) && t[s + 2] === Math.fround(this._$_b$_) && t[s + 3] === Math.fround(this._$_a$_);
        }
        _$equalsRGBF32Array$_(t, s) {
            return t[s] === Math.fround(this._$_r$_) && t[s + 1] === Math.fround(this._$_g$_) && t[s + 2] === Math.fround(this._$_b$_);
        }
        multiply(t) {
            this._$_r$_ *= t._$_r$_, this._$_g$_ *= t._$_g$_, this._$_b$_ *= t._$_b$_, this._$_a$_ *= t._$_a$_;
        }
        _$multiplyAlpha$_(t) {
            this._$_r$_ *= t, this._$_g$_ *= t, this._$_b$_ *= t, this._$_a$_ *= t;
        }
        _$premultiply$_() {
            return this._$_r$_ *= this._$_a$_, this._$_g$_ *= this._$_a$_, this._$_b$_ *= this._$_a$_, 
            this;
        }
        _$unpremultiply$_() {
            return this._$_r$_ /= this._$_a$_, this._$_g$_ /= this._$_a$_, this._$_b$_ /= this._$_a$_, 
            this;
        }
        _$clamp$_() {
            return this._$_r$_ = la._$clamp$_(this._$_r$_, 0, 1), this._$_g$_ = la._$clamp$_(this._$_g$_, 0, 1), 
            this._$_b$_ = la._$clamp$_(this._$_b$_, 0, 1), this._$_a$_ = la._$clamp$_(this._$_a$_, 0, 1), 
            this;
        }
        _$setFromRgbValue$_(t) {
            this._$_r$_ = la._$GetRValue$_(t), this._$_g$_ = la._$GetGValue$_(t), this._$_b$_ = la._$GetBValue$_(t), 
            this._$_a$_ = la._$GetAValue$_(t);
        }
        _$getCssRgb$_(t, s, i) {
            return `rgb(${100 * (la._$IsFiniteNumber$_(t) ? t : this._$getR$_())}%, ${100 * (la._$IsFiniteNumber$_(s) ? s : this._$getG$_())}%, ${100 * (la._$IsFiniteNumber$_(i) ? i : this._$getB$_())}%)`;
        }
        _$getCssRgba$_(t, s, i, e) {
            return `rgba(${100 * (la._$IsFiniteNumber$_(t) ? t : this._$getR$_())}%, ${100 * (la._$IsFiniteNumber$_(s) ? s : this._$getG$_())}%, ${100 * (la._$IsFiniteNumber$_(i) ? i : this._$getB$_())}%, ${la._$IsFiniteNumber$_(e) ? e : this._$getA$_()})`;
        }
        _$toHexString$_() {
            const t = Math.round(255 * this._$getR$_()), s = Math.round(255 * this._$getG$_()), i = Math.round(255 * this._$getB$_());
            return "#" + aa(t.toString(16)) + aa(s.toString(16)) + aa(i.toString(16));
        }
        _$parseHexString$_(t) {
            if ("string" != typeof t) return !1;
            let s, i, e;
            if ("#" === (t = t.trim()).charAt(0) && (t = t.substr(1)), 3 === t.length) s = parseInt(t[0], 16) / 15, 
            i = parseInt(t[1], 16) / 15, e = parseInt(t[2], 16) / 15; else {
                if (6 !== t.length) return !1;
                s = parseInt(t.substr(0, 2), 16) / 255, i = parseInt(t.substr(2, 2), 16) / 255, 
                e = parseInt(t.substr(4, 2), 16) / 255;
            }
            return isFinite(s) && this._$setR$_(s), isFinite(i) && this._$setG$_(i), isFinite(e) && this._$setB$_(e), 
            this._$setA$_(1), !0;
        }
        _$toCommaSeparatedRgb$_() {
            return `${Math.round(255 * this._$getR$_())}, ${Math.round(255 * this._$getG$_())}, ${Math.round(255 * this._$getB$_())}`;
        }
        _$toRgbArray$_() {
            return [ Math.round(255 * this._$getR$_()), Math.round(255 * this._$getG$_()), Math.round(255 * this._$getB$_()) ];
        }
        _$parseCommaSeparatedRgb$_(t) {
            if ("string" != typeof t) return !1;
            const s = (t = t.replace(/^rgb\(|\)|%/, "")).split(",");
            if (s.length < 3) return !1;
            const i = parseInt(s[0].trim(), 10) / 255, e = parseInt(s[1].trim(), 10) / 255, n = parseInt(s[2].trim(), 10) / 255;
            return isFinite(i) && this._$setR$_(i), isFinite(e) && this._$setG$_(e), isFinite(n) && this._$setB$_(n), 
            this._$setA$_(1), !0;
        }
        _$parseCommaSeparatedPercentageRgb$_(t) {
            if ("string" != typeof t) return !1;
            const s = (t = t.replace(/^rgb\(|\)|%/, "")).split(",");
            if (s.length < 3) return !1;
            const i = parseInt(s[0].trim(), 10) / 100, e = parseInt(s[1].trim(), 10) / 100, n = parseInt(s[2].trim(), 10) / 100;
            return isFinite(i) && this._$setR$_(i), isFinite(e) && this._$setG$_(e), isFinite(n) && this._$setB$_(n), 
            this._$setA$_(1), !0;
        }
        _$parseCommaSeparatedRgba$_(t) {
            if ("string" != typeof t) return !1;
            const s = (t = t.replace(/^rgba\(|\)|%/, "")).split(",");
            if (s.length < 4) return !1;
            const i = parseInt(s[0].trim(), 10) / 255, e = parseInt(s[1].trim(), 10) / 255, n = parseInt(s[2].trim(), 10) / 255, h = parseFloat(s[3].trim());
            return isFinite(i) && this._$setR$_(i), isFinite(e) && this._$setG$_(e), isFinite(n) && this._$setB$_(n), 
            isFinite(h) && this._$setA$_(h), !0;
        }
        _$parseCommaSeparatedPercentageRgba$_(t) {
            if ("string" != typeof t) return !1;
            const s = (t = t.replace(/^rgba\(|\)|%/, "")).split(",");
            if (s.length < 4) return !1;
            const i = parseInt(s[0].trim(), 10) / 100, e = parseInt(s[1].trim(), 10) / 100, n = parseInt(s[2].trim(), 10) / 100, h = parseFloat(s[3].trim());
            return isFinite(i) && this._$setR$_(i), isFinite(e) && this._$setG$_(e), isFinite(n) && this._$setB$_(n), 
            isFinite(h) && this._$setA$_(h), !0;
        }
        _$parseString$_(t) {
            if ("string" != typeof t) return !1;
            if ((t = t.replace(/\s+/, "")).includes(",")) {
                if (t.startsWith("rgb(")) return t.includes("%") ? this._$parseCommaSeparatedPercentageRgb$_(t) : this._$parseCommaSeparatedRgb$_(t);
                if (t.startsWith("rgba(")) return t.includes("%") ? this._$parseCommaSeparatedPercentageRgba$_(t) : this._$parseCommaSeparatedRgba$_(t);
                if (t.startsWith("hsl(") || t.startsWith("hsla(")) return this._$parseHSLString$_(t);
                {
                    const s = t.split(",");
                    return t.includes("%") ? 3 === s.length ? this._$parseCommaSeparatedPercentageRgb$_(t) : 4 === s.length && this._$parseCommaSeparatedPercentageRgba$_(t) : 3 === s.length ? this._$parseCommaSeparatedRgb$_(t) : 4 === s.length && this._$parseCommaSeparatedRgba$_(t);
                }
            }
            return this._$parseHexString$_(t);
        }
        toJSON() {
            return [ this._$_r$_, this._$_g$_, this._$_b$_, this._$_a$_ ];
        }
        _$setFromHSLA$_(t, s, i, e) {
            let n, h, r;
            if (t %= 360, s = la._$clamp$_(s, 0, 100), i = la._$clamp$_(i, 0, 100), e = la._$clamp$_(e, 0, 1), 
            t /= 360, i /= 100, 0 == (s /= 100)) n = h = r = i; else {
                const e = i < .5 ? i * (1 + s) : i + s - i * s, o = 2 * i - e;
                n = ua(o, e, t + 1 / 3), h = ua(o, e, t), r = ua(o, e, t - 1 / 3);
            }
            return this._$setR$_(n), this._$setG$_(h), this._$setB$_(r), this._$setA$_(e), this;
        }
        _$parseHSLString$_(t) {
            const s = t.replace(/ |hsl|hsla|\(|\)|;/gi, ""), i = ca.exec(s), e = fa.exec(s);
            return i && 4 === i.length ? (this._$setFromHSLA$_(+i[1], +i[2], +i[3], 1), !0) : !(!e || 5 !== e.length || (this._$setFromHSLA$_(+i[1], +i[2], +i[3], +i[4]), 
            0));
        }
        _$toHSLAString$_() {
            const t = this._$_r$_, s = this._$_g$_, i = this._$_b$_, e = this._$_a$_;
            return `hsla(${la._$Color$_._$GetHue$_(t, s, i)}, ${la._$Color$_._$GetSaturation$_(t, s, i)}%, ${la._$Color$_._$GetLuminosity$_(t, s, i)}%, ${e})`;
        }
        _$toHSLAArray$_() {
            const t = this._$_r$_, s = this._$_g$_, i = this._$_b$_;
            return [ la._$Color$_._$GetHue$_(t, s, i), la._$Color$_._$GetSaturation$_(t, s, i), la._$Color$_._$GetLuminosity$_(t, s, i), this._$_a$_ ];
        }
        _$setFromJSON$_(t) {
            Array.isArray(t) && (t.length < 3 || (this._$_r$_ = t[0], this._$_g$_ = t[1], this._$_b$_ = t[2], 
            t.length >= 4 ? this._$_a$_ = t[3] : this._$_a$_ = 1));
        }
        set r(t) {
            this._$setR$_(t);
        }
        get r() {
            return this._$getR$_();
        }
        set g(t) {
            this._$setG$_(t);
        }
        get g() {
            return this._$getG$_();
        }
        set b(t) {
            this._$setB$_(t);
        }
        get b() {
            return this._$getB$_();
        }
        set a(t) {
            this._$setA$_(t);
        }
        get a() {
            return this._$getA$_();
        }
        _$setAtIndex$_(t, s) {
            switch (t) {
              case 0:
                this._$setR$_(s);
                break;

              case 1:
                this._$setG$_(s);
                break;

              case 2:
                this._$setB$_(s);
                break;

              case 3:
                this._$setA$_(s);
                break;

              default:
                throw new RangeError("invalid color index");
            }
        }
        _$getAtIndex$_(t) {
            switch (t) {
              case 0:
                return this._$getR$_();

              case 1:
                return this._$getG$_();

              case 2:
                return this._$getB$_();

              case 3:
                return this._$getA$_();

              default:
                throw new RangeError("invalid color index");
            }
        }
        static _$Equals$_(t, s) {
            let i, e;
            if (Array.isArray(t)) i = new la._$Color$_, i._$setFromJSON$_(t); else {
                if (!(t instanceof la._$Color$_)) throw new Error("unexpected type");
                i = t;
            }
            if (Array.isArray(s)) e = new la._$Color$_, e._$setFromJSON$_(s); else {
                if (!(s instanceof la._$Color$_)) throw new Error("unexpected type");
                e = s;
            }
            return i.equals(e);
        }
        static _$DiffChannel$_(t, s) {
            return la._$clamp$_(Math.max(t, s) - Math.min(t, s), 0, 1);
        }
        static _$Diff$_(t, s) {
            const i = new la._$Color$_;
            return i._$setR$_(Math.max(t._$_r$_, s._$_r$_) - Math.min(t._$_r$_, s._$_r$_)), 
            i._$setG$_(Math.max(t._$_g$_, s._$_g$_) - Math.min(t._$_g$_, s._$_g$_)), i._$setB$_(Math.max(t._$_b$_, s._$_b$_) - Math.min(t._$_b$_, s._$_b$_)), 
            i._$setA$_(Math.max(t._$_a$_, s._$_a$_) - Math.min(t._$_a$_, s._$_a$_)), i;
        }
        static _$DiffNoAlpha$_(t, s) {
            const i = new la._$Color$_(0, 0, 0, 1);
            return i._$setR$_(Math.max(t._$_r$_, s._$_r$_) - Math.min(t._$_r$_, s._$_r$_)), 
            i._$setG$_(Math.max(t._$_g$_, s._$_g$_) - Math.min(t._$_g$_, s._$_g$_)), i._$setB$_(Math.max(t._$_b$_, s._$_b$_) - Math.min(t._$_b$_, s._$_b$_)), 
            i;
        }
        static _$GetHue$_(t, s, i) {
            const e = Math.max(t, s, i), n = Math.min(t, s, i);
            if (e === n) return 0;
            let h = 0;
            switch (e) {
              case t:
                h = (s - i) / (e - n) + (s < i ? 6 : 0);
                break;

              case s:
                h = (i - t) / (e - n) + 2;
                break;

              case i:
                h = (t - s) / (e - n) + 4;
            }
            return Math.round(h / 6 * 360);
        }
        static _$GetSaturation$_(t, s, i) {
            const e = Math.max(t, s, i), n = Math.min(t, s, i);
            if (e === n) return 0;
            const h = e - n, r = (e + n) / 2 > .5 ? h / (2 - e - n) : h / (e + n);
            return Math.round(100 * r);
        }
        static _$GetLuminosity$_(t, s, i) {
            const e = Math.max(t, s, i), n = (e + Math.min(t, s, i)) / 2;
            return e ? Math.round(100 * n) : 0;
        }
    }, la._$Color$_._$White$_ = Object.freeze(la._$New$_(la._$Color$_, 1, 1, 1, 1)), 
    la._$Color$_._$Black$_ = Object.freeze(la._$New$_(la._$Color$_, 0, 0, 0, 1)), la._$Color$_._$TransparentBlack$_ = Object.freeze(la._$New$_(la._$Color$_, 0, 0, 0, 0));
}

{
    const da = self._$C3$_;
    da._$Vector2$_ = class {
        constructor(t, s) {
            this._$_x$_ = 0, this._$_y$_ = 0, t instanceof da._$Vector2$_ ? this._$copy$_(t) : this.set(t || 0, s || 0);
        }
        set(t, s) {
            this._$_x$_ = +t, this._$_y$_ = +s;
        }
        _$copy$_(t) {
            this._$_x$_ = t._$_x$_, this._$_y$_ = t._$_y$_;
        }
        equals(t) {
            return this._$_x$_ === t._$_x$_ && this._$_y$_ === t._$_y$_;
        }
        _$equalsValues$_(t, s) {
            return this._$_x$_ === t && this._$_y$_ === s;
        }
        _$equalsF32Array$_(t, s) {
            return t[s] === Math.fround(this._$_x$_) && t[s + 1] === Math.fround(this._$_y$_);
        }
        _$setX$_(t) {
            this._$_x$_ = +t;
        }
        _$getX$_() {
            return this._$_x$_;
        }
        _$setY$_(t) {
            this._$_y$_ = +t;
        }
        _$getY$_() {
            return this._$_y$_;
        }
        toArray() {
            return [ this._$_x$_, this._$_y$_ ];
        }
        _$toTypedArray$_() {
            return new Float64Array(this.toArray());
        }
        _$writeToTypedArray$_(t, s) {
            t[s++] = this._$_x$_, t[s] = this._$_y$_;
        }
        offset(t, s) {
            this._$_x$_ += +t, this._$_y$_ += +s;
        }
        scale(t, s) {
            this._$_x$_ *= t, this._$_y$_ *= s;
        }
        _$divide$_(t, s) {
            this._$_x$_ /= t, this._$_y$_ /= s;
        }
        round() {
            this._$_x$_ = Math.round(this._$_x$_), this._$_y$_ = Math.round(this._$_y$_);
        }
        floor() {
            this._$_x$_ = Math.floor(this._$_x$_), this._$_y$_ = Math.floor(this._$_y$_);
        }
        ceil() {
            this._$_x$_ = Math.ceil(this._$_x$_), this._$_y$_ = Math.ceil(this._$_y$_);
        }
        angle() {
            return da._$angleTo$_(0, 0, this._$_x$_, this._$_y$_);
        }
        _$lengthSquared$_() {
            return this._$_x$_ * this._$_x$_ + this._$_y$_ * this._$_y$_;
        }
        length() {
            return da._$hypot2DFast$_(this._$_x$_, this._$_y$_);
        }
        _$rotatePrecalc$_(t, s) {
            const i = this._$_x$_ * s - this._$_y$_ * t;
            this._$_y$_ = this._$_y$_ * s + this._$_x$_ * t, this._$_x$_ = i;
        }
        rotate(t) {
            0 !== t && this._$rotatePrecalc$_(Math.sin(t), Math.cos(t));
        }
        _$rotateAbout$_(t, s, i) {
            0 === t || s === this._$_x$_ && i === this._$_y$_ || (this._$_x$_ -= s, this._$_y$_ -= i, 
            this._$rotatePrecalc$_(Math.sin(t), Math.cos(t)), this._$_x$_ += +s, this._$_y$_ += +i);
        }
        move(t, s) {
            0 !== s && (this._$_x$_ += Math.cos(t) * s, this._$_y$_ += Math.sin(t) * s);
        }
        normalize() {
            const t = this.length();
            0 !== t && 1 !== t && (this._$_x$_ /= t, this._$_y$_ /= t);
        }
        _$clamp$_(t, s) {
            this._$_x$_ = da._$clamp$_(this._$_x$_, t, s), this._$_y$_ = da._$clamp$_(this._$_y$_, t, s);
        }
        _$dot$_(t) {
            return this._$_x$_ * t._$_x$_ + this._$_y$_ * t._$_y$_;
        }
        reverse() {
            this._$_x$_ = -this._$_x$_, this._$_y$_ = -this._$_y$_;
        }
        _$perp$_() {
            let t = this._$_x$_;
            return this._$_x$_ = this._$_y$_, this._$_y$_ = -t, this;
        }
    };
}

{
    const pa = self._$C3$_;
    pa.Rect = class {
        constructor(t, s, i, e) {
            this._$_left$_ = NaN, this._$_top$_ = NaN, this._$_right$_ = NaN, this._$_bottom$_ = NaN, 
            this._$_left$_ = 0, this._$_top$_ = 0, this._$_right$_ = 0, this._$_bottom$_ = 0, 
            t instanceof pa.Rect ? this._$copy$_(t) : this.set(t || 0, s || 0, i || 0, e || 0);
        }
        set(t, s, i, e) {
            this._$_left$_ = +t, this._$_top$_ = +s, this._$_right$_ = +i, this._$_bottom$_ = +e;
        }
        _$setWH$_(t, s, i, e) {
            t = +t, s = +s, this._$_left$_ = t, this._$_top$_ = s, this._$_right$_ = t + +i, 
            this._$_bottom$_ = s + +e;
        }
        _$copy$_(t) {
            this._$_left$_ = +t._$_left$_, this._$_top$_ = +t._$_top$_, this._$_right$_ = +t._$_right$_, 
            this._$_bottom$_ = +t._$_bottom$_;
        }
        clone() {
            return new pa.Rect(this._$_left$_, this._$_top$_, this._$_right$_, this._$_bottom$_);
        }
        static _$Merge$_(t, s) {
            const i = new pa.Rect;
            return i._$setLeft$_(Math.min(t._$_left$_, s._$_left$_)), i._$setTop$_(Math.min(t._$_top$_, s._$_top$_)), 
            i._$setRight$_(Math.max(t._$_right$_, s._$_right$_)), i._$setBottom$_(Math.max(t._$_bottom$_, s._$_bottom$_)), 
            i;
        }
        static _$FromObject$_(t) {
            return new pa.Rect(t.left, t.top, t.right, t.bottom);
        }
        equals(t) {
            return this._$_left$_ === t._$_left$_ && this._$_top$_ === t._$_top$_ && this._$_right$_ === t._$_right$_ && this._$_bottom$_ === t._$_bottom$_;
        }
        _$equalsWH$_(t, s, i, e) {
            return this._$_left$_ === t && this._$_top$_ === s && this.width() === i && this.height() === e;
        }
        _$equalsF32Array$_(t, s) {
            return t[s] === Math.fround(this._$_left$_) && t[s + 1] === Math.fround(this._$_top$_) && t[s + 2] === Math.fround(this._$_right$_) && t[s + 3] === Math.fround(this._$_bottom$_);
        }
        _$setLeft$_(t) {
            this._$_left$_ = +t;
        }
        _$getLeft$_() {
            return this._$_left$_;
        }
        _$setTop$_(t) {
            this._$_top$_ = +t;
        }
        _$getTop$_() {
            return this._$_top$_;
        }
        _$setRight$_(t) {
            this._$_right$_ = +t;
        }
        _$getRight$_() {
            return this._$_right$_;
        }
        _$setBottom$_(t) {
            this._$_bottom$_ = +t;
        }
        _$getBottom$_() {
            return this._$_bottom$_;
        }
        toArray() {
            return [ this._$_left$_, this._$_top$_, this._$_right$_, this._$_bottom$_ ];
        }
        _$toTypedArray$_() {
            return new Float64Array(this.toArray());
        }
        _$toDOMRect$_() {
            return new DOMRect(this._$_left$_, this._$_top$_, this.width(), this.height());
        }
        static _$fromDOMRect$_(t) {
            return pa._$New$_(pa.Rect, t.left, t.top, t.right, t.bottom);
        }
        _$writeToTypedArray$_(t, s) {
            t[s++] = this._$_left$_, t[s++] = this._$_top$_, t[s++] = this._$_right$_, t[s] = this._$_bottom$_;
        }
        _$writeAsQuadToTypedArray$_(t, s) {
            t[s++] = this._$_left$_, t[s++] = this._$_top$_, t[s++] = this._$_right$_, t[s++] = this._$_top$_, 
            t[s++] = this._$_right$_, t[s++] = this._$_bottom$_, t[s++] = this._$_left$_, t[s] = this._$_bottom$_;
        }
        _$writeAsQuadToTypedArray3D$_(t, s, i) {
            t[s++] = this._$_left$_, t[s++] = this._$_top$_, t[s++] = i, t[s++] = this._$_right$_, 
            t[s++] = this._$_top$_, t[s++] = i, t[s++] = this._$_right$_, t[s++] = this._$_bottom$_, 
            t[s++] = i, t[s++] = this._$_left$_, t[s++] = this._$_bottom$_, t[s] = i;
        }
        width() {
            return this._$_right$_ - this._$_left$_;
        }
        height() {
            return this._$_bottom$_ - this._$_top$_;
        }
        _$midX$_() {
            return (this._$_left$_ + this._$_right$_) / 2;
        }
        _$midY$_() {
            return (this._$_top$_ + this._$_bottom$_) / 2;
        }
        offset(t, s) {
            t = +t, s = +s, this._$_left$_ += t, this._$_top$_ += s, this._$_right$_ += t, this._$_bottom$_ += s;
        }
        offsetLeft(t) {
            this._$_left$_ += +t;
        }
        offsetTop(t) {
            this._$_top$_ += +t;
        }
        _$offsetRight$_(t) {
            this._$_right$_ += +t;
        }
        _$offsetBottom$_(t) {
            this._$_bottom$_ += +t;
        }
        _$toSquare$_(t) {
            if ("x" !== t) throw new Error("invalid axis, only 'x' supported");
            this._$_top$_ < this._$_bottom$_ ? this._$_left$_ < this._$_right$_ ? this._$_bottom$_ = this._$_top$_ + this.width() : this._$_bottom$_ = this._$_top$_ - this.width() : this._$_left$_ < this._$_right$_ ? this._$_bottom$_ = this._$_top$_ - this.width() : this._$_bottom$_ = this._$_top$_ + this.width();
        }
        _$inflate$_(t, s) {
            t = +t, s = +s, this._$_left$_ -= t, this._$_top$_ -= s, this._$_right$_ += t, this._$_bottom$_ += s;
        }
        _$deflate$_(t, s) {
            t = +t, s = +s, this._$_left$_ += t, this._$_top$_ += s, this._$_right$_ -= t, this._$_bottom$_ -= s;
        }
        multiply(t, s) {
            this._$_left$_ *= t, this._$_top$_ *= s, this._$_right$_ *= t, this._$_bottom$_ *= s;
        }
        _$divide$_(t, s) {
            this._$_left$_ /= t, this._$_top$_ /= s, this._$_right$_ /= t, this._$_bottom$_ /= s;
        }
        _$mirrorAround$_(t) {
            this._$_left$_ = +t - this._$_left$_, this._$_right$_ = +t - this._$_right$_;
        }
        _$flipAround$_(t) {
            this._$_top$_ = +t - this._$_top$_, this._$_bottom$_ = +t - this._$_bottom$_;
        }
        _$rotate90DegreesAround$_(t, s) {
            const i = this.width(), e = this.height(), n = this._$getLeft$_() + i * t, h = this._$getTop$_() + e * s;
            this._$setWH$_(n - e * s, h - i * t, e, i);
        }
        _$swapLeftRight$_() {
            const t = this._$_left$_;
            this._$_left$_ = this._$_right$_, this._$_right$_ = t;
        }
        _$swapTopBottom$_() {
            const t = this._$_top$_;
            this._$_top$_ = this._$_bottom$_, this._$_bottom$_ = t;
        }
        _$shuntY$_(t) {
            const s = this._$_top$_;
            this._$_top$_ = +t - this._$_bottom$_, this._$_bottom$_ = +t - s;
        }
        round() {
            this._$_left$_ = Math.round(this._$_left$_), this._$_top$_ = Math.round(this._$_top$_), 
            this._$_right$_ = Math.round(this._$_right$_), this._$_bottom$_ = Math.round(this._$_bottom$_);
        }
        _$roundInner$_() {
            this._$_left$_ = Math.ceil(this._$_left$_), this._$_top$_ = Math.ceil(this._$_top$_), 
            this._$_right$_ = Math.floor(this._$_right$_), this._$_bottom$_ = Math.floor(this._$_bottom$_);
        }
        _$roundOuter$_() {
            this._$_left$_ = Math.floor(this._$_left$_), this._$_top$_ = Math.floor(this._$_top$_), 
            this._$_right$_ = Math.ceil(this._$_right$_), this._$_bottom$_ = Math.ceil(this._$_bottom$_);
        }
        floor() {
            this._$_left$_ = Math.floor(this._$_left$_), this._$_top$_ = Math.floor(this._$_top$_), 
            this._$_right$_ = Math.floor(this._$_right$_), this._$_bottom$_ = Math.floor(this._$_bottom$_);
        }
        ceil() {
            this._$_left$_ = Math.ceil(this._$_left$_), this._$_top$_ = Math.ceil(this._$_top$_), 
            this._$_right$_ = Math.ceil(this._$_right$_), this._$_bottom$_ = Math.ceil(this._$_bottom$_);
        }
        _$clamp$_(t, s, i, e) {
            this._$_left$_ = Math.max(this._$_left$_, +t), this._$_top$_ = Math.max(this._$_top$_, +s), 
            this._$_right$_ = Math.min(this._$_right$_, +i), this._$_bottom$_ = Math.min(this._$_bottom$_, +e);
        }
        _$clampBoth$_(t, s, i, e) {
            t = +t, s = +s, i = +i, e = +e, this._$_left$_ = pa._$clamp$_(this._$_left$_, t, i), 
            this._$_top$_ = pa._$clamp$_(this._$_top$_, s, e), this._$_right$_ = pa._$clamp$_(this._$_right$_, t, i), 
            this._$_bottom$_ = pa._$clamp$_(this._$_bottom$_, s, e);
        }
        normalize() {
            this._$_left$_ > this._$_right$_ && this._$swapLeftRight$_(), this._$_top$_ > this._$_bottom$_ && this._$swapTopBottom$_();
        }
        _$intersectsRect$_(t) {
            return !(t._$_right$_ < this._$_left$_ || t._$_bottom$_ < this._$_top$_ || t._$_left$_ > this._$_right$_ || t._$_top$_ > this._$_bottom$_);
        }
        _$intersectsRectOffset$_(t, s, i) {
            return !(t._$_right$_ + s < this._$_left$_ || t._$_bottom$_ + i < this._$_top$_ || t._$_left$_ + s > this._$_right$_ || t._$_top$_ + i > this._$_bottom$_);
        }
        _$containsPoint$_(t, s) {
            return t >= this._$_left$_ && t <= this._$_right$_ && s >= this._$_top$_ && s <= this._$_bottom$_;
        }
        _$containsRect$_(t) {
            return t._$_left$_ >= this._$_left$_ && t._$_top$_ >= this._$_top$_ && t._$_right$_ <= this._$_right$_ && t._$_bottom$_ <= this._$_bottom$_;
        }
        _$expandToContain$_(t) {
            t._$_left$_ < this._$_left$_ && (this._$_left$_ = +t._$_left$_), t._$_top$_ < this._$_top$_ && (this._$_top$_ = +t._$_top$_), 
            t._$_right$_ > this._$_right$_ && (this._$_right$_ = +t._$_right$_), t._$_bottom$_ > this._$_bottom$_ && (this._$_bottom$_ = +t._$_bottom$_);
        }
        _$lerpInto$_(t) {
            this._$_left$_ = pa._$lerp$_(t._$_left$_, t._$_right$_, this._$_left$_), this._$_top$_ = pa._$lerp$_(t._$_top$_, t._$_bottom$_, this._$_top$_), 
            this._$_right$_ = pa._$lerp$_(t._$_left$_, t._$_right$_, this._$_right$_), this._$_bottom$_ = pa._$lerp$_(t._$_top$_, t._$_bottom$_, this._$_bottom$_);
        }
    };
}

{
    const ma = self._$C3$_;
    ma._$Quad$_ = class {
        constructor(t, s, i, e, n, h, r, o) {
            this._$_tlx$_ = NaN, this._$_tly$_ = NaN, this._$_trx$_ = NaN, this._$_try$_ = NaN, 
            this._$_brx$_ = NaN, this._$_bry$_ = NaN, this._$_blx$_ = NaN, this._$_bly$_ = NaN, 
            this._$_tlx$_ = 0, this._$_tly$_ = 0, this._$_trx$_ = 0, this._$_try$_ = 0, this._$_brx$_ = 0, 
            this._$_bry$_ = 0, this._$_blx$_ = 0, this._$_bly$_ = 0, t instanceof ma._$Quad$_ ? this._$copy$_(t) : this.set(t || 0, s || 0, i || 0, e || 0, n || 0, h || 0, r || 0, o || 0);
        }
        set(t, s, i, e, n, h, r, o) {
            this._$_tlx$_ = +t, this._$_tly$_ = +s, this._$_trx$_ = +i, this._$_try$_ = +e, 
            this._$_brx$_ = +n, this._$_bry$_ = +h, this._$_blx$_ = +r, this._$_bly$_ = +o;
        }
        _$setRect$_(t, s, i, e) {
            this.set(t, s, i, s, i, e, t, e);
        }
        _$copy$_(t) {
            this._$_tlx$_ = t._$_tlx$_, this._$_tly$_ = t._$_tly$_, this._$_trx$_ = t._$_trx$_, 
            this._$_try$_ = t._$_try$_, this._$_brx$_ = t._$_brx$_, this._$_bry$_ = t._$_bry$_, 
            this._$_blx$_ = t._$_blx$_, this._$_bly$_ = t._$_bly$_;
        }
        equals(t) {
            return this._$_tlx$_ === t._$_tlx$_ && this._$_tly$_ === t._$_tly$_ && this._$_trx$_ === t._$_trx$_ && this._$_try$_ === t._$_try$_ && this._$_brx$_ === t._$_brx$_ && this._$_bry$_ === t._$_bry$_ && this._$_blx$_ === t._$_blx$_ && this._$_bly$_ === t._$_bly$_;
        }
        _$setTlx$_(t) {
            this._$_tlx$_ = +t;
        }
        _$getTlx$_() {
            return this._$_tlx$_;
        }
        _$setTly$_(t) {
            this._$_tly$_ = +t;
        }
        _$getTly$_() {
            return this._$_tly$_;
        }
        _$setTrx$_(t) {
            this._$_trx$_ = +t;
        }
        _$getTrx$_() {
            return this._$_trx$_;
        }
        _$setTry$_(t) {
            this._$_try$_ = +t;
        }
        _$getTry$_() {
            return this._$_try$_;
        }
        _$setBrx$_(t) {
            this._$_brx$_ = +t;
        }
        _$getBrx$_() {
            return this._$_brx$_;
        }
        _$setBry$_(t) {
            this._$_bry$_ = +t;
        }
        _$getBry$_() {
            return this._$_bry$_;
        }
        _$setBlx$_(t) {
            this._$_blx$_ = +t;
        }
        _$getBlx$_() {
            return this._$_blx$_;
        }
        _$setBly$_(t) {
            this._$_bly$_ = +t;
        }
        _$getBly$_() {
            return this._$_bly$_;
        }
        _$toDOMQuad$_() {
            return new DOMQuad(new DOMPoint(this._$_tlx$_, this._$_tly$_), new DOMPoint(this._$_trx$_, this._$_try$_), new DOMPoint(this._$_brx$_, this._$_bry$_), new DOMPoint(this._$_blx$_, this._$_bly$_));
        }
        static _$fromDOMQuad$_(t) {
            return ma._$New$_(ma._$Quad$_, t.p1.x, t.p1.y, t.p2.x, t.p2.y, t.p3.x, t.p3.y, t.p4.x, t.p4.y);
        }
        toArray() {
            return [ this._$_tlx$_, this._$_tly$_, this._$_trx$_, this._$_try$_, this._$_brx$_, this._$_bry$_, this._$_blx$_, this._$_bly$_ ];
        }
        _$toTypedArray$_() {
            return new Float64Array(this.toArray());
        }
        _$writeToTypedArray$_(t, s) {
            t[s++] = this._$_tlx$_, t[s++] = this._$_tly$_, t[s++] = this._$_trx$_, t[s++] = this._$_try$_, 
            t[s++] = this._$_brx$_, t[s++] = this._$_bry$_, t[s++] = this._$_blx$_, t[s] = this._$_bly$_;
        }
        _$writeToTypedArray3D$_(t, s, i) {
            t[s++] = this._$_tlx$_, t[s++] = this._$_tly$_, t[s++] = i, t[s++] = this._$_trx$_, 
            t[s++] = this._$_try$_, t[s++] = i, t[s++] = this._$_brx$_, t[s++] = this._$_bry$_, 
            t[s++] = i, t[s++] = this._$_blx$_, t[s++] = this._$_bly$_, t[s] = i;
        }
        offset(t, s) {
            t = +t, s = +s, this._$_tlx$_ += t, this._$_tly$_ += s, this._$_trx$_ += t, this._$_try$_ += s, 
            this._$_brx$_ += t, this._$_bry$_ += s, this._$_blx$_ += t, this._$_bly$_ += s;
        }
        round() {
            this._$_tlx$_ = Math.round(this._$_tlx$_), this._$_tly$_ = Math.round(this._$_tly$_), 
            this._$_trx$_ = Math.round(this._$_trx$_), this._$_try$_ = Math.round(this._$_try$_), 
            this._$_brx$_ = Math.round(this._$_brx$_), this._$_bry$_ = Math.round(this._$_bry$_), 
            this._$_blx$_ = Math.round(this._$_blx$_), this._$_bly$_ = Math.round(this._$_bly$_);
        }
        floor() {
            this._$_tlx$_ = Math.floor(this._$_tlx$_), this._$_tly$_ = Math.floor(this._$_tly$_), 
            this._$_trx$_ = Math.floor(this._$_trx$_), this._$_try$_ = Math.floor(this._$_try$_), 
            this._$_brx$_ = Math.floor(this._$_brx$_), this._$_bry$_ = Math.floor(this._$_bry$_), 
            this._$_blx$_ = Math.floor(this._$_blx$_), this._$_bly$_ = Math.floor(this._$_bly$_);
        }
        ceil() {
            this._$_tlx$_ = Math.ceil(this._$_tlx$_), this._$_tly$_ = Math.ceil(this._$_tly$_), 
            this._$_trx$_ = Math.ceil(this._$_trx$_), this._$_try$_ = Math.ceil(this._$_try$_), 
            this._$_brx$_ = Math.ceil(this._$_brx$_), this._$_bry$_ = Math.ceil(this._$_bry$_), 
            this._$_blx$_ = Math.ceil(this._$_blx$_), this._$_bly$_ = Math.ceil(this._$_bly$_);
        }
        _$setFromRect$_(t) {
            this._$_tlx$_ = t._$_left$_, this._$_tly$_ = t._$_top$_, this._$_trx$_ = t._$_right$_, 
            this._$_try$_ = t._$_top$_, this._$_brx$_ = t._$_right$_, this._$_bry$_ = t._$_bottom$_, 
            this._$_blx$_ = t._$_left$_, this._$_bly$_ = t._$_bottom$_;
        }
        _$setFromRotatedRect$_(t, s) {
            0 === s ? this._$setFromRect$_(t) : this._$setFromRotatedRectPrecalc$_(t, Math.sin(s), Math.cos(s));
        }
        _$setFromRotatedRectPrecalc$_(t, s, i) {
            const e = t._$_left$_ * s, n = t._$_top$_ * s, h = t._$_right$_ * s, r = t._$_bottom$_ * s, o = t._$_left$_ * i, a = t._$_top$_ * i, u = t._$_right$_ * i, l = t._$_bottom$_ * i;
            this._$_tlx$_ = o - n, this._$_tly$_ = a + e, this._$_trx$_ = u - n, this._$_try$_ = a + h, 
            this._$_brx$_ = u - r, this._$_bry$_ = l + h, this._$_blx$_ = o - r, this._$_bly$_ = l + e;
        }
        _$getBoundingBox$_(t) {
            t.set(Math.min(this._$_tlx$_, this._$_trx$_, this._$_brx$_, this._$_blx$_), Math.min(this._$_tly$_, this._$_try$_, this._$_bry$_, this._$_bly$_), Math.max(this._$_tlx$_, this._$_trx$_, this._$_brx$_, this._$_blx$_), Math.max(this._$_tly$_, this._$_try$_, this._$_bry$_, this._$_bly$_));
        }
        _$containsPoint$_(t, s) {
            let i = this._$_trx$_ - this._$_tlx$_, e = this._$_try$_ - this._$_tly$_;
            const n = this._$_brx$_ - this._$_tlx$_, h = this._$_bry$_ - this._$_tly$_, r = t - this._$_tlx$_, o = s - this._$_tly$_;
            let a = i * i + e * e, u = i * n + e * h, l = i * r + e * o;
            const c = n * n + h * h, f = n * r + h * o;
            let d = 1 / (a * c - u * u), p = (c * l - u * f) * d, m = (a * f - u * l) * d;
            return p >= 0 && m > 0 && p + m < 1 || (i = this._$_blx$_ - this._$_tlx$_, e = this._$_bly$_ - this._$_tly$_, 
            a = i * i + e * e, u = i * n + e * h, l = i * r + e * o, d = 1 / (a * c - u * u), 
            p = (c * l - u * f) * d, m = (a * f - u * l) * d, p >= 0 && m > 0 && p + m < 1);
        }
        _$midX$_() {
            return (this._$_tlx$_ + this._$_trx$_ + this._$_brx$_ + this._$_blx$_) / 4;
        }
        _$midY$_() {
            return (this._$_tly$_ + this._$_try$_ + this._$_bry$_ + this._$_bly$_) / 4;
        }
        _$intersectsSegment$_(t, s, i, e) {
            return !(!this._$containsPoint$_(t, s) && !this._$containsPoint$_(i, e)) || ma._$segmentIntersectsQuad$_(t, s, i, e, this);
        }
        _$intersectsQuad$_(t) {
            let s = t._$midX$_(), i = t._$midY$_();
            if (this._$containsPoint$_(s, i)) return !0;
            if (s = this._$midX$_(), i = this._$midY$_(), t._$containsPoint$_(s, i)) return !0;
            const e = this._$_tlx$_, n = this._$_tly$_, h = this._$_trx$_, r = this._$_try$_, o = this._$_brx$_, a = this._$_bry$_, u = this._$_blx$_, l = this._$_bly$_;
            return ma._$segmentIntersectsQuad$_(e, n, h, r, t) || ma._$segmentIntersectsQuad$_(h, r, o, a, t) || ma._$segmentIntersectsQuad$_(o, a, u, l, t) || ma._$segmentIntersectsQuad$_(u, l, e, n, t);
        }
        _$rotatePointsAnticlockwise$_() {
            const t = this._$_tlx$_, s = this._$_tly$_;
            this._$_tlx$_ = this._$_trx$_, this._$_tly$_ = this._$_try$_, this._$_trx$_ = this._$_brx$_, 
            this._$_try$_ = this._$_bry$_, this._$_brx$_ = this._$_blx$_, this._$_bry$_ = this._$_bly$_, 
            this._$_blx$_ = t, this._$_bly$_ = s;
        }
        _$mirror$_() {
            this._$_swap$_(0, 2), this._$_swap$_(1, 3), this._$_swap$_(6, 4), this._$_swap$_(7, 5);
        }
        _$flip$_() {
            this._$_swap$_(0, 6), this._$_swap$_(1, 7), this._$_swap$_(2, 4), this._$_swap$_(3, 5);
        }
        _$diag$_() {
            this._$_swap$_(2, 6), this._$_swap$_(3, 7);
        }
        _$_swap$_(t, s) {
            const i = this._$_getAtIndex$_(t);
            this._$_setAtIndex$_(t, this._$_getAtIndex$_(s)), this._$_setAtIndex$_(s, i);
        }
        _$_getAtIndex$_(t) {
            switch (t) {
              case 0:
                return this._$_tlx$_;

              case 1:
                return this._$_tly$_;

              case 2:
                return this._$_trx$_;

              case 3:
                return this._$_try$_;

              case 4:
                return this._$_brx$_;

              case 5:
                return this._$_bry$_;

              case 6:
                return this._$_blx$_;

              case 7:
                return this._$_bly$_;

              default:
                throw new RangeError("invalid quad point index");
            }
        }
        _$_setAtIndex$_(t, s) {
            switch (s = +s, t) {
              case 0:
                this._$_tlx$_ = s;
                break;

              case 1:
                this._$_tly$_ = s;
                break;

              case 2:
                this._$_trx$_ = s;
                break;

              case 3:
                this._$_try$_ = s;
                break;

              case 4:
                this._$_brx$_ = s;
                break;

              case 5:
                this._$_bry$_ = s;
                break;

              case 6:
                this._$_blx$_ = s;
                break;

              case 7:
                this._$_bly$_ = s;
                break;

              default:
                throw new RangeError("invalid quad point index");
            }
        }
    };
}

{
    const ga = self._$C3$_, ya = (self.assert, [ 0, 0, 1, 0, 1, 1, 0, 1 ]), Ma = ga._$New$_(ga._$Quad$_);
    ga._$CollisionPoly$_ = class extends ga._$DefendedBase$_ {
        constructor(t, s = !0) {
            super(), t || (t = ya), this._$_ptsArr$_ = Float64Array.from(t), this._$_bbox$_ = new ga.Rect, 
            this._$_isBboxChanged$_ = !0, this._$_enabled$_ = s;
        }
        _$Release$_() {}
        _$pointsArr$_() {
            return this._$_ptsArr$_;
        }
        _$pointCount$_() {
            return this._$_ptsArr$_.length / 2;
        }
        _$setPoints$_(t) {
            this._$_ptsArr$_.length === t.length ? this._$_ptsArr$_.set(t) : this._$_ptsArr$_ = Float64Array.from(t), 
            this._$_isBboxChanged$_ = !0;
        }
        _$setDefaultPoints$_() {
            this._$setPoints$_(ya);
        }
        _$copy$_(t) {
            this._$setPoints$_(t._$_ptsArr$_);
        }
        _$setBboxChanged$_() {
            this._$_isBboxChanged$_ = !0;
        }
        _$_updateBbox$_() {
            if (!this._$_isBboxChanged$_) return;
            const t = this._$_ptsArr$_;
            let s = t[0], i = t[1], e = s, n = i;
            for (let h = 0, r = t.length; h < r; h += 2) {
                const r = t[h], o = t[h + 1];
                r < s && (s = r), r > e && (e = r), o < i && (i = o), o > n && (n = o);
            }
            this._$_bbox$_.set(s, i, e, n), this._$_isBboxChanged$_ = !1;
        }
        _$setFromRect$_(t, s, i) {
            let e = this._$_ptsArr$_;
            8 !== e.length && (e = new Float64Array(8), this._$_ptsArr$_ = e), e[0] = t._$getLeft$_() - s, 
            e[1] = t._$getTop$_() - i, e[2] = t._$getRight$_() - s, e[3] = t._$getTop$_() - i, 
            e[4] = t._$getRight$_() - s, e[5] = t._$getBottom$_() - i, e[6] = t._$getLeft$_() - s, 
            e[7] = t._$getBottom$_() - i, this._$_bbox$_._$copy$_(t), 0 === s && 0 === i || this._$_bbox$_.offset(-s, -i), 
            this._$_isBboxChanged$_ = !1;
        }
        _$setFromQuad$_(t, s, i) {
            Ma._$copy$_(t), Ma.offset(s, i), this._$setPoints$_(Ma.toArray()), this._$_isBboxChanged$_ = !0;
        }
        transform(t, s, i) {
            let e = 0, n = 1;
            0 !== i && (e = Math.sin(i), n = Math.cos(i)), this._$transformPrecalc$_(t, s, e, n);
        }
        _$transformPrecalc$_(t, s, i, e) {
            const n = this._$_ptsArr$_;
            for (let h = 0, r = n.length; h < r; h += 2) {
                const r = h + 1, o = n[h] * t, a = n[r] * s;
                n[h] = o * e - a * i, n[r] = a * e + o * i;
            }
            this._$_isBboxChanged$_ = !0;
        }
        offset(t, s) {
            const i = this._$_ptsArr$_;
            for (let e = 0, n = i.length; e < n; e += 2) i[e] += t, i[e + 1] += s;
        }
        _$containsPoint$_(t, s) {
            const i = this._$_ptsArr$_;
            if (t === i[0] && s === i[1]) return !0;
            this._$_updateBbox$_();
            const e = this._$_bbox$_, n = e._$getLeft$_() - 110, h = e._$getTop$_() - 101, r = e._$getRight$_() + 131, o = e._$getBottom$_() + 120;
            let a = 0, u = 0, l = 0, c = 0, f = 0, d = 0, p = 0, m = 0;
            n < t ? (a = n, l = t) : (a = t, l = n), h < s ? (u = h, c = s) : (u = s, c = h), 
            r < t ? (f = r, p = t) : (f = t, p = r), o < s ? (d = o, m = s) : (d = s, m = o);
            let g = 0, y = 0;
            for (let e = 0, M = i.length; e < M; e += 2) {
                const w = (e + 2) % M, S = i[e], b = i[e + 1], T = i[w], v = i[w + 1];
                ga._$segmentsIntersectPreCalc$_(n, h, t, s, a, l, u, c, S, b, T, v) && ++g, ga._$segmentsIntersectPreCalc$_(r, o, t, s, f, p, d, m, S, b, T, v) && ++y;
            }
            return g % 2 == 1 || y % 2 == 1;
        }
        _$intersectsPoly$_(t, s, i) {
            const e = t._$_ptsArr$_, n = this._$_ptsArr$_;
            if (this._$containsPoint$_(e[0] + s, e[1] + i)) return !0;
            if (t._$containsPoint$_(n[0] - s, n[1] - i)) return !0;
            for (let t = 0, h = n.length; t < h; t += 2) {
                const r = (t + 2) % h, o = n[t], a = n[t + 1], u = n[r], l = n[r + 1];
                let c = 0, f = 0, d = 0, p = 0;
                o < u ? (c = o, d = u) : (c = u, d = o), a < l ? (f = a, p = l) : (f = l, p = a);
                for (let t = 0, n = e.length; t < n; t += 2) {
                    const h = (t + 2) % n, r = e[t] + s, m = e[t + 1] + i, g = e[h] + s, y = e[h + 1] + i;
                    if (ga._$segmentsIntersectPreCalc$_(o, a, u, l, c, d, f, p, r, m, g, y)) return !0;
                }
            }
            return !1;
        }
        _$intersectsSegment$_(t, s, i, e, n, h) {
            if (this._$containsPoint$_(i - t, e - s)) return !0;
            if (this._$containsPoint$_(n - t, h - s)) return !0;
            let r = 0, o = 0, a = 0, u = 0;
            i < n ? (r = i, a = n) : (r = n, a = i), e < h ? (o = e, u = h) : (o = h, u = e);
            const l = this._$_ptsArr$_;
            for (let c = 0, f = l.length; c < f; c += 2) {
                const d = (c + 2) % f, p = l[c] + t, m = l[c + 1] + s, g = l[d] + t, y = l[d + 1] + s;
                if (ga._$segmentsIntersectPreCalc$_(i, e, n, h, r, a, o, u, p, m, g, y)) return !0;
            }
            return !1;
        }
        _$mirror$_(t) {
            const s = this._$_ptsArr$_;
            for (let i = 0, e = s.length; i < e; i += 2) s[i] = 2 * t - s[i];
            this._$_isBboxChanged$_ = !0;
        }
        _$flip$_(t) {
            const s = this._$_ptsArr$_;
            for (let i = 0, e = s.length; i < e; i += 2) {
                const e = i + 1;
                s[e] = 2 * t - s[e];
            }
            this._$_isBboxChanged$_ = !0;
        }
        _$diag$_() {
            const t = this._$_ptsArr$_;
            for (let s = 0, i = t.length; s < i; s += 2) {
                const i = s + 1, e = t[s];
                t[s] = t[i], t[i] = e;
            }
            this._$_isBboxChanged$_ = !0;
        }
        _$GetMidX$_() {
            const t = this._$_ptsArr$_;
            let s = 0;
            for (let i = 0, e = t.length; i < e; i += 2) s += t[i];
            return s / this._$pointCount$_();
        }
        _$GetMidY$_() {
            const t = this._$_ptsArr$_;
            let s = 0;
            for (let i = 0, e = t.length; i < e; i += 2) s += t[i + 1];
            return s / this._$pointCount$_();
        }
        _$GetPointsArray$_() {
            return this._$_ptsArr$_;
        }
        _$GetPointCount$_() {
            return this._$pointCount$_();
        }
        _$IsEnabled$_() {
            return this._$_enabled$_;
        }
    };
}

{
    const wa = self._$C3$_;
    wa._$PairMap$_ = class extends wa._$DefendedBase$_ {
        constructor(t) {
            if (super(), this._$_firstMap$_ = new Map, t) for (const [s, i, e] of t) this.Set(s, i, e);
        }
        _$Release$_() {
            this._$Clear$_(), this._$_firstMap$_ = null;
        }
        _$IsEmpty$_() {
            return 0 === this._$_firstMap$_.size;
        }
        _$Clear$_() {
            const t = this._$_firstMap$_;
            for (const s of t.values()) s.clear();
            t.clear();
        }
        Set(t, s, i) {
            const e = this._$_firstMap$_;
            let n = e.get(t);
            n || (n = new Map, e.set(t, n)), n.set(s, i);
        }
        _$Get$_(t, s) {
            const i = this._$_firstMap$_.get(t);
            return i ? i.get(s) : i;
        }
        _$Has$_(t, s) {
            const i = this._$_firstMap$_.get(t);
            return !!i && i.has(s);
        }
        _$Delete$_(t, s) {
            const i = this._$_firstMap$_, e = i.get(t);
            if (!e) return !1;
            const n = e.delete(s);
            return n && 0 === e.size && i.delete(t), n;
        }
        _$DeleteEither$_(t) {
            const s = this._$_firstMap$_, i = s.get(t);
            i && (i.clear(), s.delete(t));
            for (const [i, e] of s.entries()) e.delete(t) && 0 === e.size && s.delete(i);
        }
        _$GetSize$_() {
            let t = 0;
            for (const s of this._$_firstMap$_.values()) t += s.size;
            return t;
        }
        * values() {
            for (const t of this._$_firstMap$_.values()) yield* t.values();
        }
        * _$keyPairs$_() {
            for (const [t, s] of this._$_firstMap$_.entries()) for (const i of s.keys()) yield [ t, i ];
        }
        * entries() {
            for (const [t, s] of this._$_firstMap$_.entries()) for (const [i, e] of s.entries()) yield [ t, i, e ];
        }
    };
}

{
    const Sa = self._$C3$_;
    Sa._$ArraySet$_ = class extends Sa._$DefendedBase$_ {
        constructor() {
            super(), this._$_set$_ = new Set, this._$_arr$_ = [], this._$_needToRebuildArray$_ = !1;
        }
        _$Release$_() {
            this._$Clear$_();
        }
        _$Clear$_() {
            this._$_set$_.clear(), Sa._$clearArray$_(this._$_arr$_), this._$_needToRebuildArray$_ = !1;
        }
        _$Add$_(t) {
            this._$_set$_.has(t) || (this._$_set$_.add(t), this._$_needToRebuildArray$_ || this._$_arr$_.push(t));
        }
        _$Has$_(t) {
            return this._$_set$_.has(t);
        }
        _$Delete$_(t) {
            this._$_set$_.delete(t) && (this._$_needToRebuildArray$_ = !0);
        }
        _$GetSize$_() {
            return this._$_set$_.size;
        }
        _$IsEmpty$_() {
            return 0 === this._$_set$_.size;
        }
        _$GetArray$_() {
            return this._$_needToRebuildArray$_ && (this._$_RebuildArray$_(), this._$_needToRebuildArray$_ = !1), 
            this._$_arr$_;
        }
        _$_RebuildArray$_() {
            const t = this._$_arr$_;
            Sa._$clearArray$_(t);
            for (const s of this._$_set$_) t.push(s);
        }
    };
}

{
    const ba = self._$C3$_, Ta = new Map, va = new Map, xa = new Map, Ia = new Map, Ga = new Map, Ca = new Map, _a = new Map, Ea = new Map, Da = new Map;
    Da.set("linear", "noease"), Da.set("default", "noease");
    const Aa = [ "default", "noease", "easeinquad", "easeoutquad", "easeinoutquad", "easeincubic", "easeoutcubic", "easeinoutcubic", "easeinquart", "easeoutquart", "easeinoutquart", "easeinquint", "easeoutquint", "easeinoutquint", "easeinsine", "easeoutsine", "easeinoutsine", "easeinexpo", "easeoutexpo", "easeinoutexpo", "easeincirc", "easeoutcirc", "easeinoutcirc", "easeinelastic", "easeoutelastic", "easeinoutelastic", "easeinback", "easeoutback", "easeinoutback", "easeinbounce", "easeoutbounce", "easeinoutbounce" ], Na = [ "default", "noease", "quad", "cubic", "quart", "quint", "sine", "expo", "circ", "elastic", "back", "bounce" ], La = new Map([ [ "linear", "noease" ], [ "in-sine", "easeinsine" ], [ "out-sine", "easeoutsine" ], [ "in-out-sine", "easeinoutsine" ], [ "in-elastic", "easeinelastic" ], [ "out-elastic", "easeoutelastic" ], [ "in-out-elastic", "easeinoutelastic" ], [ "in-back", "easeinback" ], [ "out-back", "easeoutback" ], [ "in-out-back", "easeinoutback" ], [ "in-bounce", "easeinbounce" ], [ "out-bounce", "easeoutbounce" ], [ "in-out-bounce", "easeinoutbounce" ], [ "in-cubic", "easeincubic" ], [ "out-cubic", "easeoutcubic" ], [ "in-out-cubic", "easeinoutcubic" ], [ "in-quadratic", "easeinquad" ], [ "out-quadratic", "easeoutquad" ], [ "in-out-quadratic", "easeinoutquad" ], [ "in-quartic", "easeinquart" ], [ "out-quartic", "easeoutquart" ], [ "in-out-quartic", "easeinoutquart" ], [ "in-quintic", "easeinquint" ], [ "out-quintic", "easeoutquint" ], [ "in-out-quintic", "easeinoutquint" ], [ "in-circular", "easeincirc" ], [ "out-circular", "easeoutcirc" ], [ "in-out-circular", "easeinoutcirc" ], [ "in-exponential", "easeinexpo" ], [ "out-exponential", "easeoutexpo" ], [ "in-out-exponential", "easeinoutexpo" ] ]);
    self._$Ease$_ = class t {
        constructor() {}
        static _$InheritEase$_() {
            return "default";
        }
        static _$DefaultEase$_() {
            return "noease";
        }
        static _$ToInternal$_(t) {
            return La.get(t);
        }
        static _$GetEditorEaseNames$_(s, ...i) {
            let e, n;
            this._$_CreateEaseMap$_(), s ? (xa.has(s) || xa.set(s, new Map), e = xa.get(s), 
            n = [ ...e.keys() ].filter((i => !t._$GetEditorEaseData$_(i, s) || t._$GetEditorEaseData$_(i, s).transition._$IsForAnyPurpose$_()))) : (e = Ga, 
            n = [ ...e.keys() ]);
            const h = n.sort();
            return [ ...va.keys() ].concat(h).filter((t => !i.includes(t)));
        }
        static _$GetRuntimeEaseNames$_() {
            this._$_CreateEaseMap$_();
            const t = [ ...Ga.keys() ];
            return t.sort(), [ ...va.keys() ].concat(t);
        }
        static _$GetCustomRuntimeEaseNames$_() {
            this._$_CreateEaseMap$_();
            const t = [ ...Ga.keys() ];
            return t.sort(), t;
        }
        static _$IsPredefinedTranslatedName$_(t) {
            for (const s of Aa) if (self.lang(`ui.bars.timeline.eases.${s}`) === t) return !0;
            for (const s of Na) if (self.lang(`ui.bars.timeline.short-eases.${s}`) === t) return !0;
        }
        static _$IsNamePredefined$_(t) {
            return this._$_CreateEaseMap$_(), [ ...va.keys() ].includes(t);
        }
        static _$_GetEase$_(s) {
            const i = Da.get(s);
            return i ? Ta.get(i) : t._$IsNamePredefined$_(s) ? Ta.get(s) : _a.has(s) ? _a.get(s) : void 0;
        }
        static _$GetBuiltInTransition$_(t) {
            return this._$_CreateEaseMap$_(), Ea.get(t);
        }
        static _$GetEditorEase$_(s, i) {
            this._$_CreateEaseMap$_();
            const e = t._$_GetEase$_(s);
            if (e) return e;
            if (!i) throw new Error("missing ease function");
            return xa.get(i).get(s);
        }
        static _$GetEditorEaseData$_(t, s) {
            this._$_CreateEaseMap$_();
            const i = Ia.get(s);
            if (i) return i.get(t);
        }
        static _$HasEditorEase$_(s, i) {
            return this._$_CreateEaseMap$_(), !!t._$_GetEase$_(s) || !!xa.get(i).get(s);
        }
        static _$GetRuntimeEase$_(s) {
            this._$_CreateEaseMap$_();
            return t._$_GetEase$_(s) || Ga.get(s);
        }
        static _$GetRuntimeEaseData$_(t) {
            return this._$_CreateEaseMap$_(), Ca.get(t);
        }
        static _$GetEaseFromIndex$_(t) {
            return this._$_CreateEaseMap$_(), this._$GetRuntimeEaseNames$_()[t];
        }
        static _$GetIndexForEase$_(t, s) {
            return this._$_CreateEaseMap$_(), this._$GetEditorEaseNames$_(s).indexOf(t);
        }
        static _$GetIndexForEaseAtRuntime$_(t) {
            return this._$GetIndexForEase$_(t);
        }
        static _$_CreateEaseMap$_() {
            0 === Ta.size && (this._$_AddPredifinedEase$_("default", (() => {})), this._$_AddPredifinedEase$_("noease", [ {
                x: 0,
                y: 0,
                sax: .336,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.336,
                eay: 0,
                se: !1,
                ee: !0
            } ], !0), this._$_AddPredifinedEase$_("easeinsine", [ {
                x: 0,
                y: 0,
                sax: .485,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.038,
                eay: 0,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeoutsine", [ {
                x: 0,
                y: 0,
                sax: .038,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.485,
                eay: 0,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeinoutsine", [ {
                x: 0,
                y: 0,
                sax: .336,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.336,
                eay: 0,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeinelastic", [ {
                x: 0,
                y: 0,
                sax: .018,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .116,
                y: .002,
                sax: .025,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .266,
                y: -.005,
                sax: .024,
                say: 0,
                eax: -.021,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .416,
                y: .016,
                sax: .024,
                say: 0,
                eax: -.026,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .566,
                y: -.045,
                sax: .061,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .716,
                y: .132,
                sax: .072,
                say: -.004,
                eax: -.045,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .866,
                y: -.373,
                sax: .06,
                say: 0,
                eax: -.049,
                eay: -.002,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.038,
                eay: -.263,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeoutelastic", [ {
                x: 0,
                y: 0,
                sax: .038,
                say: .263,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .136,
                y: 1.373,
                sax: .049,
                say: .002,
                eax: -.06,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .286,
                y: .868,
                sax: .045,
                say: 0,
                eax: -.072,
                eay: .004,
                se: !0,
                ee: !0
            }, {
                x: .436,
                y: 1.045,
                sax: .025,
                say: 0,
                eax: -.061,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .586,
                y: .984,
                sax: .026,
                say: 0,
                eax: -.024,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .736,
                y: 1.005,
                sax: .021,
                say: 0,
                eax: -.024,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .886,
                y: .998,
                sax: .025,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.018,
                eay: 0,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeinoutelastic", [ {
                x: 0,
                y: 0,
                sax: .025,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .067,
                y: .001,
                sax: .025,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .18,
                y: -.005,
                sax: .025,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .292,
                y: .025,
                sax: .053,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .405,
                y: -.118,
                sax: .069,
                say: 0,
                eax: -.027,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .597,
                y: 1.118,
                sax: .027,
                say: 0,
                eax: -.069,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .71,
                y: .975,
                sax: .025,
                say: 0,
                eax: -.053,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .822,
                y: 1.005,
                sax: .025,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .935,
                y: .999,
                sax: .025,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeinback", [ {
                x: 0,
                y: 0,
                sax: .35,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.34,
                eay: -1.579,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeoutback", [ {
                x: 0,
                y: 0,
                sax: .34,
                say: 1.579,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.35,
                eay: 0,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeinoutback", [ {
                x: 0,
                y: 0,
                sax: .035,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .242,
                y: -.1,
                sax: .258,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .76,
                y: 1.1,
                sax: .025,
                say: 0,
                eax: -.26,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.035,
                eay: 0,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeinbounce", [ {
                x: 0,
                y: 0,
                sax: .033,
                say: .025,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .092,
                y: 0,
                sax: .026,
                say: .078,
                eax: -.033,
                eay: .025,
                se: !0,
                ee: !0
            }, {
                x: .274,
                y: 0,
                sax: .097,
                say: .319,
                eax: -.026,
                eay: .078,
                se: !0,
                ee: !0
            }, {
                x: .637,
                y: 0,
                sax: .105,
                say: .625,
                eax: -.097,
                eay: .319,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.125,
                eay: -.004,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeoutbounce", [ {
                x: 0,
                y: 0,
                sax: .125,
                say: .004,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .365,
                y: 1,
                sax: .097,
                say: -.319,
                eax: -.105,
                eay: -.625,
                se: !0,
                ee: !0
            }, {
                x: .728,
                y: 1,
                sax: .026,
                say: -.078,
                eax: -.097,
                eay: -.319,
                se: !0,
                ee: !0
            }, {
                x: .91,
                y: 1,
                sax: .033,
                say: -.025,
                eax: -.026,
                eay: -.078,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.033,
                eay: -.025,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeinoutbounce", [ {
                x: 0,
                y: 0,
                sax: .01,
                say: .006,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .046,
                y: 0,
                sax: .021,
                say: .038,
                eax: -.01,
                eay: .006,
                se: !0,
                ee: !0
            }, {
                x: .137,
                y: 0,
                sax: .059,
                say: .158,
                eax: -.021,
                eay: .038,
                se: !0,
                ee: !0
            }, {
                x: .319,
                y: 0,
                sax: .117,
                say: .744,
                eax: -.059,
                eay: .158,
                se: !0,
                ee: !0
            }, {
                x: .683,
                y: 1,
                sax: .059,
                say: -.158,
                eax: -.117,
                eay: -.744,
                se: !0,
                ee: !0
            }, {
                x: .865,
                y: 1,
                sax: .021,
                say: -.038,
                eax: -.059,
                eay: -.158,
                se: !0,
                ee: !0
            }, {
                x: .956,
                y: 1,
                sax: .01,
                say: -.006,
                eax: -.021,
                eay: -.038,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.01,
                eay: -.006,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeincubic", [ {
                x: 0,
                y: 0,
                sax: .75,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.138,
                eay: -.321,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeoutcubic", [ {
                x: 0,
                y: 0,
                sax: .138,
                say: .321,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.75,
                eay: 0,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeinoutcubic", [ {
                x: 0,
                y: 0,
                sax: .285,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .5,
                y: .5,
                sax: .081,
                say: .272,
                eax: -.081,
                eay: -.272,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.285,
                eay: 0,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeinquad", [ {
                x: 0,
                y: 0,
                sax: .4,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.178,
                eay: -.392,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeoutquad", [ {
                x: 0,
                y: 0,
                sax: .178,
                say: .392,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.4,
                eay: 0,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeinoutquad", [ {
                x: 0,
                y: 0,
                sax: .25,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .5,
                y: .5,
                sax: .03,
                say: .065,
                eax: -.03,
                eay: -.065,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.25,
                eay: 0,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeinquart", [ {
                x: 0,
                y: 0,
                sax: .25,
                say: 1,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.5,
                eay: 0,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeoutquart", [ {
                x: 0,
                y: 0,
                sax: .5,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.25,
                eay: -1,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeinoutquart", [ {
                x: 0,
                y: 0,
                sax: .765,
                say: .03,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.765,
                eay: -.03,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeinquint", [ {
                x: 0,
                y: 0,
                sax: .6,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.2,
                eay: -1,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeoutquint", [ {
                x: 0,
                y: 0,
                sax: .2,
                say: 1,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.6,
                eay: 0,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeinoutquint", [ {
                eax: 0,
                eay: 0,
                ee: !1,
                sax: .84,
                say: 0,
                se: !0,
                x: 0,
                y: 0
            }, {
                eax: -.84,
                eay: 0,
                ee: !0,
                sax: 0,
                say: 0,
                se: !1,
                x: 1,
                y: 1
            } ]), this._$_AddPredifinedEase$_("easeincirc", [ {
                x: 0,
                y: 0,
                sax: .25,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.024,
                eay: -.808,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeoutcirc", [ {
                x: 0,
                y: 0,
                sax: .024,
                say: .808,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.25,
                eay: 0,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeinoutcirc", [ {
                x: 0,
                y: 0,
                sax: .125,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .5,
                y: .5,
                sax: .02,
                say: .428,
                eax: -.02,
                eay: -.428,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.125,
                eay: 0,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeinexpo", [ {
                x: 0,
                y: 0,
                sax: .66,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.14,
                eay: -1,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeoutexpo", [ {
                x: 0,
                y: 0,
                sax: .14,
                say: 1,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.66,
                eay: 0,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeinoutexpo", [ {
                eax: 0,
                eay: 0,
                ee: !1,
                sax: .345,
                say: 0,
                se: !0,
                x: 0,
                y: 0
            }, {
                eax: -.06,
                eay: -.5,
                ee: !0,
                sax: .06,
                say: .5,
                se: !0,
                x: .5,
                y: .5
            }, {
                eax: -.335,
                eay: 0,
                ee: !0,
                sax: 0,
                say: 0,
                se: !1,
                x: 1,
                y: 1
            } ]), this._$_AddPrivateCustomEase$_("cubicbezier", this._$EaseCubicBezier$_), this._$_AddPrivateCustomEase$_("spline", this._$EaseSpline$_));
        }
        static _$_AddPredifinedEase$_(s, i, e = !1) {
            if ("function" == typeof i) t._$_AddEase$_(s, i, "predefined"); else {
                if (!ba._$IsArray$_(i)) throw new Error("unexpected arguments");
                if (self._$BuiltInTransition$_) {
                    const n = ba._$New$_(self._$BuiltInTransition$_, s, e);
                    n._$SetFromJson$_(i), t._$_AddEase$_(s, ((t, s, i, e) => n._$Interpolate$_(t, s, i, e)), "predefined"), 
                    Ea.set(s, n);
                } else {
                    const n = ba._$New$_(ba._$Transition$_, [ s, i.map((t => [ t.x, t.y, t.sax, t.say, t.eax, t.eay, t.se, t.ee ])) ], !1);
                    n._$MakeLinear$_(e), t._$_AddEase$_(s, ((t, s, i, e) => n._$Interpolate$_(t, s, i, e)), "predefined");
                }
            }
        }
        static _$_AddPrivateCustomEase$_(s, i) {
            t._$_AddEase$_(s, i, "private");
        }
        static _$AddCustomEase$_(s, i, e, n) {
            this._$_CreateEaseMap$_(), t._$_AddEase$_(s, i, "custom", e, n);
        }
        static _$RemoveCustomEase$_(t, s) {
            if (this._$IsNamePredefined$_(t)) return;
            if ([ ..._a.keys() ].includes(t)) return;
            const i = xa.get(s);
            i && i.delete(t);
            const e = Ia.get(s);
            e && e.delete(t);
        }
        static _$_AddEase$_(t, s, i, e, n) {
            switch (i) {
              case "predefined":
                Ta.set(t, s), va.set(t, s);
                break;

              case "custom":
                e ? (xa.has(e) || xa.set(e, new Map), Ia.has(e) || Ia.set(e, new Map), xa.get(e).set(t, s), 
                Ia.get(e).set(t, n)) : (Ga.set(t, s), Ca.set(t, n));
                break;

              case "private":
                Ta.set(t, s), _a.set(t, s);
                break;

              default:
                throw new Error("unexpected ease mode");
            }
        }
        static _$NoEase$_(t, s, i, e) {
            return 0 === e ? s : i * t / e + s;
        }
        static _$EaseCubicBezier$_(t, s, i, e, n) {
            return s + 3 * t * (i - s) + 3 * t ** 2 * (s + e - 2 * i) + t ** 3 * (n - s + 3 * i - 3 * e);
        }
        static _$EaseSpline$_(t, s, i, e, n, h, r, o, a, u) {
            if (e === n && h === r) return t;
            const l = za(t, s, e, h, o, u), c = Pa(i, n, r, a), f = ka(i, n, r, a), d = Fa(i, n, r, a);
            return ja(l, c, f, d);
        }
        static _$GetBezierSamples$_(t, s, i, e) {
            const n = [], h = Pa(t, s, i, e), r = ka(t, s, i, e), o = Fa(t, s, i, e);
            for (let t = 0; t < Oa; ++t) {
                const s = ja(t * Ra, h, r, o);
                n.push(s);
            }
            return n;
        }
    };
    const Oa = 11, Ra = 1 / (Oa - 1), Pa = (t, s, i, e) => e - 3 * i + 3 * s - t, ka = (t, s, i, e) => 3 * i - 6 * s + 3 * t, Fa = (t, s, i, e) => 3 * (s - t), ja = (t, s, i, e) => ((s * t + i) * t + e) * t, Ba = (t, s, i, e) => 3 * s * t * t + 2 * i * t + e, za = (t, s, i, e, n, h) => {
        if (1 == t) return 1;
        let r = 0, o = 1, a = h[o], u = Oa - 1;
        for (h[Oa - 1]; o != u && a <= t; ) o++, a = h[o], r += Ra;
        o--, a = h[o];
        let l = r + (t - a) / (h[o + 1] - a) * Ra;
        const c = Pa(s, i, e, n), f = ka(s, i, e, n), d = Fa(s, i, e, n), p = Ba(l, c, f, d);
        if (0 === p) return l;
        if (p >= .01) {
            for (let s = 0; s < 4; ++s) l -= (ja(l, c, f, d) - t) / Ba(l, c, f, d);
            return l;
        }
        {
            let s, i, e = r, n = r + Ra, h = 0;
            do {
                l = e + (n - e) / 2;
                let r = ja(l, c, f, d) - t;
                r > 0 ? n = l : e = l, s = Math.abs(r) > 1e-7, i = ++h < 10;
            } while (s && i);
            return l;
        }
    };
}

{
    let Ua = function(t) {
        Wa._$IsString$_(t);
    };
    0;
    const Wa = self._$C3$_;
    Wa._$ProbabilityTable$_ = class {
        constructor(t) {
            this._$_items$_ = [], this._$_name$_ = t || "", this._$_totalWeight$_ = 0;
        }
        _$Release$_() {
            this._$Clear$_(), this._$_items$_ = null;
        }
        _$GetName$_() {
            return this._$_name$_;
        }
        _$Clear$_() {
            Wa._$clear2DArray$_(this._$_items$_), this._$_totalWeight$_ = 0;
        }
        _$GetTotalWeight$_() {
            return this._$_totalWeight$_;
        }
        _$Sample$_(t = Math.random() * this._$GetTotalWeight$_()) {
            let s = 0;
            for (const [i, e] of this._$_items$_) if (s += i, t < s) return e;
            return 0;
        }
        _$HasItems$_() {
            return !!this._$_items$_.length;
        }
        _$AddItem$_(t, s) {
            Ua(s), this._$_totalWeight$_ += t, this._$_items$_.push([ t, s ]);
        }
        _$RemoveItem$_(t, s) {
            Ua(s);
            const i = 0 === t;
            for (let e = 0; e < this._$_items$_.length; e++) {
                const n = this._$_items$_[e], h = i || n[0] === t, r = n[1] === s;
                if (h && r) {
                    this._$_items$_.splice(e, 1), this._$_totalWeight$_ -= n[0];
                    break;
                }
            }
        }
        _$asJSON$_() {
            return JSON.stringify(this._$_items$_);
        }
        static _$fromJSON$_(t, s) {
            const i = new Wa._$ProbabilityTable$_(s), e = JSON.parse(t);
            for (const t of e) {
                const s = t[0], e = t[1];
                i._$AddItem$_(s, e);
            }
            return i;
        }
    };
}

{
    const Ja = self._$C3$_;
    let Qa = 0;
    Ja._$ScreenReaderText$_ = class {
        constructor(t, s) {
            this._$_runtime$_ = t, this._$_text$_ = s, this._$_id$_ = Qa++, this._$_runtime$_._$PostComponentMessageToDOM$_("runtime", "screen-reader-text", {
                type: "create",
                id: this._$_id$_,
                text: this._$_text$_
            });
        }
        _$Release$_() {
            this._$_runtime$_._$PostComponentMessageToDOM$_("runtime", "screen-reader-text", {
                type: "release",
                id: this._$_id$_
            }), this._$_runtime$_ = null, this._$_text$_ = "", this._$_id$_ = -1;
        }
        _$SetText$_(t) {
            this._$_text$_ !== t && (this._$_text$_ = t, this._$_runtime$_._$PostComponentMessageToDOM$_("runtime", "screen-reader-text", {
                type: "update",
                id: this._$_id$_,
                text: this._$_text$_
            }));
        }
    };
}

self._$C3$_.Event = class {
    constructor(t, s) {
        this.type = t, this.cancelable = !!s, this.defaultPrevented = !1, this._$propagationStopped$_ = !1, 
        this._$isAsync$_ = !1;
    }
    preventDefault() {
        if (!this.cancelable) throw new Error(`event '${this.type}' is not cancelable`);
        this.defaultPrevented = !0;
    }
    stopPropagation() {
        if (!this.cancelable) throw new Error(`event '${this.type}' cannot be stopped`);
        if (this._$isAsync$_) throw new Error(`cannot stop async event '${this.type}' propagation`);
        this._$propagationStopped$_ = !0;
    }
};

{
    const Ya = self._$C3$_;
    self.assert;
    Ya.Event._$Handler$_ = class extends Ya._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_type$_ = t, this._$_captureListeners$_ = [], this._$_captureListenersSet$_ = new Set, 
            this._$_listeners$_ = [], this._$_listenersSet$_ = new Set, this._$_fireDepth$_ = 0, 
            this._$_queueModifyListeners$_ = [];
        }
        _$Release$_() {
            this._$_fireDepth$_ > 0 || (Ya._$clearArray$_(this._$_captureListeners$_), this._$_captureListenersSet$_.clear(), 
            Ya._$clearArray$_(this._$_listeners$_), this._$_listenersSet$_.clear(), Ya._$clearArray$_(this._$_queueModifyListeners$_), 
            Ya._$Release$_(this));
        }
        _$_AddListener$_(t, s) {
            if (this._$_IsFiring$_()) this._$_queueModifyListeners$_.push({
                _$op$_: "add",
                _$func$_: t,
                capture: s
            }); else if (s) {
                if (this._$_captureListenersSet$_.has(t)) return;
                this._$_captureListeners$_.push(t), this._$_captureListenersSet$_.add(t);
            } else {
                if (this._$_listenersSet$_.has(t)) return;
                this._$_listeners$_.push(t), this._$_listenersSet$_.add(t);
            }
        }
        _$_RemoveListener$_(t, s) {
            this._$_IsFiring$_() ? this._$_queueModifyListeners$_.push({
                _$op$_: "remove",
                _$func$_: t,
                capture: s
            }) : s ? this._$_captureListenersSet$_.has(t) && (this._$_captureListenersSet$_.delete(t), 
            Ya._$arrayFindRemove$_(this._$_captureListeners$_, t)) : this._$_listenersSet$_.has(t) && (this._$_listenersSet$_.delete(t), 
            Ya._$arrayFindRemove$_(this._$_listeners$_, t));
        }
        _$_IsEmpty$_() {
            return !this._$_captureListeners$_.length && !this._$_listeners$_.length;
        }
        _$_IsFiring$_() {
            return this._$_fireDepth$_ > 0;
        }
        _$_ProcessQueuedListeners$_() {
            const t = new Set, s = new Set;
            for (const i of this._$_queueModifyListeners$_) if ("add" === i._$op$_) this._$_AddListener$_(i._$func$_, i.capture), 
            i.capture ? s.delete(i._$func$_) : t.delete(i._$func$_); else {
                if ("remove" !== i._$op$_) throw new Error("invalid op");
                i.capture ? (this._$_captureListenersSet$_.delete(i._$func$_), s.add(i._$func$_)) : (this._$_listenersSet$_.delete(i._$func$_), 
                t.add(i._$func$_));
            }
            Ya._$arrayRemoveAllInSet$_(this._$_listeners$_, t), Ya._$arrayRemoveAllInSet$_(this._$_captureListeners$_, s), 
            Ya._$clearArray$_(this._$_queueModifyListeners$_);
        }
        _$_FireCancellable$_(t) {
            this._$_IncreaseFireDepth$_();
            let s = !1;
            for (let i = 0, e = this._$_captureListeners$_.length; i < e; ++i) if (this._$_captureListeners$_[i](t), 
            t._$propagationStopped$_) {
                s = !0;
                break;
            }
            if (!s) for (let s = 0, i = this._$_listeners$_.length; s < i && (this._$_listeners$_[s](t), 
            !t._$propagationStopped$_); ++s) ;
            return this._$_DecreaseFireDepth$_(), !t.defaultPrevented;
        }
        _$_FireNonCancellable$_(t) {
            this._$_IncreaseFireDepth$_();
            for (let s = 0, i = this._$_captureListeners$_.length; s < i; ++s) this._$_captureListeners$_[s](t);
            for (let s = 0, i = this._$_listeners$_.length; s < i; ++s) this._$_listeners$_[s](t);
            return this._$_DecreaseFireDepth$_(), !0;
        }
        _$_IncreaseFireDepth$_() {
            this._$_fireDepth$_++;
        }
        _$_DecreaseFireDepth$_() {
            this._$_fireDepth$_--, 0 === this._$_fireDepth$_ && this._$_queueModifyListeners$_.length > 0 && this._$_ProcessQueuedListeners$_();
        }
        _$SetDelayRemoveEventsEnabled$_(t) {
            t ? this._$_IncreaseFireDepth$_() : this._$_DecreaseFireDepth$_();
        }
        _$_FireAsync$_(t) {
            let s = [];
            for (let i = 0, e = this._$_captureListeners$_.length; i < e; ++i) {
                let e = this._$_captureListeners$_[i];
                s.push(Ya._$Asyncify$_((() => e(t))));
            }
            for (let i = 0, e = this._$_listeners$_.length; i < e; ++i) {
                let e = this._$_listeners$_[i];
                s.push(Ya._$Asyncify$_((() => e(t))));
            }
            return Promise.all(s).then((() => !t.defaultPrevented));
        }
        _$_FireAndWait_AsyncOptional$_(t) {
            const s = [];
            this._$_IncreaseFireDepth$_();
            for (let i = 0, e = this._$_captureListeners$_.length; i < e; ++i) {
                const e = this._$_captureListeners$_[i](t);
                e instanceof Promise && s.push(e);
            }
            for (let i = 0, e = this._$_listeners$_.length; i < e; ++i) {
                const e = this._$_listeners$_[i](t);
                e instanceof Promise && s.push(e);
            }
            return this._$_DecreaseFireDepth$_(), s.length ? Promise.all(s).then((() => !t.defaultPrevented)) : !t.defaultPrevented;
        }
        async _$_FireAndWaitAsync$_(t) {
            return await this._$_FireAndWait_AsyncOptional$_(t);
        }
        async _$_FireAndWaitAsyncSequential$_(t) {
            this._$_IncreaseFireDepth$_();
            for (let s = 0, i = this._$_captureListeners$_.length; s < i; ++s) {
                const i = this._$_captureListeners$_[s](t);
                i instanceof Promise && await i;
            }
            for (let s = 0, i = this._$_listeners$_.length; s < i; ++s) {
                const i = this._$_listeners$_[s](t);
                i instanceof Promise && await i;
            }
            return this._$_DecreaseFireDepth$_(), !t.defaultPrevented;
        }
        * _$_FireAsGenerator$_(t) {
            this._$_IncreaseFireDepth$_();
            for (let s = 0, i = this._$_captureListeners$_.length; s < i; ++s) {
                const i = this._$_captureListeners$_[s](t);
                Ya._$IsIterator$_(i) && (yield* i);
            }
            for (let s = 0, i = this._$_listeners$_.length; s < i; ++s) {
                const i = this._$_listeners$_[s](t);
                Ya._$IsIterator$_(i) && (yield* i);
            }
            this._$_DecreaseFireDepth$_();
        }
    };
}

{
    const Va = self._$C3$_;
    Va.Event._$Dispatcher$_ = class extends Va._$DefendedBase$_ {
        constructor() {
            super(), this._$_eventHandlers$_ = new Map, this._$_dispatcherWasReleased$_ = !1;
        }
        _$Release$_() {
            if (this._$_dispatcherWasReleased$_) throw new Error("already released");
            this._$ClearEvents$_(), this._$_dispatcherWasReleased$_ = !0, Va._$Release$_(this);
        }
        _$WasReleased$_() {
            return this._$_dispatcherWasReleased$_;
        }
        _$ClearEvents$_() {
            if (this._$_eventHandlers$_) {
                for (let t of this._$_eventHandlers$_.values()) t._$Release$_();
                this._$_eventHandlers$_.clear();
            }
        }
        _$_GetHandlerByType$_(t, s) {
            let i = this._$_eventHandlers$_.get(t);
            return i || (s ? (i = Va._$New$_(Va.Event._$Handler$_, t), this._$_eventHandlers$_.set(t, i), 
            i) : null);
        }
        _$HasAnyHandlerFor$_(t) {
            return this._$_eventHandlers$_.has(t);
        }
        addEventListener(t, s, i) {
            this._$_GetHandlerByType$_(t, !0)._$_AddListener$_(s, !!i);
        }
        removeEventListener(t, s, i) {
            let e = this._$_GetHandlerByType$_(t, !1);
            e && (e._$_RemoveListener$_(s, !!i), e._$_IsEmpty$_() && this._$_eventHandlers$_.delete(t));
        }
        dispatchEvent(t) {
            const s = this._$_GetHandlerByType$_(t.type, !1);
            return !s || (t.cancelable ? s._$_FireCancellable$_(t) : s._$_FireNonCancellable$_(t));
        }
        _$dispatchEventAsync$_(t) {
            const s = this._$_GetHandlerByType$_(t.type, !1);
            return s ? (t._$isAsync$_ = !0, s._$_FireAsync$_(t)) : Promise.resolve(!0);
        }
        async _$dispatchEventAndClearAsync$_(t) {
            const s = this._$_GetHandlerByType$_(t.type, !1);
            if (!s) return !0;
            this._$_eventHandlers$_.delete(t.type), t._$isAsync$_ = !0;
            const i = await s._$_FireAsync$_(t);
            return s._$Release$_(), i;
        }
        async _$dispatchEventAndWaitAsync$_(t) {
            const s = this._$_GetHandlerByType$_(t.type, !1);
            return !s || await s._$_FireAndWaitAsync$_(t);
        }
        _$dispatchEventAndWait_AsyncOptional$_(t) {
            const s = this._$_GetHandlerByType$_(t.type, !1);
            return !s || s._$_FireAndWait_AsyncOptional$_(t);
        }
        async _$dispatchEventAndWaitAsyncSequential$_(t) {
            const s = this._$_GetHandlerByType$_(t.type, !1);
            return !s || await s._$_FireAndWaitAsyncSequential$_(t);
        }
        _$dispatchGeneratorEvent$_(t) {
            const s = this._$_GetHandlerByType$_(t.type, !1);
            if (!s) return null;
            if (t.cancelable) throw new Error("not supported");
            return s._$_FireAsGenerator$_(t);
        }
        _$SetDelayRemoveEventsEnabled$_(t) {
            for (const s of this._$_eventHandlers$_.values()) s._$SetDelayRemoveEventsEnabled$_(t);
        }
    };
}

{
    let Ha = function(t) {
        tu = Ka && 0 === su ? requestIdleCallback(qa, {
            timeout: 35
        }) : setTimeout(qa, su > 0 ? 1 : t);
    }, qa = function(t) {
        if (tu = -1, !$a.length) return;
        let s = performance.now(), i = s, e = 0, n = 0;
        do {
            Xa($a.shift()), i = performance.now(), ++e, n = (i - s) / e * 1.1;
        } while ($a.length && (Ka && 0 === su && void 0 !== t ? n < t.timeRemaining() : i - s + n < 12));
        if (-1 === tu && $a.length) {
            let t = i - s;
            Ha(Math.max(16 - t, 4));
        }
    }, Xa = function(t) {
        let s;
        try {
            s = t._$func$_();
        } catch (s) {
            return void t.reject(s);
        }
        t.resolve(s);
    };
    0;
    const Za = self._$C3$_, Ka = "undefined" != typeof requestIdleCallback;
    let $a = [], tu = -1, su = 0, iu = Za._$QueryString$_._$Has$_("disable-asyncify");
    iu && console.warn("[Asyncify] Asyncify has been disabled due to disable-asyncify in the query string. Some work will now be done synchronously."), 
    Za._$Asyncify$_ = function(t) {
        let s = null;
        return Za._$isDebug$_ && (s = Za._$GetCallStack$_()), new Promise(((i, e) => {
            $a.push({
                _$func$_: t,
                resolve: i,
                reject: e,
                stack: s
            }), iu ? Xa($a.pop()) : -1 === tu && Ha(16);
        }));
    }, Za._$Asyncify$_._$SetHighThroughputMode$_ = function(t) {
        if (t) ++su; else if (--su, su < 0) throw new Error("already turned off high throughput mode");
    };
}

{
    let eu = function() {
        ru = -1;
    }, nu = function() {
        ou = -1, au = -1;
        let t = Date.now();
        for (let s of uu) if (s._$_CheckTimeout$_(t)) {
            let t = s._$_GetDeadline$_();
            (-1 === au || t < au) && (au = t);
        } else uu.delete(s);
        if (-1 !== au) {
            let s = Math.max(au - t + 100, 1e3);
            ou = self.setTimeout(nu, s);
        }
    };
    0;
    const hu = self._$C3$_;
    let ru = -1;
    hu._$FastGetDateNow$_ = function() {
        return -1 === ru && (ru = Date.now(), self.setTimeout(eu, 16)), ru;
    };
    let ou = -1, au = -1, uu = new Set;
    hu._$IdleTimeout$_ = class {
        constructor(t, s) {
            this._$_callback$_ = t, this._$_timeout$_ = 1e3 * s, this._$_deadline$_ = 0, this._$_isActive$_ = !1;
        }
        _$Reset$_() {
            let t = hu._$FastGetDateNow$_();
            this._$_deadline$_ = t + this._$_timeout$_, this._$_isActive$_ || (uu.add(this), 
            this._$_isActive$_ = !0), -1 === ou ? (au = this._$_deadline$_, ou = self.setTimeout(nu, this._$_timeout$_ + 100)) : this._$_deadline$_ < au && au > t + 1e3 && (self.clearTimeout(ou), 
            au = this._$_deadline$_, ou = self.setTimeout(nu, this._$_timeout$_ + 100));
        }
        _$_CheckTimeout$_(t) {
            return !(t >= this._$_deadline$_ && (this._$_callback$_() ? (this._$_deadline$_ = t + this._$_timeout$_, 
            0) : (this._$_isActive$_ = !1, 1)));
        }
        _$_GetDeadline$_() {
            return this._$_deadline$_;
        }
        _$Cancel$_() {
            this._$_isActive$_ && (uu.delete(this), this._$_isActive$_ = !1, 0 === uu.size && -1 !== ou && (self.clearTimeout(ou), 
            ou = -1, au = -1));
        }
        _$Release$_() {
            this._$Cancel$_(), this._$_callback$_ = null;
        }
    };
}

{
    const lu = self._$C3$_;
    lu._$Disposable$_ = class t {
        constructor(t) {
            this._$_disposed$_ = !1, this._$_disposeAction$_ = t;
        }
        _$Dispose$_() {
            this._$_disposed$_ || (this._$_disposed$_ = !0, this._$_disposeAction$_ && (this._$_disposeAction$_(), 
            this._$_disposeAction$_ = null));
        }
        _$IsDisposed$_() {
            return this._$_disposed$_;
        }
        _$Release$_() {
            this._$Dispose$_();
        }
        static _$Release$_(s) {
            return new t((() => s._$Release$_()));
        }
        static _$From$_(t, s, i, e, n) {
            if (null == e) e = !1; else if ("boolean" != typeof e && "object" != typeof e) throw new TypeError("invalid event listener options");
            if (n && (i = i.bind(n)), s.includes(" ")) {
                s = s.split(" ");
                const n = new lu._$CompositeDisposable$_;
                for (let h of s) t.addEventListener(h, i, e), n._$Add$_(lu._$New$_(lu._$Disposable$_, (() => t.removeEventListener(h, i, e))));
                return n;
            }
            return t.addEventListener(s, i, e), lu._$New$_(lu._$Disposable$_, (() => t.removeEventListener(s, i, e)));
        }
    }, lu._$StubDisposable$_ = class extends lu._$Disposable$_ {
        _$SetAction$_(t) {
            this._$_disposeAction$_ = t;
        }
    }, lu._$CompositeDisposable$_ = class extends lu._$Disposable$_ {
        constructor(...t) {
            super(), this._$_disposables$_ = new Set;
            for (let s of t) this._$Add$_(s);
        }
        _$Add$_(...t) {
            if (this._$_disposed$_) throw new Error("already disposed");
            for (let s of t) this._$_disposables$_.add(s);
        }
        _$Remove$_(t) {
            if (this._$_disposed$_) throw new Error("already disposed");
            this._$_disposables$_.delete(t);
        }
        _$RemoveAll$_() {
            if (this._$_disposed$_) throw new Error("already disposed");
            if (this._$_disposables$_) {
                for (let t of this._$_disposables$_) t._$Dispose$_();
                this._$_disposables$_.clear();
            }
        }
        _$IsDisposed$_() {
            return this._$_disposed$_;
        }
        _$Dispose$_() {
            if (this._$_disposed$_) throw new Error("already disposed");
            this._$_disposed$_ = !0;
            for (let t of this._$_disposables$_) t._$Dispose$_();
            this._$_disposables$_.clear(), this._$_disposables$_ = null;
        }
        _$Release$_() {
            this._$Dispose$_();
        }
    };
}

{
    const cu = self._$C3$_;
    cu._$KahanSum$_ = class extends cu._$DefendedBase$_ {
        constructor() {
            super(), this._$_c$_ = 0, this._$_y$_ = 0, this._$_t$_ = 0, this._$_sum$_ = 0;
        }
        _$Add$_(t) {
            t = +t, this._$_y$_ = t - this._$_c$_, this._$_t$_ = this._$_sum$_ + this._$_y$_, 
            this._$_c$_ = this._$_t$_ - this._$_sum$_ - this._$_y$_, this._$_sum$_ = this._$_t$_;
        }
        _$Subtract$_(t) {
            this._$_sum$_ -= +t;
        }
        _$Get$_() {
            return this._$_sum$_;
        }
        _$Reset$_() {
            this._$_c$_ = 0, this._$_y$_ = 0, this._$_t$_ = 0, this._$_sum$_ = 0;
        }
        Set(t) {
            this._$_c$_ = 0, this._$_y$_ = 0, this._$_t$_ = 0, this._$_sum$_ = +t;
        }
        _$Copy$_(t) {
            this._$_c$_ = t._$_c$_, this._$_y$_ = t._$_y$_, this._$_t$_ = t._$_t$_, this._$_sum$_ = t._$_sum$_;
        }
        _$Release$_() {}
    };
}

{
    const fu = self._$C3$_, du = {}, pu = !0;
    du._$RBnode$_ = function(t) {
        this._$tree$_ = t, this.right = this._$tree$_._$sentinel$_, this.left = this._$tree$_._$sentinel$_, 
        this.parent = null, this.color = !1, this.key = null;
    }, du._$RedBlackSet$_ = function(t) {
        this.size = 0, this._$sentinel$_ = new du._$RBnode$_(this), this._$sentinel$_.color = !1, 
        this.root = this._$sentinel$_, this.root.parent = this._$sentinel$_, this.compare = t || this._$default_compare$_;
    }, du._$RedBlackSet$_.prototype._$default_compare$_ = function(t, s) {
        return t < s ? -1 : s < t ? 1 : 0;
    }, du._$RedBlackSet$_.prototype.clone = function() {
        var t = new du._$RedBlackSet$_(this.compare);
        return t._$insertAll$_(this), t;
    }, du._$RedBlackSet$_.prototype.clear = function() {
        this.size = 0, this._$sentinel$_ = new du._$RBnode$_(this), this._$sentinel$_.color = !1, 
        this.root = this._$sentinel$_, this.root.parent = this._$sentinel$_;
    }, du._$RedBlackSet$_.prototype._$leftRotate$_ = function(t) {
        var s = t.right;
        t.right = s.left, s.left != this._$sentinel$_ && (s.left.parent = t), s.parent = t.parent, 
        t.parent == this._$sentinel$_ ? this.root = s : t == t.parent.left ? t.parent.left = s : t.parent.right = s, 
        s.left = t, t.parent = s;
    }, du._$RedBlackSet$_.prototype._$rightRotate$_ = function(t) {
        var s = t.left;
        t.left = s.right, s.right != this._$sentinel$_ && (s.right.parent = t), s.parent = t.parent, 
        t.parent == this._$sentinel$_ ? this.root = s : t == t.parent.right ? t.parent.right = s : t.parent.left = s, 
        s.right = t, t.parent = s;
    }, du._$RedBlackSet$_.prototype._$insert$_ = function(t) {
        if (this.contains(t)) this._$get_$_(t).key = t; else {
            var s = new du._$RBnode$_(this);
            s.key = t;
            for (var i = this._$sentinel$_, e = this.root; e != this._$sentinel$_; ) i = e, 
            e = this.compare(s.key, e.key) < 0 ? e.left : e.right;
            s.parent = i, i == this._$sentinel$_ ? this.root = s : this.compare(s.key, i.key) < 0 ? i.left = s : i.right = s, 
            s.left = this._$sentinel$_, s.right = this._$sentinel$_, s.color = pu, this._$insertFixup$_(s), 
            this.size++;
        }
    }, du._$RedBlackSet$_.prototype._$insertFixup$_ = function(t) {
        for (;t != this._$sentinel$_ && t != this.root && t.parent.color == pu; ) {
            var s;
            t.parent == t.parent.parent.left ? (s = t.parent.parent.right).color == pu ? (t.parent.color = !1, 
            s.color = !1, t.parent.parent.color = pu, t = t.parent.parent) : (t == t.parent.right && (t = t.parent, 
            this._$leftRotate$_(t)), t.parent.color = !1, t.parent.parent.color = pu, t.parent.parent != this._$sentinel$_ && this._$rightRotate$_(t.parent.parent)) : (s = t.parent.parent.left).color == pu ? (t.parent.color = !1, 
            s.color = !1, t.parent.parent.color = pu, t = t.parent.parent) : (t == t.parent.left && (t = t.parent, 
            this._$rightRotate$_(t)), t.parent.color = !1, t.parent.parent.color = pu, t.parent.parent != this._$sentinel$_ && this._$leftRotate$_(t.parent.parent));
        }
        this.root.color = !1;
    }, du._$RedBlackSet$_.prototype._$delete_$_ = function(t) {
        var s, i;
        (i = (s = t.left == this._$sentinel$_ || t.right == this._$sentinel$_ ? t : this._$successor_$_(t)).left != this._$sentinel$_ ? s.left : s.right).parent = s.parent, 
        s.parent == this._$sentinel$_ ? this.root = i : s == s.parent.left ? s.parent.left = i : s.parent.right = i, 
        s != t && (t.key = s.key), 0 == s.color && this._$deleteFixup$_(i), this.size--;
    }, du._$RedBlackSet$_.prototype._$deleteFixup$_ = function(t) {
        for (;t != this.root && 0 == t.color; ) {
            var s;
            t == t.parent.left ? ((s = t.parent.right).color == pu && (s.color = !1, t.parent.color = pu, 
            this._$leftRotate$_(t.parent), s = t.parent.right), 0 == s.left.color && 0 == s.right.color ? (s.color = pu, 
            t = t.parent) : (0 == s.right.color && (s.left.color = !1, s.color = pu, this._$rightRotate$_(s), 
            s = t.parent.right), s.color = t.parent.color, t.parent.color = !1, s.right.color = !1, 
            this._$leftRotate$_(t.parent), t = this.root)) : ((s = t.parent.left).color == pu && (s.color = !1, 
            t.parent.color = pu, this._$rightRotate$_(t.parent), s = t.parent.left), 0 == s.right.color && 0 == s.left.color ? (s.color = pu, 
            t = t.parent) : (0 == s.left.color && (s.right.color = !1, s.color = pu, this._$leftRotate$_(s), 
            s = t.parent.left), s.color = t.parent.color, t.parent.color = !1, s.left.color = !1, 
            this._$rightRotate$_(t.parent), t = this.root));
        }
        t.color = !1;
    }, du._$RedBlackSet$_.prototype.remove = function(t) {
        var s = this._$get_$_(t);
        if (s != this._$sentinel$_) {
            var i = s.key;
            return this._$delete_$_(s), i;
        }
        return null;
    }, du._$RedBlackSet$_.prototype._$removeSwapped$_ = function(t, s) {
        this.remove(s);
    }, du._$RedBlackSet$_.prototype.min = function(t) {
        for (;t.left != this._$sentinel$_; ) t = t.left;
        return t;
    }, du._$RedBlackSet$_.prototype.max = function(t) {
        for (;t.right != this._$sentinel$_; ) t = t.right;
        return t;
    }, du._$RedBlackSet$_.prototype._$successor_$_ = function(t) {
        if (t.right != this._$sentinel$_) return this.min(t.right);
        for (var s = t.parent; s != this._$sentinel$_ && t == s.right; ) t = s, s = s.parent;
        return s;
    }, du._$RedBlackSet$_.prototype._$predeccessor_$_ = function(t) {
        if (t.left != this._$sentinel$_) return this.max(t.left);
        for (var s = t.parent; s != this._$sentinel$_ && t == s.left; ) t = s, s = s.parent;
        return s;
    }, du._$RedBlackSet$_.prototype._$successor$_ = function(t) {
        if (this.size > 0) {
            var s = this._$get_$_(t);
            if (s == this._$sentinel$_) return null;
            if (s.right != this._$sentinel$_) return this.min(s.right).key;
            for (var i = s.parent; i != this._$sentinel$_ && s == i.right; ) s = i, i = i.parent;
            return i != this._$sentinel$_ ? i.key : null;
        }
        return null;
    }, du._$RedBlackSet$_.prototype._$predecessor$_ = function(t) {
        if (this.size > 0) {
            var s = this._$get_$_(t);
            if (s == this._$sentinel$_) return null;
            if (s.left != this._$sentinel$_) return this.max(s.left).key;
            for (var i = s.parent; i != this._$sentinel$_ && s == i.left; ) s = i, i = i.parent;
            return i != this._$sentinel$_ ? i.key : null;
        }
        return null;
    }, du._$RedBlackSet$_.prototype._$getMin$_ = function() {
        return this.min(this.root).key;
    }, du._$RedBlackSet$_.prototype._$getMax$_ = function() {
        return this.max(this.root).key;
    }, du._$RedBlackSet$_.prototype._$get_$_ = function(t) {
        for (var s = this.root; s != this._$sentinel$_ && 0 != this.compare(s.key, t); ) s = this.compare(t, s.key) < 0 ? s.left : s.right;
        return s;
    }, du._$RedBlackSet$_.prototype.contains = function(t) {
        return null != this._$get_$_(t).key;
    }, du._$RedBlackSet$_.prototype.getValues = function() {
        var t = [];
        return this.forEach((function(s) {
            t.push(s);
        })), t;
    }, du._$RedBlackSet$_.prototype._$insertAll$_ = function(t) {
        if ("array" == du._$typeOf$_(t)) for (var s = 0; s < t.length; s++) this._$insert$_(t[s]); else if ("function" == du._$typeOf$_(t.forEach)) t.forEach(this._$insert$_, this); else if ("function" == du._$typeOf$_(t.getValues)) {
            var i = t.getValues();
            for (s = 0; s < i.length; s++) this._$insert$_(i[s]);
        } else if ("object" == du._$typeOf$_(t)) for (var e in t) this._$insert$_(t[e]);
    }, du._$RedBlackSet$_.prototype._$removeAll$_ = function(t) {
        if ("array" == du._$typeOf$_(t)) for (var s = 0; s < t.length; s++) this.remove(t[s]); else if ("function" == du._$typeOf$_(t.forEach)) t.forEach(this._$removeSwapped$_, this); else if ("function" == du._$typeOf$_(t.getValues)) {
            var i = t.getValues();
            for (s = 0; s < i.length; s++) this.remove(i[s]);
        } else if ("object" == du._$typeOf$_(t)) for (var e in t) this.remove(t[e]);
    }, du._$RedBlackSet$_.prototype._$containsAll$_ = function(t) {
        if ("array" == du._$typeOf$_(t)) {
            for (var s = 0; s < t.length; s++) if (!this.contains(t[s])) return !1;
            return !0;
        }
        if ("function" == du._$typeOf$_(t.forEach)) return t.every(this.contains, this);
        if ("function" == du._$typeOf$_(t.getValues)) {
            var i = t.getValues();
            for (s = 0; s < i.length; s++) if (!this.contains(i[s])) return !1;
            return !0;
        }
        if ("object" == du._$typeOf$_(t)) {
            for (var e in t) if (!this.contains(t[e])) return !1;
            return !0;
        }
    }, du._$RedBlackSet$_.prototype.range = function(t, s) {
        var i = [];
        return this._$traverseFromTo$_((function(t) {
            i.push(t);
        }), t, s), i;
    }, du._$RedBlackSet$_.prototype._$traverse$_ = function(t, s) {
        if (!this._$isEmpty$_()) for (var i = this.min(this.root); i != this._$sentinel$_; ) {
            if (t.call(s, i.key, this)) return;
            i = this._$successor_$_(i);
        }
    }, du._$RedBlackSet$_.prototype._$traverseFrom$_ = function(t, s, i) {
        if (!this._$isEmpty$_()) for (var e = this._$get_$_(s); e != this._$sentinel$_; ) {
            if (t.call(i, e.key, this)) return;
            e = this._$successor_$_(e);
        }
    }, du._$RedBlackSet$_.prototype.traverseTo = function(t, s, i) {
        if (!this._$isEmpty$_()) for (var e = this.min(this.root), n = this._$get_$_(s); e != n; ) {
            if (t.call(i, e.key, this)) return;
            e = this._$successor_$_(e);
        }
    }, du._$RedBlackSet$_.prototype._$traverseFromTo$_ = function(t, s, i, e) {
        if (!this._$isEmpty$_()) for (var n = this._$get_$_(s), h = this._$get_$_(i); n != h; ) {
            if (t.call(e, n.key, this)) return;
            n = this._$successor_$_(n);
        }
    }, du._$RedBlackSet$_.prototype._$traverseBackwards$_ = function(t, s) {
        if (!this._$isEmpty$_()) for (var i = this.max(this.root); i != this._$sentinel$_; ) {
            if (t.call(s, i.key, this)) return;
            i = this._$predeccessor_$_(i);
        }
    }, du._$RedBlackSet$_.prototype.forEach = function(t, s) {
        if (!this._$isEmpty$_()) for (var i = this.min(this.root); i != this._$sentinel$_; i = this._$successor_$_(i)) t.call(s, i.key, i.key, this);
    }, du._$RedBlackSet$_.prototype.some = function(t, s) {
        if (this._$isEmpty$_()) return !1;
        for (var i = this.min(this.root); i != this._$sentinel$_; i = this._$successor_$_(i)) if (t.call(s, i.key, i.key, this)) return !0;
        return !1;
    }, du._$RedBlackSet$_.prototype.every = function(t, s) {
        if (this._$isEmpty$_()) return !1;
        for (var i = this.min(this.root); i != this._$sentinel$_; i = this._$successor_$_(i)) if (!t.call(s, i.key, i.key, this)) return !1;
        return !0;
    }, du._$RedBlackSet$_.prototype.map = function(t, s) {
        var i = [];
        if (this._$isEmpty$_()) return i;
        for (var e = this.min(this.root); e != this._$sentinel$_; e = this._$successor_$_(e)) i.push(t.call(s, e.key, e.key, this));
        return i;
    }, du._$RedBlackSet$_.prototype.filter = function(t, s) {
        var i = [];
        if (this._$isEmpty$_()) return i;
        for (var e = this.min(this.root); e != this._$sentinel$_; e = this._$successor_$_(e)) t.call(s, e.key, e.key, this) && i.push(e.key);
        return i;
    }, du._$RedBlackSet$_.prototype._$getCount$_ = function() {
        return this.size;
    }, du._$RedBlackSet$_.prototype._$isEmpty$_ = function() {
        return 0 == this.size;
    }, du._$RedBlackSet$_.prototype.isSubsetOf = function(t) {
        var s = du._$getCount$_(t);
        if (this._$getCount$_() > s) return !1;
        var i = 0;
        if (this._$isEmpty$_()) return !0;
        for (var e = this.min(this.root); e != this._$sentinel$_; e = this._$successor_$_(e)) du.contains.call(t, t, e.key) && i++;
        return i == this._$getCount$_();
    }, du._$RedBlackSet$_.prototype.intersection = function(t) {
        var s = new du._$RedBlackSet$_(this.compare);
        if (this._$isEmpty$_()) return s;
        for (var i = this.min(this.root); i != this._$sentinel$_; i = this._$successor_$_(i)) t.contains.call(t, i.key, i.key, this) && s._$insert$_(i.key);
        return s;
    }, fu._$RedBlackSet$_ = class extends fu._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_rbSet$_ = new du._$RedBlackSet$_(t), this._$_enableQueue$_ = !1, 
            this._$_queueInsert$_ = new Set, this._$_queueRemove$_ = new Set;
        }
        _$Add$_(t) {
            this._$_enableQueue$_ ? this._$_rbSet$_.contains(t) ? this._$_queueRemove$_.delete(t) : this._$_queueInsert$_.add(t) : this._$_rbSet$_._$insert$_(t);
        }
        _$Remove$_(t) {
            this._$_enableQueue$_ ? this._$_rbSet$_.contains(t) ? this._$_queueRemove$_.add(t) : this._$_queueInsert$_.delete(t) : this._$_rbSet$_.remove(t);
        }
        _$Has$_(t) {
            return this._$_enableQueue$_ ? !!this._$_queueInsert$_.has(t) || !this._$_queueRemove$_.has(t) && this._$_rbSet$_.contains(t) : this._$_rbSet$_.contains(t);
        }
        _$Clear$_() {
            this._$_rbSet$_.clear(), this._$_queueInsert$_.clear(), this._$_queueRemove$_.clear();
        }
        toArray() {
            if (this._$_enableQueue$_) throw new Error("cannot be used in queueing mode");
            return this._$_rbSet$_.getValues();
        }
        _$GetSize$_() {
            return this._$_rbSet$_._$getCount$_() + this._$_queueInsert$_.size - this._$_queueRemove$_.size;
        }
        _$IsEmpty$_() {
            return 0 === this._$GetSize$_();
        }
        _$Front$_() {
            if (this._$IsEmpty$_()) throw new Error("empty set");
            if (this._$_enableQueue$_) throw new Error("cannot be used in queueing mode");
            const t = this._$_rbSet$_;
            return t.min(t.root).key;
        }
        _$Shift$_() {
            if (this._$IsEmpty$_()) throw new Error("empty set");
            if (this._$_enableQueue$_) throw new Error("cannot be used in queueing mode");
            const t = this._$Front$_();
            return this._$Remove$_(t), t;
        }
        _$SetQueueingEnabled$_(t) {
            if (t = !!t, this._$_enableQueue$_ !== t && (this._$_enableQueue$_ = t, !t)) {
                for (const t of this._$_queueRemove$_) this._$_rbSet$_.remove(t);
                this._$_queueRemove$_.clear();
                for (const t of this._$_queueInsert$_) this._$_rbSet$_._$insert$_(t);
                this._$_queueInsert$_.clear();
            }
        }
        _$ForEach$_(t) {
            this._$_rbSet$_.forEach(t);
        }
        * values() {
            if (this._$IsEmpty$_()) return;
            const t = this._$_rbSet$_;
            for (let s = t.min(t.root); s != t._$sentinel$_; s = t._$successor_$_(s)) yield s.key;
        }
        [Symbol.iterator]() {
            return this.values();
        }
    };
}

{
    const mu = self._$C3$_;
    mu._$PromiseThrottle$_ = class {
        constructor(t = mu.hardwareConcurrency) {
            this._$_maxParallel$_ = t, this._$_queue$_ = [], this._$_activeCount$_ = 0;
        }
        _$Add$_(t) {
            return new Promise(((s, i) => {
                this._$_queue$_.push({
                    _$func$_: t,
                    resolve: s,
                    reject: i
                }), this._$_MaybeStartNext$_();
            }));
        }
        _$_FindInQueue$_(t) {
            for (let s = 0, i = this._$_queue$_.length; s < i; ++s) if (this._$_queue$_[s]._$func$_ === t) return s;
            return -1;
        }
        _$RemoveAndResolve$_(t, s) {
            const i = this._$_FindInQueue$_(t);
            if (-1 === i) throw new Error("cannot find promise to resolve");
            this._$_queue$_[i].resolve(s), this._$_queue$_.splice(i, 1);
        }
        _$RemoveAndReject$_(t, s) {
            const i = this._$_FindInQueue$_(t);
            if (-1 === i) throw new Error("cannot find promise to reject");
            this._$_queue$_[i].reject(s), this._$_queue$_.splice(i, 1);
        }
        async _$_MaybeStartNext$_() {
            if (!this._$_queue$_.length) return;
            if (this._$_activeCount$_ >= this._$_maxParallel$_) return;
            this._$_activeCount$_++;
            const t = this._$_queue$_.shift();
            try {
                const s = await t._$func$_();
                t.resolve(s);
            } catch (s) {
                t.reject(s);
            }
            this._$_activeCount$_--, this._$_MaybeStartNext$_();
        }
        static async _$Batch$_(t, s) {
            const i = [];
            let e = !1;
            const n = async t => {
                let n;
                for (;n = s.pop(); ) {
                    if (e) return;
                    try {
                        i.push(await n());
                    } catch (t) {
                        throw e = !0, t;
                    }
                }
            }, h = [];
            for (;t--; ) h.push(n());
            return await Promise.all(h), i;
        }
    };
}

{
    const gu = self._$C3$_;
    gu._$RateLimiter$_ = class {
        constructor(t, s, i) {
            this._$_callback$_ = t, this._$_interval$_ = s, this._$_intervalOnBattery$_ = i || 2 * s, 
            this._$_timerId$_ = -1, this._$_lastCallTime$_ = -1 / 0, this._$_timerCallFunc$_ = () => this._$_OnTimer$_(), 
            this._$_ignoreReset$_ = !1, this._$_canRunImmediate$_ = !1, this._$_callbackArguments$_ = null;
        }
        _$SetCanRunImmediate$_(t) {
            this._$_canRunImmediate$_ = !!t;
        }
        _$_GetInterval$_() {
            return void 0 !== gu._$Battery$_ && gu._$Battery$_._$IsOnBatteryPower$_() ? this._$_intervalOnBattery$_ : this._$_interval$_;
        }
        _$Call$_(...t) {
            if (-1 !== this._$_timerId$_) return;
            this._$_callbackArguments$_ = t;
            let s = gu._$FastGetDateNow$_(), i = s - this._$_lastCallTime$_, e = this._$_GetInterval$_();
            i >= e && this._$_canRunImmediate$_ ? (this._$_lastCallTime$_ = s, this._$_RunCallback$_()) : this._$_timerId$_ = self.setTimeout(this._$_timerCallFunc$_, Math.max(e - i, 4));
        }
        _$_RunCallback$_() {
            this._$_ignoreReset$_ = !0;
            const t = this._$_callbackArguments$_;
            this._$_callbackArguments$_ = null, t ? this._$_callback$_(...t) : this._$_callback$_(), 
            this._$_ignoreReset$_ = !1;
        }
        _$Reset$_() {
            this._$_ignoreReset$_ || (this._$_CancelTimer$_(), this._$_callbackArguments$_ = null, 
            this._$_lastCallTime$_ = gu._$FastGetDateNow$_());
        }
        _$_OnTimer$_() {
            this._$_timerId$_ = -1, this._$_lastCallTime$_ = gu._$FastGetDateNow$_(), this._$_RunCallback$_();
        }
        _$_CancelTimer$_() {
            -1 !== this._$_timerId$_ && (self.clearTimeout(this._$_timerId$_), this._$_timerId$_ = -1);
        }
        _$Release$_() {
            this._$_CancelTimer$_(), this._$_callback$_ = null, this._$_callbackArguments$_ = null, 
            this._$_timerCallFunc$_ = null;
        }
    };
}

{
    const yu = self._$C3$_;
    yu._$SVGRasterManager$_ = class {
        constructor() {
            this._$_images$_ = new Map, this._$_allowNpotSurfaces$_ = !1, this._$_getBaseSizeCallback$_ = null, 
            this._$_rasterAtSizeCallback$_ = null, this._$_releaseResultCallback$_ = null, this._$_redrawCallback$_ = null;
        }
        _$SetNpotSurfaceAllowed$_(t) {
            this._$_allowNpotSurfaces$_ = !!t;
        }
        _$IsNpotSurfaceAllowed$_() {
            return this._$_allowNpotSurfaces$_;
        }
        _$SetGetBaseSizeCallback$_(t) {
            this._$_getBaseSizeCallback$_ = t;
        }
        _$GetBaseSize$_(t) {
            if (!this._$_getBaseSizeCallback$_) throw new Error("no get base size callback set");
            return this._$_getBaseSizeCallback$_(t);
        }
        _$SetRasterAtSizeCallback$_(t) {
            this._$_rasterAtSizeCallback$_ = t;
        }
        _$RasterAtSize$_(t, s, i, e, n, h) {
            if (!this._$_rasterAtSizeCallback$_) throw new Error("no raster at size callback set");
            return this._$_rasterAtSizeCallback$_(t, s, i, e, n, h);
        }
        _$SetReleaseResultCallback$_(t) {
            this._$_releaseResultCallback$_ = t;
        }
        _$ReleaseResult$_(t) {
            if (!this._$_releaseResultCallback$_) throw new Error("no release result callback set");
            this._$_releaseResultCallback$_(t);
        }
        _$SetRedrawCallback$_(t) {
            this._$_redrawCallback$_ = t;
        }
        _$Redraw$_() {
            if (!this._$_redrawCallback$_) throw new Error("no redraw callback set");
            this._$_redrawCallback$_();
        }
        _$AddImage$_(t) {
            let s = this._$_images$_.get(t);
            return s || (s = yu._$New$_(yu._$SVGRasterImage$_, this, t), this._$_images$_.set(t, s)), 
            s._$IncReference$_(), s;
        }
        _$_RemoveImage$_(t) {
            this._$_images$_.delete(t._$GetDataSource$_());
        }
        _$OnTexturesChanged$_() {
            for (const t of this._$_images$_.values()) t._$ReleaseRasterizedResult$_(), t._$ForceRasterAgain$_();
        }
    };
}

{
    const Mu = self._$C3$_;
    Mu._$SVGRasterImage$_ = class {
        constructor(t, s) {
            this._$_manager$_ = t, this._$_dataSource$_ = s, this._$_refCount$_ = 0, this._$_baseWidth$_ = 0, 
            this._$_baseHeight$_ = 0, this._$_getBaseSizePromise$_ = this._$_manager$_._$GetBaseSize$_(s).then((t => {
                this._$_manager$_ && (this._$_baseWidth$_ = t[0], this._$_baseHeight$_ = t[1], this._$_manager$_._$Redraw$_());
            })).catch((t => {
                console.error("[SVG] Error loading SVG: ", t), this._$_hadError$_ = !0, this._$_manager$_ && this._$_manager$_._$Redraw$_();
            })), this._$_rasterSurfaceWidth$_ = 0, this._$_rasterSurfaceHeight$_ = 0, this._$_rasterImageWidth$_ = 0, 
            this._$_rasterImageHeight$_ = 0, this._$_isRasterizing$_ = !1, this._$_rasterizedResult$_ = null, 
            this._$_forceRaster$_ = !1, this._$_hadError$_ = !1;
        }
        _$Release$_() {
            if (this._$_refCount$_ <= 0) throw new Error("already released");
            this._$_refCount$_--, 0 === this._$_refCount$_ && this._$_Release$_();
        }
        _$ReleaseRasterizedResult$_() {
            this._$_rasterizedResult$_ && (this._$_manager$_._$ReleaseResult$_(this._$_rasterizedResult$_), 
            this._$_rasterizedResult$_ = null);
        }
        _$_Release$_() {
            this._$ReleaseRasterizedResult$_(), this._$_manager$_._$_RemoveImage$_(this), this._$_manager$_ = null;
        }
        _$GetDataSource$_() {
            return this._$_dataSource$_;
        }
        _$IncReference$_() {
            this._$_refCount$_++;
        }
        _$HasReferences$_() {
            return this._$_refCount$_ > 0;
        }
        _$GetRasterizedResult$_() {
            return this._$_rasterizedResult$_;
        }
        _$ForceRasterAgain$_() {
            this._$_forceRaster$_ = !0;
        }
        async _$StartRasterForSize$_(t, s, i) {
            if (0 === s || 0 === i || this._$_hadError$_) return;
            if (this._$_isRasterizing$_) return;
            let e = Mu._$nextHighestPowerOfTwo$_(Math.ceil(s)), n = Mu._$nextHighestPowerOfTwo$_(Math.ceil(i));
            const h = Math.max(e, n);
            if (h > 4096) {
                const t = 4096 / h;
                s *= t, i *= t, e = Math.min(Math.ceil(e * t), 4096), n = Math.min(Math.ceil(n * t), 4096);
            }
            if (s < e && i < n) {
                const t = s / i;
                e / n > t ? (s = n * t, i = n) : (s = e, i = e / t);
            }
            if (this._$_manager$_._$IsNpotSurfaceAllowed$_() && (e = Math.ceil(s), n = Math.ceil(i)), 
            e <= this._$_rasterSurfaceWidth$_ && n <= this._$_rasterSurfaceHeight$_ && !this._$_forceRaster$_) return;
            this._$_isRasterizing$_ = !0, this._$_rasterSurfaceWidth$_ = e, this._$_rasterSurfaceHeight$_ = n;
            const r = await this._$_manager$_._$RasterAtSize$_(this._$_dataSource$_, t, this._$_rasterSurfaceWidth$_, this._$_rasterSurfaceHeight$_, s, i);
            this._$_manager$_ && (this._$ReleaseRasterizedResult$_(), this._$_rasterizedResult$_ = r, 
            this._$_rasterImageWidth$_ = s, this._$_rasterImageHeight$_ = i, this._$_isRasterizing$_ = !1, 
            this._$_forceRaster$_ = !1, this._$_manager$_._$Redraw$_());
        }
        _$WhenBaseSizeReady$_() {
            return this._$_getBaseSizePromise$_;
        }
        _$GetBaseWidth$_() {
            return this._$_baseWidth$_;
        }
        _$GetBaseHeight$_() {
            return this._$_baseHeight$_;
        }
        _$GetRasterWidth$_() {
            return this._$_rasterImageWidth$_;
        }
        _$GetRasterHeight$_() {
            return this._$_rasterImageHeight$_;
        }
        _$HadError$_() {
            return this._$_hadError$_;
        }
    };
}

{
    let wu = function(t) {
        return Iu.get(t);
    };
    0;
    const Su = self._$C3$_;
    Su._$UTF8_BOM$_ = "\ufeff";
    const bu = new Set("0123456789");
    Su._$IsNumericChar$_ = function(t) {
        return bu.has(t);
    };
    const Tu = new Set(" \t\n\r            ​\u2028\u2029  　");
    Su._$IsWhitespaceChar$_ = function(t) {
        return Tu.has(t);
    }, Su._$FilterWhitespace$_ = function(t) {
        return [ ...t ].filter((t => !Su._$IsWhitespaceChar$_(t))).join("");
    }, Su._$IsStringAllWhitespace$_ = function(t) {
        for (const s of t) if (!Su._$IsWhitespaceChar$_(s)) return !1;
        return !0;
    }, Su._$IsCharArrayAllWhitespace$_ = function(t) {
        for (const s of t) if (!Su._$IsWhitespaceChar$_(s)) return !1;
        return !0;
    }, Su._$IsUnprintableChar$_ = function(t) {
        return 1 === t.length && t.charCodeAt(0) < 32;
    }, Su._$FilterUnprintableChars$_ = function(t) {
        return [ ...t ].filter((t => !Su._$IsUnprintableChar$_(t))).join("");
    };
    let vu = null;
    try {
        vu = new RegExp("\\p{P}(?<=[\\u3000-\\u303F\\uFF00-\\uFFEF])", "u");
    } catch (t) {
        console.warn("Unable to detect CJK punctuation: ", t);
    }
    Su._$IsCJKPunctuationChar$_ = function(t) {
        return !Su._$IsWhitespaceChar$_(t) && vu && vu.test(t);
    };
    const xu = new Set("0123456789.+-e");
    Su._$IsStringNumber$_ = function(t) {
        if (!(t = t.trim()).length) return !1;
        let s = t.charAt(0);
        if ("-" !== s && !bu.has(s)) return !1;
        for (let s of t) if (!xu.has(s)) return !1;
        return !0;
    }, Su._$RemoveTrailingDigits$_ = function(t) {
        let s = t.length;
        for (;s > 0; ) {
            let i = t.charAt(s - 1);
            if (!Su._$IsNumericChar$_(i)) break;
            --s;
        }
        return t.substr(0, s);
    }, Su._$IncrementNumberAtEndOf$_ = function(t) {
        let s = Su._$RemoveTrailingDigits$_(t), i = t.substr(s.length);
        return i = i ? (parseInt(i, 10) + 1).toString() : "2", s + i;
    };
    const Iu = new Map([ [ "&", "&amp;" ], [ "<", "&lt;" ], [ ">", "&gt;" ], [ '"', "&quot;" ], [ "'", "&#39;" ] ]), Gu = /[&<>"']/g;
    Su._$EscapeHTML$_ = function(t) {
        return t.replace(Gu, wu);
    }, Su._$EscapeJS$_ = function(t) {
        let s = Su._$ReplaceAll$_(t, "\\", "\\\\");
        return s = Su._$ReplaceAll$_(s, '"', '\\"'), s = Su._$ReplaceAll$_(s, "\t", "\\t"), 
        s = Su._$ReplaceAll$_(s, "\r", ""), Su._$ReplaceAll$_(s, "\n", "\\n");
    }, Su._$EscapeXML$_ = function(t) {
        let s = Su._$ReplaceAll$_(t, "&", "&amp;");
        return s = Su._$ReplaceAll$_(s, "<", "&lt;"), s = Su._$ReplaceAll$_(s, ">", "&gt;"), 
        Su._$ReplaceAll$_(s, '"', "&quot;");
    };
    const Cu = /[-[\]{}()*+?.,\\^$|#\s]/g;
    Su._$EscapeRegex$_ = function(t) {
        return t.replace(Cu, "\\$&");
    }, Su._$CountCharsInString$_ = function(t, s) {
        let i = 0;
        for (const e of t) e === s && ++i;
        return i;
    }, Su._$StringPosToLineNumber$_ = function(t, s) {
        let i = 0, e = 0;
        for (;i < s; ) {
            if (i = t.indexOf("\n", i), -1 === i) return e;
            e++, i++;
        }
        return e;
    }, Su._$FindAll$_ = function(t, s, i = !1) {
        if (!s) return [];
        i || (t = t.toLowerCase(), s = s.toLowerCase());
        const e = s.length;
        let n = 0, h = 0, r = [];
        for (;(h = t.indexOf(s, n)) > -1; ) r.push(h), n = h + e;
        return r;
    }, Su._$ReplaceAll$_ = function(t, s, i) {
        return t.replaceAll(s, (() => i));
    }, Su._$ReplaceAllCaseInsensitive$_ = function(t, s, i) {
        return t.replace(new RegExp(Su._$EscapeRegex$_(s), "gi"), (() => i));
    }, Su._$SetElementContent$_ = function(t, s) {
        "string" == typeof s ? t.textContent = s : s._$isPlainText$_() ? t.textContent = s.toString() : (t.innerHTML = s._$toHTML$_(), 
        s instanceof Su._$BBString$_ && s._$attachLinkHandlers$_(t));
    }, Su._$StringLikeEquals$_ = function(t, s) {
        return t instanceof Su._$HtmlString$_ || t instanceof Su._$BBString$_ ? t.equals(s) : s instanceof Su._$HtmlString$_ || s instanceof Su._$BBString$_ ? s.equals(t) : t === s;
    }, Su._$StringSubstitute$_ = function(t, ...s) {
        let i = t;
        for (let e = 0, n = s.length; e < n; ++e) {
            const n = `{${e}}`;
            if (!t.includes(n)) throw new Error(`missing placeholder '${n}' in string substitution`);
            i = i.replace(n, s[e].toString());
        }
        return i;
    }, Su._$StringSubstituteAllowMissing$_ = function(t, ...s) {
        let i = t, e = -1, n = -1;
        for (let h = 0, r = s.length; h < r; ++h) {
            const r = `{${h}}`;
            t.includes(r) ? (n = h, i = i.replace(r, s[h].toString())) : -1 === e && (e = h);
        }
        if (e >= 0 && n >= 0 && e < n) throw new Error(`missing placeholder '${e}' in string substitution`);
        return i;
    }, Su._$StringSubstituteMap$_ = function(t, s) {
        let i = t;
        for (let [t, e] of Object.entries(s)) i = i.replaceAll(t, e.toString());
        return i;
    }, Su._$SortAZ$_ = function(t, s) {
        return t > s ? 1 : t < s ? -1 : 0;
    }, Su._$SortAZCaseInsensitive$_ = function(t, s) {
        let i = t.toLowerCase(), e = s.toLowerCase();
        return i > e ? 1 : i < e ? -1 : 0;
    };
    const _u = new self.Intl.Segmenter;
    Su._$SplitGraphemes$_ = function(t) {
        const s = [];
        for (const i of _u.segment(t)) s.push(i.segment);
        return s;
    }, Su._$IterateGraphemes$_ = function*(t) {
        for (const s of _u.segment(t)) yield s.segment;
    }, Su._$CountGraphemes$_ = function(t) {
        let s = 0;
        for (const i of _u.segment(t)) ++s;
        return s;
    };
    const Eu = 1073741824, Du = 1099511627776;
    Su._$FormatDataSize$_ = function(t, s) {
        let i = "common." + (s ? "dataRates" : "dataSizes") + ".";
        const e = self._$langSub$_;
        if (t < 1024) return e(i + "bytes", t);
        if (t < 1048576) {
            let s = t / 1024;
            return s = s < 10 ? Math.round(10 * s) / 10 : Math.round(s), e(i + "kilobytes", s);
        }
        if (t < Eu) {
            let s = t / 1048576;
            return s = s < 10 ? Math.round(10 * s) / 10 : Math.round(s), e(i + "megabytes", s);
        }
        if (t < Du) {
            let s = t / Eu;
            return s = s < 10 ? Math.round(10 * s) / 10 : Math.round(s), e(i + "gigabytes", s);
        }
        {
            let s = t / Du;
            return s = s < 10 ? Math.round(10 * s) / 10 : Math.round(s), e(i + "terabytes", s);
        }
    };
    const Au = {
        _$approximate$_: !1,
        _$days$_: !0,
        _$hours$_: !0,
        _$minutes$_: !0,
        _$seconds$_: !0
    };
    Su._$FormatTime$_ = function(t, s) {
        s = Object.assign({}, Au, s), Su._$Lang$_._$PushContext$_("common.time");
        const i = [], e = self.lang, n = self._$langPluralSub$_;
        if (s._$days$_) {
            const s = Math.floor(t / 86400);
            s > 0 && (t -= 24 * s * 3600, i.push(n(".days", null, s)));
        }
        if (s._$hours$_) {
            const s = Math.floor(t / 3600);
            (s > 0 || i.length) && (t -= 3600 * s, i.push(n(".hours", null, s)));
        }
        if (s._$minutes$_) {
            const e = Math.floor(t / 60);
            (e > 0 || i.length || !s._$seconds$_) && (t -= 60 * e, i.push(n(".minutes", null, e)));
        }
        if (s._$seconds$_) {
            const s = Math.floor(t % 60);
            i.push(n(".seconds", null, s));
        }
        const h = (s._$approximate$_ ? e(".approx-prefix") : "") + i.join(e(".separator"));
        return Su._$Lang$_._$PopContext$_(), h;
    }, Su._$ZeroPad$_ = function(t, s) {
        let i = t < 0 ? "-" : "", e = (t = Math.abs(t)).toString(), n = s - e.length;
        for (let t = 0; t < n; ++t) i += "0";
        return i + e;
    }, Su._$StringToTitleCase$_ = function(t) {
        return t.toLowerCase().replace(/\b\w/g, (t => t.toUpperCase()));
    }, Su._$CompareVersionStrings$_ = function(t, s) {
        let i = t.split(".").map((t => t.trim())), e = s.split(".").map((t => t.trim()));
        Su._$resizeArray$_(i, 4, "0"), Su._$resizeArray$_(e, 4, "0"), i = i.map((t => parseInt(t, 10))), 
        e = e.map((t => parseInt(t, 10)));
        for (let t = 0; t < 4; ++t) {
            const s = i[t] - e[t];
            if (0 !== s) return s < 0 ? -1 : 1;
        }
        return 0;
    }, Su._$CreateGUID$_ = function() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (t => {
            const s = Math.floor(16 * Math.random());
            return ("x" === t ? s : 3 & s | 8).toString(16);
        }));
    }, Su._$StringHammingDistance$_ = function(t, s) {
        if (t.length !== s.length) throw new Error("strings must be same length");
        let i = 0;
        for (let e = 0, n = t.length; e < n; ++e) t.charAt(e) !== s.charAt(e) && ++i;
        return i;
    }, Su._$StringLevenshteinDistance$_ = function(t, s) {
        if (0 === t.length) return s.length;
        if (0 === s.length) return t.length;
        let i, e, n, h, r, o;
        for (t.length > s.length && (i = t, t = s, s = i), o = Array(t.length + 1), e = 0; e <= t.length; e++) o[e] = e;
        for (e = 1; e <= s.length; e++) {
            for (h = e, n = 1; n <= t.length; n++) r = s[e - 1] === t[n - 1] ? o[n - 1] : Math.min(o[n - 1] + 1, Math.min(h + 1, o[n] + 1)), 
            o[n - 1] = h, h = r;
            o[t.length] = h;
        }
        return o[t.length];
    };
}

{
    let Nu = function(t, s, i) {
        const e = Ou.get(i);
        if (!e) return "class" === i ? s ? "</span>" : `<span class="bbclass${Bu++}">` : t;
        if ("string" == typeof e) {
            if ("a" === e && 0 === Fu.length || "abbr" === e && 0 === ju.length) return t;
            if ("a" !== e || s) {
                if ("abbr" !== e || s) return "<" + s + e + ">";
                {
                    const t = parseInt(i.substring(3), 10) - 1;
                    if (t < 0 || t >= ju.length) throw new Error("invalid bbcode tip substitution");
                    const s = ju[t];
                    let e = "";
                    if ("string" == typeof s ? e = s : "function" == typeof s && (e = s()), "string" != typeof e) throw new TypeError("invalid bbcode tip");
                    return `<abbr title="${Lu._$ReplaceAll$_(e, '"', "&quot;")}">`;
                }
            }
            {
                const t = parseInt(i.substring(1), 10) - 1;
                if (t < 0 || t >= Fu.length) throw new Error("invalid bbcode link substitution");
                const s = Fu[t];
                if ("string" == typeof s) return `<a href="${Fu[t]}">`;
                if ("function" == typeof s) return `<a class="bblink${t}">`;
                throw new TypeError("invalid bbcode link action");
            }
        }
        if (Array.isArray(e)) {
            let t = e[0], i = e[1];
            return s ? "</" + t + ">" : `<${t} class="${i}">`;
        }
    };
    0;
    const Lu = self._$C3$_, Ou = (self.assert, new Map([ [ "b", "strong" ], [ "i", "em" ], [ "s", "s" ], [ "u", "u" ], [ "sub", "sub" ], [ "sup", "sup" ], [ "small", "small" ], [ "mark", "mark" ], [ "code", "code" ], [ "a1", "a" ], [ "a2", "a" ], [ "a3", "a" ], [ "a4", "a" ], [ "a5", "a" ], [ "a6", "a" ], [ "a7", "a" ], [ "a8", "a" ], [ "a9", "a" ], [ "tip1", "abbr" ], [ "tip2", "abbr" ], [ "tip3", "abbr" ], [ "tip4", "abbr" ], [ "tip5", "abbr" ], [ "tip6", "abbr" ], [ "tip7", "abbr" ], [ "tip8", "abbr" ], [ "tip9", "abbr" ], [ "bad", [ "span", "bbCodeBad" ] ], [ "good", [ "span", "bbCodeGood" ] ], [ "info", [ "span", "bbCodeInfo" ] ], [ "h1", [ "span", "bbCodeH1" ] ], [ "h2", [ "span", "bbCodeH2" ] ], [ "h3", [ "span", "bbCodeH3" ] ], [ "h4", [ "span", "bbCodeH4" ] ], [ "item", [ "span", "bbCodeItem" ] ] ])), Ru = new Set([ "icon" ]), Pu = /\[(\/?)([a-zA-Z0-9]+)\]/g, ku = /\[(\/?)([^\[\n]*?)\]/g;
    let Fu = null, ju = null, Bu = 0;
    const zu = /\n/g;
    Lu._$BBString$_ = class {
        constructor(t, s) {
            if (this._$_bbstr$_ = s && s._$noEscape$_ ? t : Lu._$EscapeHTML$_(t), this._$_htmlstr$_ = "", 
            this._$_convertLineBreaks$_ = !1, this._$_linkActions$_ = [], this._$_tipList$_ = [], 
            s) {
                if (this._$_convertLineBreaks$_ = !!s._$convertLineBreaks$_, s.links) {
                    if (s.links.length > 9) throw new Error("too many links");
                    this._$_linkActions$_ = s.links;
                }
                if (s._$tips$_) {
                    if (s._$tips$_.length > 9) throw new Error("too many tips");
                    this._$_tipList$_ = s._$tips$_;
                }
            }
            this._$_hasAnyBBtags$_ = this._$_bbstr$_.includes("["), this._$_needsLineBreakConversion$_ = this._$_convertLineBreaks$_ && this._$_bbstr$_.includes("\n"), 
            this._$_isPlain$_ = !this._$_hasAnyBBtags$_ && !this._$_needsLineBreakConversion$_ && !this._$_bbstr$_.includes("&"), 
            this._$_hasParsedFragments$_ = !1, this._$_fragments$_ = [];
        }
        toString() {
            return this._$_bbstr$_;
        }
        valueOf() {
            return this._$_bbstr$_;
        }
        _$isPlainText$_() {
            return this._$_isPlain$_;
        }
        _$toPlainText$_() {
            return this._$_hasAnyBBtags$_ ? this._$_bbstr$_.replace(Pu, "") : this._$_bbstr$_;
        }
        _$toHTML$_() {
            if (this._$_isPlain$_) return this._$_bbstr$_;
            if (!this._$_htmlstr$_ && this._$_bbstr$_) {
                let t = this._$_bbstr$_;
                this._$_hasAnyBBtags$_ && (Bu = 0, Fu = this._$_linkActions$_, ju = this._$_tipList$_, 
                t = t.replace(Pu, Nu), Fu = null, ju = null), this._$_needsLineBreakConversion$_ && (t = t.replace(zu, "<br>")), 
                this._$_htmlstr$_ = t;
            }
            return this._$_htmlstr$_;
        }
        _$attachLinkHandlers$_(t) {
            if (this._$_linkActions$_.length) for (let s = 0, i = this._$_linkActions$_.length; s < i; ++s) {
                const i = this._$_linkActions$_[s];
                if ("function" != typeof i) continue;
                const e = t.querySelector(".bblink" + s);
                if (!e) throw new Error("unable to attach BBString link handler");
                e.onclick = i;
            }
        }
        equals(t) {
            return t instanceof Lu._$HtmlString$_ ? this._$toHTML$_() === t._$toHTML$_() : t instanceof Lu._$BBString$_ ? this._$_bbstr$_ === t._$_bbstr$_ : this._$_bbstr$_ === t;
        }
        _$toFragmentList$_() {
            if (this._$_hasParsedFragments$_) return this._$_fragments$_;
            const t = [], s = this._$_bbstr$_, i = [];
            ku.lastIndex = 0;
            let e = 0, n = null;
            for (;null !== (n = ku.exec(s)); ) {
                const h = n.index;
                if (h > 0 && "\\" === s.charAt(h - 1)) continue;
                const r = n[0], o = n[1], a = n[2], u = s.substring(e, h);
                if (e = h + r.length, u && t.push({
                    text: u,
                    _$styles$_: i.slice(0)
                }), a) if (o) {
                    const t = a.toLowerCase();
                    for (let s = i.length - 1; s >= 0; --s) if (i[s].tag === t) {
                        i.splice(s, 1);
                        break;
                    }
                } else {
                    let s = a, e = null;
                    const n = a.indexOf("=");
                    if (-1 !== n ? (s = a.substring(0, n).toLowerCase(), e = a.substring(n + 1)) : s = s.toLowerCase(), 
                    Ru.has(s)) {
                        if ("icon" !== s) throw new Error(`unknown self-closing tag ${s}`);
                        t.push({
                            icon: e,
                            _$styles$_: i.slice(0)
                        });
                    } else i.push({
                        tag: s,
                        _$param$_: e
                    });
                }
            }
            e < s.length && t.push({
                text: s.substring(e),
                _$styles$_: i.slice(0)
            });
            for (const s of t) s.text && (s.text = this._$_ProcessBBCodeEscapeSequences$_(s.text));
            return this._$_fragments$_ = t.map((t => t.icon ? Lu._$New$_(Lu._$IconFragment$_, {
                icon: t.icon,
                _$styles$_: t._$styles$_
            }) : Lu._$New$_(Lu._$TextFragment$_, {
                _$chArr$_: Lu._$SplitGraphemes$_(t.text),
                _$styles$_: t._$styles$_
            }))), this._$_hasParsedFragments$_ = !0, this._$_fragments$_;
        }
        _$_ProcessBBCodeEscapeSequences$_(t) {
            return t = Lu._$ReplaceAll$_(t, "\\[", "["), Lu._$ReplaceAll$_(t, "\\\\", "\\");
        }
        static _$StripTags$_(t) {
            return Lu._$New$_(Lu._$BBString$_, t, {
                _$noEscape$_: !0
            })._$toPlainText$_();
        }
        static _$StripAnyTags$_(t) {
            return t.replace(ku, "");
        }
    };
}

{
    let Uu = function(t) {
        return " " !== t && " " !== t && Vu._$IsWhitespaceChar$_(t);
    }, Wu = function(t) {
        return Hu.has(t);
    }, Ju = function(t) {
        return Vu._$IsCJKPunctuationChar$_(t) && !Wu(t);
    }, Qu = function(t) {
        for (;t.length > 0 && Uu(t.at(-1)); ) t.pop();
    }, Yu = function(t) {
        return "\n" === t || "\r\n" === t;
    };
    0;
    const Vu = self._$C3$_, Hu = new Set("〈《「『【〔〖〘〚〝");
    Vu._$WordWrap$_ = class {
        constructor() {
            this._$_lines$_ = [], this._$_iconSet$_ = null;
        }
        _$GetLines$_() {
            return this._$_lines$_;
        }
        _$GetLineCount$_() {
            return this._$_lines$_.length;
        }
        _$SetIconSet$_(t) {
            this._$_iconSet$_ = t;
        }
        _$_MeasureLine$_(t, s) {
            let i = 0, e = 0, n = 0, h = 0, r = 0;
            for (const o of t) {
                if (-1 === o._$GetWidth$_()) {
                    const t = s(o);
                    o._$SetHeight$_(t.height), o._$SetFontBoundingBoxAscent$_(t.fontBoundingBoxAscent || 0), 
                    o._$SetFontBoundingBoxDescent$_(t.fontBoundingBoxDescent || 0), o._$SetTopToAlphabeticDistance$_(t._$topToAlphabeticDistance$_ || 0), 
                    o._$IsText$_() ? o._$SetWidth$_(t.width) : o._$IsIcon$_() && o._$CalculateWidthFromHeight$_(this._$_iconSet$_);
                }
                i += o._$GetWidth$_(), e = Math.max(e, o._$GetHeight$_()), n = Math.max(n, o._$GetFontBoundingBoxAscent$_()), 
                h = Math.max(h, o._$GetFontBoundingBoxDescent$_()), r = Math.max(r, o._$GetTopToAlphabeticDistance$_());
            }
            return {
                width: i,
                height: e,
                fontBoundingBoxAscent: n,
                fontBoundingBoxDescent: h,
                _$topToAlphabeticDistance$_: r
            };
        }
        _$_AddLine$_(t, s, i, e, n, h) {
            this._$_lines$_.push(Vu._$New$_(Vu._$WordWrap$_._$Line$_, {
                _$fragments$_: t,
                width: s,
                height: i,
                fontBoundingBoxAscent: e,
                fontBoundingBoxDescent: n,
                _$topToAlphabeticDistance$_: h
            }));
        }
        _$WordWrap$_(t, s, i, e, n) {
            if ("string" == typeof t && (t = [ Vu._$New$_(Vu._$TextFragment$_, {
                _$chArr$_: Vu._$SplitGraphemes$_(t)
            }) ]), Vu._$clearArray$_(this._$_lines$_), !t.length || 1 === t.length && t[0]._$IsText$_() && t[0]._$IsEmpty$_() || i < 2) return;
            if (1 === t.length) {
                const e = t[0];
                if (e._$IsText$_() && e._$GetLength$_() <= 100 && !e._$HasNewLine$_()) {
                    let {width: t, height: h, fontBoundingBoxAscent: r, fontBoundingBoxDescent: o, _$topToAlphabeticDistance$_: a} = s(e);
                    if (t += n, e._$SetWidth$_(t), e._$SetHeight$_(h), e._$SetFontBoundingBoxAscent$_(r || 0), 
                    e._$SetFontBoundingBoxDescent$_(o || 0), e._$SetTopToAlphabeticDistance$_(a || 0), 
                    t <= i) return void this._$_AddLine$_([ e ], t, h, r, o, a);
                }
            }
            let h;
            h = "word" === e ? this._$_TokeniseByWord$_(t) : "cjk" === e ? this._$_TokeniseByCJK$_(t) : this._$_TokeniseByChar$_(t), 
            this._$_WrapText$_(h, s, i, n);
        }
        _$_TokeniseByWord$_(t) {
            const s = [];
            let i = [], e = !1;
            for (const n of t) {
                const t = n._$GetStyles$_();
                if (n._$IsIcon$_()) i.length > 0 && s.push(i), s.push([ n ]), i = []; else for (const h of n._$GetCharacterArray$_()) if (Yu(h)) i.length > 0 && s.push(i), 
                s.push([ Vu._$New$_(Vu._$TextFragment$_, {
                    _$chArr$_: [ "\n" ],
                    _$styles$_: t
                }) ]), i = []; else if (0 === i.length) i.push(Vu._$New$_(Vu._$TextFragment$_, {
                    _$chArr$_: [ h ],
                    _$styles$_: t
                })), e = Uu(h); else {
                    const n = Uu(h);
                    if (n === e) {
                        const s = i.at(-1);
                        s._$GetStyles$_() === t ? s._$_AppendChar$_(h) : i.push(Vu._$New$_(Vu._$TextFragment$_, {
                            _$chArr$_: [ h ],
                            _$styles$_: t
                        }));
                    } else s.push(i), i = [ Vu._$New$_(Vu._$TextFragment$_, {
                        _$chArr$_: [ h ],
                        _$styles$_: t
                    }) ], e = n;
                }
            }
            return i.length > 0 && s.push(i), s;
        }
        _$_TokeniseByCJK$_(t) {
            const s = [];
            let i = [], e = !1;
            for (const n of t) {
                const t = n._$GetStyles$_();
                if (n._$IsIcon$_()) i.length > 0 && s.push(i), s.push([ n ]), i = []; else for (const h of n._$GetCharacterArray$_()) if (Yu(h)) i.length > 0 && s.push(i), 
                s.push([ Vu._$New$_(Vu._$TextFragment$_, {
                    _$chArr$_: [ "\n" ],
                    _$styles$_: t
                }) ]), i = []; else if (0 === i.length) i.push(Vu._$New$_(Vu._$TextFragment$_, {
                    _$chArr$_: [ h ],
                    _$styles$_: t
                })), e = Wu(h); else if (e || Ju(h)) {
                    const s = i.at(-1);
                    s._$GetStyles$_() === t ? s._$_AppendChar$_(h) : i.push(Vu._$New$_(Vu._$TextFragment$_, {
                        _$chArr$_: [ h ],
                        _$styles$_: t
                    })), e = Wu(h);
                } else s.push(i), i = [ Vu._$New$_(Vu._$TextFragment$_, {
                    _$chArr$_: [ h ],
                    _$styles$_: t
                }) ], e = Wu(h);
            }
            return i.length > 0 && s.push(i), s;
        }
        _$_TokeniseByChar$_(t) {
            const s = [];
            for (const i of t) if (i._$IsText$_()) {
                const t = i._$GetCharacterArray$_();
                Vu._$appendArray$_(s, t.map((t => [ Vu._$New$_(Vu._$TextFragment$_, {
                    _$chArr$_: [ t ],
                    _$styles$_: i._$GetStyles$_()
                }) ])));
            } else s.push([ i ]);
            return s;
        }
        _$_CopyLine$_(t) {
            return t.map((t => t._$_Clone$_()));
        }
        _$_AddWordToLine$_(t, s) {
            const i = t.length ? t.at(-1) : null;
            let e = 0;
            i && i._$IsText$_() && s[0]._$IsText$_() && s[0]._$GetStyles$_() === i._$GetStyles$_() && (i._$_Append$_(s[0]._$GetCharacterArray$_()), 
            e = 1);
            for (let i = s.length; e < i; ++e) {
                const i = s[e];
                t.push(i._$_Clone$_());
            }
        }
        _$_WrapText$_(t, s, i, e) {
            let n = [], h = 0, r = 0, o = 0, a = 0, u = 0;
            for (const e of t) {
                if (1 === e.length && e[0]._$IsText$_() && 1 === e[0]._$GetLength$_() && Yu(e[0]._$GetCharacterArray$_()[0])) {
                    if (0 === r) {
                        const t = s(Vu._$New$_(Vu._$TextFragment$_, {
                            _$chArr$_: [ " " ],
                            _$styles$_: e[0]._$GetStyles$_()
                        }));
                        r = t.height, o = t.fontBoundingBoxAscent || 0, a = t.fontBoundingBoxDescent || 0, 
                        u = t._$topToAlphabeticDistance$_ || 0;
                    }
                    this._$_AddLine$_(n, h, r, o, a, u), n = [], h = 0, r = 0, o = 0, a = 0, u = 0;
                    continue;
                }
                const t = this._$_CopyLine$_(n);
                this._$_AddWordToLine$_(t, e);
                const l = this._$_MeasureLine$_(t, s), c = l.width;
                if (c >= i) if (n.length > 0 && this._$_AddLine$_(n, h, r, o, a, u), n = [], e[0]._$IsText$_() && Vu._$IsCharArrayAllWhitespace$_(e[0]._$GetCharacterArray$_())) h = 0, 
                r = 0, o = 0, a = 0, u = 0; else {
                    this._$_AddWordToLine$_(n, e);
                    const t = this._$_MeasureLine$_(n, s);
                    h = t.width, r = t.height, o = t.fontBoundingBoxAscent, a = t.fontBoundingBoxDescent, 
                    u = t._$topToAlphabeticDistance$_;
                } else n = t, h = c, r = l.height, o = l.fontBoundingBoxAscent, a = l.fontBoundingBoxDescent, 
                u = l._$topToAlphabeticDistance$_;
            }
            n.length > 0 && this._$_AddLine$_(n, h, r, o, a, u), this._$_TrimLinesTrailingWhitespace$_(s, e);
        }
        _$_TrimLinesTrailingWhitespace$_(t, s) {
            for (const i of this._$_lines$_) {
                const e = i._$_GetFragmentsArray$_();
                if (!e.length) continue;
                let n = e.at(-1);
                if (n._$IsText$_()) {
                    const h = n._$GetCharacterArray$_(), r = h.slice(0);
                    if (Qu(r), 0 === r.length) i._$OffsetWidth$_(-n._$GetWidth$_()), e.pop(); else if (r.length < h.length) {
                        n._$SetCharacterArray$_(r);
                        const s = t(n).width, e = n._$GetWidth$_() - s;
                        n._$SetWidth$_(s), i._$OffsetWidth$_(-e);
                    }
                    0 !== s && e.length > 0 && (n = e.at(-1), n._$OffsetWidth$_(s), i._$OffsetWidth$_(s));
                }
            }
        }
        _$Clear$_() {
            Vu._$clearArray$_(this._$_lines$_);
        }
        _$GetMaxLineWidth$_() {
            return this._$_lines$_.reduce(((t, s) => Math.max(t, s._$GetWidth$_())), 0);
        }
        _$GetTotalLineHeight$_() {
            return this._$_lines$_.reduce(((t, s) => t + s._$GetHeight$_()), 0);
        }
    };
}

self._$C3$_._$WordWrap$_._$Line$_ = class {
    constructor(t) {
        this._$_fragments$_ = t._$fragments$_ || [], this._$_width$_ = t.width || -1, this._$_height$_ = t.height || -1, 
        this._$_fontBoundingBoxAscent$_ = t.fontBoundingBoxAscent || -1, this._$_fontBoundingBoxDescent$_ = t.fontBoundingBoxDescent || -1, 
        this._$_topToAlphabeticDistance$_ = t._$topToAlphabeticDistance$_ || -1, this._$_posX$_ = 0, 
        this._$_posY$_ = 0;
    }
    _$fragments$_() {
        return this._$_fragments$_.values();
    }
    * _$fragmentsReverse$_() {
        const t = this._$_fragments$_;
        for (let s = t.length - 1; s >= 0; --s) yield t[s];
    }
    _$_GetFragmentsArray$_() {
        return this._$_fragments$_;
    }
    _$OffsetWidth$_(t) {
        this._$_width$_ += t;
    }
    _$GetWidth$_() {
        return this._$_width$_;
    }
    _$GetHeight$_() {
        return this._$_height$_;
    }
    _$GetFoundBoundingBoxAscent$_() {
        return this._$_fontBoundingBoxAscent$_;
    }
    _$GetFontBoundingBoxDescent$_() {
        return this._$_fontBoundingBoxDescent$_;
    }
    _$GetTopToAlphabeticDistance$_() {
        return this._$_topToAlphabeticDistance$_;
    }
    _$SetPosX$_(t) {
        this._$_posX$_ = t;
    }
    _$GetPosX$_() {
        return this._$_posX$_;
    }
    _$SetPosY$_(t) {
        this._$_posY$_ = t;
    }
    _$GetPosY$_() {
        return this._$_posY$_;
    }
};

self._$C3$_._$FragmentBase$_ = class {
    constructor(t) {
        this._$_styles$_ = t._$styles$_ || [], this._$_width$_ = t.width || -1, this._$_height$_ = t.height || -1, 
        this._$_fontBoundingBoxAscent$_ = t.fontBoundingBoxAscent || -1, this._$_fontBoundingBoxDescent$_ = t.fontBoundingBoxDescent || -1, 
        this._$_topToAlphabeticDistance$_ = t._$topToAlphabeticDistance$_ || -1, this._$_posX$_ = 0, 
        this._$_posY$_ = 0;
    }
    _$IsText$_() {
        return !1;
    }
    _$IsIcon$_() {
        return !1;
    }
    _$GetStyles$_() {
        return this._$_styles$_;
    }
    _$GetStyleTag$_(t) {
        const s = this._$_styles$_;
        for (let i = s.length - 1; i >= 0; --i) {
            const e = s[i];
            if (e.tag === t) return e;
        }
        return null;
    }
    _$HasStyleTag$_(t) {
        return !!this._$GetStyleTag$_(t);
    }
    _$GetStyleMap$_() {
        const t = new Map;
        for (const s of this._$_styles$_) t.set(s.tag, s._$param$_);
        return t;
    }
    _$OffsetWidth$_(t) {
        this._$_width$_ += t;
    }
    _$SetWidth$_(t) {
        this._$_width$_ = t;
    }
    _$GetWidth$_() {
        return this._$_width$_;
    }
    _$SetHeight$_(t) {
        this._$_height$_ = t;
    }
    _$GetHeight$_() {
        return this._$_height$_;
    }
    _$SetFontBoundingBoxAscent$_(t) {
        this._$_fontBoundingBoxAscent$_ = t;
    }
    _$GetFontBoundingBoxAscent$_() {
        return this._$_fontBoundingBoxAscent$_;
    }
    _$SetFontBoundingBoxDescent$_(t) {
        this._$_fontBoundingBoxDescent$_ = t;
    }
    _$GetFontBoundingBoxDescent$_() {
        return this._$_fontBoundingBoxDescent$_;
    }
    _$SetTopToAlphabeticDistance$_(t) {
        this._$_topToAlphabeticDistance$_ = t;
    }
    _$GetTopToAlphabeticDistance$_() {
        return this._$_topToAlphabeticDistance$_;
    }
    _$SetPosX$_(t) {
        this._$_posX$_ = t;
    }
    _$GetPosX$_() {
        return this._$_posX$_;
    }
    _$SetPosY$_(t) {
        this._$_posY$_ = t;
    }
    _$GetPosY$_() {
        return this._$_posY$_;
    }
};

{
    const qu = self._$C3$_;
    qu._$TextFragment$_ = class extends qu._$FragmentBase$_ {
        constructor(t) {
            super(t), this._$_chArr$_ = t._$chArr$_;
        }
        _$IsText$_() {
            return !0;
        }
        _$_Append$_(t) {
            qu._$appendArray$_(this._$_chArr$_, t), this._$_width$_ = -1, this._$_height$_ = -1, 
            this._$_fontBoundingBoxAscent$_ = -1, this._$_fontBoundingBoxDescent$_ = -1, this._$_topToAlphabeticDistance$_ = -1;
        }
        _$_AppendChar$_(t) {
            this._$_chArr$_.push(t);
        }
        _$_Clone$_() {
            return qu._$New$_(qu._$TextFragment$_, {
                _$chArr$_: this._$_chArr$_.slice(0),
                _$styles$_: this._$_styles$_,
                width: this._$_width$_,
                height: this._$_height$_,
                fontBoundingBoxAscent: this._$_fontBoundingBoxAscent$_,
                fontBoundingBoxDescent: this._$_fontBoundingBoxDescent$_,
                _$topToAlphabeticDistance$_: this._$_topToAlphabeticDistance$_
            });
        }
        _$GetCharacterArray$_() {
            return this._$_chArr$_;
        }
        _$SetCharacterArray$_(t) {
            this._$_chArr$_ = t;
        }
        _$GetLength$_() {
            return this._$_chArr$_.length;
        }
        _$IsEmpty$_() {
            return 0 === this._$_chArr$_.length;
        }
        _$HasNewLine$_() {
            return this._$_chArr$_.includes("\n");
        }
    };
}

{
    const Xu = self._$C3$_;
    Xu._$IconFragment$_ = class extends Xu._$FragmentBase$_ {
        constructor(t) {
            super(t), this._$_icon$_ = t.icon;
        }
        _$IsIcon$_() {
            return !0;
        }
        _$GetIconParameter$_() {
            return this._$_icon$_;
        }
        _$_Clone$_() {
            return Xu._$New$_(Xu._$IconFragment$_, {
                icon: this._$_icon$_,
                _$styles$_: this._$_styles$_,
                width: this._$_width$_,
                height: this._$_height$_,
                fontBoundingBoxAscent: this._$_fontBoundingBoxAscent$_,
                fontBoundingBoxDescent: this._$_fontBoundingBoxDescent$_,
                _$topToAlphabeticDistance$_: this._$_topToAlphabeticDistance$_
            });
        }
        _$GetTextIcon$_(t) {
            if (!t) return null;
            let s = Number(this._$_icon$_);
            return String(s) === this._$_icon$_ ? (s = Math.floor(s), t._$GetTextIconByIndex$_(s)) : t._$GetTextIconByTag$_(this._$_icon$_);
        }
        _$CalculateWidthFromHeight$_(t) {
            const s = this._$GetTextIcon$_(t);
            this._$_width$_ = s ? this._$_height$_ * s._$GetWidth$_() / s._$GetHeight$_() : 0;
        }
        _$GetDrawable$_(t) {
            const s = this._$GetTextIcon$_(t);
            return s ? s._$GetDrawable$_() : null;
        }
        _$GetLength$_() {
            return 1;
        }
    };
}

{
    const Zu = self._$C3$_;
    Zu._$TextIconManager$_ = class {
        constructor(t) {
            this._$_iconSets$_ = new Map, this._$_getIconSetMetaCallback$_ = t._$getIconSetMeta$_, 
            this._$_getIconSetContentCallback$_ = t._$getIconSetContent$_;
        }
        _$Release$_() {
            for (const t of this._$_iconSets$_.values()) t._$Release$_();
            this._$_iconSets$_.clear();
        }
        _$GetIconSet$_(t) {
            let s = this._$_iconSets$_.get(t);
            if (s) return s;
            const i = this._$_getIconSetMetaCallback$_(t);
            return s = Zu._$New$_(Zu._$TextIconSet$_, this, {
                source: t,
                _$iconMeta$_: i
            }), this._$_iconSets$_.set(t, s), s;
        }
        _$HasIconSet$_(t) {
            return this._$_iconSets$_.has(t);
        }
        _$DeleteIconSet$_(t) {
            const s = this._$_iconSets$_.get(t);
            s && s._$Release$_(), this._$_iconSets$_.delete(t);
        }
        async _$_GetIconSetContent$_(t) {
            return await this._$_getIconSetContentCallback$_(t);
        }
    };
}

{
    const Ku = self._$C3$_;
    Ku._$TextIconSet$_ = class {
        constructor(t, s) {
            this._$_textIconManager$_ = t, this._$_source$_ = s.source, this._$_iconsArray$_ = [], 
            this._$_iconsByTag$_ = new Map, this._$_hasStartedLoad$_ = !1, this._$_isLoading$_ = !1, 
            this._$_loadPromise$_ = null;
            const i = s._$iconMeta$_._$icons$_;
            for (let t = 0, s = i.length; t < s; ++t) {
                const s = i[t], e = Ku._$New$_(Ku._$TextIcon$_, this, {
                    index: t,
                    tag: s.tag,
                    source: s.source,
                    width: s.width,
                    height: s.height
                });
                this._$_iconsArray$_.push(e), s.tag && this._$_iconsByTag$_.set(s.tag.toLowerCase(), e);
            }
        }
        _$Release$_() {
            for (const t of this._$_iconsArray$_) t._$Release$_();
            Ku._$clearArray$_(this._$_iconsArray$_), this._$_iconsByTag$_.clear(), this._$_textIconManager$_ = null, 
            this._$_source$_ = null;
        }
        _$HasLoaded$_() {
            return this._$_hasStartedLoad$_;
        }
        _$IsLoading$_() {
            return this._$_isLoading$_;
        }
        _$LoadContent$_() {
            return this._$_loadPromise$_ || (this._$_loadPromise$_ = this._$_DoLoadContent$_()), 
            this._$_loadPromise$_;
        }
        async _$_DoLoadContent$_() {
            if (this._$_hasStartedLoad$_) return;
            this._$_hasStartedLoad$_ = !0, this._$_isLoading$_ = !0;
            const t = await this._$_textIconManager$_._$_GetIconSetContent$_(this._$_source$_);
            if (!this._$_textIconManager$_) return;
            const s = t._$icons$_;
            for (let t = 0, i = Math.min(s.length, this._$_iconsArray$_.length); t < i; ++t) {
                const i = s[t]._$drawable$_;
                this._$_iconsArray$_[t]._$_SetDrawable$_(i);
            }
            this._$_isLoading$_ = !1;
        }
        _$GetTextIconByIndex$_(t) {
            return (t = Math.floor(t)) < 0 || t >= this._$_iconsArray$_.length ? null : this._$_iconsArray$_[t];
        }
        _$GetTextIconByTag$_(t) {
            return this._$_iconsByTag$_.get(t.toLowerCase()) || null;
        }
    };
}

self._$C3$_._$TextIcon$_ = class {
    constructor(t, s) {
        this._$_textIconSet$_ = t, this._$_source$_ = s.source || null, this._$_index$_ = s.index, 
        this._$_tag$_ = s.tag, this._$_width$_ = s.width, this._$_height$_ = s.height, this._$_drawable$_ = null;
    }
    _$Release$_() {
        this._$_width$_ = 0, this._$_height$_ = 0, this._$_textIconSet$_ = null;
    }
    _$GetSource$_() {
        return this._$_source$_;
    }
    _$GetWidth$_() {
        return this._$_width$_;
    }
    _$GetHeight$_() {
        return this._$_height$_;
    }
    _$_SetDrawable$_(t) {
        this._$_drawable$_ = t;
    }
    _$GetDrawable$_() {
        return this._$_drawable$_;
    }
};

{
    let $u = function(t, s, i, e) {
        const n = ul;
        nl._$subtract$_(ol, i, s), nl._$subtract$_(al, t, s), nl._$cross$_(n, ol, al), nl.normalize(n, n), 
        e.set(n[0], n[1], n[2], nl._$dot$_(t, n));
    }, tl = function(t, s, i, e, n, h, r) {
        const o = r.x, a = r.y, u = r.z, l = r.w, c = r._$xF$_, f = r._$yF$_, d = r._$zF$_, p = 1 - c, m = 1 - f, g = 1 - d;
        return o * t * c + o * e * p + a * s * f + a * n * m + u * i * d + u * h * g >= l || o * e * c + o * t * p + a * n * f + a * s * m + u * h * d + u * i * g > l;
    }, sl = function(t, s, i, e) {
        return e.x * t + e.y * s + e.z * i >= e.w;
    };
    0;
    const il = self._$C3$_, el = self._$glMatrix$_, nl = el._$vec3$_, hl = el._$vec4$_, rl = el._$mat4$_, ol = nl.create(), al = nl.create(), ul = nl.create(), ll = hl.create(), cl = rl.create(), fl = nl.create(), dl = nl.create(), pl = nl.create(), ml = nl.create(), gl = nl.create(), yl = nl.create(), Ml = nl.create(), wl = nl.create(), Sl = hl._$fromValues$_(0, 0, 1, 1);
    il._$Gfx$_ = {
        _$Project$_(t, s, i, e, n, h, r) {
            const o = e[0] * t + e[4] * s + e[8] * i + e[12], a = e[1] * t + e[5] * s + e[9] * i + e[13], u = e[2] * t + e[6] * s + e[10] * i + e[14], l = e[3] * t + e[7] * s + e[11] * i + e[15];
            let c = n[0] * o + n[4] * a + n[8] * u + n[12] * l, f = n[1] * o + n[5] * a + n[9] * u + n[13] * l, d = n[2] * o + n[6] * a + n[10] * u + n[14] * l, p = n[3] * o + n[7] * a + n[11] * u + n[15] * l;
            return 0 !== p && (p = 1 / p, c *= p, f *= p, d *= p, r[0] = (.5 * c + .5) * h[2] + h[0], 
            r[1] = (.5 * f + .5) * h[3] + h[1], r[2] = .5 * (1 + d), !0);
        },
        _$Unproject$_(t, s, i, e, n, h, r) {
            const o = cl, a = ll;
            return rl.multiply(o, n, e), null !== rl._$invert$_(o, o) && (a[0] = (t - h[0]) / h[2] * 2 - 1, 
            a[1] = (s - h[1]) / h[3] * 2 - 1, a[2] = 2 * i - 1, a[3] = 1, hl._$transformMat4$_(a, a, o), 
            0 !== a[3] && (a[3] = 1 / a[3], r[0] = a[0] * a[3], r[1] = a[1] * a[3], r[2] = a[2] * a[3], 
            !0));
        },
        _$UnprojectScreenToWorldZ$_(t, s, i, e, n, h, r) {
            const o = ol, a = al;
            if (!il._$Gfx$_._$Unproject$_(t, s, 0, e, n, h, o)) return !1;
            if (!il._$Gfx$_._$Unproject$_(t, s, 1, e, n, h, a)) return !1;
            const u = al;
            nl._$subtract$_(u, a, o);
            const l = ul;
            nl.set(l, 0, 0, 1);
            const c = -i, f = nl._$dot$_(l, u);
            let d = 0;
            if (0 === f) {
                if (0 !== nl._$dot$_(l, o) + c) return !1;
            } else if (d = -(nl._$dot$_(o, l) + c) / f, d < 0) return !1;
            return nl._$scaleAndAdd$_(r, o, u, d), !0;
        }
    };
    class bl {
        constructor() {
            this.x = NaN, this.y = NaN, this.z = NaN, this.w = NaN, this._$xF$_ = NaN, this._$yF$_ = NaN, 
            this._$zF$_ = NaN;
        }
        set(t, s, i, e) {
            this.x = t, this.y = s, this.z = i, this.w = e, this._$xF$_ = t > 0 ? 1 : 0, this._$yF$_ = s > 0 ? 1 : 0, 
            this._$zF$_ = i > 0 ? 1 : 0;
        }
    }
    il._$Gfx$_._$ViewFrustum$_ = class {
        constructor() {
            this._$_leftP$_ = new bl, this._$_topP$_ = new bl, this._$_rightP$_ = new bl, this._$_bottomP$_ = new bl, 
            this._$_nearP$_ = new bl, this._$_farP$_ = new bl;
        }
        _$CalculatePlanes$_(t, s) {
            const i = Sl;
            il._$Gfx$_._$Unproject$_(0, 1, 0, t, s, i, fl), il._$Gfx$_._$Unproject$_(1, 1, 0, t, s, i, dl), 
            il._$Gfx$_._$Unproject$_(0, 0, 0, t, s, i, pl), il._$Gfx$_._$Unproject$_(1, 0, 0, t, s, i, ml), 
            il._$Gfx$_._$Unproject$_(0, 1, 1, t, s, i, gl), il._$Gfx$_._$Unproject$_(1, 1, 1, t, s, i, yl), 
            il._$Gfx$_._$Unproject$_(0, 0, 1, t, s, i, Ml), il._$Gfx$_._$Unproject$_(1, 0, 1, t, s, i, wl), 
            $u(pl, fl, gl, this._$_leftP$_), $u(fl, dl, yl, this._$_topP$_), $u(dl, ml, wl, this._$_rightP$_), 
            $u(ml, pl, Ml, this._$_bottomP$_), $u(Ml, gl, yl, this._$_farP$_), $u(ml, dl, fl, this._$_nearP$_);
        }
        _$ContainsAABB$_(t, s, i, e, n, h) {
            return tl(t, s, i, e, n, h, this._$_leftP$_) && tl(t, s, i, e, n, h, this._$_topP$_) && tl(t, s, i, e, n, h, this._$_rightP$_) && tl(t, s, i, e, n, h, this._$_bottomP$_) && tl(t, s, i, e, n, h, this._$_nearP$_) && tl(t, s, i, e, n, h, this._$_farP$_);
        }
        _$IsBehindNearPlane$_(t, s, i) {
            return !sl(t, s, i, this._$_nearP$_);
        }
    };
}

{
    const Tl = self._$C3$_, vl = self._$glMatrix$_, xl = vl._$vec3$_, Il = vl._$vec4$_, Gl = vl._$mat4$_, Cl = Gl.create(), _l = xl._$fromValues$_(0, 0, 0), El = xl._$fromValues$_(0, 0, 0), Dl = xl._$fromValues$_(0, 0, 0), Al = xl._$fromValues$_(0, 1, 0), Nl = (Il._$fromValues$_(0, 0, 0, 0), 
    new Tl._$Quad$_), Ll = new Tl.Rect, Ol = new Tl._$Quad$_(0, 0, 1, 0, 1, 1, 0, 1), Rl = {
        _$nearZ$_: 1,
        _$farZ$_: 1e4
    }, Pl = Gl._$fromValues$_(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, .5, 0, 0, 0, .5, 1);
    Tl._$Gfx$_._$RendererBase$_ = class {
        constructor(t) {
            t = Object.assign({}, Rl, t), this._$_width$_ = 0, this._$_height$_ = 0, this._$_fovY$_ = Tl._$toRadians$_(45), 
            this._$_tan_fovY_2$_ = Math.tan(this._$_fovY$_ / 2), this._$_matP$_ = Gl.create(), 
            this._$_matMV$_ = Gl.create(), this._$_zAxisScale$_ = !1, this._$_nearZ$_ = t._$nearZ$_, 
            this._$_farZ$_ = t._$farZ$_, this._$_allShaderPrograms$_ = [], this._$_shaderProgramsByName$_ = new Map, 
            this._$_spTextureFill$_ = null, this._$_spPoints$_ = null, this._$_spTilemapFill$_ = null, 
            this._$_spTileRandomization$_ = null, this._$_spColorFill$_ = null, this._$_spLinearGradientFill$_ = null, 
            this._$_spPenumbraFill$_ = null, this._$_spHardEllipseFill$_ = null, this._$_spHardEllipseOutline$_ = null, 
            this._$_spSmoothEllipseFill$_ = null, this._$_spSmoothEllipseOutline$_ = null, this._$_spSmoothLineFill$_ = null, 
            this._$_stateGroups$_ = new Map, this._$_currentStateGroup$_ = null, this._$_blendModeTable$_ = [], 
            this._$_namedBlendModeMap$_ = new Map, this._$_baseZ$_ = 0, this._$_currentZ$_ = 0, 
            this._$_lineWidth$_ = 1, this._$_lineWidthStack$_ = [ this._$_lineWidth$_ ], this._$_lineCap$_ = 1, 
            this._$_lineCapStack$_ = [ this._$_lineCap$_ ], this._$_lineOffset$_ = .5, this._$_lineOffsetStack$_ = [ this._$_lineOffset$_ ], 
            this._$_frameNumber$_ = 0, this._$_enableMipmaps$_ = !0, this._$_hasMajorPerformanceCaveat$_ = !1;
        }
        _$FillIndexBufferData$_(t) {
            let s = 0, i = t.length, e = 0;
            for (;s < i; ) t[s++] = e, t[s++] = e + 1, t[s++] = e + 2, t[s++] = e, t[s++] = e + 2, 
            t[s++] = e + 3, e += 4;
        }
        _$_ClearState$_() {
            this._$_baseZ$_ = 0, this._$_currentZ$_ = 0, this._$_spTextureFill$_ = null, this._$_spPoints$_ = null, 
            this._$_spTilemapFill$_ = null, this._$_spTileRandomization$_ = null, this._$_spColorFill$_ = null, 
            this._$_spLinearGradientFill$_ = null, this._$_spPenumbraFill$_ = null, this._$_spHardEllipseFill$_ = null, 
            this._$_spHardEllipseOutline$_ = null, this._$_spSmoothEllipseFill$_ = null, this._$_spSmoothEllipseOutline$_ = null, 
            this._$_spSmoothLineFill$_ = null, this._$_ClearAllShaderPrograms$_();
        }
        _$InitState$_() {
            this._$_ClearState$_(), this._$_currentStateGroup$_ = null;
        }
        _$OnDeviceOrContextLost$_() {
            for (const t of this._$_allShaderPrograms$_) t._$Release$_();
            this._$_ClearState$_();
        }
        _$GetWidth$_() {
            return this._$_width$_;
        }
        _$GetHeight$_() {
            return this._$_height$_;
        }
        _$GetDefaultCameraZ$_(t) {
            return this._$IsZAxisScaleNormalized$_() ? 100 : t / (2 * this._$_GetTanFovYDiv2$_());
        }
        _$GetZAxisScaleFactor$_(t) {
            return this._$IsZAxisScaleNormalized$_() ? t / (2 * this._$_GetTanFovYDiv2$_()) / this._$GetDefaultCameraZ$_(t) : 1;
        }
        _$SetNearZ$_(t) {
            this._$_nearZ$_ = t;
        }
        _$GetNearZ$_() {
            return this._$_nearZ$_;
        }
        _$SetFarZ$_(t) {
            this._$_farZ$_ = t;
        }
        _$GetFarZ$_() {
            return this._$_farZ$_;
        }
        _$SetFovY$_(t) {
            this._$_fovY$_ = t, this._$_tan_fovY_2$_ = Math.tan(this._$_fovY$_ / 2);
        }
        _$GetFovY$_() {
            return this._$_fovY$_;
        }
        _$_GetTanFovYDiv2$_() {
            return this._$_tan_fovY_2$_;
        }
        _$SetZAxisScaleNormalized$_() {
            this._$_zAxisScale$_ = !1;
        }
        _$SetZAxisScaleRegular$_() {
            this._$_zAxisScale$_ = !0;
        }
        _$IsZAxisScaleNormalized$_() {
            return !this._$_zAxisScale$_;
        }
        _$IsZAxisScaleRegular$_() {
            return this._$_zAxisScale$_;
        }
        _$CalculatePerspectiveMatrix$_(t, s, i = .5, e = .5) {
            const n = this._$GetNearZ$_(), h = this._$GetFarZ$_(), r = this._$GetFovY$_();
            if (.5 === i && .5 === e) this._$IsWebGPU$_() ? Gl._$perspectiveZO$_(t, r, s, n, h) : Gl.perspective(t, r, s, n, h); else {
                const r = 2 * (i = 1 - i) - 2, o = 2 * i, a = 2 * e - 2, u = 2 * e, l = this._$_GetTanFovYDiv2$_() * n, c = l * s;
                Gl._$frustum$_(t, r * c, o * c, a * l, u * l, n, h), this._$IsWebGPU$_() && Gl.mul(t, Pl, t);
            }
        }
        _$CalculateOrthographicMatrix$_(t, s, i, e = 1) {
            const n = self.devicePixelRatio, h = 2 * this._$GetDefaultCameraZ$_(i) * n * this._$_GetTanFovYDiv2$_() / i, r = s * h / (2 * n * e), o = i * h / (2 * n * e), a = -r, u = r, l = -o, c = o;
            this._$IsWebGPU$_() ? Gl._$orthoZO$_(t, a, u, l, c, this._$GetNearZ$_(), this._$GetFarZ$_()) : Gl._$ortho$_(t, a, u, l, c, this._$GetNearZ$_(), this._$GetFarZ$_());
        }
        _$CalculateLookAtModelView$_(t, s, i, e, n, h = 1) {
            let r = 1;
            this._$IsZAxisScaleNormalized$_() && (r = 200 * this._$_GetTanFovYDiv2$_() / n);
            const o = Dl;
            xl.set(o, r, -r, 1);
            const a = _l, u = El;
            xl.multiply(a, s, o), xl.multiply(u, i, o), Gl._$lookAt$_(t, a, u, e || Al), o[2] = h, 
            Gl.scale(t, t, o);
        }
        _$CalculateLookAtModelView2$_(t, s, i, e, n, h, r, o) {
            return xl.set(_l, t, s, i), xl.set(El, e, n, h), this._$CalculateLookAtModelView$_(Cl, _l, El, Al, r, o), 
            Cl;
        }
        _$_AddShaderProgram$_(t) {
            this._$_allShaderPrograms$_.push(t), this._$_shaderProgramsByName$_.set(t._$GetName$_(), t);
        }
        _$_RemoveShaderProgram$_(t) {
            const s = this._$_allShaderPrograms$_.indexOf(t);
            -1 !== s && this._$_allShaderPrograms$_.splice(s, 1), this._$_shaderProgramsByName$_.delete(t._$GetName$_());
        }
        _$_ClearAllShaderPrograms$_() {
            Tl._$clearArray$_(this._$_allShaderPrograms$_), this._$_shaderProgramsByName$_.clear();
        }
        _$GetShaderProgramByName$_(t) {
            return this._$_shaderProgramsByName$_.get(t) || null;
        }
        _$GetTextureFillShaderProgram$_() {
            return this._$_spTextureFill$_;
        }
        _$SetTextureFillMode$_() {
            this._$SetProgram$_(this._$_spTextureFill$_);
        }
        _$GetPointsRenderingProgram$_() {
            return this._$_spPoints$_;
        }
        _$SetPointsRenderingProgram$_() {
            this._$SetProgram$_(this._$_spPoints$_);
        }
        _$SetTilemapFillMode$_() {
            this._$SetProgram$_(this._$_spTilemapFill$_);
        }
        _$SetTileRandomizationMode$_() {
            this._$SetProgram$_(this._$_spTileRandomization$_);
        }
        _$SetColorFillMode$_() {
            this._$SetProgram$_(this._$_spColorFill$_);
        }
        _$SetLinearGradientFillMode$_() {
            this._$SetProgram$_(this._$_spLinearGradientFill$_);
        }
        _$SetPenumbraFillMode$_() {
            this._$SetProgram$_(this._$_spPenumbraFill$_);
        }
        _$SetHardEllipseFillMode$_() {
            this._$SetProgram$_(this._$_spHardEllipseFill$_);
        }
        _$SetHardEllipseOutlineMode$_() {
            this._$SetProgram$_(this._$_spHardEllipseOutline$_);
        }
        _$SetSmoothEllipseFillMode$_() {
            this._$SetProgram$_(this._$_spSmoothEllipseFill$_);
        }
        _$SetSmoothEllipseOutlineMode$_() {
            this._$SetProgram$_(this._$_spSmoothEllipseOutline$_);
        }
        _$SetSmoothLineFillMode$_() {
            this._$SetProgram$_(this._$_spSmoothLineFill$_);
        }
        _$_SetCurrentStateGroup$_(t) {
            this._$_currentStateGroup$_ = t;
        }
        _$GetCurrentStateGroup$_() {
            return this._$_currentStateGroup$_;
        }
        _$AcquireStateGroup$_(t, s, i, e) {
            const n = Tl._$Gfx$_._$StateGroup$_._$MakeKey$_(t, s, i, e);
            let h = this._$_stateGroups$_.get(n);
            return h || (h = Tl._$New$_(Tl._$Gfx$_._$StateGroup$_, this, t, s, i, e), this._$_stateGroups$_.set(n, h)), 
            h._$AddRef$_(), h;
        }
        _$ReleaseStateGroup$_(t) {
            t._$DecRef$_(), 0 === t._$_GetRefCount$_() && (this._$_currentStateGroup$_ === t && (this._$_currentStateGroup$_ = null), 
            this._$_stateGroups$_.delete(t._$GetKey$_()), t._$Release$_());
        }
        _$_InitBlendModeData$_(t) {
            Tl._$clearArray$_(this._$_blendModeTable$_), this._$_namedBlendModeMap$_.clear();
            let s = 0;
            for (const i of t) {
                const t = i[0], e = i[1], n = i[2];
                this._$_blendModeTable$_.push([ e, n ]), this._$_namedBlendModeMap$_.set(t, {
                    number: s,
                    _$srcBlend$_: e,
                    _$destBlend$_: n
                }), s++;
            }
        }
        _$_GetBlendByIndex$_(t) {
            return this._$_blendModeTable$_[t];
        }
        _$GetSrcBlendByIndex$_(t) {
            return this._$_GetBlendByIndex$_(t)[0];
        }
        _$GetDestBlendByIndex$_(t) {
            return this._$_GetBlendByIndex$_(t)[1];
        }
        _$GetNamedBlend$_(t) {
            const s = this._$_namedBlendModeMap$_.get(t);
            if (void 0 === s) throw new Error("invalid blend name");
            return s;
        }
        _$NamedBlendToNumber$_(t) {
            const s = this._$_namedBlendModeMap$_.get(t);
            if (void 0 === s) throw new Error("invalid blend name");
            return s.number;
        }
        _$SetBaseZ$_(t) {
            this._$_baseZ$_ = t;
        }
        _$GetBaseZ$_() {
            return this._$_baseZ$_;
        }
        _$SetCurrentZ$_(t) {
            this._$_currentZ$_ = t, this._$_currentStateGroup$_ = null;
        }
        _$GetCurrentZ$_() {
            return this._$_currentZ$_;
        }
        _$Line$_(t, s, i, e) {
            const n = Tl._$angleTo$_(t, s, i, e), h = Math.sin(n), r = Math.cos(n), o = .5 * this._$_lineWidth$_, a = h * o, u = r * o, l = this._$_lineCap$_;
            2 === l ? this._$LinePreCalc_LineCap2$_(t, s, 0, i, e, 0, a, u) : 1 === l ? this._$LinePreCalc_LineCap1$_(t, s, 0, i, e, 0, a, u) : this._$LinePreCalc_LineCap0$_(t, s, 0, i, e, 0, a, u);
        }
        _$Line3D$_(t, s, i, e, n, h) {
            const r = Tl._$angleTo$_(t, s, e, n), o = Math.sin(r), a = Math.cos(r), u = .5 * this._$_lineWidth$_, l = o * u, c = a * u, f = this._$_lineCap$_;
            2 === f ? this._$LinePreCalc_LineCap2$_(t, s, i, e, n, h, l, c) : 1 === f ? this._$LinePreCalc_LineCap1$_(t, s, i, e, n, h, l, c) : this._$LinePreCalc_LineCap0$_(t, s, i, e, n, h, l, c);
        }
        _$LinePreCalc_LineCap2$_(t, s, i, e, n, h, r, o) {
            const a = this._$_lineOffset$_, u = t + a - o, l = s + a - r, c = e + a + o, f = n + a + r, d = 2 * o, p = 2 * r, m = u + r, g = l - o, y = u - r + d, M = l + o + p, w = c + r, S = f - o, b = c - r - d, T = f + o - p;
            this._$Quad3D2$_(m, g, i, w, S, h, b, T, h, y, M, i, Ol);
        }
        _$LinePreCalc_LineCap1$_(t, s, i, e, n, h, r, o) {
            const a = this._$_lineOffset$_, u = t + a - o, l = s + a - r, c = e + a + o, f = n + a + r, d = u + r, p = l - o, m = u - r, g = l + o, y = c + r, M = f - o, w = c - r, S = f + o;
            this._$Quad3D2$_(d, p, i, y, M, h, w, S, h, m, g, i, Ol);
        }
        _$LinePreCalc_LineCap0$_(t, s, i, e, n, h, r, o) {
            const a = this._$_lineOffset$_, u = t + a, l = s + a, c = e + a, f = n + a, d = u + r, p = l - o, m = u - r, g = l + o, y = c + r, M = f - o, w = c - r, S = f + o;
            this._$Quad3D2$_(d, p, i, y, M, h, w, S, h, m, g, i, Ol);
        }
        _$TexturedLine$_(t, s, i, e, n, h) {
            const r = Tl._$angleTo$_(t, s, i, e), o = Math.sin(r), a = Math.cos(r), u = .5 * this._$_lineWidth$_, l = o * u, c = a * u, f = this._$_lineCap$_;
            2 === f ? this._$TexturedLinePreCalc_LineCap2$_(t, s, i, e, l, c, n, h) : 1 === f ? this._$TexturedLinePreCalc_LineCap1$_(t, s, i, e, l, c, n, h) : this._$TexturedLinePreCalc_LineCap0$_(t, s, i, e, l, c, n, h);
        }
        _$TexturedLinePreCalc_LineCap2$_(t, s, i, e, n, h, r, o) {
            const a = this._$_lineOffset$_, u = t + a - h, l = s + a - n, c = i + a + h, f = e + a + n, d = 2 * h, p = 2 * n, m = u + n, g = l - h, y = u - n + d, M = l + h + p, w = c + n, S = f - h, b = c - n - d, T = f + h - p;
            Nl.set(m, g, w, S, b, T, y, M), Ll.set(r, 0, o, 0), this._$Quad3$_(Nl, Ll);
        }
        _$TexturedLinePreCalc_LineCap1$_(t, s, i, e, n, h, r, o) {
            const a = this._$_lineOffset$_, u = t + a - h, l = s + a - n, c = i + a + h, f = e + a + n, d = u + n, p = l - h, m = u - n, g = l + h, y = c + n, M = f - h, w = c - n, S = f + h;
            Nl.set(d, p, y, M, w, S, m, g), Ll.set(r, 0, o, 0), this._$Quad3$_(Nl, Ll);
        }
        _$TexturedLinePreCalc_LineCap0$_(t, s, i, e, n, h, r, o) {
            const a = this._$_lineOffset$_, u = t + a, l = s + a, c = i + a, f = e + a, d = u + n, p = l - h, m = u - n, g = l + h, y = c + n, M = f - h, w = c - n, S = f + h;
            Nl.set(d, p, y, M, w, S, m, g), Ll.set(r, 0, o, 0), this._$Quad3$_(Nl, Ll);
        }
        _$LineRect$_(t, s, i, e) {
            const n = .5 * this._$_lineWidth$_, h = this._$_lineCap$_;
            2 === h ? this._$_LineRectPreCalc_LineCap2$_(t, s, i, e, n) : 1 === h ? this._$_LineRectPreCalc_LineCap1$_(t, s, i, e, n) : this._$_LineRectPreCalc_LineCap0$_(t, s, i, e, n);
        }
        _$_LineRectPreCalc_LineCap2$_(t, s, i, e, n) {
            this._$LinePreCalc_LineCap2$_(t, s, 0, i, s, 0, 0, n), this._$LinePreCalc_LineCap2$_(i, s, 0, i, e, 0, n, 0), 
            this._$LinePreCalc_LineCap2$_(i, e, 0, t, e, 0, 0, -n), this._$LinePreCalc_LineCap2$_(t, e, 0, t, s, 0, -n, 0);
        }
        _$_LineRectPreCalc_LineCap1$_(t, s, i, e, n) {
            this._$LinePreCalc_LineCap1$_(t, s, 0, i, s, 0, 0, n), this._$LinePreCalc_LineCap1$_(i, s, 0, i, e, 0, n, 0), 
            this._$LinePreCalc_LineCap1$_(i, e, 0, t, e, 0, 0, -n), this._$LinePreCalc_LineCap1$_(t, e, 0, t, s, 0, -n, 0);
        }
        _$_LineRectPreCalc_LineCap0$_(t, s, i, e, n) {
            this._$LinePreCalc_LineCap0$_(t, s, 0, i, s, 0, 0, n), this._$LinePreCalc_LineCap0$_(i, s, 0, i, e, 0, n, 0), 
            this._$LinePreCalc_LineCap0$_(i, e, 0, t, e, 0, 0, -n), this._$LinePreCalc_LineCap0$_(t, e, 0, t, s, 0, -n, 0);
        }
        _$LineRect2$_(t) {
            this._$LineRect$_(t._$getLeft$_(), t._$getTop$_(), t._$getRight$_(), t._$getBottom$_());
        }
        _$LineQuad$_(t) {
            const s = Tl._$angleTo$_(t._$getTlx$_(), t._$getTly$_(), t._$getTrx$_(), t._$getTry$_()), i = Math.sin(s), e = Math.cos(s), n = .5 * this._$_lineWidth$_, h = i * n, r = e * n, o = this._$_lineCap$_;
            2 === o ? this._$_LineQuadPreCalc_LineCap2$_(t, h, r) : 1 === o ? this._$_LineQuadPreCalc_LineCap1$_(t, h, r) : this._$_LineQuadPreCalc_LineCap0$_(t, h, r);
        }
        _$_LineQuadPreCalc_LineCap2$_(t, s, i) {
            this._$LinePreCalc_LineCap2$_(t._$getTlx$_(), t._$getTly$_(), 0, t._$getTrx$_(), t._$getTry$_(), 0, s, i), 
            this._$LinePreCalc_LineCap2$_(t._$getTrx$_(), t._$getTry$_(), 0, t._$getBrx$_(), t._$getBry$_(), 0, i, -s), 
            this._$LinePreCalc_LineCap2$_(t._$getBrx$_(), t._$getBry$_(), 0, t._$getBlx$_(), t._$getBly$_(), 0, -s, -i), 
            this._$LinePreCalc_LineCap2$_(t._$getBlx$_(), t._$getBly$_(), 0, t._$getTlx$_(), t._$getTly$_(), 0, -i, s);
        }
        _$_LineQuadPreCalc_LineCap1$_(t, s, i) {
            this._$LinePreCalc_LineCap1$_(t._$getTlx$_(), t._$getTly$_(), 0, t._$getTrx$_(), t._$getTry$_(), 0, s, i), 
            this._$LinePreCalc_LineCap1$_(t._$getTrx$_(), t._$getTry$_(), 0, t._$getBrx$_(), t._$getBry$_(), 0, i, -s), 
            this._$LinePreCalc_LineCap1$_(t._$getBrx$_(), t._$getBry$_(), 0, t._$getBlx$_(), t._$getBly$_(), 0, -s, -i), 
            this._$LinePreCalc_LineCap1$_(t._$getBlx$_(), t._$getBly$_(), 0, t._$getTlx$_(), t._$getTly$_(), 0, -i, s);
        }
        _$_LineQuadPreCalc_LineCap0$_(t, s, i) {
            this._$LinePreCalc_LineCap0$_(t._$getTlx$_(), t._$getTly$_(), 0, t._$getTrx$_(), t._$getTry$_(), 0, s, i), 
            this._$LinePreCalc_LineCap0$_(t._$getTrx$_(), t._$getTry$_(), 0, t._$getBrx$_(), t._$getBry$_(), 0, i, -s), 
            this._$LinePreCalc_LineCap0$_(t._$getBrx$_(), t._$getBry$_(), 0, t._$getBlx$_(), t._$getBly$_(), 0, -s, -i), 
            this._$LinePreCalc_LineCap0$_(t._$getBlx$_(), t._$getBly$_(), 0, t._$getTlx$_(), t._$getTly$_(), 0, -i, s);
        }
        _$SetLineWidth$_(t) {
            this._$_lineWidth$_ = t, this._$_lineWidthStack$_[this._$_lineWidthStack$_.length - 1] = t;
        }
        _$GetLineWidth$_() {
            return this._$_lineWidth$_;
        }
        _$PushLineWidth$_(t) {
            if (this._$_lineWidthStack$_.length >= 100) throw new Error("pushed too many line widths - check push/pop pairs");
            this._$_lineWidthStack$_.push(t), this._$_lineWidth$_ = t;
        }
        _$PopLineWidth$_() {
            if (this._$_lineWidthStack$_.length <= 1) throw new Error("cannot pop last line width - check push/pop pairs");
            this._$_lineWidthStack$_.pop(), this._$_lineWidth$_ = this._$_lineWidthStack$_.at(-1);
        }
        _$SetLineCapButt$_() {
            this._$_lineCap$_ = 0, this._$_lineCapStack$_[this._$_lineCapStack$_.length - 1] = 0;
        }
        _$SetLineCapSquare$_() {
            this._$_lineCap$_ = 1, this._$_lineCapStack$_[this._$_lineCapStack$_.length - 1] = 0;
        }
        _$SetLineCapZag$_() {
            this._$_lineCap$_ = 2, this._$_lineCapStack$_[this._$_lineCapStack$_.length - 1] = 0;
        }
        _$PushLineCap$_(t) {
            if ("butt" === t) this._$PushLineCapButt$_(); else if ("square" === t) this._$PushLineCapSquare$_(); else {
                if ("zag" !== t) throw new Error("invalid line cap");
                this._$PushLineCapZag$_();
            }
        }
        _$PushLineCapButt$_() {
            if (this._$_lineCapStack$_.length >= 100) throw new Error("pushed too many line caps - check push/pop pairs");
            this._$_lineCapStack$_.push(0), this._$_lineCap$_ = 0;
        }
        _$PushLineCapSquare$_() {
            if (this._$_lineCapStack$_.length >= 100) throw new Error("pushed too many line caps - check push/pop pairs");
            this._$_lineCapStack$_.push(1), this._$_lineCap$_ = 1;
        }
        _$PushLineCapZag$_() {
            if (this._$_lineCapStack$_.length >= 100) throw new Error("pushed too many line caps - check push/pop pairs");
            this._$_lineCapStack$_.push(2), this._$_lineCap$_ = 2;
        }
        _$PopLineCap$_() {
            if (this._$_lineCapStack$_.length <= 1) throw new Error("cannot pop last line cap - check push/pop pairs");
            this._$_lineCapStack$_.pop(), this._$_lineCap$_ = this._$_lineCapStack$_.at(-1);
        }
        _$SetLineOffset$_(t) {
            this._$_lineOffset$_ = t, this._$_lineOffsetStack$_[this._$_lineOffsetStack$_.length - 1] = t;
        }
        _$GetLineOffset$_() {
            return this._$_lineOffset$_;
        }
        _$PushLineOffset$_(t) {
            if (this._$_lineOffsetStack$_.length >= 100) throw new Error("pushed too many line offsets - check push/pop pairs");
            this._$_lineOffsetStack$_.push(t), this._$_lineOffset$_ = t;
        }
        _$PopLineOffset$_() {
            if (this._$_lineOffsetStack$_.length <= 1) throw new Error("cannot pop last line offset - check push/pop pairs");
            this._$_lineOffsetStack$_.pop(), this._$_lineOffset$_ = this._$_lineOffsetStack$_.at(-1);
        }
        _$ConvexPoly$_(t) {
            const s = t.length / 2;
            if (s < 3) throw new Error("need at least 3 points");
            const i = s - 2, e = i - 1, n = t[0], h = t[1];
            for (let s = 0; s < i; s += 2) {
                const i = 2 * s, r = t[i + 2], o = t[i + 3], a = t[i + 4], u = t[i + 5];
                if (s === e) this._$Quad2$_(n, h, r, o, a, u, a, u); else {
                    const s = t[i + 6], e = t[i + 7];
                    this._$Quad2$_(n, h, r, o, a, u, s, e);
                }
            }
        }
        _$GetNumVertexComponents$_() {
            return 3;
        }
        _$Finish$_() {
            this._$EndBatch$_(!0), this._$_frameNumber$_++;
        }
        _$GetFrameNumber$_() {
            return this._$_frameNumber$_;
        }
        _$IncrementFrameNumber$_() {
            this._$_frameNumber$_++;
        }
        _$SetMipmapsEnabled$_(t) {
            this._$_enableMipmaps$_ = !!t;
        }
        _$AreMipmapsEnabled$_() {
            return this._$_enableMipmaps$_;
        }
        _$SetHasMajorPerformanceCaveat$_(t) {
            this._$_hasMajorPerformanceCaveat$_ = !!t;
        }
        _$HasMajorPerformanceCaveat$_() {
            return this._$_hasMajorPerformanceCaveat$_;
        }
        _$IsWebGL$_() {
            return !1;
        }
        _$IsWebGPU$_() {
            return !1;
        }
        _$GetEstimatedBackBufferMemoryUsage$_() {}
        _$GetEstimatedRenderBufferMemoryUsage$_() {}
        _$GetEstimatedTextureMemoryUsage$_() {}
        _$GetEstimatedTotalMemoryUsage$_() {
            return this._$GetEstimatedBackBufferMemoryUsage$_() + this._$GetEstimatedRenderBufferMemoryUsage$_() + this._$GetEstimatedTextureMemoryUsage$_();
        }
        _$CreateRendererText$_() {
            return Tl._$New$_(Tl._$Gfx$_._$RendererText$_, this);
        }
    };
}

self._$C3$_._$Gfx$_._$ShaderProgramBase$_ = class {
    constructor(t, s) {
        this._$_name$_ = s.name, this._$_renderer$_ = t, this._$_extendBoxHorizontal$_ = s._$extendBoxHorizontal$_ || 0, 
        this._$_extendBoxVertical$_ = s._$extendBoxVertical$_ || 0, this._$_crossSampling$_ = !!s._$crossSampling$_, 
        this._$_mustPreDraw$_ = !!s._$mustPreDraw$_, this._$_preservesOpaqueness$_ = !!s._$preservesOpaqueness$_, 
        this._$_supports3dDirectRendering$_ = !!s._$supports3dDirectRendering$_, this._$_animated$_ = !!s.animated, 
        this._$_blendsBackground$_ = !!s._$blendsBackground$_, this._$_usesDepth$_ = !!s._$usesDepth$_, 
        this._$_usesAnySrcRectOrPixelSize$_ = !1, this._$_needsPostDrawOrExtendBox$_ = this._$_crossSampling$_ || this._$_blendsBackground$_ || 0 !== this._$_extendBoxHorizontal$_ || 0 !== this._$_extendBoxVertical$_;
    }
    _$Release$_() {
        this._$_renderer$_ = null;
    }
    _$GetRenderer$_() {
        return this._$_renderer$_;
    }
    _$GetName$_() {
        return this._$_name$_;
    }
    _$ExtendsBox$_() {
        return 0 !== this._$_extendBoxHorizontal$_ || 0 !== this._$_extendBoxVertical$_;
    }
    _$GetBoxExtendHorizontal$_() {
        return this._$_extendBoxHorizontal$_;
    }
    _$GetBoxExtendVertical$_() {
        return this._$_extendBoxVertical$_;
    }
    _$UsesCrossSampling$_() {
        return this._$_crossSampling$_;
    }
    _$MustPreDraw$_() {
        return this._$_mustPreDraw$_;
    }
    _$PreservesOpaqueness$_() {
        return this._$_preservesOpaqueness$_;
    }
    _$Supports3DDirectRendering$_() {
        return this._$_supports3dDirectRendering$_;
    }
    _$IsAnimated$_() {
        return this._$_animated$_;
    }
    _$BlendsBackground$_() {
        return this._$_blendsBackground$_;
    }
    _$UsesDepth$_() {
        return this._$_usesDepth$_;
    }
    _$UsesAnySrcRectOrPixelSize$_() {
        return this._$_usesAnySrcRectOrPixelSize$_;
    }
    _$NeedsPostDrawOrExtendsBox$_() {
        return this._$_needsPostDrawOrExtendBox$_;
    }
    _$UsesIsSrcTexRotated$_() {
        return !1;
    }
};

{
    const kl = self._$C3$_;
    kl._$Gfx$_._$StateGroup$_ = class {
        constructor(t, s, i, e, n) {
            this._$_renderer$_ = t, this._$_refCount$_ = 0, this._$_shaderProgram$_ = null, 
            this._$_shaderProgramName$_ = "", this._$_blendMode$_ = i, this._$_color$_ = kl._$New$_(kl._$Color$_), 
            this._$_color$_.set(e), this._$_zElevation$_ = n, "string" == typeof s ? this._$_shaderProgramName$_ = s : (this._$_shaderProgram$_ = s, 
            this._$_shaderProgramName$_ = this._$_shaderProgram$_._$GetName$_());
        }
        _$Release$_() {
            if (this._$_refCount$_ > 0) throw new Error("releasing state group still in use");
            this._$_renderer$_ = null, this._$_shaderProgram$_ = null, this._$_shaderProgramName$_ = "";
        }
        _$Apply$_() {
            const t = this._$_renderer$_;
            t._$SetProgram$_(this._$_shaderProgram$_), t._$SetBlendMode$_(this._$_blendMode$_), 
            t._$SetColor$_(this._$_color$_), t._$SetCurrentZ$_(this._$_zElevation$_), t._$_SetCurrentStateGroup$_(this);
        }
        _$GetKey$_() {
            return kl._$Gfx$_._$StateGroup$_._$MakeKey$_(this._$_shaderProgramName$_, this._$_blendMode$_, this._$_color$_, this._$_zElevation$_);
        }
        _$AddRef$_() {
            ++this._$_refCount$_;
        }
        _$DecRef$_() {
            --this._$_refCount$_;
        }
        _$_GetRefCount$_() {
            return this._$_refCount$_;
        }
        _$OnContextLost$_() {
            this._$_shaderProgram$_ = null;
        }
        _$OnContextRestored$_(t) {
            if (this._$_shaderProgram$_ = t._$GetShaderProgramByName$_(this._$_shaderProgramName$_), 
            !this._$_shaderProgram$_) throw new Error("failed to restore shader program");
        }
        static _$MakeKey$_(t, s, i, e) {
            return ("string" == typeof t ? t : t._$GetName$_()) + "," + s + "," + i._$getR$_() + "," + i._$getG$_() + "," + i._$getB$_() + "," + i._$getA$_() + "," + e;
        }
    };
}

{
    let Fl = function(t, s, i) {
        const e = i._$getTlx$_(), n = i._$getTly$_(), h = i._$getTrx$_() - e, r = i._$getTry$_() - n;
        return [ e + h * t + (i._$getBlx$_() - e) * s, n + r * t + (i._$getBly$_() - n) * s ];
    };
    0;
    const jl = self._$C3$_, Bl = jl._$New$_(jl._$Quad$_);
    jl._$Gfx$_._$MeshPoint$_ = class {
        constructor(t, s, i) {
            this._$_mesh$_ = t, this._$_col$_ = s, this._$_row$_ = i, this._$_x$_ = NaN, this._$_y$_ = NaN, 
            this._$_zElevation$_ = NaN, this._$_u$_ = NaN, this._$_v$_ = NaN, this._$_x$_ = 0, 
            this._$_y$_ = 0, this._$_zElevation$_ = 0, this._$_u$_ = 0, this._$_v$_ = 0;
        }
        _$_Init$_(t, s, i, e) {
            this._$_x$_ = t, this._$_y$_ = s, this._$_u$_ = i, this._$_v$_ = e;
        }
        _$GetX$_() {
            return this._$_x$_;
        }
        _$SetX$_(t) {
            this._$_x$_ !== t && (this._$_x$_ = t, this._$_mesh$_._$_SetPointsChanged$_());
        }
        _$GetY$_() {
            return this._$_y$_;
        }
        _$SetY$_(t) {
            this._$_y$_ !== t && (this._$_y$_ = t, this._$_mesh$_._$_SetPointsChanged$_());
        }
        _$GetZElevation$_() {
            return this._$_zElevation$_;
        }
        _$SetZElevation$_(t) {
            this._$_zElevation$_ !== t && (this._$_zElevation$_ = Math.max(t, 0), this._$_mesh$_._$_SetPointsChanged$_());
        }
        _$GetU$_() {
            return this._$_u$_;
        }
        _$SetU$_(t) {
            this._$_u$_ = t;
        }
        _$GetV$_() {
            return this._$_v$_;
        }
        _$SetV$_(t) {
            this._$_v$_ = t;
        }
        _$_Interpolate_TexRect$_(t, s, i) {
            [this._$_x$_, this._$_y$_] = Fl(t._$_x$_, t._$_y$_, s), this._$_zElevation$_ = t._$_zElevation$_, 
            this._$_u$_ = jl._$lerp$_(i._$getLeft$_(), i._$getRight$_(), t._$_u$_), this._$_v$_ = jl._$lerp$_(i._$getTop$_(), i._$getBottom$_(), t._$_v$_);
        }
        _$_Interpolate_TexQuad$_(t, s, i) {
            [this._$_x$_, this._$_y$_] = Fl(t._$_x$_, t._$_y$_, s), this._$_zElevation$_ = t._$_zElevation$_, 
            [this._$_u$_, this._$_v$_] = Fl(t._$_u$_, t._$_v$_, i);
        }
        _$SaveToJson$_() {
            return {
                x: this._$GetX$_(),
                y: this._$GetY$_(),
                z: this._$GetZElevation$_(),
                u: this._$GetU$_(),
                v: this._$GetV$_()
            };
        }
        _$LoadFromJson$_(t) {
            this._$SetX$_(t.x), this._$SetY$_(t.y), t.hasOwnProperty("z") && this._$SetZElevation$_(t.z), 
            this._$SetU$_(t.u), this._$SetV$_(t.v);
        }
        _$GetMesh$_() {
            return this._$_mesh$_;
        }
        _$GetColumn$_() {
            return this._$_col$_;
        }
        _$GetRow$_() {
            return this._$_row$_;
        }
    }, jl._$Gfx$_._$Mesh$_ = class {
        constructor(t, s, i) {
            if (t < 2 || s < 2) throw new Error("invalid mesh size");
            this._$_hsize$_ = t, this._$_vsize$_ = s, this._$_owner$_ = i || null, this._$_pts$_ = [], 
            this._$_minX$_ = 0, this._$_minY$_ = 0, this._$_maxX$_ = 1, this._$_maxY$_ = 1, 
            this._$_maxZ$_ = 0, this._$_pointsChanged$_ = !1;
            const e = t - 1, n = s - 1;
            for (let i = 0; i < s; ++i) {
                const s = [];
                for (let h = 0; h < t; ++h) {
                    const t = jl._$New$_(jl._$Gfx$_._$MeshPoint$_, this, h, i), r = h / e, o = i / n;
                    t._$_Init$_(r, o, r, o), s.push(t);
                }
                this._$_pts$_.push(s);
            }
        }
        _$Release$_() {
            jl._$clearArray$_(this._$_pts$_);
        }
        _$GetHSize$_() {
            return this._$_hsize$_;
        }
        _$GetVSize$_() {
            return this._$_vsize$_;
        }
        _$GetOwner$_() {
            return this._$_owner$_;
        }
        _$_GetPoints$_() {
            return this._$_pts$_;
        }
        _$_SetPointsChanged$_() {
            this._$_pointsChanged$_ = !0;
        }
        _$_MaybeComputeBounds$_() {
            if (!this._$_pointsChanged$_) return;
            let t = 1 / 0, s = 1 / 0, i = -1 / 0, e = -1 / 0, n = 0;
            for (const h of this._$_pts$_) for (const r of h) {
                const h = r._$GetX$_(), o = r._$GetY$_();
                t = Math.min(t, h), s = Math.min(s, o), i = Math.max(i, h), e = Math.max(e, o), 
                n = Math.max(n, r._$GetZElevation$_());
            }
            this._$_minX$_ = t, this._$_minY$_ = s, this._$_maxX$_ = i, this._$_maxY$_ = e, 
            this._$_maxZ$_ = n, this._$_pointsChanged$_ = !1;
        }
        _$GetMinX$_() {
            return this._$_MaybeComputeBounds$_(), this._$_minX$_;
        }
        _$GetMinY$_() {
            return this._$_MaybeComputeBounds$_(), this._$_minY$_;
        }
        _$GetMaxX$_() {
            return this._$_MaybeComputeBounds$_(), this._$_maxX$_;
        }
        _$GetMaxY$_() {
            return this._$_MaybeComputeBounds$_(), this._$_maxY$_;
        }
        _$GetMaxZ$_() {
            return this._$_MaybeComputeBounds$_(), this._$_maxZ$_;
        }
        _$HasAnyZElevation$_() {
            return this._$GetMaxZ$_() > 0;
        }
        _$GetMeshPointAt$_(t, s) {
            return t = Math.floor(t), s = Math.floor(s), t < 0 || t >= this._$_hsize$_ || s < 0 || s >= this._$_vsize$_ ? null : this._$_pts$_[s][t];
        }
        _$CalculateTransformedMesh$_(t, s, i) {
            const e = i instanceof jl.Rect;
            if (t._$GetHSize$_() !== this._$GetHSize$_() || t._$GetVSize$_() !== this._$GetVSize$_()) throw new Error("source mesh wrong size");
            const n = t._$_pts$_, h = this._$_pts$_;
            for (let t = 0, r = h.length; t < r; ++t) {
                const r = n[t], o = h[t];
                for (let t = 0, n = o.length; t < n; ++t) {
                    const n = r[t], h = o[t];
                    e ? h._$_Interpolate_TexRect$_(n, s, i) : h._$_Interpolate_TexQuad$_(n, s, i);
                }
            }
        }
        _$Draw$_(t) {
            const s = this._$_pts$_;
            let i = s[0];
            for (let e = 1, n = s.length; e < n; ++e) {
                const n = s[e];
                let h = i[0], r = n[0];
                for (let s = 1, e = n.length; s < e; ++s) {
                    const e = i[s], o = n[s];
                    Bl.set(h._$GetU$_(), h._$GetV$_(), e._$GetU$_(), e._$GetV$_(), o._$GetU$_(), o._$GetV$_(), r._$GetU$_(), r._$GetV$_()), 
                    t._$Quad3D2$_(h._$GetX$_(), h._$GetY$_(), h._$GetZElevation$_(), e._$GetX$_(), e._$GetY$_(), e._$GetZElevation$_(), o._$GetX$_(), o._$GetY$_(), o._$GetZElevation$_(), r._$GetX$_(), r._$GetY$_(), r._$GetZElevation$_(), Bl), 
                    h = e, r = o;
                }
                i = n;
            }
        }
        _$Outline$_(t, s) {
            s || (s = (t, s, i) => [ t, s, i ]);
            const i = this._$_pts$_;
            let e = i[0];
            for (let n = 1, h = i.length; n < h; ++n) {
                const r = i[n];
                let o = e[0], a = r[0];
                for (let i = 1, u = r.length; i < u; ++i) {
                    const l = e[i], c = r[i], [f, d, p] = s(o._$GetX$_(), o._$GetY$_(), o._$GetZElevation$_()), [m, g, y] = s(l._$GetX$_(), l._$GetY$_(), l._$GetZElevation$_()), [M, w, S] = s(c._$GetX$_(), c._$GetY$_(), c._$GetZElevation$_()), [b, T, v] = s(a._$GetX$_(), a._$GetY$_(), a._$GetZElevation$_());
                    t._$Line3D$_(f, d, p, m, g, y), t._$Line3D$_(f, d, p, M, w, S), t._$Line3D$_(f, d, p, b, T, v), 
                    i === u - 1 && t._$Line3D$_(m, g, y, M, w, S), n === h - 1 && t._$Line3D$_(b, T, v, M, w, S), 
                    o = l, a = c;
                }
                e = r;
            }
        }
        _$InsertPolyMeshVertices$_(t) {
            const s = .001, i = .99999999, e = t._$pointsArr$_(), n = [], h = this._$GetHSize$_() - 1, r = this._$GetVSize$_() - 1, o = 1 / h, a = 1 / r, u = h - 1, l = r - 1;
            let c = e[0], f = e[1], d = jl._$clamp$_(Math.floor(c * h), 0, u), p = jl._$clamp$_(Math.floor(f * r), 0, l), m = !0, g = 0, y = 0, M = 0, w = -1;
            const S = () => {
                c = jl._$clamp$_(jl._$lerp$_(c, g, M), 0, 1), f = jl._$clamp$_(jl._$lerp$_(f, y, M), 0, 1), 
                n.push(c, f);
            };
            for (let t = 0, b = e.length; t < b; t += 2) {
                c = e[t], f = e[t + 1], n.push(c, f), d = jl._$clamp$_(Math.floor(c * h), 0, u), 
                p = jl._$clamp$_(Math.floor(f * r), 0, l);
                const T = (t + 2) % b;
                for (g = e[T], y = e[T + 1], w = -1; ;) {
                    if (n.length > 1e6) throw new Error("Too many mesh poly points");
                    const t = d * o, e = p * a, h = (d + 1) * o, r = (p + 1) * a;
                    if (m = jl._$isPointInTriangleInclusive$_(c, f, t, e, h, e, h, r), 0 !== w && (M = jl._$rayIntersectExtended$_(c, f, g, y, t, e, h, r, -.001), 
                    M >= 0 && M <= i)) S(), m = !m, w = 0; else if (p > 0 && 2 !== w && (M = jl._$rayIntersectExtended$_(c, f, g, y, t, e, h, e, s), 
                    M >= 0 && M <= i)) S(), p--, m = !1, w = 4; else if (d < u && 3 !== w && (M = jl._$rayIntersectExtended$_(c, f, g, y, h, e, h, r, s), 
                    M >= 0 && M <= i)) S(), d++, m = !1, w = 1; else if (d > 0 && 1 !== w && (M = jl._$rayIntersectExtended$_(c, f, g, y, t, e, t, r, s), 
                    M >= 0 && M <= i)) S(), d--, m = !0, w = 3; else {
                        if (!(p < l && 4 !== w && (M = jl._$rayIntersectExtended$_(c, f, g, y, t, r, h, r, s), 
                        M >= 0 && M <= i))) break;
                        S(), p++, m = !0, w = 2;
                    }
                }
            }
            return jl._$New$_(jl._$CollisionPoly$_, n);
        }
        _$TransformCollisionPoly$_(t, s) {
            const i = this._$_TransformPolyPoints$_(t);
            this._$_SimplifyPoly$_(i), s._$setPoints$_(i);
        }
        _$_TransformPolyPoints$_(t) {
            const s = [], i = t._$pointsArr$_();
            for (let t = 0, e = i.length; t < e; t += 2) {
                const e = i[t], n = i[t + 1], [h, r] = this._$TransformPoint$_(e, n);
                s.push(h, r);
            }
            return s;
        }
        _$TransformPoint$_(t, s) {
            const i = this._$GetHSize$_() - 1, e = this._$GetVSize$_() - 1, n = 1 / i, h = 1 / e, r = jl._$clamp$_(Math.floor(t * i), 0, i - 1), o = jl._$clamp$_(Math.floor(s * e), 0, e - 1), a = r * n, u = o * h, l = (r + 1) * n, c = (o + 1) * h, f = this._$GetMeshPointAt$_(r, o), d = this._$GetMeshPointAt$_(r + 1, o + 1), p = jl._$isPointInTriangleInclusive$_(t, s, a, u, l, u, l, c), m = p ? a + n : a, g = p ? u : u + h, y = this._$GetMeshPointAt$_(r + (p ? 1 : 0), o + (p ? 0 : 1)), [M, w, S] = jl._$triangleCartesianToBarycentric$_(t, s, a, u, m, g, l, c);
            return jl._$triangleBarycentricToCartesian3d$_(M, w, S, f._$GetX$_(), f._$GetY$_(), f._$GetZElevation$_(), y._$GetX$_(), y._$GetY$_(), y._$GetZElevation$_(), d._$GetX$_(), d._$GetY$_(), d._$GetZElevation$_());
        }
        _$_SimplifyPoly$_(t) {
            const s = [], i = 1e-7;
            let e = t[0], n = t[1], h = e - t.at(-2), r = n - t.at(-1);
            for (let o = 0, a = t.length; o < a; o += 2) {
                const u = (o + 2) % a, l = t[u], c = t[u + 1], f = l - e, d = c - n, p = Math.abs(f) < i && Math.abs(h) < i && Math.sign(d) === Math.sign(r), m = Math.abs(d) < i && Math.abs(r) < i && Math.sign(f) === Math.sign(h);
                (!p && !m && Math.abs(f / h - d / r) > .001 || 0 == f && 0 === d) && s.push(e, n), 
                e = l, n = c, h = f, r = d;
            }
            s.length >= 6 && s.length < t.length && jl._$shallowAssignArray$_(t, s);
        }
        _$SaveToJson$_() {
            return {
                cols: this._$GetHSize$_(),
                rows: this._$GetVSize$_(),
                points: this._$_pts$_.map((t => t.map((t => t._$SaveToJson$_()))))
            };
        }
        _$LoadFromJson$_(t) {
            const s = this._$GetHSize$_(), i = this._$GetVSize$_();
            if (t.cols !== s || t.rows !== i) throw new Error("mesh data wrong size");
            const e = t.points;
            for (let t = 0; t < i; ++t) {
                const i = e[t];
                for (let e = 0; e < s; ++e) this._$GetMeshPointAt$_(e, t)._$LoadFromJson$_(i[e]);
            }
        }
    };
}

{
    let zl = function(t, s) {
        let i, e, n, h;
        switch (t) {
          case "rgba8":
            i = s.RGBA8, e = s.RGBA, n = s.RGBA, h = s.UNSIGNED_BYTE;
            break;

          case "rgb8":
            i = s.RGB8, e = s.RGB, n = s.RGB, h = s.UNSIGNED_BYTE;
            break;

          case "rgba4":
            i = s.RGBA4, e = s.RGBA, n = s.RGBA, h = s.UNSIGNED_SHORT_4_4_4_4;
            break;

          case "rgb5_a1":
            i = s.RGB5_A1, e = s.RGBA, n = s.RGBA, h = s.UNSIGNED_SHORT_5_5_5_1;
            break;

          case "rgb565":
            i = s.RGB565, e = s.RGB, n = s.RGB, h = s.UNSIGNED_SHORT_5_6_5;
            break;

          default:
            throw new Error("invalid pixel format");
        }
        return {
            _$sizedinternalformat$_: i,
            _$internalformat$_: e,
            format: n,
            type: h
        };
    };
    0;
    const Ul = self._$C3$_, Wl = new Set([ "rgba8", "rgb8", "rgba4", "rgb5_a1", "rgb565" ]), Jl = new Set([ "nearest", "bilinear", "trilinear" ]), Ql = new Set([ "default", "low", "high" ]), Yl = new Set([ "clamp-to-edge", "repeat", "mirror-repeat" ]), Vl = {
        _$wrapX$_: "clamp-to-edge",
        _$wrapY$_: "clamp-to-edge",
        _$sampling$_: "trilinear",
        _$anisotropy$_: 0,
        _$pixelFormat$_: "rgba8",
        _$mipMap$_: !0,
        _$mipMapQuality$_: "default",
        _$premultiplyAlpha$_: !0,
        _$isSvg$_: !1,
        width: -1,
        height: -1
    }, Hl = {
        _$premultiplyAlpha$_: !0,
        flipY: !1
    }, ql = new Set;
    Ul._$Gfx$_._$WebGLRendererTexture$_ = class {
        constructor(t) {
            this._$_renderer$_ = t, this._$_texture$_ = null, this._$_width$_ = 0, this._$_height$_ = 0, 
            this._$_isStatic$_ = !0, this._$_wrapX$_ = "clamp-to-edge", this._$_wrapY$_ = "clamp-to-edge", 
            this._$_sampling$_ = "trilinear", this._$_anisotropy$_ = 0, this._$_pixelFormat$_ = "rgba8", 
            this._$_isMipMapped$_ = !1, this._$_mipMapQuality$_ = "default", this._$_refCount$_ = 0;
        }
        _$_CreateStatic$_(t, s) {
            if (!("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap || "undefined" != typeof OffscreenCanvas && t instanceof OffscreenCanvas || t instanceof ImageData || t instanceof ArrayBuffer || null === t)) throw new Error("invalid texture source");
            if (s = Object.assign({}, Vl, s), this._$_texture$_) throw new Error("already created texture");
            if (this._$_wrapX$_ = s._$wrapX$_, this._$_wrapY$_ = s._$wrapY$_, this._$_sampling$_ = s._$sampling$_, 
            this._$_anisotropy$_ = s._$anisotropy$_, this._$_pixelFormat$_ = s._$pixelFormat$_, 
            this._$_isMipMapped$_ = !!s._$mipMap$_ && this._$_renderer$_._$AreMipmapsEnabled$_(), 
            this._$_mipMapQuality$_ = s._$mipMapQuality$_, !Yl.has(this._$_wrapX$_) || !Yl.has(this._$_wrapY$_)) throw new Error("invalid wrap mode");
            if (!Jl.has(this._$_sampling$_)) throw new Error("invalid sampling");
            if (!Wl.has(this._$_pixelFormat$_)) throw new Error("invalid pixel format");
            if (!Ql.has(this._$_mipMapQuality$_)) throw new Error("invalid mipmap quality");
            if (this._$_isStatic$_ = !0, t instanceof ArrayBuffer || null === t || s._$isSvg$_) {
                if (this._$_width$_ = s.width, this._$_height$_ = s.height, t instanceof ArrayBuffer && t.byteLength !== this._$_width$_ * this._$_height$_ * 4) throw new Error("ArrayBuffer wrong size");
            } else this._$_width$_ = t.width, this._$_height$_ = t.height;
            if (this._$_width$_ <= 0 || this._$_height$_ <= 0) throw new Error("invalid texture data size");
            if (s._$isSvg$_) {
                const s = Ul._$CreateCanvas$_(this._$_width$_, this._$_height$_);
                s.getContext("2d").drawImage(t, 0, 0, this._$_width$_, this._$_height$_), t = s;
            }
            const i = Ul._$isPOT$_(this._$_width$_) && Ul._$isPOT$_(this._$_height$_), e = this._$_renderer$_._$GetMaxTextureSize$_();
            if (this._$_width$_ > e || this._$_height$_ > e) throw new Error("texture data exceeds maximum texture size");
            const n = this._$_renderer$_._$GetContext$_(), h = this._$_renderer$_._$GetWebGLVersionNumber$_();
            this._$_texture$_ = n.createTexture(), n.bindTexture(n.TEXTURE_2D, this._$_texture$_), 
            n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, s._$premultiplyAlpha$_), n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, !1);
            const r = zl(this._$_pixelFormat$_, n);
            if (this._$_renderer$_._$SupportsNPOTTextures$_() || i || !this._$_IsTiled$_()) if (h >= 2) {
                let s;
                s = this._$_isMipMapped$_ ? Math.floor(Math.log2(Math.max(this._$_width$_, this._$_height$_)) + 1) : 1, 
                n.texStorage2D(n.TEXTURE_2D, s, r._$sizedinternalformat$_, this._$_width$_, this._$_height$_), 
                t instanceof ArrayBuffer ? n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, this._$_width$_, this._$_height$_, r.format, r.type, new Uint8Array(t)) : null !== t && n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, r.format, r.type, t);
            } else t instanceof ArrayBuffer ? n.texImage2D(n.TEXTURE_2D, 0, r._$internalformat$_, this._$_width$_, this._$_height$_, 0, r.format, r.type, new Uint8Array(t)) : null === t ? n.texImage2D(n.TEXTURE_2D, 0, r._$internalformat$_, this._$_width$_, this._$_height$_, 0, r.format, r.type, null) : n.texImage2D(n.TEXTURE_2D, 0, r._$internalformat$_, r.format, r.type, t); else {
                if (null === t) throw new Error("cannot pass null data when creating a NPOT tiled texture without NPOT support");
                if (t instanceof ArrayBuffer && (t = new ImageData(new Uint8ClampedArray(t), this._$_width$_, this._$_height$_)), 
                t instanceof ImageData) {
                    const s = Ul._$CreateCanvas$_(this._$_width$_, this._$_height$_);
                    s.getContext("2d").putImageData(t, 0, 0), t = s;
                }
                const s = Ul._$CreateCanvas$_(Ul._$nextHighestPowerOfTwo$_(this._$_width$_), Ul._$nextHighestPowerOfTwo$_(this._$_height$_)), i = s.getContext("2d");
                i.imageSmoothingEnabled = "nearest" !== this._$_sampling$_, i.drawImage(t, 0, 0, this._$_width$_, this._$_height$_, 0, 0, s.width, s.height), 
                n.texImage2D(n.TEXTURE_2D, 0, r._$internalformat$_, r.format, r.type, s);
            }
            null !== t && this._$_SetTextureParameters$_(n), n.bindTexture(n.TEXTURE_2D, null), 
            this._$_renderer$_._$_ResetLastTexture$_(), this._$_refCount$_ = 1, ql.add(this);
        }
        _$_CreateDynamic$_(t, s, i) {
            if (i = Object.assign({}, Vl, i), this._$_texture$_) throw new Error("already created texture");
            if (this._$_wrapX$_ = i._$wrapX$_, this._$_wrapY$_ = i._$wrapY$_, this._$_sampling$_ = i._$sampling$_, 
            this._$_pixelFormat$_ = i._$pixelFormat$_, this._$_isMipMapped$_ = !!i._$mipMap$_ && this._$_renderer$_._$AreMipmapsEnabled$_(), 
            this._$_mipMapQuality$_ = i._$mipMapQuality$_, !Yl.has(this._$_wrapX$_) || !Yl.has(this._$_wrapY$_)) throw new Error("invalid wrap mode");
            if (!Jl.has(this._$_sampling$_)) throw new Error("invalid sampling");
            if (!Wl.has(this._$_pixelFormat$_)) throw new Error("invalid pixel format");
            if (!Ql.has(this._$_mipMapQuality$_)) throw new Error("invalid mipmap quality");
            this._$_isStatic$_ = !1, this._$_width$_ = Math.floor(t), this._$_height$_ = Math.floor(s);
            const e = Ul._$isPOT$_(this._$_width$_) && Ul._$isPOT$_(this._$_height$_), n = this._$_renderer$_._$GetMaxTextureSize$_();
            if (this._$_width$_ <= 0 || this._$_height$_ <= 0) throw new Error("invalid texture size");
            if (this._$_width$_ > n || this._$_height$_ > n) throw new Error("texture exceeds maximum texture size");
            if (!this._$_renderer$_._$SupportsNPOTTextures$_() && this._$_IsTiled$_() && !e) throw new Error("non-power-of-two tiled textures not supported");
            const h = this._$_renderer$_._$GetContext$_(), r = this._$_renderer$_._$GetWebGLVersionNumber$_();
            this._$_texture$_ = h.createTexture(), h.bindTexture(h.TEXTURE_2D, this._$_texture$_), 
            h.pixelStorei(h.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i._$premultiplyAlpha$_), h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL, !1);
            const o = zl(this._$_pixelFormat$_, h), a = r >= 2 ? o._$sizedinternalformat$_ : o._$internalformat$_;
            h.texImage2D(h.TEXTURE_2D, 0, a, this._$_width$_, this._$_height$_, 0, o.format, o.type, null), 
            this._$_SetTextureParameters$_(h), h.bindTexture(h.TEXTURE_2D, null), this._$_renderer$_._$_ResetLastTexture$_(), 
            this._$_refCount$_ = 1, ql.add(this);
        }
        _$_GetMipMapHint$_(t) {
            if ("default" === this._$_mipMapQuality$_) return this._$_isStatic$_ ? t.NICEST : t.FASTEST;
            if ("low" === this._$_mipMapQuality$_) return t.FASTEST;
            if ("high" === this._$_mipMapQuality$_) return t.NICEST;
            throw new Error("invalid mipmap quality");
        }
        _$_IsTiled$_() {
            return "clamp-to-edge" !== this._$_wrapX$_ || "clamp-to-edge" !== this._$_wrapY$_;
        }
        _$_GetTextureWrapMode$_(t, s) {
            if ("clamp-to-edge" === s) return t.CLAMP_TO_EDGE;
            if ("repeat" === s) return t.REPEAT;
            if ("mirror-repeat" === s) return t.MIRRORED_REPEAT;
            throw new Error("invalid wrap mode");
        }
        _$_SetTextureParameters$_(t) {
            const s = Ul._$isPOT$_(this._$_width$_) && Ul._$isPOT$_(this._$_height$_);
            if (t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, this._$_GetTextureWrapMode$_(t, this._$_wrapX$_)), 
            t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, this._$_GetTextureWrapMode$_(t, this._$_wrapY$_)), 
            "nearest" === this._$_sampling$_) t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST), 
            t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), this._$_isMipMapped$_ = !1; else if (t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.LINEAR), 
            (s || this._$_renderer$_._$SupportsNPOTTextures$_()) && this._$_isMipMapped$_) {
                t.hint(t.GENERATE_MIPMAP_HINT, this._$_GetMipMapHint$_(t)), t.generateMipmap(t.TEXTURE_2D);
                const s = "trilinear" === this._$_sampling$_ && !this._$_renderer$_._$HasMajorPerformanceCaveat$_();
                t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, s ? t.LINEAR_MIPMAP_LINEAR : t.LINEAR_MIPMAP_NEAREST);
            } else t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), this._$_isMipMapped$_ = !1;
            const i = this._$_renderer$_._$_GetAnisotropicExtension$_();
            i && this._$_anisotropy$_ > 0 && "nearest" !== this._$_sampling$_ && t.texParameterf(t.TEXTURE_2D, i.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(this._$_anisotropy$_, this._$_renderer$_._$_GetMaxAnisotropy$_()));
        }
        _$_Update$_(t, s) {
            if (!("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLVideoElement && t instanceof HTMLVideoElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap || "undefined" != typeof OffscreenCanvas && t instanceof OffscreenCanvas || t instanceof ImageData)) throw new Error("invalid texture source");
            if (!this._$_texture$_ || this._$_refCount$_ <= 0) throw new Error("texture not created");
            if (this._$_isStatic$_) throw new Error("cannot update static texture");
            s = Object.assign({}, Hl, s);
            const i = t.width || t.videoWidth, e = t.height || t.videoHeight, n = this._$_renderer$_._$GetWebGLVersionNumber$_(), h = this._$_renderer$_._$GetContext$_();
            h.bindTexture(h.TEXTURE_2D, this._$_texture$_), h.pixelStorei(h.UNPACK_PREMULTIPLY_ALPHA_WEBGL, s._$premultiplyAlpha$_), 
            h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL, !!s.flipY);
            const r = zl(this._$_pixelFormat$_, h), o = n >= 2 ? r._$sizedinternalformat$_ : r._$internalformat$_;
            try {
                if (this._$_width$_ === i && this._$_height$_ === e) {
                    const s = Ul._$isPOT$_(this._$_width$_) && Ul._$isPOT$_(this._$_height$_);
                    h.texSubImage2D(h.TEXTURE_2D, 0, 0, 0, r.format, r.type, t), (s || this._$_renderer$_._$SupportsNPOTTextures$_()) && this._$_isMipMapped$_ && (h.hint(h.GENERATE_MIPMAP_HINT, this._$_GetMipMapHint$_(h)), 
                    h.generateMipmap(h.TEXTURE_2D));
                } else {
                    this._$_width$_ = i, this._$_height$_ = e;
                    const s = Ul._$isPOT$_(this._$_width$_) && Ul._$isPOT$_(this._$_height$_);
                    if (!this._$_renderer$_._$SupportsNPOTTextures$_() && this._$_IsTiled$_() && !s) throw new Error("non-power-of-two tiled textures not supported");
                    h.texImage2D(h.TEXTURE_2D, 0, o, r.format, r.type, t), (s || this._$_renderer$_._$SupportsNPOTTextures$_()) && this._$_isMipMapped$_ && (h.hint(h.GENERATE_MIPMAP_HINT, this._$_GetMipMapHint$_(h)), 
                    h.generateMipmap(h.TEXTURE_2D));
                }
            } catch (t) {
                console.error("Error updating WebGL texture: ", t);
            }
            h.bindTexture(h.TEXTURE_2D, null), this._$_renderer$_._$_ResetLastTexture$_();
        }
        _$_Delete$_() {
            if (this._$_refCount$_ > 0) throw new Error("texture still has references");
            if (!this._$_texture$_) throw new Error("already deleted texture");
            ql.delete(this), this._$_renderer$_._$GetContext$_().deleteTexture(this._$_texture$_), 
            this._$_texture$_ = null;
        }
        _$IsValid$_() {
            return !!this._$_texture$_;
        }
        _$_GetTexture$_() {
            return this._$_texture$_;
        }
        _$GetRenderer$_() {
            return this._$_renderer$_;
        }
        _$AddReference$_() {
            this._$_refCount$_++;
        }
        _$SubtractReference$_() {
            if (this._$_refCount$_ <= 0) throw new Error("no more references");
            this._$_refCount$_--;
        }
        _$GetReferenceCount$_() {
            return this._$_refCount$_;
        }
        _$GetWidth$_() {
            return this._$_width$_;
        }
        _$GetHeight$_() {
            return this._$_height$_;
        }
        _$IsStatic$_() {
            return this._$_isStatic$_;
        }
        _$GetEstimatedMemoryUsage$_() {
            let t = this._$_width$_ * this._$_height$_;
            switch (this._$_pixelFormat$_) {
              case "rgba8":
                t *= 4;
                break;

              case "rgb8":
                t *= 3;
                break;

              case "rgba4":
              case "rgb5_a1":
              case "rgb565":
                t *= 2;
            }
            return this._$_isMipMapped$_ && (t += Math.floor(t / 3)), t;
        }
        static _$OnContextLost$_() {
            ql.clear();
        }
        static _$allTextures$_() {
            return ql.values();
        }
    };
}

{
    const Xl = self._$C3$_, Zl = (self.assert, self._$glMatrix$_), Kl = (Zl._$vec3$_, 
    Zl._$mat4$_), $l = new Set([ "nearest", "bilinear", "trilinear" ]), tc = {
        _$sampling$_: "trilinear",
        alpha: !0,
        depth: !1,
        _$isSampled$_: !0,
        _$isDefaultSize$_: !0,
        _$multisampling$_: 0
    }, sc = new Set;
    Xl._$Gfx$_._$WebGLRenderTarget$_ = class {
        constructor(t) {
            this._$_renderer$_ = t, this._$_frameBuffer$_ = null, this._$_frameBufferNoDepth$_ = null, 
            this._$_texture$_ = null, this._$_renderBuffer$_ = null, this._$_width$_ = 0, this._$_height$_ = 0, 
            this._$_isDefaultSize$_ = !0, this._$_sampling$_ = "trilinear", this._$_alpha$_ = !0, 
            this._$_depth$_ = !1, this._$_isSampled$_ = !0, this._$_multisampling$_ = 0, this._$_projectionMatrix$_ = Kl.create(), 
            this._$_lastFov$_ = 0, this._$_lastNearZ$_ = 0, this._$_lastFarZ$_ = 0;
        }
        _$_Create$_(t, s, i) {
            i = Object.assign({}, tc, i);
            const e = this._$_renderer$_._$GetWebGLVersionNumber$_();
            if (this._$_texture$_ || this._$_renderBuffer$_) throw new Error("already created render target");
            if (this._$_sampling$_ = i._$sampling$_, this._$_alpha$_ = !!i.alpha, this._$_depth$_ = !!i.depth, 
            this._$_isSampled$_ = !!i._$isSampled$_, this._$_isDefaultSize$_ = !!i._$isDefaultSize$_, 
            this._$_multisampling$_ = i._$multisampling$_, !$l.has(this._$_sampling$_)) throw new Error("invalid sampling");
            if (this._$_multisampling$_ > 0 && (e < 2 || this._$_isSampled$_)) throw new Error("invalid use of multisampling");
            if (e < 2 && (this._$_isSampled$_ = !0), this._$_width$_ = t, this._$_height$_ = s, 
            this._$_width$_ <= 0 || this._$_height$_ <= 0) throw new Error("invalid render target size");
            this._$_CalculateProjection$_();
            const n = this._$_renderer$_._$GetContext$_();
            if (this._$_frameBuffer$_ = n.createFramebuffer(), this._$_depth$_ && (this._$_frameBufferNoDepth$_ = n.createFramebuffer()), 
            this._$_isSampled$_) {
                this._$_texture$_ = this._$_renderer$_._$CreateDynamicTexture$_(this._$_width$_, this._$_height$_, {
                    _$sampling$_: this._$_sampling$_,
                    _$pixelFormat$_: this._$_alpha$_ ? "rgba8" : "rgb8",
                    _$mipMap$_: !1
                });
                const t = this._$_texture$_._$_GetTexture$_();
                n.bindFramebuffer(n.FRAMEBUFFER, this._$_frameBuffer$_), n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, t, 0), 
                this._$_depth$_ && (n.bindFramebuffer(n.FRAMEBUFFER, this._$_frameBufferNoDepth$_), 
                n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, t, 0));
            } else {
                this._$_renderBuffer$_ = n.createRenderbuffer(), n.bindRenderbuffer(n.RENDERBUFFER, this._$_renderBuffer$_);
                const t = this._$_alpha$_ ? n.RGBA8 : n.RGB8;
                if (this._$_multisampling$_ > 0) {
                    const s = n.getInternalformatParameter(n.RENDERBUFFER, t, n.SAMPLES);
                    if (s && s[0]) {
                        const t = s[0];
                        this._$_multisampling$_ > t && (this._$_multisampling$_ = t);
                    } else this._$_multisampling$_ = 0;
                }
                0 === this._$_multisampling$_ ? n.renderbufferStorage(n.RENDERBUFFER, t, this._$_width$_, this._$_height$_) : n.renderbufferStorageMultisample(n.RENDERBUFFER, this._$_multisampling$_, t, this._$_width$_, this._$_height$_), 
                n.bindFramebuffer(n.FRAMEBUFFER, this._$_frameBuffer$_), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, this._$_renderBuffer$_), 
                this._$_depth$_ && (n.bindFramebuffer(n.FRAMEBUFFER, this._$_frameBufferNoDepth$_), 
                n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, this._$_renderBuffer$_)), 
                n.bindRenderbuffer(n.RENDERBUFFER, null);
            }
            const h = this._$_renderer$_._$_GetDepthBuffer$_();
            this._$_depth$_ && h && (n.bindFramebuffer(n.FRAMEBUFFER, this._$_frameBuffer$_), 
            this._$_renderer$_._$_CanSampleDepth$_() ? n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, h, 0) : n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, h)), 
            n.bindFramebuffer(n.FRAMEBUFFER, null), sc.add(this);
        }
        _$_Resize$_(t, s) {
            if (this._$_width$_ === t && this._$_height$_ === s) return;
            this._$_width$_ = t, this._$_height$_ = s, this._$_CalculateProjection$_();
            const i = this._$_renderer$_._$GetContext$_();
            i.bindFramebuffer(i.FRAMEBUFFER, this._$_frameBuffer$_), this._$_texture$_ ? this._$_texture$_._$_Update$_(new ImageData(this._$_width$_, this._$_height$_)) : (i.bindRenderbuffer(i.RENDERBUFFER, this._$_renderBuffer$_), 
            i.renderbufferStorage(i.RENDERBUFFER, this._$_alpha$_ ? i.RGBA8 : i.RGB8, this._$_width$_, this._$_height$_), 
            i.bindRenderbuffer(i.RENDERBUFFER, null));
            const e = this._$_renderer$_._$_GetDepthBuffer$_();
            this._$_depth$_ && e && (this._$_renderer$_._$_CanSampleDepth$_() ? i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.TEXTURE_2D, e, 0) : i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.RENDERBUFFER, e)), 
            i.bindFramebuffer(i.FRAMEBUFFER, null);
        }
        _$_Delete$_() {
            if (!this._$_texture$_ && !this._$_renderBuffer$_) throw new Error("already deleted render target");
            sc.delete(this);
            const t = this._$_renderer$_._$GetContext$_();
            this._$_texture$_ ? (t.bindFramebuffer(t.FRAMEBUFFER, this._$_frameBuffer$_), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, null, 0), 
            this._$_depth$_ && (t.bindFramebuffer(t.FRAMEBUFFER, this._$_frameBufferNoDepth$_), 
            t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, null, 0)), 
            this._$_renderer$_._$DeleteTexture$_(this._$_texture$_), this._$_texture$_ = null) : this._$_renderBuffer$_ && (t.bindFramebuffer(t.FRAMEBUFFER, this._$_frameBuffer$_), 
            t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, null), 
            this._$_depth$_ && (t.bindFramebuffer(t.FRAMEBUFFER, this._$_frameBufferNoDepth$_), 
            t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, null)), 
            t.deleteRenderbuffer(this._$_renderBuffer$_), this._$_renderBuffer$_ = null), t.bindFramebuffer(t.FRAMEBUFFER, null), 
            this._$_renderer$_._$GetWebGLVersionNumber$_() >= 2 && (t.bindFramebuffer(t.READ_FRAMEBUFFER, null), 
            t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null)), t.deleteFramebuffer(this._$_frameBuffer$_), 
            this._$_depth$_ && t.deleteFramebuffer(this._$_frameBufferNoDepth$_);
            const s = this._$_renderer$_._$GetBatchState$_();
            s._$currentFramebuffer$_ = null, s._$currentFramebufferNoDepth$_ = null, this._$_frameBuffer$_ = null;
        }
        _$_CalculateProjection$_() {
            this._$_renderer$_._$CalculatePerspectiveMatrix$_(this._$_projectionMatrix$_, this._$_width$_ / this._$_height$_), 
            this._$_lastFov$_ = this._$_renderer$_._$GetFovY$_(), this._$_lastNearZ$_ = this._$_renderer$_._$GetNearZ$_(), 
            this._$_lastFarZ$_ = this._$_renderer$_._$GetFarZ$_();
        }
        _$_GetFramebuffer$_() {
            return this._$_frameBuffer$_;
        }
        _$_GetFramebufferNoDepth$_() {
            return this._$_frameBufferNoDepth$_;
        }
        _$GetRenderer$_() {
            return this._$_renderer$_;
        }
        _$GetTexture$_() {
            return this._$_texture$_;
        }
        _$GetProjectionMatrix$_() {
            return this._$_renderer$_._$GetFovY$_() === this._$_lastFov$_ && this._$_renderer$_._$GetNearZ$_() === this._$_lastNearZ$_ && this._$_renderer$_._$GetFarZ$_() === this._$_lastFarZ$_ || this._$_CalculateProjection$_(), 
            this._$_projectionMatrix$_;
        }
        _$IsLinearSampling$_() {
            return "nearest" !== this._$_sampling$_;
        }
        _$HasAlpha$_() {
            return this._$_alpha$_;
        }
        _$IsSampled$_() {
            return this._$_isSampled$_;
        }
        _$HasDepthBuffer$_() {
            return this._$_depth$_;
        }
        _$GetWidth$_() {
            return this._$_width$_;
        }
        _$GetHeight$_() {
            return this._$_height$_;
        }
        _$IsDefaultSize$_() {
            return this._$_isDefaultSize$_;
        }
        _$GetMultisampling$_() {
            return this._$_multisampling$_;
        }
        _$GetOptions$_() {
            const t = {
                _$sampling$_: this._$_sampling$_,
                alpha: this._$_alpha$_,
                _$isSampled$_: this._$_isSampled$_
            };
            return this._$_isDefaultSize$_ || (t.width = this._$_width$_, t.height = this._$_height$_), 
            t;
        }
        _$IsCompatibleWithOptions$_(t) {
            return "nearest" !== (t = Object.assign({}, tc, t))._$sampling$_ === this._$IsLinearSampling$_() && !!t.alpha === this._$HasAlpha$_() && !!t.depth === this._$HasDepthBuffer$_() && !(this._$_renderer$_._$GetWebGLVersionNumber$_() >= 2 && !!t._$isSampled$_ !== this._$IsSampled$_()) && ("number" == typeof t.width || "number" == typeof t.height ? !this._$IsDefaultSize$_() && this._$GetWidth$_() === Math.floor(t.width) && this._$GetHeight$_() === Math.floor(t.height) : this._$IsDefaultSize$_());
        }
        _$_GetWebGLTexture$_() {
            return this._$_texture$_ ? this._$_texture$_._$_GetTexture$_() : null;
        }
        _$GetEstimatedMemoryUsage$_() {
            return this._$_texture$_ ? this._$_texture$_._$GetEstimatedMemoryUsage$_() : this._$_width$_ * this._$_height$_ * (this._$_alpha$_ ? 4 : 3);
        }
        static async _$DebugReadPixelsToBlob$_(t, s) {
            const i = await t._$ReadBackRenderTargetToImageData$_(s, !0);
            return await Xl._$ImageDataToBlob$_(i);
        }
        static _$OnContextLost$_() {
            sc.clear();
        }
        static _$allRenderTargets$_() {
            return sc.values();
        }
        static _$ResizeAll$_(t, s) {
            for (const i of sc) i._$IsDefaultSize$_() && i._$_Resize$_(t, s);
        }
    };
}

{
    const ic = self._$C3$_, ec = self._$glMatrix$_, nc = (ec._$vec3$_, ec._$mat4$_, 
    new Set([ "aPos", "aTex", "aPoints", "matP", "matMV", "samplerFront", "samplerBack", "samplerDepth", "destStart", "destEnd", "srcStart", "srcEnd", "srcOriginStart", "srcOriginEnd", "pixelSize", "seconds", "devicePixelRatio", "layerScale", "layerAngle", "layoutStart", "layoutEnd", "color", "color2_", "pointTexStart", "pointTexEnd", "zElevation", "tileSize", "tileSpacing", "outlineThickness", "zNear", "zFar" ]));
    ic._$Gfx$_._$WebGLShaderProgram$_ = class extends ic._$Gfx$_._$ShaderProgramBase$_ {
        static async _$Compile$_(t, s) {
            const i = t._$GetContext$_(), e = s.src, n = s._$vertexSrc$_, h = s.name, r = i.createShader(i.FRAGMENT_SHADER);
            i.shaderSource(r, e), i.compileShader(r);
            const o = i.createShader(i.VERTEX_SHADER);
            i.shaderSource(o, n), i.compileShader(o);
            const a = i.createProgram();
            i.attachShader(a, r), i.attachShader(a, o), i.bindAttribLocation(a, 0, "aPos"), 
            i.bindAttribLocation(a, 1, "aTex"), i.bindAttribLocation(a, 2, "aPoints"), i.linkProgram(a);
            const u = t._$_GetParallelShaderCompileExtension$_();
            if (u ? await t._$_WaitForObjectReady$_((() => i.getProgramParameter(a, u.COMPLETION_STATUS_KHR))) : await ic._$Wait$_(5), 
            !i.getShaderParameter(r, i.COMPILE_STATUS)) {
                const t = i.getShaderInfoLog(r);
                throw i.deleteShader(r), i.deleteShader(o), i.deleteProgram(a), new Error("Error compiling fragment shader: " + t);
            }
            if (!i.getShaderParameter(o, i.COMPILE_STATUS)) {
                const t = i.getShaderInfoLog(o);
                throw i.deleteShader(r), i.deleteShader(o), i.deleteProgram(a), new Error("Error compiling vertex shader: " + t);
            }
            if (!i.getProgramParameter(a, i.LINK_STATUS)) {
                const t = i.getProgramInfoLog(a);
                throw i.deleteShader(r), i.deleteShader(o), i.deleteProgram(a), new Error("Error linking shader program: " + t);
            }
            const l = ic._$FilterUnprintableChars$_(i.getProgramInfoLog(a) || "").trim();
            return l && !ic._$IsStringAllWhitespace$_(l) && console.info(`[WebGL] Shader program '${h}' compilation log: `, l), 
            i.deleteShader(r), i.deleteShader(o), a;
        }
        static async _$Create$_(t, s) {
            const i = await ic._$Gfx$_._$WebGLShaderProgram$_._$Compile$_(t, s);
            return new ic._$Gfx$_._$WebGLShaderProgram$_(t, i, s);
        }
        constructor(t, s, i) {
            super(t, i);
            const e = t._$GetContext$_(), n = t._$GetBatchState$_();
            t._$EndBatch$_(), e.useProgram(s), this._$_gl$_ = e, this._$_shaderProgram$_ = s, 
            this._$_isDeviceTransform$_ = "<default-device-transform>" === i.name;
            const h = e.getAttribLocation(s, "aPos"), r = e.getAttribLocation(s, "aTex");
            this._$_locAPoints$_ = e.getAttribLocation(s, "aPoints"), -1 !== h && (e.bindBuffer(e.ARRAY_BUFFER, t._$_vertexBuffer$_), 
            e.vertexAttribPointer(h, t._$GetNumVertexComponents$_(), e.FLOAT, !1, 0, 0), e.enableVertexAttribArray(h)), 
            -1 !== r && (e.bindBuffer(e.ARRAY_BUFFER, t._$_texcoordBuffer$_), e.vertexAttribPointer(r, 2, e.FLOAT, !1, 0, 0), 
            e.enableVertexAttribArray(r)), -1 !== this._$_locAPoints$_ && (e.bindBuffer(e.ARRAY_BUFFER, t._$_pointBuffer$_), 
            e.vertexAttribPointer(this._$_locAPoints$_, 4, e.FLOAT, !1, 0, 0), e.enableVertexAttribArray(this._$_locAPoints$_)), 
            e.bindBuffer(e.ARRAY_BUFFER, null), this._$_uMatP$_ = new ic._$Gfx$_._$WebGLShaderUniform$_(this, "matP", "mat4"), 
            this._$_uMatMV$_ = new ic._$Gfx$_._$WebGLShaderUniform$_(this, "matMV", "mat4"), 
            this._$_uColor$_ = new ic._$Gfx$_._$WebGLShaderUniform$_(this, "color", "vec4"), 
            this._$_uSamplerFront$_ = new ic._$Gfx$_._$WebGLShaderUniform$_(this, "samplerFront", "sampler"), 
            this._$_uPointTexStart$_ = new ic._$Gfx$_._$WebGLShaderUniform$_(this, "pointTexStart", "vec2"), 
            this._$_uPointTexEnd$_ = new ic._$Gfx$_._$WebGLShaderUniform$_(this, "pointTexEnd", "vec2"), 
            this._$_uZElevation$_ = new ic._$Gfx$_._$WebGLShaderUniform$_(this, "zElevation", "float"), 
            this._$_uTileSize$_ = new ic._$Gfx$_._$WebGLShaderUniform$_(this, "tileSize", "vec2"), 
            this._$_uTileSpacing$_ = new ic._$Gfx$_._$WebGLShaderUniform$_(this, "tileSpacing", "vec2"), 
            this._$_uColor2$_ = new ic._$Gfx$_._$WebGLShaderUniform$_(this, "color2_", "vec4"), 
            this._$_uOutlineThickness$_ = new ic._$Gfx$_._$WebGLShaderUniform$_(this, "outlineThickness", "float"), 
            this._$_uSamplerBack$_ = new ic._$Gfx$_._$WebGLShaderUniform$_(this, "samplerBack", "sampler"), 
            this._$_uSamplerDepth$_ = new ic._$Gfx$_._$WebGLShaderUniform$_(this, "samplerDepth", "sampler"), 
            this._$_uDestStart$_ = new ic._$Gfx$_._$WebGLShaderUniform$_(this, "destStart", "vec2"), 
            this._$_uDestEnd$_ = new ic._$Gfx$_._$WebGLShaderUniform$_(this, "destEnd", "vec2"), 
            this._$_uSrcStart$_ = new ic._$Gfx$_._$WebGLShaderUniform$_(this, "srcStart", "vec2"), 
            this._$_uSrcEnd$_ = new ic._$Gfx$_._$WebGLShaderUniform$_(this, "srcEnd", "vec2"), 
            this._$_uSrcOriginStart$_ = new ic._$Gfx$_._$WebGLShaderUniform$_(this, "srcOriginStart", "vec2"), 
            this._$_uSrcOriginEnd$_ = new ic._$Gfx$_._$WebGLShaderUniform$_(this, "srcOriginEnd", "vec2"), 
            this._$_uPixelSize$_ = new ic._$Gfx$_._$WebGLShaderUniform$_(this, "pixelSize", "vec2"), 
            this._$_uSeconds$_ = new ic._$Gfx$_._$WebGLShaderUniform$_(this, "seconds", "float"), 
            this._$_uDevicePixelRatio$_ = new ic._$Gfx$_._$WebGLShaderUniform$_(this, "devicePixelRatio", "float"), 
            this._$_uLayerScale$_ = new ic._$Gfx$_._$WebGLShaderUniform$_(this, "layerScale", "float"), 
            this._$_uLayerAngle$_ = new ic._$Gfx$_._$WebGLShaderUniform$_(this, "layerAngle", "float"), 
            this._$_uLayoutStart$_ = new ic._$Gfx$_._$WebGLShaderUniform$_(this, "layoutStart", "vec2"), 
            this._$_uLayoutEnd$_ = new ic._$Gfx$_._$WebGLShaderUniform$_(this, "layoutEnd", "vec2"), 
            this._$_uZNear$_ = new ic._$Gfx$_._$WebGLShaderUniform$_(this, "zNear", "float"), 
            this._$_uZFar$_ = new ic._$Gfx$_._$WebGLShaderUniform$_(this, "zFar", "float"), 
            this._$_hasAnyOptionalUniforms$_ = !!(this._$_uPixelSize$_._$IsUsed$_() || this._$_uSeconds$_._$IsUsed$_() || this._$_uSamplerBack$_._$IsUsed$_() || this._$_uDestStart$_._$IsUsed$_() || this._$_uDestEnd$_._$IsUsed$_() || this._$_uSrcStart$_._$IsUsed$_() || this._$_uSrcEnd$_._$IsUsed$_() || this._$_uSrcOriginStart$_._$IsUsed$_() || this._$_uSrcOriginEnd$_._$IsUsed$_() || this._$_uDevicePixelRatio$_._$IsUsed$_() || this._$_uLayerScale$_._$IsUsed$_() || this._$_uLayerAngle$_._$IsUsed$_() || this._$_uLayoutStart$_._$IsUsed$_() || this._$_uLayoutEnd$_._$IsUsed$_());
            const o = i.parameters || [];
            this._$_uCustomParameters$_ = [], this._$_usesAnySrcRectOrPixelSize$_ = this._$_uPixelSize$_._$IsUsed$_() || this._$_uSrcStart$_._$IsUsed$_() || this._$_uSrcEnd$_._$IsUsed$_() || this._$_uSrcOriginStart$_._$IsUsed$_() || this._$_uSrcOriginEnd$_._$IsUsed$_(), 
            this._$_hasCurrentMatP$_ = !1, this._$_hasCurrentMatMV$_ = !1, this._$_uColor$_._$Init4f$_(1, 1, 1, 1), 
            this._$_uColor2$_._$Init4f$_(1, 1, 1, 1), this._$_uSamplerFront$_._$Init1i$_(0), 
            this._$_uSamplerBack$_._$Init1i$_(1), this._$_uSamplerDepth$_._$Init1i$_(2), this._$_uPointTexStart$_._$Init2f$_(0, 0), 
            this._$_uPointTexEnd$_._$Init2f$_(1, 1), this._$_uZElevation$_._$Init1f$_(0), this._$_uTileSize$_._$Init2f$_(0, 0), 
            this._$_uTileSpacing$_._$Init2f$_(0, 0), this._$_uDestStart$_._$Init2f$_(0, 0), 
            this._$_uDestEnd$_._$Init2f$_(1, 1), this._$_uSrcStart$_._$Init2f$_(0, 0), this._$_uSrcEnd$_._$Init2f$_(0, 0), 
            this._$_uSrcOriginStart$_._$Init2f$_(0, 0), this._$_uSrcOriginEnd$_._$Init2f$_(0, 0), 
            this._$_uPixelSize$_._$Init2f$_(0, 0), this._$_uDevicePixelRatio$_._$Init1f$_(1), 
            this._$_uZNear$_._$Init1f$_(t._$GetNearZ$_()), this._$_uZFar$_._$Init1f$_(t._$GetFarZ$_()), 
            this._$_uLayerScale$_._$Init1f$_(1), this._$_uLayerAngle$_._$Init1f$_(0), this._$_uSeconds$_._$Init1f$_(0), 
            this._$_uLayoutStart$_._$Init2f$_(0, 0), this._$_uLayoutEnd$_._$Init2f$_(0, 0), 
            this._$_uOutlineThickness$_._$Init1f$_(1);
            for (const t of o) {
                const s = t[0], i = t[2], e = new ic._$Gfx$_._$WebGLShaderUniform$_(this, s, i);
                "color" === i ? e._$Init3f$_(0, 0, 0) : e._$Init1f$_(0), this._$_uCustomParameters$_.push(e);
            }
            this._$_isDeviceTransform$_ ? this._$_UpdateDeviceTransformUniforms$_(n._$currentMatP$_) : (this._$UpdateMatP$_(n._$currentMatP$_, !0), 
            this._$UpdateMatMV$_(n._$currentMV$_, !0));
            const a = n._$currentShader$_;
            e.useProgram(a ? a._$_shaderProgram$_ : null);
        }
        _$Release$_() {
            this._$_gl$_.deleteProgram(this._$_shaderProgram$_), this._$_shaderProgram$_ = null, 
            this._$_renderer$_._$_RemoveShaderProgram$_(this), this._$_gl$_ = null, super._$Release$_();
        }
        _$GetWebGLContext$_() {
            return this._$_gl$_;
        }
        _$GetShaderProgram$_() {
            return this._$_shaderProgram$_;
        }
        _$GetParameterCount$_() {
            return this._$_uCustomParameters$_.length;
        }
        _$GetParameterType$_(t) {
            return t < 0 || t >= this._$_uCustomParameters$_.length ? null : this._$_uCustomParameters$_[t]._$GetType$_();
        }
        _$AreCustomParametersAlreadySetInBatch$_(t) {
            for (let s = 0, i = t.length; s < i; ++s) if (!this._$_uCustomParameters$_[s]._$IsSetToCustomInBatch$_(t[s])) return !1;
            return !0;
        }
        _$SetCustomParametersInBatch$_(t) {
            for (let s = 0, i = t.length; s < i; ++s) this._$_uCustomParameters$_[s]._$SetBatchValueCustom$_(t[s]);
        }
        _$AreOptionalUniformsAlreadySetInBatch$_(t, s, i, e, n, h, r, o, a, u) {
            return !(this._$_uSamplerBack$_._$IsUsed$_() || this._$_uPixelSize$_._$IsUsed$_() && !this._$_uPixelSize$_._$IsSetTo2InBatch$_(n, h) || this._$_uDestStart$_._$IsUsed$_() && !this._$_uDestStart$_._$IsSetTo2InBatch$_(t._$getLeft$_(), t._$getTop$_()) || this._$_uDestEnd$_._$IsUsed$_() && !this._$_uDestEnd$_._$IsSetTo2InBatch$_(t._$getRight$_(), t._$getBottom$_()) || this._$_uDevicePixelRatio$_._$IsUsed$_() && !this._$_uDevicePixelRatio$_._$IsSetTo1InBatch$_(r) || this._$_uLayerScale$_._$IsUsed$_() && !this._$_uLayerScale$_._$IsSetTo1InBatch$_(o) || this._$_uLayerAngle$_._$IsUsed$_() && !this._$_uLayerAngle$_._$IsSetTo1InBatch$_(a) || this._$_uSrcStart$_._$IsUsed$_() && !this._$_uSrcStart$_._$IsSetTo2InBatch$_(s._$getLeft$_(), s._$getTop$_()) || this._$_uSrcEnd$_._$IsUsed$_() && !this._$_uSrcEnd$_._$IsSetTo2InBatch$_(s._$getRight$_(), s._$getBottom$_()) || this._$_uSrcOriginStart$_._$IsUsed$_() && !this._$_uSrcOriginStart$_._$IsSetTo2InBatch$_(i._$getLeft$_(), i._$getTop$_()) || this._$_uSrcOriginEnd$_._$IsUsed$_() && !this._$_uSrcOriginEnd$_._$IsSetTo2InBatch$_(i._$getRight$_(), i._$getBottom$_()) || this._$_uLayoutStart$_._$IsUsed$_() && !this._$_uLayoutStart$_._$IsSetTo2InBatch$_(e._$getLeft$_(), e._$getTop$_()) || this._$_uLayoutEnd$_._$IsUsed$_() && !this._$_uLayoutEnd$_._$IsSetTo2InBatch$_(e._$getTop$_(), e._$getBottom$_()) || this._$_uSeconds$_._$IsUsed$_() && !this._$_uSeconds$_._$IsSetTo1InBatch$_(u));
        }
        _$SetOptionalUniformsInBatch$_(t, s, i, e, n, h, r, o, a, u) {
            this._$_uSamplerBack$_._$IsUsed$_() || (this._$_uPixelSize$_._$IsUsed$_() && this._$_uPixelSize$_._$SetBatch2$_(n, h), 
            this._$_uDestStart$_._$IsUsed$_() && this._$_uDestStart$_._$SetBatch2$_(t._$getLeft$_(), t._$getTop$_()), 
            this._$_uDestEnd$_._$IsUsed$_() && this._$_uDestEnd$_._$SetBatch2$_(t._$getRight$_(), t._$getBottom$_()), 
            this._$_uDevicePixelRatio$_._$IsUsed$_() && this._$_uDevicePixelRatio$_._$SetBatch1$_(r), 
            this._$_uLayerScale$_._$IsUsed$_() && this._$_uLayerScale$_._$SetBatch1$_(o), this._$_uLayerAngle$_._$IsUsed$_() && this._$_uLayerAngle$_._$SetBatch1$_(a), 
            this._$_uSrcStart$_._$IsUsed$_() && this._$_uSrcStart$_._$SetBatch2$_(s._$getLeft$_(), s._$getTop$_()), 
            this._$_uSrcEnd$_._$IsUsed$_() && this._$_uSrcEnd$_._$SetBatch2$_(s._$getRight$_(), s._$getBottom$_()), 
            this._$_uSrcOriginStart$_._$IsUsed$_() && this._$_uSrcOriginStart$_._$SetBatch2$_(i._$getLeft$_(), i._$getTop$_()), 
            this._$_uSrcOriginEnd$_._$IsUsed$_() && this._$_uSrcOriginEnd$_._$SetBatch2$_(i._$getRight$_(), i._$getBottom$_()), 
            this._$_uLayoutStart$_._$IsUsed$_() && this._$_uLayoutStart$_._$SetBatch2$_(e._$getLeft$_(), e._$getTop$_()), 
            this._$_uLayoutEnd$_._$IsUsed$_() && this._$_uLayoutEnd$_._$SetBatch2$_(e._$getTop$_(), e._$getBottom$_()), 
            this._$_uSeconds$_._$IsUsed$_() && this._$_uSeconds$_._$SetBatch1$_(u));
        }
        _$UpdateMatP$_(t, s) {
            this._$_hasCurrentMatP$_ && !s || this._$_isDeviceTransform$_ || (this._$_uMatP$_._$IsUsed$_() && this._$_uMatP$_._$UpdateMatrix4fv$_(t), 
            this._$_hasCurrentMatP$_ = !0);
        }
        _$SetMatPStale$_() {
            this._$_hasCurrentMatP$_ = !1;
        }
        _$UpdateMatMV$_(t, s) {
            this._$_hasCurrentMatMV$_ && !s || this._$_isDeviceTransform$_ || (this._$_uMatMV$_._$IsUsed$_() && this._$_uMatMV$_._$UpdateMatrix4fv$_(t), 
            this._$_hasCurrentMatMV$_ = !0);
        }
        _$SetMatMVStale$_() {
            this._$_hasCurrentMatMV$_ = !1;
        }
        _$_UpdateDeviceTransformUniforms$_(t) {
            if (!this._$_isDeviceTransform$_) throw new Error("not device transform shader");
            this._$_uMatP$_._$UpdateMatrix4fv$_(t);
            const s = this._$_renderer$_, i = s._$GetWidth$_() / 2, e = s._$GetHeight$_() / 2, n = s._$CalculateLookAtModelView2$_(i, e, s._$GetDefaultCameraZ$_(s._$GetHeight$_()), i, e, 0, s._$GetHeight$_());
            this._$_uMatMV$_._$UpdateMatrix4fv$_(n);
        }
        _$UpdateColor$_(t) {
            this._$_uColor$_._$IsUsed$_() && this._$_uColor$_._$Update4f$_(t[0], t[1], t[2], t[3]);
        }
        static _$GetReservedUniformNames$_() {
            return nc;
        }
        static _$_GetConservativeDepthShaderPrefix$_(t) {
            return t ? "\n#extension GL_EXT_conservative_depth : enable\nlayout (depth_greater) out highp float gl_FragDepth;\n\t" : "";
        }
        static _$GetDefaultVertexShaderSource$_(t) {
            const s = t ? "highmedp" : "mediump";
            return [ "#ifdef GL_FRAGMENT_PRECISION_HIGH", "#define highmedp highp", "#else", "#define highmedp mediump", "#endif", "attribute highp vec3 aPos;", `attribute ${s} vec2 aTex;`, `varying ${s} vec2 vTex;`, "uniform highp mat4 matP;", "uniform highp mat4 matMV;", "void main(void) {", "\tgl_Position = matP * matMV * vec4(aPos, 1.0);", "\tvTex = aTex;", "}" ].join("\n");
        }
        static _$GetDefaultVertexShaderSource_WebGL2$_(t) {
            const s = t ? "highp" : "mediump";
            return [ "#version 300 es", "in highp vec3 aPos;", `in ${s} vec2 aTex;`, `out ${s} vec2 vTex;`, "uniform highp mat4 matP;", "uniform highp mat4 matMV;", "void main(void) {", "\tgl_Position = matP * matMV * vec4(aPos, 1.0);", "\tvTex = aTex;", "}" ].join("\n");
        }
        static _$GetTextureFillFragmentShaderSource_WebGL1_NoFragDepth$_() {
            return [ "varying mediump vec2 vTex;", "uniform lowp vec4 color;", "uniform lowp sampler2D samplerFront;", "void main(void) {", "\tgl_FragColor = texture2D(samplerFront, vTex) * color;", "}" ].join("\n");
        }
        static _$GetTextureFillFragmentShaderSource_WebGL1_FragDepthEXT$_() {
            return [ "#extension GL_EXT_frag_depth : enable", "varying mediump vec2 vTex;", "uniform lowp vec4 color;", "uniform lowp sampler2D samplerFront;", "void main(void) {", "\tgl_FragColor = texture2D(samplerFront, vTex) * color;", "\tgl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}" ].join("\n");
        }
        static _$GetTextureFillFragmentShaderSource_WebGL2$_(t) {
            return [ "#version 300 es", ic._$Gfx$_._$WebGLShaderProgram$_._$_GetConservativeDepthShaderPrefix$_(t), "in mediump vec2 vTex;", "out lowp vec4 outColor;", "uniform lowp vec4 color;", "uniform lowp sampler2D samplerFront;", "void main(void) {", "\toutColor = texture(samplerFront, vTex) * color;", "\tgl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}" ].join("\n");
        }
        static _$GetTilemapFragmentShaderSource_WebGL1_NoFragDepth$_() {
            return [ "#ifdef GL_FRAGMENT_PRECISION_HIGH", "#define highmedp highp", "#else", "#define highmedp mediump", "#endif", "varying highmedp vec2 vTex;", "uniform lowp vec4 color;", "uniform lowp sampler2D samplerFront;", "uniform highmedp vec2 srcStart;", "uniform highmedp vec2 pixelSize;", "uniform highmedp vec2 tileSize;", "uniform highmedp vec2 tileSpacing;", "void main(void) {", "\thighmedp vec2 tile = floor(vTex);", "\thighmedp vec2 tex = fract(vTex);", "\thighmedp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);", "\thighmedp vec2 lowerBound = tileOrigin + pixelSize / 2.0;", "\thighmedp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;", "\tgl_FragColor = texture2D(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * color;", "}" ].join("\n");
        }
        static _$GetTilemapFragmentShaderSource_WebGL1_FragDepthEXT$_() {
            return [ "#extension GL_EXT_frag_depth : enable", "#ifdef GL_FRAGMENT_PRECISION_HIGH", "#define highmedp highp", "#else", "#define highmedp mediump", "#endif", "varying highmedp vec2 vTex;", "uniform lowp vec4 color;", "uniform lowp sampler2D samplerFront;", "uniform highmedp vec2 srcStart;", "uniform highmedp vec2 pixelSize;", "uniform highmedp vec2 tileSize;", "uniform highmedp vec2 tileSpacing;", "void main(void) {", "\thighmedp vec2 tile = floor(vTex);", "\thighmedp vec2 tex = fract(vTex);", "\thighmedp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);", "\thighmedp vec2 lowerBound = tileOrigin + pixelSize / 2.0;", "\thighmedp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;", "\tgl_FragColor = texture2D(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * color;", "\tgl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}" ].join("\n");
        }
        static _$GetTilemapFragmentShaderSource_WebGL2$_(t) {
            return [ "#version 300 es", ic._$Gfx$_._$WebGLShaderProgram$_._$_GetConservativeDepthShaderPrefix$_(t), "in highp vec2 vTex;", "out lowp vec4 outColor;", "uniform lowp vec4 color;", "uniform lowp sampler2D samplerFront;", "uniform highp vec2 srcStart;", "uniform highp vec2 pixelSize;", "uniform highp vec2 tileSize;", "uniform highp vec2 tileSpacing;", "void main(void) {", "\thighp vec2 tile = floor(vTex);", "\thighp vec2 tex = fract(vTex);", "\thighp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);", "\thighp vec2 lowerBound = tileOrigin + pixelSize / 2.0;", "\thighp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;", "\toutColor = texture(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * color;", "\tgl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}" ].join("\n");
        }
        static _$GetTileRandomizationFragmentShaderSource$_(t, s, i, e) {
            let n = "";
            return t >= 2 ? n = "#version 300 es\n" + ic._$Gfx$_._$WebGLShaderProgram$_._$_GetConservativeDepthShaderPrefix$_(e) : (s && (n = "#extension GL_EXT_frag_depth : enable\n"), 
            i && (n += "#extension GL_EXT_shader_texture_lod : enable\n", n += "#extension GL_OES_standard_derivatives : enable\n")), 
            n + `\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n#define highmedp highp\n#else\n#define highmedp mediump\n#endif\nprecision highmedp float;\n${t >= 2 ? "in" : "varying"} vec2 vTex;\n${t >= 2 ? "out lowp vec4 outColor;" : ""}\nuniform lowp vec4 color;\nuniform lowp sampler2D samplerFront;\nuniform vec2 pixelSize;\n\nuniform vec2 tileSize;\nuniform vec2 tileSpacing;\nuniform float outlineThickness;\n\nconst float PI = 3.1415926;\n\nlowp vec4 cospVec4(lowp vec4 a, lowp vec4 b, float x)\n{\n\treturn (a + b + (a - b) * cos(x * PI)) / 2.0;\n}\n\nvec3 randVec3(vec2 seed)\n{\n\treturn vec3(fract(sin(dot(seed.xy + vec2(0.1, 0.1), vec2(12.9898,78.233))) * 43758.5453),\n\t\t\t\tfract(sin(dot(seed.yx + vec2(0.1, 0.1), vec2(12.9898,-78.233))) * 43758.5453),\n\t\t\t\tfract(sin(dot(seed.xy + vec2(0.1, 0.1), vec2(-12.9898,-78.233))) * 43758.5453));\n}\n\nlowp vec4 sampleTile(vec2 tile, vec2 uv, vec2 ddx, vec2 ddy)\n{\n\tvec2 posRandom = tileSize;\n\tfloat angleRandom = outlineThickness;\n\t\n\tvec3 rand = (randVec3(floor(tile + 0.5)) - 0.5) * 2.0;\n\t\n\tfloat angle = angleRandom * rand.z * PI;\n\tfloat sin_a = sin(angle);\n\tfloat cos_a = cos(angle);\n\tfloat aspect = pixelSize.x / pixelSize.y;\n\n\tvec2 mid = tile + vec2(0.5, 0.5);\n\tvec2 dp = uv - mid;\n\tdp.x /= aspect;\n\tvec2 r = vec2(dp.x * cos_a - dp.y * sin_a,\n\t\t\t\t  dp.y * cos_a + dp.x * sin_a);\n\tr.x *= aspect;\n\n\tvec2 p = mid + r + (posRandom * rand.xy / 2.0);\n\t\n\t${t >= 2 ? "return textureGrad(samplerFront, p, ddx, ddy);" : ""}\n\t${t < 2 && i ? "return texture2DGradEXT(samplerFront, p, ddx, ddy);" : ""}\n\t${t < 2 && !i ? "return texture2D(samplerFront, p);" : ""}\n}\n\nvoid main(void) {\n\t\n\t${t < 2 ? "lowp vec4 outColor;" : ""}\n\t\n\tfloat blendMarginX = tileSpacing.x;\n\tfloat blendMarginY = tileSpacing.y;\n\t\n\tvec2 tile = floor(vTex);\n\tvec2 tex = fract(vTex);\n\tvec2 ddx = ${t >= 2 || i ? "dFdx(vTex)" : "vec2(0.0, 0.0)"};\n\tvec2 ddy = ${t >= 2 || i ? "dFdy(vTex)" : "vec2(0.0, 0.0)"};\n\t\n\tvec4 curTile = sampleTile(tile, vTex, ddx, ddy);\n\t\n\tbool inLeftMargin = (tex.x < blendMarginX);\n\tbool inRightMargin = (tex.x > 1.0 - blendMarginX);\n\tbool inTopMargin = (tex.y < blendMarginY);\n\tbool inBottomMargin = (tex.y > 1.0 - blendMarginY);\n\t\n\tif (inLeftMargin)\n\t{\n\t\tlowp vec4 leftTile = sampleTile(tile + vec2(-1.0, 0.0), vTex, ddx, ddy);\n\t\tfloat leftMix = (tex.x / (blendMarginX * 2.0)) + 0.5;\n\t\tlowp vec4 leftMixedTile = cospVec4(leftTile, curTile, leftMix);\n\t\t\n\t\tif (inTopMargin)\n\t\t{\n\t\t\tlowp vec4 topTile =     sampleTile(tile + vec2(0.0,  -1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 topLeftTile = sampleTile(tile + vec2(-1.0, -1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 topLeftMixedTile = cospVec4(topLeftTile, topTile, leftMix);\n\t\t\t\n\t\t\toutColor = cospVec4(topLeftMixedTile, leftMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);\n\t\t}\n\t\telse if (inBottomMargin)\n\t\t{\n\t\t\tlowp vec4 bottomTile =     sampleTile(tile + vec2(0.0,  1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 bottomLeftTile = sampleTile(tile + vec2(-1.0, 1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 bottomLeftMixedTile = cospVec4(bottomLeftTile, bottomTile, leftMix);\n\t\t\t\n\t\t\toutColor = cospVec4(leftMixedTile, bottomLeftMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));\n\t\t}\n\t\telse\n\t\t{\n\t\t\toutColor = leftMixedTile;\n\t\t}\n\t}\n\telse if (inRightMargin)\n\t{\n\t\tlowp vec4 rightTile = sampleTile(tile + vec2(1.0, 0.0), vTex, ddx, ddy);\n\t\tfloat rightMix = (tex.x - (1.0 - blendMarginX)) / (blendMarginX * 2.0);\n\t\tlowp vec4 rightMixedTile = cospVec4(curTile, rightTile, rightMix);\n\t\t\n\t\tif (inTopMargin)\n\t\t{\n\t\t\tlowp vec4 topTile =      sampleTile(tile + vec2(0.0, -1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 topRightTile = sampleTile(tile + vec2(1.0, -1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 topRightMixedTile = cospVec4(topTile, topRightTile, rightMix);\n\t\t\t\n\t\t\toutColor = cospVec4(topRightMixedTile, rightMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);\n\t\t}\n\t\telse if (inBottomMargin)\n\t\t{\n\t\t\tlowp vec4 bottomTile =      sampleTile(tile + vec2(0.0, 1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 bottomRightTile = sampleTile(tile + vec2(1.0, 1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 bottomRightMixedTile = cospVec4(bottomTile, bottomRightTile, rightMix);\n\t\t\t\n\t\t\toutColor = cospVec4(rightMixedTile, bottomRightMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));\n\t\t}\n\t\telse\n\t\t{\n\t\t\toutColor = rightMixedTile;\n\t\t}\n\t}\n\telse if (inTopMargin)\n\t{\n\t\tlowp vec4 topTile = sampleTile(tile + vec2(0.0, -1.0), vTex, ddx, ddy);\n\t\toutColor = cospVec4(topTile, curTile, (tex.y / (blendMarginY * 2.0)) + 0.5);\n\t}\n\telse if (inBottomMargin)\n\t{\n\t\tlowp vec4 bottomTile = sampleTile(tile + vec2(0.0, 1.0), vTex, ddx, ddy);\n\t\toutColor = cospVec4(curTile, bottomTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));\n\t}\n\telse\n\t{\n\t\toutColor = curTile;\n\t}\n\t\n\toutColor *= color;\n\t${t < 2 ? "gl_FragColor = outColor;" : ""}\n\t${t >= 2 ? "gl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);" : ""}\n\t${t < 2 && s ? "gl_FragDepthEXT = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);" : ""}\n}\n`;
        }
        static _$GetPointVertexShaderSource_WebGL1$_() {
            return [ "attribute vec4 aPoints;", "varying float pointOpacity;", "uniform float zElevation;", "uniform mat4 matP;", "uniform mat4 matMV;", "void main(void) {", "\tgl_Position = matP * matMV * vec4(aPoints.xy, zElevation, 1.0);", "\tgl_PointSize = aPoints.z;", "\tpointOpacity = aPoints.w;", "}" ].join("\n");
        }
        static _$GetPointVertexShaderSource_WebGL2$_() {
            return [ "#version 300 es", "in vec4 aPoints;", "out float pointOpacity;", "uniform float zElevation;", "uniform mat4 matP;", "uniform mat4 matMV;", "void main(void) {", "\tgl_Position = matP * matMV * vec4(aPoints.xy, zElevation, 1.0);", "\tgl_PointSize = aPoints.z;", "\tpointOpacity = aPoints.w;", "}" ].join("\n");
        }
        static _$GetPointFragmentShaderSource_WebGL1_NoFragDepth$_() {
            return [ "uniform lowp sampler2D samplerFront;", "varying lowp float pointOpacity;", "uniform mediump vec2 pointTexStart;", "uniform mediump vec2 pointTexEnd;", "uniform lowp vec4 color;", "void main(void) {", "\tmediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);", "\tmediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);", "\tmediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));", "\tgl_FragColor = texture2D(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;", "}" ].join("\n");
        }
        static _$GetPointFragmentShaderSource_WebGL1_FragDepthEXT$_() {
            return [ "#extension GL_EXT_frag_depth : enable", "uniform lowp sampler2D samplerFront;", "varying lowp float pointOpacity;", "uniform mediump vec2 pointTexStart;", "uniform mediump vec2 pointTexEnd;", "uniform lowp vec4 color;", "void main(void) {", "\tmediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);", "\tmediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);", "\tmediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));", "\tgl_FragColor = texture2D(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;", "\tgl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}" ].join("\n");
        }
        static _$GetPointFragmentShaderSource_WebGL2$_(t) {
            return [ "#version 300 es", ic._$Gfx$_._$WebGLShaderProgram$_._$_GetConservativeDepthShaderPrefix$_(t), "uniform lowp sampler2D samplerFront;", "in lowp float pointOpacity;", "uniform mediump vec2 pointTexStart;", "uniform mediump vec2 pointTexEnd;", "uniform lowp vec4 color;", "out lowp vec4 outColor;", "void main(void) {", "\tmediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);", "\tmediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);", "\tmediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));", "\toutColor = texture(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;", "\tgl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}" ].join("\n");
        }
        static _$GetColorFillFragmentShaderSource$_() {
            return [ "uniform lowp vec4 color;", "void main(void) {", "\tgl_FragColor = color;", "}" ].join("\n");
        }
        static _$GetLinearGradientFillFragmentShaderSource$_() {
            return [ "precision lowp float;", "varying mediump vec2 vTex;", "uniform vec4 color;", "uniform vec4 color2_;", "vec3 fromLinear(vec3 linearRGB)", "{", "\tbvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));", "\tvec3 higher = vec3(1.055) * pow(abs(linearRGB), vec3(1.0/2.4)) - vec3(0.055);", "\tvec3 lower = linearRGB * vec3(12.92);", "\treturn mix(higher, lower, vec3(cutoff));", "}", "vec3 toLinear(vec3 sRGB)", "{", "\tbvec3 cutoff = lessThan(sRGB, vec3(0.04045));", "\tvec3 higher = pow(abs((sRGB + vec3(0.055))/vec3(1.055)), vec3(2.4));", "\tvec3 lower = sRGB/vec3(12.92);", "\treturn mix(higher, lower, vec3(cutoff));", "}", "void main(void) {", "\tvec3 linearGrad = mix(toLinear(color.rgb), toLinear(color2_.rgb), vTex.x);", "\tfloat a = mix(color.a, color2_.a, vTex.x);", "\tgl_FragColor = vec4(fromLinear(linearGrad) * a, a);", "}" ].join("\n");
        }
        static _$GetPenumbraFillFragmentShaderSource$_() {
            return [ "#ifdef GL_FRAGMENT_PRECISION_HIGH", "#define highmedp highp", "#else", "#define highmedp mediump", "#endif", "precision lowp float;", "varying highmedp vec2 vTex;", "uniform vec4 color;", "void main(void) {", "\thighmedp float grad = vTex.x / (1.0 - vTex.y);", "\tgl_FragColor = color * (1.0 - (cos(grad * 3.141592653589793) + 1.0) / 2.0);", "}" ].join("\n");
        }
        static _$GetSmoothLineFillFragmentShaderSource$_() {
            return [ "varying mediump vec2 vTex;", "uniform lowp vec4 color;", "void main(void) {", "\tlowp float f = 1.0 - abs(vTex.y - 0.5) * 2.0;", "\tgl_FragColor = color * f;", "}" ].join("\n");
        }
        static _$GetHardEllipseFillFragmentShaderSource$_() {
            return [ "varying mediump vec2 vTex;", "uniform lowp vec4 color;", "void main(void) {", "\tmediump vec2 diff = vTex - vec2(0.5, 0.5);", "\tmediump vec2 diffSq = diff * diff;", "\tmediump float f = step(diffSq.x + diffSq.y, 0.25);", "\tgl_FragColor = color * f;", "}" ].join("\n");
        }
        static _$GetHardEllipseOutlineFragmentShaderSource$_() {
            return [ "varying mediump vec2 vTex;", "uniform lowp vec4 color;", "uniform mediump vec2 pixelSize;", "uniform mediump float outlineThickness;", "void main(void) {", "\tmediump vec2 diff = vTex - vec2(0.5, 0.5);", "\tmediump vec2 diffSq = diff * diff;", "\tmediump float distSq = diffSq.x + diffSq.y;", "\tmediump vec2 norm = normalize(diff);", "\tmediump vec2 halfNorm = norm * 0.5;", "\tmediump float innerF = step(distSq, 0.25);", "\tmediump vec2 innerEdge = halfNorm - pixelSize * norm * outlineThickness;", "\tmediump vec2 innerEdgeSq = innerEdge * innerEdge;", "\tmediump float outerF = step(innerEdgeSq.x + innerEdgeSq.y, distSq);", "\tgl_FragColor = color * innerF * outerF;", "}" ].join("\n");
        }
        static _$GetSmoothEllipseFillFragmentShaderSource$_() {
            return [ "varying mediump vec2 vTex;", "uniform lowp vec4 color;", "uniform mediump vec2 pixelSize;", "void main(void) {", "\tmediump vec2 diff = vTex - vec2(0.5, 0.5);", "\tmediump vec2 diffSq = diff * diff;", "\tmediump vec2 norm = normalize(diff);", "\tmediump vec2 halfNorm = norm * 0.5;", "\tmediump vec2 halfNormSq = halfNorm * halfNorm;", "\tmediump vec2 innerEdge = halfNorm - pixelSize * norm;", "\tmediump vec2 innerEdgeSq = innerEdge * innerEdge;", "\tmediump float f = smoothstep(halfNormSq.x + halfNormSq.y, innerEdgeSq.x + innerEdgeSq.y, diffSq.x + diffSq.y);", "\tgl_FragColor = color * f;", "}" ].join("\n");
        }
        static _$GetSmoothEllipseOutlineFragmentShaderSource$_() {
            return [ "varying mediump vec2 vTex;", "uniform lowp vec4 color;", "uniform mediump vec2 pixelSize;", "uniform mediump float outlineThickness;", "void main(void) {", "\tmediump vec2 diff = vTex - vec2(0.5, 0.5);", "\tmediump vec2 diffSq = diff * diff;", "\tmediump float distSq = diffSq.x + diffSq.y;", "\tmediump vec2 norm = normalize(diff);", "\tmediump vec2 halfNorm = norm * 0.5;", "\tmediump vec2 halfNormSq = halfNorm * halfNorm;", "\tmediump vec2 pxNorm = pixelSize * norm;", "\tmediump vec2 innerEdge1 = halfNorm - pxNorm;", "\tmediump vec2 innerEdge1Sq = innerEdge1 * innerEdge1;", "\tmediump float innerF = smoothstep(halfNormSq.x + halfNormSq.y, innerEdge1Sq.x + innerEdge1Sq.y, distSq);", "\tmediump vec2 innerEdge2 = halfNorm - pxNorm * outlineThickness;", "\tmediump vec2 innerEdge2Sq = innerEdge2 * innerEdge2;", "\tmediump vec2 innerEdge3 = halfNorm - pxNorm * (outlineThickness + 1.0);", "\tmediump vec2 innerEdge3Sq = innerEdge3 * innerEdge3;", "\tmediump float outerF = smoothstep(innerEdge3Sq.x + innerEdge3Sq.y, innerEdge2Sq.x + innerEdge2Sq.y, distSq);", "\tgl_FragColor = color * innerF * outerF;", "}" ].join("\n");
        }
    };
}

{
    const hc = self._$C3$_, rc = self._$glMatrix$_._$mat4$_, oc = new Map([ [ "float", 1 ], [ "percent", 1 ], [ "sampler", 1 ], [ "vec2", 2 ], [ "vec3", 3 ], [ "color", 3 ], [ "vec4", 4 ], [ "mat4", 16 ] ]);
    hc._$Gfx$_._$WebGLShaderUniform$_ = class {
        constructor(t, s, i) {
            if (!oc.has(i)) throw new Error("invalid uniform type");
            this._$_owner$_ = t, this._$_gl$_ = this._$_owner$_._$GetWebGLContext$_(), this._$_name$_ = s, 
            this._$_type$_ = i, this._$_isColorType$_ = "color" === this._$_type$_, this._$_location$_ = this._$_gl$_.getUniformLocation(this._$_owner$_._$GetShaderProgram$_(), s), 
            this._$_isUsed$_ = !!this._$_location$_;
            const e = oc.get(i);
            this._$_lastValue$_ = new Float32Array(e), this._$_lastBatchValue$_ = new Float32Array(e);
        }
        _$Release$_() {
            this._$_owner$_ = null, this._$_gl$_ = null, this._$_location$_ = null;
        }
        _$IsUsed$_() {
            return this._$_isUsed$_;
        }
        _$GetType$_() {
            return this._$_type$_;
        }
        _$IsColorType$_() {
            return this._$_isColorType$_;
        }
        _$Init1f$_(t) {
            this._$IsUsed$_() && (this._$_lastValue$_[0] = t, this._$_lastBatchValue$_.set(this._$_lastValue$_), 
            this._$_gl$_.uniform1f(this._$_location$_, t));
        }
        _$Init1i$_(t) {
            this._$IsUsed$_() && (this._$_lastValue$_[0] = t, this._$_lastBatchValue$_.set(this._$_lastValue$_), 
            this._$_gl$_.uniform1i(this._$_location$_, t));
        }
        _$Init2f$_(t, s) {
            this._$IsUsed$_() && (this._$_lastValue$_[0] = t, this._$_lastValue$_[1] = s, this._$_lastBatchValue$_.set(this._$_lastValue$_), 
            this._$_gl$_.uniform2f(this._$_location$_, t, s));
        }
        _$Init3f$_(t, s, i) {
            this._$IsUsed$_() && (this._$_lastValue$_[0] = t, this._$_lastValue$_[1] = s, this._$_lastValue$_[2] = i, 
            this._$_lastBatchValue$_.set(this._$_lastValue$_), this._$_gl$_.uniform3f(this._$_location$_, t, s, i));
        }
        _$Init4f$_(t, s, i, e) {
            this._$IsUsed$_() && (this._$_lastValue$_[0] = t, this._$_lastValue$_[1] = s, this._$_lastValue$_[2] = i, 
            this._$_lastValue$_[3] = e, this._$_lastBatchValue$_.set(this._$_lastValue$_), this._$_gl$_.uniform4f(this._$_location$_, t, s, i, e));
        }
        _$Update1f$_(t) {
            t = Math.fround(t);
            const s = this._$_lastValue$_;
            s[0] !== t && (s[0] = t, this._$_gl$_.uniform1f(this._$_location$_, t));
        }
        _$Update1i$_(t) {
            const s = this._$_lastValue$_;
            s[0] !== t && (s[0] = t, this._$_gl$_.uniform1i(this._$_location$_, t));
        }
        _$Update2f$_(t, s) {
            t = Math.fround(t), s = Math.fround(s);
            const i = this._$_lastValue$_;
            i[0] === t && i[1] === s || (i[0] = t, i[1] = s, this._$_gl$_.uniform2f(this._$_location$_, t, s));
        }
        _$Update3f$_(t, s, i) {
            t = Math.fround(t), s = Math.fround(s), i = Math.fround(i);
            const e = this._$_lastValue$_;
            e[0] === t && e[1] === s && e[2] === i || (e[0] = t, e[1] = s, e[2] = i, this._$_gl$_.uniform3f(this._$_location$_, t, s, i));
        }
        _$Update4f$_(t, s, i, e) {
            t = Math.fround(t), s = Math.fround(s), i = Math.fround(i), e = Math.fround(e);
            const n = this._$_lastValue$_;
            n[0] === t && n[1] === s && n[2] === i && n[3] === e || (n[0] = t, n[1] = s, n[2] = i, 
            n[3] = e, this._$_gl$_.uniform4f(this._$_location$_, t, s, i, e));
        }
        _$UpdateMatrix4fv$_(t) {
            const s = this._$_lastValue$_;
            rc._$exactEquals$_(s, t) || (hc._$typedArraySet16$_(s, t, 0), this._$_gl$_.uniformMatrix4fv(this._$_location$_, !1, t));
        }
        _$IsSetToCustomInBatch$_(t) {
            const s = this._$_lastBatchValue$_;
            return this._$IsColorType$_() ? s[0] === Math.fround(t._$getR$_()) && s[1] === Math.fround(t._$getG$_()) && s[2] === Math.fround(t._$getB$_()) : s[0] === Math.fround(t);
        }
        _$SetBatchValueCustom$_(t) {
            const s = this._$_lastBatchValue$_;
            this._$IsColorType$_() ? (s[0] = t._$getR$_(), s[1] = t._$getG$_(), s[2] = t._$getB$_()) : s[0] = t;
        }
        _$IsSetTo1InBatch$_(t) {
            return this._$_lastBatchValue$_[0] === Math.fround(t);
        }
        _$IsSetTo2InBatch$_(t, s) {
            const i = this._$_lastBatchValue$_;
            return i[0] === Math.fround(t) && i[1] === Math.fround(s);
        }
        _$SetBatch1$_(t) {
            this._$_lastBatchValue$_[0] = t;
        }
        _$SetBatch2$_(t, s) {
            const i = this._$_lastBatchValue$_;
            i[0] = t, i[1] = s;
        }
    };
}

{
    const ac = self._$C3$_, uc = self._$glMatrix$_, lc = uc._$vec4$_, cc = uc._$mat4$_;
    ac._$Gfx$_._$BatchState$_ = class {
        constructor(t) {
            this._$renderer$_ = t, this._$currentMV$_ = cc.create(), this._$currentMatP$_ = cc.create(), 
            this._$currentFramebuffer$_ = null, this._$currentFramebufferNoDepth$_ = null, this._$isDepthSamplingEnabled$_ = !1, 
            this._$currentColor$_ = lc._$fromValues$_(1, 1, 1, 1), this._$currentShader$_ = null, 
            this._$pointTexCoords$_ = new ac.Rect, this.clearColor = ac._$New$_(ac._$Color$_, 0, 0, 0, 0);
        }
    }, ac._$Gfx$_._$WebGLBatchJob$_ = class {
        constructor(t) {
            const s = new ArrayBuffer(96);
            this._$_type$_ = 0, this._$_batchState$_ = t, this._$_gl$_ = t._$renderer$_._$GetContext$_(), 
            this._$_startIndex$_ = 0, this._$_indexCount$_ = 0, this._$_texParam$_ = null, this._$_mat4param$_ = new Float32Array(s, 0, 16), 
            this._$_colorParam$_ = new Float32Array(s, 64, 4), this._$_srcOriginRect$_ = new Float32Array(s, 80, 4), 
            this._$_shaderParams$_ = [];
        }
        _$InitQuad$_(t, s) {
            this._$_type$_ = 1, this._$_startIndex$_ = t, this._$_indexCount$_ = s;
        }
        _$DoQuad$_() {
            const t = this._$_gl$_;
            t.drawElements(t.TRIANGLES, this._$_indexCount$_, t.UNSIGNED_SHORT, this._$_startIndex$_);
        }
        _$InitSetTexture$_(t) {
            this._$_type$_ = 2, this._$_texParam$_ = t;
        }
        _$DoSetTexture$_() {
            const t = this._$_gl$_, s = this._$_texParam$_;
            t.bindTexture(t.TEXTURE_2D, s ? s._$_GetTexture$_() : null);
        }
        _$InitSetColor$_(t) {
            this._$_type$_ = 3, t._$writeToTypedArray$_(this._$_colorParam$_, 0);
        }
        _$DoSetColor$_() {
            const t = this._$_colorParam$_, s = this._$_batchState$_;
            lc._$copy$_(s._$currentColor$_, t), s._$currentShader$_._$UpdateColor$_(t);
        }
        _$InitSetGradientColor$_(t) {
            this._$_type$_ = 21, t._$writeToTypedArray$_(this._$_colorParam$_, 0);
        }
        _$DoSetGradientColor$_() {
            const t = this._$_colorParam$_, s = this._$_batchState$_._$currentShader$_;
            s._$_uColor2$_._$IsUsed$_() && s._$_uColor2$_._$Update4f$_(t[0], t[1], t[2], t[3]);
        }
        _$InitSetBlend$_(t, s) {
            this._$_type$_ = 4, this._$_startIndex$_ = t, this._$_indexCount$_ = s;
        }
        _$DoSetBlend$_() {
            this._$_gl$_.blendFunc(this._$_startIndex$_, this._$_indexCount$_);
        }
        _$InitSetViewport$_(t, s, i, e) {
            this._$_type$_ = 5;
            const n = this._$_colorParam$_;
            n[0] = t, n[1] = s, n[2] = i, n[3] = e;
        }
        _$DoSetViewport$_() {
            const t = this._$_colorParam$_;
            this._$_gl$_.viewport(t[0], t[1], t[2], t[3]);
        }
        _$InitSetProjection$_(t) {
            this._$_type$_ = 6, cc._$copy$_(this._$_mat4param$_, t);
        }
        _$DoSetProjection$_() {
            const t = this._$_batchState$_, s = t._$renderer$_._$_allShaderPrograms$_, i = t._$currentShader$_, e = this._$_mat4param$_;
            for (let t = 0, n = s.length; t < n; ++t) {
                const n = s[t];
                n === i ? n._$UpdateMatP$_(e, !0) : n._$SetMatPStale$_();
            }
            cc._$copy$_(t._$currentMatP$_, e);
        }
        _$InitSetModelView$_(t) {
            this._$_type$_ = 7, cc._$copy$_(this._$_mat4param$_, t);
        }
        _$DoSetModelView$_() {
            const t = this._$_batchState$_, s = t._$renderer$_._$_allShaderPrograms$_, i = t._$currentShader$_, e = this._$_mat4param$_;
            for (let t = 0, n = s.length; t < n; ++t) {
                const n = s[t];
                n === i ? n._$UpdateMatMV$_(e, !0) : n._$SetMatMVStale$_();
            }
            cc._$copy$_(t._$currentMV$_, e);
        }
        _$InitSetRenderTarget$_(t) {
            this._$_type$_ = 8, this._$_texParam$_ = t;
        }
        _$DoSetRenderTarget$_() {
            const t = this._$_gl$_, s = this._$_texParam$_, i = this._$_batchState$_;
            s ? (i._$currentFramebuffer$_ = s._$_GetFramebuffer$_(), i._$currentFramebufferNoDepth$_ = s._$_GetFramebufferNoDepth$_(), 
            i._$isDepthSamplingEnabled$_ && i._$currentFramebufferNoDepth$_ ? t.bindFramebuffer(t.FRAMEBUFFER, i._$currentFramebufferNoDepth$_) : t.bindFramebuffer(t.FRAMEBUFFER, i._$currentFramebuffer$_)) : (i._$currentFramebuffer$_ = null, 
            i._$currentFramebufferNoDepth$_ = null, t.bindFramebuffer(t.FRAMEBUFFER, null));
        }
        _$InitClearSurface$_(t) {
            this._$_type$_ = 9, t._$writeToTypedArray$_(this._$_mat4param$_, 0);
        }
        _$InitClearSurface2$_(t, s, i, e) {
            this._$_type$_ = 9;
            const n = this._$_mat4param$_;
            n[0] = t, n[1] = s, n[2] = i, n[3] = e;
        }
        _$DoClearSurface$_() {
            const t = this._$_gl$_, s = this._$_mat4param$_, i = this._$_batchState$_.clearColor, e = s[0], n = s[1], h = s[2], r = s[3];
            i._$equalsRgba$_(e, n, h, r) || (t.clearColor(e, n, h, r), i._$setRgba$_(e, n, h, r)), 
            t.clear(t.COLOR_BUFFER_BIT);
        }
        _$InitSetPointTexCoords$_(t) {
            this._$_type$_ = 15, t._$writeToTypedArray$_(this._$_mat4param$_, 0);
        }
        _$DoSetPointTextureCoords$_() {
            const t = this._$_mat4param$_;
            this._$_batchState$_._$pointTexCoords$_.set(t[0], t[1], t[2], t[3]);
        }
        _$InitPoints$_(t, s) {
            this._$_type$_ = 10, this._$_startIndex$_ = t, this._$_indexCount$_ = 1, this._$_mat4param$_[0] = s;
        }
        _$DoPoints$_() {
            const t = this._$_gl$_, s = this._$_batchState$_, i = s._$renderer$_._$_spPoints$_;
            t.useProgram(i._$_shaderProgram$_), i._$UpdateMatP$_(s._$currentMatP$_, !1), i._$UpdateMatMV$_(s._$currentMV$_, !1);
            const e = s._$pointTexCoords$_;
            i._$_uPointTexStart$_._$IsUsed$_() && i._$_uPointTexStart$_._$Update2f$_(e._$getLeft$_(), e._$getTop$_()), 
            i._$_uPointTexEnd$_._$IsUsed$_() && i._$_uPointTexEnd$_._$Update2f$_(e._$getRight$_(), e._$getBottom$_());
            const n = this._$_mat4param$_[0];
            if (i._$_uZElevation$_._$IsUsed$_() && i._$_uZElevation$_._$Update1f$_(n), i._$_uColor$_._$IsUsed$_()) {
                const t = s._$currentColor$_;
                i._$_uColor$_._$Update4f$_(t[0], t[1], t[2], t[3]);
            }
            t.drawArrays(t.POINTS, this._$_startIndex$_ / 4, this._$_indexCount$_), t.useProgram(s._$currentShader$_._$_shaderProgram$_);
        }
        _$InitSetProgram$_(t) {
            this._$_type$_ = 11, this._$_texParam$_ = t;
        }
        _$DoSetProgram$_() {
            const t = this._$_gl$_, s = this._$_batchState$_, i = this._$_texParam$_;
            if (s._$currentShader$_ = i, t.useProgram(i._$_shaderProgram$_), i._$UpdateMatP$_(s._$currentMatP$_, !1), 
            i._$UpdateMatMV$_(s._$currentMV$_, !1), i._$_uColor$_._$IsUsed$_()) {
                const t = s._$currentColor$_;
                i._$_uColor$_._$Update4f$_(t[0], t[1], t[2], t[3]);
            }
        }
        _$InitSetProgramParameters$_() {
            this._$_type$_ = 12;
        }
        _$DoSetProgramParameters$_() {
            const t = this._$_batchState$_._$currentShader$_, s = this._$_gl$_, i = this._$_mat4param$_, e = this._$_colorParam$_, n = this._$_srcOriginRect$_;
            if (t._$_uSamplerBack$_._$IsUsed$_()) {
                const t = this._$_batchState$_._$renderer$_, i = this._$_texParam$_;
                t._$_lastTexture1$_ !== i && (s.activeTexture(s.TEXTURE1), s.bindTexture(s.TEXTURE_2D, i ? i._$_GetTexture$_() : null), 
                t._$_lastTexture1$_ = i, s.activeTexture(s.TEXTURE0));
            }
            t._$_uPixelSize$_._$IsUsed$_() && t._$_uPixelSize$_._$Update2f$_(i[0], i[1]), t._$_uDestStart$_._$IsUsed$_() && t._$_uDestStart$_._$Update2f$_(i[2], i[3]), 
            t._$_uDestEnd$_._$IsUsed$_() && t._$_uDestEnd$_._$Update2f$_(i[4], i[5]), t._$_uDevicePixelRatio$_._$IsUsed$_() && t._$_uDevicePixelRatio$_._$Update1f$_(this._$_indexCount$_), 
            t._$_uLayerScale$_._$IsUsed$_() && t._$_uLayerScale$_._$Update1f$_(i[6]), t._$_uLayerAngle$_._$IsUsed$_() && t._$_uLayerAngle$_._$Update1f$_(i[7]), 
            t._$_uSrcStart$_._$IsUsed$_() && t._$_uSrcStart$_._$Update2f$_(i[12], i[13]), t._$_uSrcEnd$_._$IsUsed$_() && t._$_uSrcEnd$_._$Update2f$_(i[14], i[15]), 
            t._$_uSrcOriginStart$_._$IsUsed$_() && t._$_uSrcOriginStart$_._$Update2f$_(n[0], n[1]), 
            t._$_uSrcOriginEnd$_._$IsUsed$_() && t._$_uSrcOriginEnd$_._$Update2f$_(n[2], n[3]), 
            t._$_uLayoutStart$_._$IsUsed$_() && t._$_uLayoutStart$_._$Update2f$_(e[0], e[1]), 
            t._$_uLayoutEnd$_._$IsUsed$_() && t._$_uLayoutEnd$_._$Update2f$_(e[2], e[3]), t._$_uSeconds$_._$IsUsed$_() && t._$_uSeconds$_._$Update1f$_(this._$_startIndex$_);
        }
        _$InitSetProgramCustomParameters$_() {
            this._$_type$_ = 13;
        }
        _$DoSetProgramCustomParameters$_() {
            const t = this._$_batchState$_._$currentShader$_._$_uCustomParameters$_, s = this._$_shaderParams$_;
            for (let i = 0, e = t.length; i < e; ++i) {
                const e = t[i], n = s[i];
                e._$IsColorType$_() ? e._$Update3f$_(n._$getR$_(), n._$getG$_(), n._$getB$_()) : e._$Update1f$_(n);
            }
        }
        _$InitInvalidateFramebuffer$_(t) {
            this._$_type$_ = 14, this._$_texParam$_ = t;
        }
        _$DoInvalidateFramebuffer$_() {
            const t = this._$_gl$_, s = this._$_texParam$_, i = this._$_batchState$_._$currentFramebuffer$_;
            s !== i && t.bindFramebuffer(t.FRAMEBUFFER, s), t.invalidateFramebuffer(t.FRAMEBUFFER, [ t.COLOR_ATTACHMENT0 ]), 
            s !== i && t.bindFramebuffer(t.FRAMEBUFFER, i);
        }
        _$InitBlitFramebuffer$_(t, s, i) {
            this._$_type$_ = 17;
            const e = this._$_mat4param$_, n = this._$_batchState$_._$renderer$_;
            e[0] = t._$GetWidth$_(), e[1] = t._$GetHeight$_(), e[2] = s ? s._$GetWidth$_() : n._$GetWidth$_(), 
            e[3] = s ? s._$GetHeight$_() : n._$GetHeight$_(), e[4] = t._$IsLinearSampling$_() ? 1 : 0, 
            e[5] = "stretch" === i;
            const h = this._$_shaderParams$_;
            ac._$clearArray$_(h), h.push(t._$_GetFramebuffer$_()), h.push(s ? s._$_GetFramebuffer$_() : null);
        }
        _$DoBlitFramebuffer$_() {
            const t = this._$_mat4param$_, s = this._$_shaderParams$_, i = this._$_gl$_, e = t[0], n = t[1], h = t[2], r = t[3], o = 0 !== t[4], a = 0 !== t[5], u = s[0], l = s[1];
            if (i.bindFramebuffer(i.READ_FRAMEBUFFER, u), i.bindFramebuffer(i.DRAW_FRAMEBUFFER, l), 
            a) i.blitFramebuffer(0, 0, e, n, 0, 0, h, r, i.COLOR_BUFFER_BIT, o ? i.LINEAR : i.NEAREST); else {
                const t = Math.min(e, h), s = Math.min(n, r), o = Math.max(n - r, 0), a = Math.max(r - n, 0);
                i.blitFramebuffer(0, o, t, s + o, 0, a, t, s + a, i.COLOR_BUFFER_BIT, i.NEAREST);
            }
        }
        _$InitStartQuery$_(t) {
            this._$_type$_ = 18, this._$_texParam$_ = t;
        }
        _$DoStartQuery$_() {
            this._$_texParam$_._$BeginTimeElapsed$_(), this._$_texParam$_ = null;
        }
        _$InitEndQuery$_(t) {
            this._$_type$_ = 19, this._$_texParam$_ = t;
        }
        _$DoEndQuery$_() {
            this._$_texParam$_._$EndTimeElapsed$_(), this._$_texParam$_ = null;
        }
        _$InitSetEllipseParams$_(t, s, i) {
            this._$_type$_ = 20;
            const e = this._$_mat4param$_;
            e[0] = t, e[1] = s, e[2] = i;
        }
        _$DoSetEllipseParams$_() {
            const t = this._$_batchState$_._$currentShader$_, s = this._$_mat4param$_;
            t._$_uPixelSize$_._$IsUsed$_() && t._$_uPixelSize$_._$Update2f$_(s[0], s[1]), t._$_uOutlineThickness$_._$IsUsed$_() && t._$_uOutlineThickness$_._$Update1f$_(s[2]);
        }
        _$InitSetTilemapInfo$_(t, s, i, e, n, h, r) {
            this._$_type$_ = 16;
            const o = this._$_mat4param$_;
            t._$writeToTypedArray$_(o, 0), o[4] = 1 / s, o[5] = 1 / i, o[6] = e / s, o[7] = n / i, 
            o[8] = h / s, o[9] = r / i;
        }
        _$DoSetTilemapInfo$_() {
            const t = this._$_batchState$_._$currentShader$_, s = this._$_mat4param$_;
            t._$_uSrcStart$_._$IsUsed$_() && t._$_uSrcStart$_._$Update2f$_(s[0], s[1]), t._$_uPixelSize$_._$IsUsed$_() && t._$_uPixelSize$_._$Update2f$_(s[4], s[5]), 
            t._$_uTileSize$_._$IsUsed$_() && t._$_uTileSize$_._$Update2f$_(s[6], s[7]), t._$_uTileSpacing$_._$IsUsed$_() && t._$_uTileSpacing$_._$Update2f$_(s[8], s[9]);
        }
        _$InitSetTileRandomizationInfo$_(t, s, i, e, n, h, r) {
            this._$_type$_ = 29;
            const o = this._$_mat4param$_;
            o[0] = 1 / t, o[1] = 1 / s, o[2] = i, o[3] = e, o[4] = n, o[5] = h, o[6] = r;
        }
        _$DoSetTileRandomizationInfo$_() {
            const t = this._$_batchState$_._$currentShader$_, s = this._$_mat4param$_;
            t._$_uPixelSize$_._$IsUsed$_() && t._$_uPixelSize$_._$Update2f$_(s[0], s[1]), t._$_uTileSize$_._$IsUsed$_() && t._$_uTileSize$_._$Update2f$_(s[2], s[3]), 
            t._$_uOutlineThickness$_._$IsUsed$_() && t._$_uOutlineThickness$_._$Update1f$_(s[4]), 
            t._$_uTileSpacing$_._$IsUsed$_() && t._$_uTileSpacing$_._$Update2f$_(s[5], s[6]);
        }
        _$InitClearDepth$_(t) {
            this._$_type$_ = 22, this._$_startIndex$_ = t ? 1 : 0;
        }
        _$DoClearDepth$_() {
            const t = this._$_gl$_, s = 0 !== this._$_startIndex$_;
            s || t.depthMask(!0), t.clear(t.DEPTH_BUFFER_BIT), s || t.depthMask(!1);
        }
        _$InitSetDepthEnabled$_(t) {
            this._$_type$_ = 23, this._$_startIndex$_ = t ? 1 : 0;
        }
        _$DoSetDepthEnabled$_() {
            const t = this._$_gl$_;
            0 === this._$_startIndex$_ ? (t.disable(t.DEPTH_TEST), t.depthMask(!1)) : (t.enable(t.DEPTH_TEST), 
            t.depthMask(!0));
        }
        _$InitSetDepthSamplingEnabled$_(t) {
            this._$_type$_ = 24, this._$_startIndex$_ = t ? 1 : 0;
        }
        _$DoSetDepthSamplingEnabled$_() {
            const t = this._$_gl$_, s = this._$_batchState$_, i = s._$renderer$_, e = 0 !== this._$_startIndex$_;
            s._$isDepthSamplingEnabled$_ = e, t.activeTexture(t.TEXTURE2), e ? (s._$currentFramebufferNoDepth$_ && t.bindFramebuffer(t.FRAMEBUFFER, s._$currentFramebufferNoDepth$_), 
            t.bindTexture(t.TEXTURE_2D, i._$_GetDepthBuffer$_())) : (t.bindTexture(t.TEXTURE_2D, null), 
            s._$currentFramebufferNoDepth$_ && t.bindFramebuffer(t.FRAMEBUFFER, s._$currentFramebuffer$_)), 
            t.activeTexture(t.TEXTURE0);
        }
        _$InitCoplanarStartStencilPass$_() {
            this._$_type$_ = 25;
        }
        _$DoCoplanarStartStencilPass$_() {
            const t = this._$_gl$_;
            t.clear(t.STENCIL_BUFFER_BIT), t.enable(t.STENCIL_TEST), t.stencilFunc(t.ALWAYS, 1, 1), 
            t.stencilOp(t.KEEP, t.KEEP, t.REPLACE), t.colorMask(!1, !1, !1, !1);
        }
        _$InitCoplanarStartColorPass$_() {
            this._$_type$_ = 26;
        }
        _$DoCoplanarStartColorPass$_() {
            const t = this._$_gl$_;
            t.colorMask(!0, !0, !0, !0), t.stencilFunc(t.EQUAL, 1, 1), t.stencilOp(t.KEEP, t.KEEP, t.KEEP);
        }
        _$InitCoplanarRestore$_() {
            this._$_type$_ = 27;
        }
        _$DoCoplanarRestore$_() {
            const t = this._$_gl$_;
            t.disable(t.STENCIL_TEST);
        }
        _$InitSetScissor$_(t, s, i, e, n) {
            this._$_type$_ = 28, this._$_startIndex$_ = t ? 1 : 0;
            const h = this._$_mat4param$_;
            h[0] = s, h[1] = i, h[2] = e, h[3] = n;
        }
        _$DoSetScissor$_() {
            const t = this._$_gl$_, s = this._$_mat4param$_;
            1 === this._$_startIndex$_ ? (t.enable(t.SCISSOR_TEST), t.scissor(s[0], s[1], s[2], s[3])) : t.disable(t.SCISSOR_TEST);
        }
        _$Run$_() {
            switch (this._$_type$_) {
              case 1:
                return void this._$DoQuad$_();

              case 2:
                return void this._$DoSetTexture$_();

              case 3:
                return void this._$DoSetColor$_();

              case 4:
                return void this._$DoSetBlend$_();

              case 5:
                return void this._$DoSetViewport$_();

              case 6:
                return void this._$DoSetProjection$_();

              case 7:
                return void this._$DoSetModelView$_();

              case 8:
                return void this._$DoSetRenderTarget$_();

              case 9:
                return void this._$DoClearSurface$_();

              case 10:
                return void this._$DoPoints$_();

              case 11:
                return void this._$DoSetProgram$_();

              case 12:
                return void this._$DoSetProgramParameters$_();

              case 13:
                return void this._$DoSetProgramCustomParameters$_();

              case 14:
                return void this._$DoInvalidateFramebuffer$_();

              case 15:
                return void this._$DoSetPointTextureCoords$_();

              case 16:
                return void this._$DoSetTilemapInfo$_();

              case 17:
                return void this._$DoBlitFramebuffer$_();

              case 18:
                return void this._$DoStartQuery$_();

              case 19:
                return void this._$DoEndQuery$_();

              case 20:
                return void this._$DoSetEllipseParams$_();

              case 21:
                return void this._$DoSetGradientColor$_();

              case 22:
                return void this._$DoClearDepth$_();

              case 23:
                return void this._$DoSetDepthEnabled$_();

              case 24:
                return void this._$DoSetDepthSamplingEnabled$_();

              case 25:
                return void this._$DoCoplanarStartStencilPass$_();

              case 26:
                return void this._$DoCoplanarStartColorPass$_();

              case 27:
                return void this._$DoCoplanarRestore$_();

              case 28:
                return void this._$DoSetScissor$_();

              case 29:
                return void this._$DoSetTileRandomizationInfo$_();
            }
        }
    };
}

{
    let fc = function(t, s, i, e, n, h) {
        s ? t.strokeRect(i, e, n, h) : t.fillRect(i, e, n, h);
    }, dc = function(t) {
        return t * (4 / 3);
    }, pc = function(t, s) {
        t = t.trim();
        const i = parseFloat(t);
        return isFinite(i) ? t.endsWith("%") ? s * i / 100 : i : 0;
    };
    0;
    const mc = self._$C3$_, gc = new Set([ "serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui", "ui-serif", "ui-sans-serif", "ui-monospace", "ui-rounded", "math", "emoji", "fangsong" ]), yc = {
        timeout: 60
    }, Mc = new mc._$Color$_(0, 0, 0, 1), wc = new Set([ "left", "center", "right" ]), Sc = new Set([ "top", "center", "bottom" ]), bc = new Set([ "word", "cjk", "character" ]), Tc = new Set([ "ltr", "rtl" ]), vc = new Set;
    mc._$FontManager$_ && mc._$FontManager$_.addEventListener("fontload", (t => {
        const s = t.font._$GetName$_();
        for (const t of vc) (t._$IsBBCodeEnabled$_() || mc._$equalsNoCase$_(t._$GetFontName$_(), s)) && t._$_SetWordWrapChanged$_();
    }));
    let xc = !1, Ic = !1;
    mc._$Gfx$_._$RendererText$_ = class {
        constructor(t, s) {
            s = Object.assign({}, yc, s), this._$_renderer$_ = t, this._$_fontName$_ = "Arial", 
            this._$_fontSize$_ = 16, this._$_fontSizeScale$_ = 1, this._$_lineHeight$_ = 0, 
            this._$_isBold$_ = !1, this._$_isItalic$_ = !1, this._$_colorStr$_ = "black", this._$_isBBcodeEnabled$_ = !1, 
            this._$_iconSet$_ = null, this._$_iconSmoothing$_ = !0, this._$onloadfont$_ = null, 
            this._$_alreadyLoadedFonts$_ = new Set, this._$_horizontalAlign$_ = "left", this._$_verticalAlign$_ = "top", 
            this._$_text$_ = "", this._$_bbString$_ = null, this._$_wrappedText$_ = mc._$New$_(mc._$WordWrap$_), 
            this._$_wrapMode$_ = "word", this._$_textDirection$_ = "ltr", this._$_wordWrapChanged$_ = !1, 
            this._$_textLayoutChanged$_ = !1, this._$_drawChanged$_ = !1, this._$_drawMaxCharCount$_ = -1, 
            this._$_drawCharCount$_ = 0, this._$_cssWidth$_ = 0, this._$_cssHeight$_ = 0, this._$_width$_ = 0, 
            this._$_height$_ = 0, this._$_zoom$_ = 1, this._$_textCanvas$_ = null, this._$_textContext$_ = null, 
            this._$_measureContext$_ = null, this._$_measureContextTop$_ = null, this._$_lastCanvasWidth$_ = -1, 
            this._$_lastCanvasHeight$_ = -1, this._$_lastTextCanvasFont$_ = "", this._$_lastMeasureCanvasFont$_ = "", 
            this._$_lastTextCanvasFillStyle$_ = "", this._$_lastTextCanvasOpacity$_ = 1, this._$_lastTextCanvasLineWidth$_ = 1, 
            this._$_measureTextCallback$_ = t => this._$_MeasureText$_(t), this._$_texture$_ = null, 
            this._$_rcTex$_ = new mc.Rect, this._$_scaleFactor$_ = 1, this._$_textureTimeout$_ = new mc._$IdleTimeout$_((() => {
                this._$ReleaseTexture$_(), this._$_SetTextCanvasSize$_(8, 8);
            }), s.timeout), this._$ontextureupdate$_ = null, this._$_wasReleased$_ = !1, vc.add(this);
        }
        _$Release$_() {
            this._$onloadfont$_ = null, this._$_alreadyLoadedFonts$_.clear(), this._$_iconSet$_ = null, 
            this._$_bbString$_ = null, this._$_textCanvas$_ = null, this._$_textContext$_ = null, 
            this._$_measureContext$_ = null, this._$_measureContextTop$_ = null, this._$_measureTextCallback$_ = null, 
            this._$_textureTimeout$_._$Release$_(), this._$ontextureupdate$_ = null, this._$ReleaseTexture$_(), 
            this._$_wrappedText$_._$Clear$_(), this._$_wrappedText$_ = null, this._$_renderer$_ = null, 
            this._$_wasReleased$_ = !0, vc.delete(this);
        }
        _$_SetDrawChanged$_() {
            this._$_drawChanged$_ = !0;
        }
        _$_SetTextLayoutChanged$_() {
            this._$_SetDrawChanged$_(), this._$_textLayoutChanged$_ = !0;
        }
        _$_SetWordWrapChanged$_() {
            this._$_SetTextLayoutChanged$_(), this._$_wordWrapChanged$_ = !0;
        }
        _$SetBBCodeEnabled$_(t) {
            if (t = !!t, this._$_isBBcodeEnabled$_ === t) return;
            this._$_isBBcodeEnabled$_ = t;
            const s = this._$_isBBcodeEnabled$_ ? "alphabetic" : "top";
            this._$_textContext$_ && (this._$_textContext$_.textBaseline = s), this._$_measureContext$_ && (this._$_measureContext$_.textBaseline = s), 
            this._$_SetWordWrapChanged$_();
        }
        _$IsBBCodeEnabled$_() {
            return this._$_isBBcodeEnabled$_;
        }
        _$SetIconSet$_(t) {
            this._$_iconSet$_ !== t && (this._$_iconSet$_ = t, this._$_wrappedText$_._$SetIconSet$_(t), 
            this._$_iconSet$_ && this._$_iconSet$_._$IsLoading$_() && this._$_iconSet$_._$LoadContent$_().then((() => this._$_SetDrawChanged$_())), 
            this._$_SetWordWrapChanged$_());
        }
        _$SetIconSmoothing$_(t) {
            t = !!t, this._$_iconSmoothing$_ !== t && (this._$_iconSmoothing$_ = t, this._$_SetDrawChanged$_());
        }
        _$SetFontName$_(t) {
            t || (t = "serif"), this._$_fontName$_ !== t && (this._$_fontName$_ = t, this._$_SetWordWrapChanged$_());
        }
        _$GetFontName$_() {
            return this._$_fontName$_;
        }
        _$SetFontSize$_(t) {
            t < .1 && (t = .1), this._$_fontSize$_ !== t && (this._$_fontSize$_ = t, this._$_SetWordWrapChanged$_());
        }
        _$GetFontSize$_() {
            return this._$_fontSize$_;
        }
        _$SetFontSizeScale$_(t) {
            this._$_fontSizeScale$_ !== t && (this._$_fontSizeScale$_ = t, this._$_SetWordWrapChanged$_());
        }
        _$SetLineHeight$_(t) {
            this._$_lineHeight$_ !== t && (this._$_lineHeight$_ = t, this._$_SetTextLayoutChanged$_());
        }
        _$GetLineHeight$_() {
            return this._$_lineHeight$_;
        }
        _$SetBold$_(t) {
            t = !!t, this._$_isBold$_ !== t && (this._$_isBold$_ = t, this._$_SetWordWrapChanged$_());
        }
        _$IsBold$_() {
            return this._$_isBold$_;
        }
        _$SetItalic$_(t) {
            t = !!t, this._$_isItalic$_ !== t && (this._$_isItalic$_ = t, this._$_SetWordWrapChanged$_());
        }
        _$IsItalic$_() {
            return this._$_isItalic$_;
        }
        _$SetDrawMaxCharacterCount$_(t) {
            t = Math.floor(t), this._$_drawMaxCharCount$_ !== t && (this._$_drawMaxCharCount$_ = t, 
            this._$_SetDrawChanged$_());
        }
        _$GetDrawMaxCharacterCount$_() {
            return this._$_drawMaxCharCount$_;
        }
        _$_GetFontString$_(t, s) {
            let i = [];
            (this._$_isBold$_ || s._$HasStyleTag$_("b")) && i.push("bold"), (this._$_isItalic$_ || s._$HasStyleTag$_("i")) && i.push("italic");
            const e = s._$GetStyleTag$_("size"), n = (e ? parseFloat(e._$param$_) : this._$_fontSize$_) * this._$_fontSizeScale$_;
            t ? i.push(n + "pt") : i.push(n * this._$GetDrawScale$_() + "pt");
            let h = this._$_fontName$_;
            const r = s._$GetStyleTag$_("font");
            return r && r._$param$_ && (h = r._$param$_, this._$onloadfont$_ && !this._$_alreadyLoadedFonts$_.has(h) && (this._$onloadfont$_(h), 
            this._$_alreadyLoadedFonts$_.add(h))), h && (gc.has(h) ? i.push(h) : i.push('"' + h + '"')), 
            i.join(" ");
        }
        _$SetColor$_(t) {
            t instanceof mc._$Color$_ && (t = t._$getCssRgb$_()), this._$_colorStr$_ !== t && (this._$_colorStr$_ = t, 
            this._$_SetDrawChanged$_());
        }
        _$SetColorRgb$_(t, s, i) {
            Mc._$setRgb$_(t, s, i), this._$SetColor$_(Mc);
        }
        _$SetHorizontalAlignment$_(t) {
            if (!wc.has(t)) throw new Error("invalid horizontal alignment");
            this._$_horizontalAlign$_ !== t && (this._$_horizontalAlign$_ = t, this._$_SetTextLayoutChanged$_());
        }
        _$GetHorizontalAlignment$_() {
            return this._$_horizontalAlign$_;
        }
        _$SetVerticalAlignment$_(t) {
            if (!Sc.has(t)) throw new Error("invalid vertical alignment");
            this._$_verticalAlign$_ !== t && (this._$_verticalAlign$_ = t, this._$_SetTextLayoutChanged$_());
        }
        _$GetVerticalAlignment$_() {
            return this._$_verticalAlign$_;
        }
        _$SetWordWrapMode$_(t) {
            if (!bc.has(t)) throw new Error("invalid word wrap mode");
            this._$_wrapMode$_ !== t && (this._$_wrapMode$_ = t, this._$_SetWordWrapChanged$_());
        }
        _$GetWordWrapMode$_() {
            return this._$_wrapMode$_;
        }
        _$SetTextDirection$_(t) {
            if (!Tc.has(t)) throw new Error("invalid text direction");
            this._$_textDirection$_ !== t && (this._$_textDirection$_ = t, this._$_textContext$_ && (this._$_textContext$_.direction = this._$_textDirection$_), 
            this._$_measureContext$_ && (this._$_measureContext$_.direction = this._$_textDirection$_), 
            this._$_SetWordWrapChanged$_());
        }
        _$GetTextDirection$_() {
            return this._$_textDirection$_;
        }
        _$SetText$_(t) {
            this._$_text$_ !== t && (this._$_text$_ = t, this._$_SetWordWrapChanged$_());
        }
        _$GetText$_() {
            return this._$_text$_;
        }
        _$GetDrawScale$_() {
            return this._$_scaleFactor$_ * this._$_zoom$_ * self.devicePixelRatio;
        }
        _$SetSize$_(t, s, i) {
            if (void 0 === i && (i = 1), t <= 0 || t <= 0) return;
            if (this._$_cssWidth$_ === t && this._$_cssHeight$_ === s && this._$_zoom$_ === i) return;
            const e = this._$_cssWidth$_;
            this._$_cssWidth$_ = t, this._$_cssHeight$_ = s, this._$_zoom$_ = i;
            const n = self.devicePixelRatio;
            this._$_width$_ = this._$_cssWidth$_ * this._$_zoom$_ * n, this._$_height$_ = this._$_cssHeight$_ * this._$_zoom$_ * n;
            const h = Math.max(this._$_width$_, this._$_height$_), r = Math.min(this._$_renderer$_._$GetMaxTextureSize$_(), 4096);
            let o = 1;
            h > r && (o = r / h, this._$_width$_ = Math.min(this._$_width$_ * o, r), this._$_height$_ = Math.min(this._$_height$_ * o, r)), 
            this._$_scaleFactor$_ = o, this._$_cssWidth$_ !== e ? this._$_SetWordWrapChanged$_() : this._$_SetTextLayoutChanged$_();
        }
        _$GetWidth$_() {
            return this._$_width$_;
        }
        _$GetHeight$_() {
            return this._$_height$_;
        }
        _$GetZoom$_() {
            return this._$_zoom$_;
        }
        _$GetTextWidth$_() {
            return this._$_UpdateTextMeasurements$_(), this._$_wrappedText$_._$GetMaxLineWidth$_();
        }
        _$GetTextHeight$_() {
            return this._$_UpdateTextMeasurements$_(), this._$_wrappedText$_._$GetTotalLineHeight$_() + this._$_wrappedText$_._$GetLineCount$_() * (this._$_lineHeight$_ + 4) - this._$_lineHeight$_;
        }
        _$GetLengthInGraphemes$_() {
            this._$_UpdateTextMeasurements$_();
            let t = 0;
            for (const s of this._$_wrappedText$_._$GetLines$_()) for (const i of s._$fragments$_()) t += i._$GetLength$_();
            return t;
        }
        _$GetTexture$_() {
            return this._$_textureTimeout$_._$Reset$_(), this._$_MaybeUpdate$_(), this._$_texture$_;
        }
        _$HitTestFragment$_(t, s) {
            this._$_UpdateTextMeasurements$_();
            const i = this._$GetDrawScale$_(), e = this._$_wrappedText$_._$GetLines$_();
            for (const n of e) {
                const e = n._$GetFontBoundingBoxDescent$_() * i;
                if (s >= n._$GetPosY$_() - n._$GetHeight$_() * i + e && s < n._$GetPosY$_() + e) for (const s of n._$fragments$_()) if (t >= s._$GetPosX$_() && t < s._$GetPosX$_() + s._$GetWidth$_() * i) return s;
            }
            return null;
        }
        * _$fragmentsWithTag$_(t) {
            this._$_UpdateTextMeasurements$_();
            const s = this._$_wrappedText$_._$GetLines$_();
            for (const i of s) for (const s of i._$fragments$_()) {
                const i = s._$GetStyleTag$_("tag");
                i && mc._$equalsNoCase$_(i._$param$_, t) && (yield s);
            }
        }
        _$FindFragmentWithTag$_(t, s) {
            for (const i of this._$fragmentsWithTag$_(t)) {
                if (0 === s) return i;
                --s;
            }
            return null;
        }
        _$CountFragmentsWithTag$_(t) {
            let s = 0;
            for (const i of this._$fragmentsWithTag$_(t)) ++s;
            return s;
        }
        _$_MaybeUpdate$_() {
            (!this._$_texture$_ || this._$_drawChanged$_ || this._$_textLayoutChanged$_ || this._$_wordWrapChanged$_) && (this._$_wasReleased$_ || this._$_width$_ <= 0 || this._$_height$_ <= 0 || (this._$_drawChanged$_ = !1, 
            this._$_DoUpdate$_()));
        }
        _$_DoUpdate$_() {
            this._$_wasReleased$_ || (this._$_UpdateTextMeasurements$_(), this._$_SetTextCanvasSize$_(Math.max(mc._$nextHighestPowerOfTwo$_(Math.ceil(this._$_width$_)), 128), Math.max(mc._$nextHighestPowerOfTwo$_(Math.ceil(this._$_height$_)), 64)), 
            this._$_DrawTextToCanvas$_(), this._$_UpdateTexture$_(), this._$_textureTimeout$_._$Reset$_());
        }
        _$_SetTextCanvasSize$_(t, s) {
            this._$_textCanvas$_ || (this._$_textCanvas$_ = mc._$CreateCanvas$_(16, 16));
            let i = !1;
            this._$_lastCanvasWidth$_ === t && this._$_lastCanvasHeight$_ === s || (this._$_lastCanvasWidth$_ = t, 
            this._$_lastCanvasHeight$_ = s, this._$_textCanvas$_.width = t, this._$_textCanvas$_.height = s, 
            i = !0), this._$_textContext$_ || (this._$_textContext$_ = this._$_textCanvas$_.getContext("2d"), 
            i = !0), i ? (this._$_textContext$_.textBaseline = this._$_isBBcodeEnabled$_ ? "alphabetic" : "top", 
            this._$_textContext$_.direction = this._$_textDirection$_, this._$_textContext$_.font = this._$_lastTextCanvasFont$_, 
            this._$_textContext$_.fillStyle = this._$_lastTextCanvasFillStyle$_, this._$_textContext$_.strokeStyle = this._$_lastTextCanvasFillStyle$_, 
            this._$_textContext$_.globalAlpha = this._$_lastTextCanvasOpacity$_, this._$_textContext$_.lineWidth = this._$_lastTextCanvasLineWidth$_) : this._$_textContext$_.clearRect(0, 0, t, s);
        }
        _$_MaybeCreateMeasureContext$_() {
            this._$_measureContext$_ || (this._$_measureContext$_ = mc._$CreateCanvas$_(16, 16).getContext("2d"), 
            this._$_measureContextTop$_ = mc._$CreateCanvas$_(16, 16).getContext("2d"), this._$_measureContext$_.textBaseline = this._$_isBBcodeEnabled$_ ? "alphabetic" : "top", 
            this._$_measureContextTop$_.textBaseline = "top", this._$_measureContext$_.direction = this._$_textDirection$_, 
            this._$_measureContextTop$_.direction = this._$_textDirection$_);
        }
        _$_SetMeasureFontString$_(t) {
            this._$_lastMeasureCanvasFont$_ !== t && (this._$_lastMeasureCanvasFont$_ = t, this._$_measureContext$_.font = t, 
            this._$_measureContextTop$_.font = t);
        }
        _$_SupportsFontBoundingBoxMeasurements$_() {
            if (!xc) {
                xc = !0, this._$_MaybeCreateMeasureContext$_();
                const t = this._$_measureContext$_.measureText("test");
                Ic = "number" == typeof t.fontBoundingBoxAscent && "number" == typeof t.fontBoundingBoxDescent;
            }
            return Ic;
        }
        _$_UpdateTextMeasurements$_() {
            this._$_UpdateWordWrap$_(), this._$_UpdateTextLayout$_();
        }
        _$_UpdateWordWrap$_() {
            this._$_wordWrapChanged$_ && (this._$_MaybeCreateMeasureContext$_(), !this._$_isBBcodeEnabled$_ || this._$_bbString$_ && this._$_bbString$_.toString() === this._$_text$_ || (this._$_bbString$_ = new mc._$BBString$_(this._$_text$_, {
                _$noEscape$_: !0
            })), this._$_wrappedText$_._$WordWrap$_(this._$_isBBcodeEnabled$_ ? this._$_bbString$_._$toFragmentList$_() : this._$_text$_, this._$_measureTextCallback$_, this._$_cssWidth$_, this._$_wrapMode$_, 0), 
            this._$_wordWrapChanged$_ = !1);
        }
        _$_UpdateTextLayout$_() {
            this._$_textLayoutChanged$_ && (this._$_LayoutText$_(), this._$_textLayoutChanged$_ = !1);
        }
        _$_MeasureText$_(t) {
            const s = t._$IsText$_() ? t._$GetCharacterArray$_().join("") : " ";
            this._$_SetMeasureFontString$_(this._$_GetFontString$_(!0, t));
            const i = t._$GetStyleTag$_("size"), e = (i ? parseFloat(i._$param$_) : this._$_fontSize$_) * this._$_fontSizeScale$_, n = this._$_measureContext$_.measureText(s);
            let h = 0;
            if (this._$_isBBcodeEnabled$_ && this._$_SupportsFontBoundingBoxMeasurements$_()) {
                const t = this._$_measureContextTop$_.measureText(s);
                h = n.fontBoundingBoxAscent - t.fontBoundingBoxAscent;
            }
            return {
                width: n.width,
                height: dc(e),
                fontBoundingBoxAscent: n.fontBoundingBoxAscent || 0,
                fontBoundingBoxDescent: n.fontBoundingBoxDescent || 0,
                _$topToAlphabeticDistance$_: h
            };
        }
        _$_SetDrawFontString$_(t) {
            this._$_lastTextCanvasFont$_ !== t && (this._$_lastTextCanvasFont$_ = t, this._$_textContext$_.font = t);
        }
        _$_SetDrawCanvasColor$_(t) {
            this._$_lastTextCanvasFillStyle$_ !== t && (this._$_lastTextCanvasFillStyle$_ = t, 
            this._$_textContext$_.fillStyle = t, this._$_textContext$_.strokeStyle = t);
        }
        _$_SetDrawCanvasOpacity$_(t) {
            this._$_lastTextCanvasOpacity$_ !== t && (this._$_lastTextCanvasOpacity$_ = t, this._$_textContext$_.globalAlpha = t);
        }
        _$_SetDrawCanvasLineWith$_(t) {
            this._$_lastTextCanvasLineWidth$_ !== t && (this._$_lastTextCanvasLineWidth$_ = t, 
            this._$_textContext$_.lineWidth = t);
        }
        _$_LayoutText$_() {
            const t = this._$GetDrawScale$_(), s = (4 + this._$_lineHeight$_) * t;
            let i = 0;
            const e = this._$_wrappedText$_._$GetLines$_();
            if (0 === e.length) return;
            for (const t of e) {
                t._$SetPosX$_(NaN), t._$SetPosY$_(NaN);
                for (const s of t._$fragments$_()) s._$SetPosX$_(NaN), s._$SetPosY$_(NaN);
            }
            const n = this._$_isBBcodeEnabled$_ && this._$_SupportsFontBoundingBoxMeasurements$_();
            let h = e[0]._$GetHeight$_() * t;
            if ("center" === this._$_verticalAlign$_) {
                const r = e.reduce(((i, e) => i + e._$GetHeight$_() * t + s), 0) - s;
                i = Math.max(this._$_height$_ / 2 - r / 2, 0), n && (h = e[0]._$GetTopToAlphabeticDistance$_() * t);
            } else if ("bottom" === this._$_verticalAlign$_) {
                const h = e.reduce(((i, e) => i + e._$GetHeight$_() * t + s), 0) - this._$_lineHeight$_ * t, r = n ? e.at(-1)._$GetFontBoundingBoxDescent$_() * t : 0;
                i = this._$_height$_ - h - r - 2;
            }
            for (let n = 0, r = e.length; n < r; ++n) {
                const r = e[n], o = r._$GetHeight$_() * t, a = i;
                if (this._$_isBBcodeEnabled$_) {
                    if (i += 0 === n ? h : o, n > 0 && i > this._$_height$_ - 4 * t) break;
                } else if (n > 0 && i >= this._$_height$_ - o) break;
                a >= 0 && this._$_LayoutTextLine$_(r, i, t), this._$_isBBcodeEnabled$_ || (i += o), 
                i += s;
            }
        }
        _$_LayoutTextLine$_(t, s, i) {
            let e = 0;
            "center" === this._$_horizontalAlign$_ ? e = Math.floor((this._$_width$_ - t._$GetWidth$_() * i) / 2) : "right" === this._$_horizontalAlign$_ && (e = this._$_width$_ - t._$GetWidth$_() * i), 
            t._$SetPosX$_(e), t._$SetPosY$_(s);
            for (const n of "ltr" === this._$_textDirection$_ ? t._$fragments$_() : t._$fragmentsReverse$_()) this._$_LayoutFragment$_(n, e, s, i), 
            e += n._$GetWidth$_() * i;
        }
        _$_LayoutFragment$_(t, s, i, e) {
            const n = t._$GetStyleTag$_("offsetx");
            s += n ? pc(n._$param$_, t._$GetHeight$_()) * e : 0;
            const h = t._$GetStyleTag$_("offsety");
            if (i += h ? pc(h._$param$_, t._$GetHeight$_()) * e : 0, t._$IsIcon$_()) {
                const s = t._$GetStyleTag$_("iconoffsety");
                i += s ? pc(s._$param$_, t._$GetHeight$_()) * e : .2 * t._$GetHeight$_() * e;
            }
            t._$SetPosX$_(s), t._$SetPosY$_(i);
        }
        _$_DrawTextToCanvas$_() {
            this._$_textContext$_.imageSmoothingEnabled = this._$_iconSmoothing$_, this._$_textContext$_.imageSmoothingQuality = "high", 
            this._$_drawCharCount$_ = 0;
            const t = this._$GetDrawScale$_(), s = this._$_wrappedText$_._$GetLines$_();
            for (const i of s) this._$_DrawTextLine$_(i, t);
        }
        _$_DrawTextLine$_(t, s) {
            const i = t._$GetPosX$_(), e = t._$GetPosY$_();
            if (Number.isFinite(i) && Number.isFinite(e)) for (const i of "ltr" === this._$_textDirection$_ ? t._$fragments$_() : t._$fragmentsReverse$_()) this._$_DrawFragment$_(i, s, t._$GetHeight$_());
        }
        _$_DrawFragment$_(t, s, i) {
            const e = this._$_textContext$_, n = t._$GetPosX$_(), h = t._$GetPosY$_();
            if (!Number.isFinite(n) || !Number.isFinite(h)) return;
            const r = i / 16;
            let o = t._$GetWidth$_() * s;
            const a = t._$GetHeight$_() * s, u = t._$GetHeight$_() / 16, l = (4 + this._$_lineHeight$_) * s;
            let c = t._$IsText$_() ? t._$GetCharacterArray$_() : null;
            if (-1 !== this._$_drawMaxCharCount$_) {
                if (this._$_drawCharCount$_ >= this._$_drawMaxCharCount$_) return;
                t._$IsText$_() && this._$_drawCharCount$_ + c.length > this._$_drawMaxCharCount$_ && (c = c.slice(0, this._$_drawMaxCharCount$_ - this._$_drawCharCount$_), 
                o = this._$_MeasureText$_(t).width * s), this._$_drawCharCount$_ += t._$GetLength$_();
            }
            const f = t._$GetStyleTag$_("background"), d = t._$HasStyleTag$_("u"), p = t._$HasStyleTag$_("s");
            if (t._$IsText$_() && mc._$IsCharArrayAllWhitespace$_(c) && !f && !d && !p || t._$HasStyleTag$_("hide")) return;
            const m = t._$GetStyleTag$_("color"), g = t._$GetStyleTag$_("opacity");
            this._$_SetDrawCanvasOpacity$_(g ? parseFloat(g._$param$_) / 100 : 1), f && (this._$_SetDrawCanvasColor$_(f._$param$_), 
            e.fillRect(n, h - a, o, a + l));
            const y = t._$GetStyleTag$_("linethickness"), M = y ? parseFloat(y._$param$_) : 1, w = t._$HasStyleTag$_("stroke");
            if (w && this._$_SetDrawCanvasLineWith$_(.5 * u * M * this._$GetDrawScale$_()), 
            t._$IsText$_()) {
                const s = c.join("");
                if (this._$_SetDrawFontString$_(this._$_GetFontString$_(!1, t)), !w) {
                    this._$_SetDrawCanvasLineWith$_(.5 * u * M * this._$GetDrawScale$_());
                    const i = t._$GetStyleTag$_("outlineback");
                    i && (this._$_SetDrawCanvasColor$_(i._$param$_), this._$_FillOrStrokeText$_(!0, s, n, h, o));
                }
                if (this._$_SetDrawCanvasColor$_(m ? m._$param$_ : this._$_colorStr$_), this._$_FillOrStrokeText$_(w, s, n, h, o), 
                !w) {
                    this._$_SetDrawCanvasLineWith$_(.5 * u * M * this._$GetDrawScale$_());
                    const i = t._$GetStyleTag$_("outline");
                    i && (this._$_SetDrawCanvasColor$_(i._$param$_), this._$_FillOrStrokeText$_(!0, s, n, h, o));
                }
            } else if (t._$IsIcon$_() && t._$GetWidth$_() > 0) {
                const s = t._$GetDrawable$_(this._$_iconSet$_);
                s && e.drawImage(s, n, h - a, o, a);
            }
            if (this._$_SetDrawCanvasColor$_(m ? m._$param$_ : this._$_colorStr$_), d && fc(e, w, n, h + s * r, o, s * r * M), 
            p) {
                const t = s * u, i = h - a / 4 + t / 2;
                e.fillRect(n, i - t * M / 2, o, t * M);
            }
        }
        _$_FillOrStrokeText$_(t, s, i, e, n) {
            "rtl" === this._$_textDirection$_ && (i += n), t ? "Gecko" === mc._$Platform$_._$BrowserEngine$_ ? this._$_textContext$_.strokeText(s, i, e, n) : this._$_textContext$_.strokeText(s, i, e) : "Gecko" === mc._$Platform$_._$BrowserEngine$_ ? this._$_textContext$_.fillText(s, i, e, n) : this._$_textContext$_.fillText(s, i, e);
        }
        _$_UpdateTexture$_() {
            this._$_renderer$_._$IsContextLost$_() || (this._$_texture$_ || (this._$_texture$_ = this._$_renderer$_._$CreateDynamicTexture$_(this._$_textCanvas$_.width, this._$_textCanvas$_.height, {
                _$mipMap$_: !0,
                _$mipMapQuality$_: "high"
            })), this._$_renderer$_._$UpdateTexture$_(this._$_textCanvas$_, this._$_texture$_), 
            this._$_rcTex$_.set(0, 0, this._$_width$_ / this._$_texture$_._$GetWidth$_(), this._$_height$_ / this._$_texture$_._$GetHeight$_()), 
            this._$ontextureupdate$_ && this._$ontextureupdate$_());
        }
        _$GetTexRect$_() {
            return this._$_rcTex$_;
        }
        _$ReleaseTexture$_() {
            this._$_texture$_ && (this._$_renderer$_._$IsContextLost$_() || this._$_renderer$_._$DeleteTexture$_(this._$_texture$_), 
            this._$_texture$_ = null);
        }
        static _$OnContextLost$_() {
            for (const t of vc) t._$ReleaseTexture$_();
        }
        static _$GetAll$_() {
            return vc.values();
        }
    };
}

{
    const Gc = self._$C3$_;
    class Cc {
        constructor(t) {
            this._$_gl$_ = t._$GetContext$_(), this._$_version$_ = t._$GetWebGLVersionNumber$_(), 
            this._$_timerExt$_ = t._$_GetDisjointTimerQueryExtension$_(), this._$_query$_ = null, 
            this._$_isActive$_ = !1, this._$_hasResult$_ = !1, this._$_result$_ = 0, 1 === this._$_version$_ ? this._$_query$_ = this._$_timerExt$_.createQueryEXT() : this._$_query$_ = this._$_gl$_.createQuery();
        }
        _$Release$_() {
            this._$_DeleteQueryObject$_(), this._$_gl$_ = null, this._$_timerExt$_ = null, this._$_hasResult$_ = !1;
        }
        _$_DeleteQueryObject$_() {
            this._$_query$_ && (1 === this._$_version$_ ? this._$_timerExt$_.deleteQueryEXT(this._$_query$_) : this._$_gl$_.deleteQuery(this._$_query$_), 
            this._$_query$_ = null);
        }
        _$BeginTimeElapsed$_() {
            if (this._$_isActive$_) throw new Error("query already active");
            1 === this._$_version$_ ? this._$_timerExt$_.beginQueryEXT(this._$_timerExt$_.TIME_ELAPSED_EXT, this._$_query$_) : this._$_gl$_.beginQuery(this._$_timerExt$_.TIME_ELAPSED_EXT, this._$_query$_), 
            this._$_isActive$_ = !0;
        }
        _$EndTimeElapsed$_() {
            if (!this._$_isActive$_) throw new Error("query not active");
            1 === this._$_version$_ ? this._$_timerExt$_.endQueryEXT(this._$_timerExt$_.TIME_ELAPSED_EXT) : this._$_gl$_.endQuery(this._$_timerExt$_.TIME_ELAPSED_EXT), 
            this._$_isActive$_ = !1;
        }
        _$CheckForResult$_() {
            if (!this._$_query$_ || this._$_hasResult$_ || this._$_isActive$_) return;
            let t = !1;
            t = 1 === this._$_version$_ ? this._$_timerExt$_.getQueryObjectEXT(this._$_query$_, this._$_timerExt$_.QUERY_RESULT_AVAILABLE_EXT) : this._$_gl$_.getQueryParameter(this._$_query$_, this._$_gl$_.QUERY_RESULT_AVAILABLE);
            const s = this._$_gl$_.getParameter(this._$_timerExt$_.GPU_DISJOINT_EXT);
            t && !s && (1 === this._$_version$_ ? this._$_result$_ = this._$_timerExt$_.getQueryObjectEXT(this._$_query$_, this._$_timerExt$_.QUERY_RESULT_EXT) : this._$_result$_ = this._$_gl$_.getQueryParameter(this._$_query$_, this._$_gl$_.QUERY_RESULT), 
            this._$_result$_ /= 1e9, this._$_hasResult$_ = !0), (t || s) && this._$_DeleteQueryObject$_();
        }
        _$HasResult$_() {
            return this._$_hasResult$_;
        }
        _$GetResult$_() {
            if (!this._$_hasResult$_) throw new Error("no result available");
            return this._$_result$_;
        }
    }
    Gc._$Gfx$_._$WebGLTimeElapsedQuery$_ = class {
        constructor(t) {
            this._$_renderer$_ = t, this._$_frameNumber$_ = t._$GetFrameNumber$_(), this._$_isActive$_ = !1, 
            this._$_parentQuery$_ = null, this._$_isNested$_ = !1, this._$_realQuery$_ = null, 
            this._$_queries$_ = [];
        }
        _$Release$_() {
            for (const t of this._$_queries$_) t instanceof Cc && t._$Release$_();
            Gc._$clearArray$_(this._$_queries$_), this._$_parentQuery$_ = null, this._$_realQuery$_ = null, 
            this._$_renderer$_ = null;
        }
        _$BeginTimeElapsed$_() {
            if (this._$_isActive$_) throw new Error("query already active");
            const t = this._$_renderer$_._$_GetTimeQueryStack$_();
            t.length > 0 ? (this._$_isNested$_ = !0, this._$_parentQuery$_ = t.at(-1), this._$_parentQuery$_._$_EndReal$_(), 
            this._$_parentQuery$_._$_queries$_.push(this)) : (this._$_isNested$_ = !1, this._$_parentQuery$_ = null), 
            this._$_isActive$_ = !0, t.push(this), this._$_StartReal$_();
        }
        _$EndTimeElapsed$_() {
            if (!this._$_isActive$_) throw new Error("query not active");
            if (this._$_renderer$_._$_GetTimeQueryStack$_().pop() !== this) throw new Error("can only end most nested query");
            this._$_isActive$_ = !1, this._$_EndReal$_(), this._$_parentQuery$_ && (this._$_parentQuery$_._$_StartReal$_(), 
            this._$_parentQuery$_ = null);
        }
        _$_StartReal$_() {
            this._$_realQuery$_ = Gc._$New$_(Cc, this._$_renderer$_), this._$_queries$_.push(this._$_realQuery$_), 
            this._$_realQuery$_._$BeginTimeElapsed$_();
        }
        _$_EndReal$_() {
            this._$_realQuery$_._$EndTimeElapsed$_(), this._$_realQuery$_ = null;
        }
        _$CheckForResult$_() {
            for (const t of this._$_queries$_) t._$CheckForResult$_();
        }
        _$IsNested$_() {
            return this._$_isNested$_;
        }
        _$HasResult$_() {
            return this._$_queries$_.every((t => t._$HasResult$_()));
        }
        _$GetResult$_() {
            return this._$_queries$_.reduce(((t, s) => t + s._$GetResult$_()), 0);
        }
        _$GetFrameNumber$_() {
            return this._$_frameNumber$_;
        }
    };
}

{
    const _c = self._$C3$_;
    _c._$Gfx$_._$WebGLQueryResultBuffer$_ = class {
        constructor(t, s = 1e3) {
            this._$_renderer$_ = t, this._$_maxQueries$_ = s, this._$_buffer$_ = [], this._$_renderer$_._$_AddQueryResultBuffer$_(this);
        }
        _$Release$_() {
            this._$Clear$_(), this._$_renderer$_._$_RemoveQueryResultBuffer$_(this), this._$_renderer$_ = null;
        }
        _$Clear$_() {
            for (const t of this._$_buffer$_) t._$Release$_();
            _c._$clearArray$_(this._$_buffer$_);
        }
        _$AddTimeElapsedQuery$_() {
            const t = new _c._$Gfx$_._$WebGLTimeElapsedQuery$_(this._$_renderer$_);
            return this._$_buffer$_.push(t), this._$_buffer$_.length > this._$_maxQueries$_ && this._$_buffer$_.shift()._$Release$_(), 
            t;
        }
        _$CheckForResults$_(t) {
            for (const s of this._$_buffer$_) {
                if (s._$GetFrameNumber$_() >= t) return;
                if (s._$IsNested$_()) return;
                s._$CheckForResult$_();
            }
        }
        _$GetFrameRangeResultSum$_(t, s) {
            if (s <= t) return NaN;
            let i = 0;
            for (const e of this._$_buffer$_) {
                if (e._$GetFrameNumber$_() >= s) break;
                if (!(e._$GetFrameNumber$_() < t)) {
                    if (!e._$HasResult$_()) return NaN;
                    i += e._$GetResult$_();
                }
            }
            return i;
        }
        _$DeleteAllBeforeFrameNumber$_(t) {
            for (let s = 0, i = this._$_buffer$_.length; s < i; ++s) {
                const i = this._$_buffer$_[s];
                if (!(i._$GetFrameNumber$_() < t)) return void (s > 0 && this._$_buffer$_.splice(0, s));
                i._$Release$_();
            }
        }
    };
}

{
    let Ec = function() {
        Wc = -1;
        for (const t of Uc) t._$checkFunc$_() && (t.resolve(), Uc.delete(t));
        Uc.size > 0 && (Wc = self.requestAnimationFrame(Ec));
    };
    0;
    const Dc = self._$C3$_, Ac = (self.assert, self._$glMatrix$_), Nc = (Ac._$vec3$_, 
    Ac._$vec4$_), Lc = Ac._$mat4$_, Oc = {
        powerPreference: "default",
        _$enableGpuProfiling$_: !0,
        alpha: !1,
        depth: !1,
        _$canSampleDepth$_: !1,
        _$maxWebGLVersion$_: 2,
        failIfMajorPerformanceCaveat: !1
    }, Rc = new Set([ "default", "low-power", "high-performance" ]), Pc = new Dc._$Quad$_(0, 0, 1, 0, 1, 1, 0, 1), kc = Lc.create(), Fc = Lc.create(), jc = new Dc._$Quad$_, Bc = new Dc.Rect;
    let zc = null;
    Dc._$isDebug$_ && (self._$debug_lose_webgl_context$_ = function() {
        zc ? zc.loseContext() : console.warn("WEBGL_lose_context not supported");
    }, self._$debug_restore_webgl_context$_ = function() {
        zc ? zc.restoreContext() : console.warn("WEBGL_lose_context not supported");
    });
    const Uc = new Set;
    let Wc = -1;
    Dc._$Gfx$_._$WebGLRenderer$_ = class extends Dc._$Gfx$_._$RendererBase$_ {
        constructor(t, s) {
            if (super(s), s = Object.assign({}, Oc, s), !Rc.has(s.powerPreference)) throw new Error("invalid power preference");
            const i = {
                alpha: !!s.alpha,
                depth: !1,
                antialias: !1,
                powerPreference: s.powerPreference,
                failIfMajorPerformanceCaveat: !!s.failIfMajorPerformanceCaveat
            };
            let e = null, n = 0;
            if (s._$maxWebGLVersion$_ >= 2 && (e = t.getContext("webgl2", i), n = 2), e || (e = t.getContext("webgl", i), 
            n = 1), !e) throw new Error("renderer-unavailable (could not get WebGL context)");
            this._$_gl$_ = e, this._$_attribs$_ = e.getContextAttributes(), this._$_versionString$_ = e.getParameter(e.VERSION), 
            this._$_version$_ = n, this._$_viewport$_ = Nc.create(), this._$_didChangeTransform$_ = !1, 
            this._$_bbProjectionMatrix$_ = Lc.create(), this._$_usesDepthBuffer$_ = !!s.depth, 
            this._$_canSampleDepth$_ = !(!s.depth || !s._$canSampleDepth$_), this._$_isDepthEnabled$_ = this._$_usesDepthBuffer$_, 
            this._$_isDepthSamplingEnabled$_ = !1, this._$_depthBuffer$_ = null, this._$_isAutoSizeDepthBuffer$_ = !0, 
            this._$_depthBufferWidth$_ = 0, this._$_depthBufferHeight$_ = 0, this._$_vertexBuffer$_ = null, 
            this._$_texcoordBuffer$_ = null, this._$_indexBuffer$_ = null, this._$_pointBuffer$_ = null, 
            this._$_vertexData$_ = new Float32Array(8e3 * this._$GetNumVertexComponents$_()), 
            this._$_indexData$_ = new Uint16Array(12e3), this._$_texcoordData$_ = new Float32Array(16e3), 
            this._$_pointData$_ = new Float32Array(32e3), this._$_vertexPtr$_ = 0, this._$_texPtr$_ = 0, 
            this._$_pointPtr$_ = 0, this._$_lastVertexPtr$_ = 0, this._$_lastProgram$_ = null, 
            this._$_spDeviceTransformTextureFill$_ = null, this._$_batch$_ = [], this._$_batchPtr$_ = 0, 
            this._$_topOfBatch$_ = 0, this._$_currentRenderTarget$_ = null, this._$_lastPointZ$_ = 0, 
            this._$_batchState$_ = Dc._$New$_(Dc._$Gfx$_._$BatchState$_, this), this._$_lastColor$_ = Dc._$New$_(Dc._$Color$_, 1, 1, 1, 1), 
            this._$_lastTexture0$_ = null, this._$_lastTexture1$_ = null, this._$_lastSrcBlend$_ = 0, 
            this._$_lastDestBlend$_ = 0, this._$_lastPointTexCoords$_ = new Dc.Rect, this._$_lastScissorRect$_ = Dc._$New$_(Dc.Rect, 0, 0, -1, -1), 
            this._$_coplanarMode$_ = 0, this._$_maxTextureSize$_ = -1, this._$_minPointSize$_ = 0, 
            this._$_maxPointSize$_ = 0, this._$_highpPrecision$_ = 0, this._$_unmaskedVendor$_ = "(unavailable)", 
            this._$_unmaskedRenderer$_ = "(unavailable)", this._$_extensions$_ = [], this._$_isInitialisingAfterContextRestored$_ = !1, 
            this._$_parallelShaderCompileExt$_ = null, this._$_anisotropicExt$_ = null, this._$_conservativeDepthExt$_ = null, 
            this._$_depthTextureExt$_ = null, this._$_fragDepthExt$_ = null, this._$_stdDerivativesExt$_ = null, 
            this._$_textureLodExt$_ = null, this._$_maxAnisotropy$_ = 0, this._$_isGpuProfilingEnabled$_ = !!s._$enableGpuProfiling$_, 
            this._$_timerExt$_ = null, this._$_allQueryResultBuffers$_ = new Set, this._$_timeQueryStack$_ = [], 
            this._$FillIndexBufferData$_(this._$_indexData$_);
        }
        _$IsWebGL$_() {
            return !0;
        }
        async _$InitState$_() {
            super._$InitState$_();
            const t = this._$_gl$_, s = this._$GetNumVertexComponents$_();
            this._$_lastColor$_._$setRgba$_(1, 1, 1, 1), this._$_lastTexture0$_ = null, this._$_lastTexture1$_ = null, 
            this._$_vertexPtr$_ = 0, this._$_pointPtr$_ = 0, this._$_lastVertexPtr$_ = 8e3 * s - 4 * s, 
            Dc._$clearArray$_(this._$_batch$_), this._$_batchPtr$_ = 0, this._$_topOfBatch$_ = 0, 
            this._$_lastProgram$_ = null, this._$_currentRenderTarget$_ = null, this._$_lastPointTexCoords$_.set(0, 0, 1, 1), 
            this._$_lastPointZ$_ = 0;
            const i = this._$_batchState$_;
            i._$currentShader$_ = null, i._$currentFramebuffer$_ = null, i._$currentFramebufferNoDepth$_ = null, 
            Nc.set(i._$currentColor$_, 1, 1, 1, 1), i.clearColor._$setRgba$_(0, 0, 0, 0), i._$pointTexCoords$_.set(0, 0, 1, 1), 
            t.clearColor(0, 0, 0, 0), t.clear(t.COLOR_BUFFER_BIT), t.enable(t.BLEND), t.blendFunc(t.ONE, t.ONE_MINUS_SRC_ALPHA), 
            this._$_lastSrcBlend$_ = t.ONE, this._$_lastDestBlend$_ = t.ONE_MINUS_SRC_ALPHA, 
            this._$_InitBlendModes$_(t), t.disable(t.CULL_FACE), t.disable(t.STENCIL_TEST), 
            t.disable(t.DITHER), this._$_usesDepthBuffer$_ ? (t.enable(t.DEPTH_TEST), t.depthMask(!0), 
            t.depthFunc(t.LEQUAL)) : (t.disable(t.DEPTH_TEST), t.depthMask(!1)), this._$_isDepthEnabled$_ = this._$_usesDepthBuffer$_, 
            this._$_isDepthSamplingEnabled$_ = !1, this._$_pointBuffer$_ = t.createBuffer(), 
            t.bindBuffer(t.ARRAY_BUFFER, this._$_pointBuffer$_), t.bufferData(t.ARRAY_BUFFER, this._$_pointData$_.byteLength, t.DYNAMIC_DRAW), 
            this._$_vertexBuffer$_ = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this._$_vertexBuffer$_), 
            t.bufferData(t.ARRAY_BUFFER, this._$_vertexData$_.byteLength, t.DYNAMIC_DRAW), this._$_texcoordBuffer$_ = t.createBuffer(), 
            t.bindBuffer(t.ARRAY_BUFFER, this._$_texcoordBuffer$_), t.bufferData(t.ARRAY_BUFFER, this._$_texcoordData$_.byteLength, t.DYNAMIC_DRAW), 
            this._$_indexBuffer$_ = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this._$_indexBuffer$_), 
            t.bufferData(t.ELEMENT_ARRAY_BUFFER, this._$_indexData$_, t.STATIC_DRAW), t.activeTexture(t.TEXTURE0), 
            t.bindTexture(t.TEXTURE_2D, null), this._$_maxTextureSize$_ = t.getParameter(t.MAX_TEXTURE_SIZE);
            const e = t.getParameter(t.ALIASED_POINT_SIZE_RANGE);
            this._$_minPointSize$_ = e[0], this._$_maxPointSize$_ = e[1];
            const n = t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT), h = t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT);
            this._$_highpPrecision$_ = n && h ? Math.min(n.precision, h.precision) : 0, this._$_maxPointSize$_ > 2048 && (this._$_maxPointSize$_ = 2048), 
            this._$_extensions$_ = t.getSupportedExtensions();
            const r = t.getExtension("WEBGL_debug_renderer_info");
            if (r && (this._$_unmaskedVendor$_ = t.getParameter(r.UNMASKED_VENDOR_WEBGL), this._$_unmaskedRenderer$_ = t.getParameter(r.UNMASKED_RENDERER_WEBGL)), 
            this._$_parallelShaderCompileExt$_ = t.getExtension("KHR_parallel_shader_compile"), 
            Dc._$isDebug$_ && (zc = t.getExtension("WEBGL_lose_context")), this._$_isGpuProfilingEnabled$_ && (1 === this._$GetWebGLVersionNumber$_() ? this._$_timerExt$_ = t.getExtension("EXT_disjoint_timer_query") : this._$_timerExt$_ = t.getExtension("EXT_disjoint_timer_query_webgl2") || t.getExtension("EXT_disjoint_timer_query")), 
            this._$_anisotropicExt$_ = t.getExtension("EXT_texture_filter_anisotropic"), this._$_anisotropicExt$_ ? this._$_maxAnisotropy$_ = t.getParameter(this._$_anisotropicExt$_.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : this._$_maxAnisotropy$_ = 0, 
            this._$GetWebGLVersionNumber$_() < 2 && this._$_usesDepthBuffer$_ && this._$_canSampleDepth$_ && (this._$_depthTextureExt$_ = t.getExtension("WEBGL_depth_texture"), 
            !this._$_depthTextureExt$_)) throw new Error("no depth texture support");
            this._$GetWebGLVersionNumber$_() < 2 && (this._$_fragDepthExt$_ = t.getExtension("EXT_frag_depth"), 
            this._$_stdDerivativesExt$_ = t.getExtension("OES_standard_derivatives"), this._$_textureLodExt$_ = t.getExtension("EXT_shader_texture_lod"));
            const o = Dc._$Gfx$_._$WebGLShaderProgram$_, a = o._$GetDefaultVertexShaderSource$_(!1);
            let u = o._$GetTextureFillFragmentShaderSource_WebGL1_NoFragDepth$_(), l = a, c = o._$GetPointFragmentShaderSource_WebGL1_NoFragDepth$_(), f = o._$GetPointVertexShaderSource_WebGL1$_(), d = o._$GetTilemapFragmentShaderSource_WebGL1_NoFragDepth$_(), p = o._$GetDefaultVertexShaderSource$_(!0), m = !1;
            this._$_usesDepthBuffer$_ && (this._$GetWebGLVersionNumber$_() < 2 ? this._$_fragDepthExt$_ && (u = o._$GetTextureFillFragmentShaderSource_WebGL1_FragDepthEXT$_(), 
            c = o._$GetPointFragmentShaderSource_WebGL1_FragDepthEXT$_(), d = o._$GetTilemapFragmentShaderSource_WebGL1_FragDepthEXT$_(), 
            m = !0) : (l = o._$GetDefaultVertexShaderSource_WebGL2$_(), u = o._$GetTextureFillFragmentShaderSource_WebGL2$_(this._$_SupportsConservativeDepth$_()), 
            c = o._$GetPointFragmentShaderSource_WebGL2$_(this._$_SupportsConservativeDepth$_()), 
            f = o._$GetPointVertexShaderSource_WebGL2$_(), d = o._$GetTilemapFragmentShaderSource_WebGL2$_(this._$_SupportsConservativeDepth$_()), 
            p = o._$GetDefaultVertexShaderSource_WebGL2$_(!0)));
            const g = o._$GetTileRandomizationFragmentShaderSource$_(this._$GetWebGLVersionNumber$_(), m, this._$_stdDerivativesExt$_ && this._$_textureLodExt$_, this._$_SupportsConservativeDepth$_()), y = this._$GetWebGLVersionNumber$_() >= 2 ? o._$GetDefaultVertexShaderSource_WebGL2$_() : a, M = [ [ u, l, "<default>" ], [ u, l, "<default-device-transform>" ], [ c, f, "<point>" ], [ o._$GetColorFillFragmentShaderSource$_(), a, "<fill>" ], [ o._$GetLinearGradientFillFragmentShaderSource$_(), a, "<lineargradient>" ], [ o._$GetPenumbraFillFragmentShaderSource$_(), a, "<penumbra>" ], [ o._$GetHardEllipseFillFragmentShaderSource$_(), a, "<hardellipse>" ], [ o._$GetHardEllipseOutlineFragmentShaderSource$_(), a, "<hardellipseoutline>" ], [ o._$GetSmoothEllipseFillFragmentShaderSource$_(), a, "<smoothellipse>" ], [ o._$GetSmoothEllipseOutlineFragmentShaderSource$_(), a, "<smoothellipseoutline>" ], [ o._$GetSmoothLineFillFragmentShaderSource$_(), a, "<smoothline>" ], [ d, p, "<tilemap>" ], [ g, y, "<tilerandomization>" ] ], w = await Promise.all(M.map((t => this._$CreateShaderProgram$_({
                src: t[0],
                _$vertexSrc$_: t[1],
                name: t[2]
            }))));
            this._$_spTextureFill$_ = w[0], this._$_spDeviceTransformTextureFill$_ = w[1], this._$_spPoints$_ = w[2], 
            this._$_spColorFill$_ = w[3], this._$_spLinearGradientFill$_ = w[4], this._$_spPenumbraFill$_ = w[5], 
            this._$_spHardEllipseFill$_ = w[6], this._$_spHardEllipseOutline$_ = w[7], this._$_spSmoothEllipseFill$_ = w[8], 
            this._$_spSmoothEllipseOutline$_ = w[9], this._$_spSmoothLineFill$_ = w[10], this._$_spTilemapFill$_ = w[11], 
            this._$_spTileRandomization$_ = w[12], this._$SetTextureFillMode$_();
        }
        async _$CreateShaderProgram$_(t) {
            const s = await Dc._$Gfx$_._$WebGLShaderProgram$_._$Create$_(this, t);
            return this._$_AddShaderProgram$_(s), s;
        }
        _$ResetLastProgram$_() {
            this._$_lastProgram$_ = null;
        }
        _$SetSize$_(t, s, i) {
            if (this._$_width$_ === t && this._$_height$_ === s && !i) return;
            this._$EndBatch$_();
            const e = this._$_gl$_, n = this._$_batchState$_;
            this._$_width$_ = t, this._$_height$_ = s, this._$_SetViewport$_(0, 0, t, s), this._$CalculatePerspectiveMatrix$_(this._$_bbProjectionMatrix$_, t / s), 
            this._$SetProjectionMatrix$_(this._$_bbProjectionMatrix$_), this._$_spDeviceTransformTextureFill$_ && (e.useProgram(this._$_spDeviceTransformTextureFill$_._$GetShaderProgram$_()), 
            this._$_spDeviceTransformTextureFill$_._$_UpdateDeviceTransformUniforms$_(this._$_matP$_), 
            this._$_lastProgram$_ = this._$_spDeviceTransformTextureFill$_, this._$_batchState$_._$currentShader$_ = this._$_spDeviceTransformTextureFill$_), 
            e.bindTexture(e.TEXTURE_2D, null), e.activeTexture(e.TEXTURE1), e.bindTexture(e.TEXTURE_2D, null), 
            e.activeTexture(e.TEXTURE0), this._$_lastTexture0$_ = null, this._$_lastTexture1$_ = null, 
            this._$_usesDepthBuffer$_ && this._$_isAutoSizeDepthBuffer$_ && this._$_SetDepthBufferSize$_(this._$_width$_, this._$_height$_), 
            this._$_currentRenderTarget$_ && this._$_currentRenderTarget$_._$_Resize$_(this._$_width$_, this._$_height$_), 
            e.bindFramebuffer(e.FRAMEBUFFER, null), this._$_currentRenderTarget$_ = null, n._$currentFramebuffer$_ = null, 
            n._$currentFramebufferNoDepth$_ = null;
        }
        _$_SetDepthBufferSize$_(t, s) {
            const i = this._$_gl$_;
            this._$_depthBuffer$_ && this._$_depthBufferWidth$_ === t && this._$_depthBufferHeight$_ === s || (this._$_canSampleDepth$_ ? (this._$_depthBuffer$_ && i.deleteTexture(this._$_depthBuffer$_), 
            this._$_depthBuffer$_ = i.createTexture(), i.bindTexture(i.TEXTURE_2D, this._$_depthBuffer$_), 
            i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.NEAREST), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.NEAREST), 
            i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), 
            this._$GetWebGLVersionNumber$_() >= 2 ? i.texImage2D(i.TEXTURE_2D, 0, i.DEPTH24_STENCIL8, t, s, 0, i.DEPTH_STENCIL, i.UNSIGNED_INT_24_8, null) : this._$_depthTextureExt$_ && i.texImage2D(i.TEXTURE_2D, 0, i.DEPTH_STENCIL, t, s, 0, i.DEPTH_STENCIL, this._$_depthTextureExt$_.UNSIGNED_INT_24_8_WEBGL, null), 
            i.bindTexture(i.TEXTURE_2D, null)) : (this._$_depthBuffer$_ && i.deleteRenderbuffer(this._$_depthBuffer$_), 
            this._$_depthBuffer$_ = i.createRenderbuffer(), i.bindRenderbuffer(i.RENDERBUFFER, this._$_depthBuffer$_), 
            i.renderbufferStorage(i.RENDERBUFFER, this._$_version$_ >= 2 ? i.DEPTH24_STENCIL8 : i.DEPTH_STENCIL, t, s), 
            i.bindRenderbuffer(i.RENDERBUFFER, null)), this._$_depthBufferWidth$_ = t, this._$_depthBufferHeight$_ = s);
        }
        _$SetFixedSizeDepthBuffer$_(t, s) {
            this._$_usesDepthBuffer$_ && (this._$_isAutoSizeDepthBuffer$_ = !1, this._$_SetDepthBufferSize$_(t, s));
        }
        _$SetAutoSizeDepthBuffer$_() {
            this._$_usesDepthBuffer$_ && (this._$_isAutoSizeDepthBuffer$_ = !0, this._$_SetDepthBufferSize$_(this._$_width$_, this._$_height$_));
        }
        _$_SetViewport$_(t, s, i, e) {
            const n = this._$_viewport$_;
            n[0] === t && n[1] === s && n[2] === i && n[3] === e || (this._$PushBatch$_()._$InitSetViewport$_(t, s, i, e), 
            Nc.set(n, t, s, i, e), this._$_topOfBatch$_ = 0);
        }
        _$SetFovY$_(t) {
            super._$SetFovY$_(t), this._$CalculatePerspectiveMatrix$_(this._$_bbProjectionMatrix$_, this._$_width$_ / this._$_height$_);
        }
        _$SetNearZ$_(t) {
            super._$SetNearZ$_(t), this._$CalculatePerspectiveMatrix$_(this._$_bbProjectionMatrix$_, this._$_width$_ / this._$_height$_);
        }
        _$SetFarZ$_(t) {
            super._$SetFarZ$_(t), this._$CalculatePerspectiveMatrix$_(this._$_bbProjectionMatrix$_, this._$_width$_ / this._$_height$_);
        }
        _$SetProjectionMatrix$_(t) {
            Lc._$exactEquals$_(this._$_matP$_, t) || (this._$PushBatch$_()._$InitSetProjection$_(t), 
            Lc._$copy$_(this._$_matP$_, t), this._$_topOfBatch$_ = 0, this._$_didChangeTransform$_ = !0);
        }
        _$SetDefaultRenderTargetProjectionState$_() {
            let t, s, i;
            const e = this._$_currentRenderTarget$_;
            null === e ? (t = this._$_bbProjectionMatrix$_, s = this._$GetWidth$_(), i = this._$GetHeight$_()) : (t = e._$GetProjectionMatrix$_(), 
            s = e._$GetWidth$_(), i = e._$GetHeight$_()), this._$SetProjectionMatrix$_(t), this._$_SetViewport$_(0, 0, s, i);
        }
        _$SetModelViewMatrix$_(t) {
            Lc._$exactEquals$_(this._$_matMV$_, t) || (this._$PushBatch$_()._$InitSetModelView$_(t), 
            Lc._$copy$_(this._$_matMV$_, t), this._$_topOfBatch$_ = 0, this._$_didChangeTransform$_ = !0);
        }
        _$ResetDidChangeTransformFlag$_() {
            this._$_didChangeTransform$_ = !1;
        }
        _$DidChangeTransform$_() {
            return this._$_didChangeTransform$_;
        }
        _$GetBatchState$_() {
            return this._$_batchState$_;
        }
        _$PushBatch$_() {
            const t = this._$_batch$_;
            return this._$_batchPtr$_ === t.length && t.push(new Dc._$Gfx$_._$WebGLBatchJob$_(this._$_batchState$_)), 
            t[this._$_batchPtr$_++];
        }
        _$EndBatch$_() {
            0 !== this._$_batchPtr$_ && (this._$IsContextLost$_() || (this._$_WriteBuffers$_(), 
            this._$_ExecuteBatch$_(), this._$_batchPtr$_ = 0, this._$_vertexPtr$_ = 0, this._$_texPtr$_ = 0, 
            this._$_pointPtr$_ = 0, this._$_topOfBatch$_ = 0));
        }
        _$_WriteBuffers$_() {
            const t = this._$_gl$_;
            this._$_pointPtr$_ > 0 && (t.bindBuffer(t.ARRAY_BUFFER, this._$_pointBuffer$_), 
            t.bufferSubData(t.ARRAY_BUFFER, 0, this._$_pointData$_.subarray(0, this._$_pointPtr$_))), 
            this._$_vertexPtr$_ > 0 && (t.bindBuffer(t.ARRAY_BUFFER, this._$_vertexBuffer$_), 
            t.bufferSubData(t.ARRAY_BUFFER, 0, this._$_vertexData$_.subarray(0, this._$_vertexPtr$_)), 
            t.bindBuffer(t.ARRAY_BUFFER, this._$_texcoordBuffer$_), t.bufferSubData(t.ARRAY_BUFFER, 0, this._$_texcoordData$_.subarray(0, this._$_texPtr$_)));
        }
        _$_ExecuteBatch$_() {
            const t = this._$_batch$_;
            for (let s = 0, i = this._$_batchPtr$_; s < i; ++s) t[s]._$Run$_();
        }
        _$GetOpacity$_() {
            return this._$_lastColor$_._$getA$_();
        }
        _$SetColorRgba$_(t, s, i, e) {
            const n = this._$_lastColor$_;
            n._$equalsRgba$_(t, s, i, e) || (n._$setRgba$_(t, s, i, e), this._$PushBatch$_()._$InitSetColor$_(n), 
            this._$_topOfBatch$_ = 0, this._$_currentStateGroup$_ = null);
        }
        _$SetOpacity$_(t) {
            const s = this._$_lastColor$_;
            s._$getA$_() !== t && (s._$setA$_(t), this._$PushBatch$_()._$InitSetColor$_(s), 
            this._$_topOfBatch$_ = 0, this._$_currentStateGroup$_ = null);
        }
        _$SetColor$_(t) {
            const s = this._$_lastColor$_;
            s.equals(t) || (s.set(t), this._$PushBatch$_()._$InitSetColor$_(s), this._$_topOfBatch$_ = 0, 
            this._$_currentStateGroup$_ = null);
        }
        _$ResetColor$_() {
            this._$SetColorRgba$_(1, 1, 1, 1);
        }
        _$GetColor$_() {
            return this._$_lastColor$_;
        }
        _$SetTexture$_(t) {
            t !== this._$_lastTexture0$_ && (this._$PushBatch$_()._$InitSetTexture$_(t), this._$_lastTexture0$_ = t, 
            this._$_topOfBatch$_ = 0);
        }
        _$_ResetLastTexture$_() {
            this._$_lastTexture0$_ = null;
        }
        _$SetBlendMode$_(t) {
            const s = this._$_GetBlendByIndex$_(t);
            this._$_SetBlend$_(s[0], s[1]);
        }
        _$SetNamedBlendMode$_(t) {
            const s = this._$GetNamedBlend$_(t);
            this._$_SetBlend$_(s._$srcBlend$_, s._$destBlend$_);
        }
        _$_SetBlend$_(t, s) {
            t === this._$_lastSrcBlend$_ && s === this._$_lastDestBlend$_ || (this._$PushBatch$_()._$InitSetBlend$_(t, s), 
            this._$_lastSrcBlend$_ = t, this._$_lastDestBlend$_ = s, this._$_topOfBatch$_ = 0, 
            this._$_currentStateGroup$_ = null);
        }
        _$IsPremultipliedAlphaBlend$_() {
            return this._$_lastSrcBlend$_ === this._$_gl$_.ONE && this._$_lastDestBlend$_ === this._$_gl$_.ONE_MINUS_SRC_ALPHA;
        }
        _$SetAlphaBlend$_() {
            this._$_SetBlend$_(this._$_gl$_.ONE, this._$_gl$_.ONE_MINUS_SRC_ALPHA);
        }
        _$SetNoPremultiplyAlphaBlend$_() {
            this._$_SetBlend$_(this._$_gl$_.SRC_ALPHA, this._$_gl$_.ONE_MINUS_SRC_ALPHA);
        }
        _$SetCopyBlend$_() {
            this._$_SetBlend$_(this._$_gl$_.ONE, this._$_gl$_.ZERO);
        }
        Rect(t) {
            this._$Rect2$_(t._$getLeft$_(), t._$getTop$_(), t._$getRight$_(), t._$getBottom$_());
        }
        _$Rect2$_(t, s, i, e) {
            this._$Quad2$_(t, s, i, s, i, e, t, e);
        }
        _$_ExtendQuadBatch$_() {
            let t = this._$_vertexPtr$_;
            t >= this._$_lastVertexPtr$_ && (this._$EndBatch$_(), t = 0), 1 === this._$_topOfBatch$_ ? this._$_batch$_[this._$_batchPtr$_ - 1]._$_indexCount$_ += 6 : (this._$PushBatch$_()._$InitQuad$_(t, 6), 
            this._$_topOfBatch$_ = 1);
        }
        _$_WriteQuadToVertexBuffer$_(t) {
            t._$writeToTypedArray3D$_(this._$_vertexData$_, this._$_vertexPtr$_, this._$_baseZ$_ + this._$_currentZ$_), 
            this._$_vertexPtr$_ += 12;
        }
        _$Quad$_(t) {
            this._$_ExtendQuadBatch$_(), this._$_WriteQuadToVertexBuffer$_(t), Pc._$writeToTypedArray$_(this._$_texcoordData$_, this._$_texPtr$_), 
            this._$_texPtr$_ += 8;
        }
        _$Quad2$_(t, s, i, e, n, h, r, o) {
            this._$_ExtendQuadBatch$_();
            const a = this._$_vertexData$_;
            let u = this._$_vertexPtr$_;
            const l = this._$_baseZ$_ + this._$_currentZ$_;
            a[u++] = t, a[u++] = s, a[u++] = l, a[u++] = i, a[u++] = e, a[u++] = l, a[u++] = n, 
            a[u++] = h, a[u++] = l, a[u++] = r, a[u++] = o, a[u++] = l, this._$_vertexPtr$_ = u, 
            Pc._$writeToTypedArray$_(this._$_texcoordData$_, this._$_texPtr$_), this._$_texPtr$_ += 8;
        }
        _$Quad3$_(t, s) {
            this._$_ExtendQuadBatch$_(), this._$_WriteQuadToVertexBuffer$_(t), s._$writeAsQuadToTypedArray$_(this._$_texcoordData$_, this._$_texPtr$_), 
            this._$_texPtr$_ += 8;
        }
        _$Quad4$_(t, s) {
            this._$_ExtendQuadBatch$_(), this._$_WriteQuadToVertexBuffer$_(t), s._$writeToTypedArray$_(this._$_texcoordData$_, this._$_texPtr$_), 
            this._$_texPtr$_ += 8;
        }
        _$Quad3D$_(t, s, i, e, n, h, r, o, a, u, l, c, f) {
            this._$_ExtendQuadBatch$_();
            const d = this._$_vertexData$_;
            let p = this._$_vertexPtr$_;
            const m = this._$_baseZ$_ + this._$_currentZ$_;
            d[p++] = t, d[p++] = s, d[p++] = m + i, d[p++] = e, d[p++] = n, d[p++] = m + h, 
            d[p++] = r, d[p++] = o, d[p++] = m + a, d[p++] = u, d[p++] = l, d[p++] = m + c, 
            this._$_vertexPtr$_ = p, f._$writeAsQuadToTypedArray$_(this._$_texcoordData$_, this._$_texPtr$_), 
            this._$_texPtr$_ += 8;
        }
        _$Quad3D2$_(t, s, i, e, n, h, r, o, a, u, l, c, f) {
            this._$_ExtendQuadBatch$_();
            const d = this._$_vertexData$_;
            let p = this._$_vertexPtr$_;
            const m = this._$_baseZ$_ + this._$_currentZ$_;
            d[p++] = t, d[p++] = s, d[p++] = m + i, d[p++] = e, d[p++] = n, d[p++] = m + h, 
            d[p++] = r, d[p++] = o, d[p++] = m + a, d[p++] = u, d[p++] = l, d[p++] = m + c, 
            this._$_vertexPtr$_ = p, f._$writeToTypedArray$_(this._$_texcoordData$_, this._$_texPtr$_), 
            this._$_texPtr$_ += 8;
        }
        _$DrawMesh$_(t, s, i) {
            const e = this._$_vertexData$_, n = this._$_texcoordData$_;
            if (i.length % 3 != 0) throw new Error("invalid index buffer length");
            for (let h = 0, r = i.length; h < r; ) {
                const r = i[h++], o = i[h++], a = i[h++], u = 3 * r, l = 3 * o, c = 3 * a, f = 2 * r, d = 2 * o, p = 2 * a;
                this._$_ExtendQuadBatch$_();
                let m = this._$_vertexPtr$_, g = this._$_texPtr$_;
                e[m++] = t[u + 0], e[m++] = t[u + 1], e[m++] = t[u + 2], e[m++] = t[l + 0], e[m++] = t[l + 1], 
                e[m++] = t[l + 2], e[m++] = t[c + 0], e[m++] = t[c + 1], e[m++] = t[c + 2], e[m++] = t[c + 0], 
                e[m++] = t[c + 1], e[m++] = t[c + 2], n[g++] = s[f + 0], n[g++] = s[f + 1], n[g++] = s[d + 0], 
                n[g++] = s[d + 1], n[g++] = s[p + 0], n[g++] = s[p + 1], n[g++] = s[p + 0], n[g++] = s[p + 1], 
                this._$_vertexPtr$_ = m, this._$_texPtr$_ = g;
            }
        }
        _$FullscreenQuad$_(t, s) {
            this._$SetCurrentZ$_(0), Lc._$copy$_(kc, this._$_matP$_), Lc._$copy$_(Fc, this._$_matMV$_), 
            this._$SetDefaultRenderTargetProjectionState$_();
            const [i, e] = this._$GetRenderTargetSize$_(this._$_currentRenderTarget$_), n = this._$CalculateLookAtModelView2$_(0, 0, this._$GetDefaultCameraZ$_(e), 0, 0, 0, e);
            if (this._$SetModelViewMatrix$_(n), "crop" === t && this._$_currentRenderTarget$_ && s) {
                const t = this._$_width$_ / 2, i = this._$_height$_ / 2, e = s._$GetWidth$_(), n = s._$GetHeight$_(), h = this._$_currentRenderTarget$_._$GetWidth$_(), r = this._$_currentRenderTarget$_._$GetHeight$_(), o = Math.min(h, e), a = Math.min(r, n), u = Math.max(n - r, 0), l = Math.max(r - n, 0);
                Bc.set(-t, i - l, -t + o, i - a - l), jc._$setFromRect$_(Bc), Bc.set(0, u, o, a + u), 
                Bc._$divide$_(e, n), this._$Quad3$_(jc, Bc);
            } else {
                const t = i / 2, s = e / 2;
                this._$Rect2$_(-t, s, t, -s);
            }
            this._$SetProjectionMatrix$_(kc), this._$SetModelViewMatrix$_(Fc);
        }
        _$StartRenderingPoints$_(t) {
            this._$_lastPointTexCoords$_.equals(t) || (this._$_lastPointTexCoords$_._$copy$_(t), 
            this._$PushBatch$_()._$InitSetPointTexCoords$_(t), this._$_topOfBatch$_ = 0);
        }
        _$FinishRenderingPoints$_() {}
        _$Point$_(t, s, i, e) {
            this._$_pointPtr$_ >= 7996 && this._$EndBatch$_();
            let n = this._$_pointPtr$_;
            const h = this._$_baseZ$_ + this._$_currentZ$_;
            2 === this._$_topOfBatch$_ && this._$_lastPointZ$_ === h ? this._$_batch$_[this._$_batchPtr$_ - 1]._$_indexCount$_++ : (this._$PushBatch$_()._$InitPoints$_(n, h), 
            this._$_topOfBatch$_ = 2, this._$_lastPointZ$_ = h);
            const r = this._$_pointData$_;
            r[n++] = t, r[n++] = s, r[n++] = i, r[n++] = e, this._$_pointPtr$_ = n;
        }
        _$SetProgram$_(t) {
            this._$_lastProgram$_ !== t && (this._$PushBatch$_()._$InitSetProgram$_(t), this._$_lastProgram$_ = t, 
            this._$_topOfBatch$_ = 0, this._$_currentStateGroup$_ = null);
        }
        _$GetProgram$_() {
            return this._$_lastProgram$_;
        }
        _$SetDeviceTransformTextureFillMode$_() {
            this._$SetProgram$_(this._$_spDeviceTransformTextureFill$_);
        }
        _$SetGradientColor$_(t) {
            this._$PushBatch$_()._$InitSetGradientColor$_(t), this._$_topOfBatch$_ = 0;
        }
        _$SetEllipseParams$_(t, s, i = 1) {
            this._$PushBatch$_()._$InitSetEllipseParams$_(t, s, i), this._$_topOfBatch$_ = 0;
        }
        _$SetTilemapInfo$_(t, s, i, e, n, h, r) {
            if (this._$_lastProgram$_ !== this._$_spTilemapFill$_) throw new Error("must set tilemap fill mode first");
            this._$PushBatch$_()._$InitSetTilemapInfo$_(t, s, i, e, n, h, r), this._$_topOfBatch$_ = 0;
        }
        _$SetTileRandomizationInfo$_(t, s, i, e, n, h, r) {
            if (this._$_lastProgram$_ !== this._$_spTileRandomization$_) throw new Error("must set tile randomization mode first");
            this._$PushBatch$_()._$InitSetTileRandomizationInfo$_(t, s, i, e, n, h, r), this._$_topOfBatch$_ = 0;
        }
        _$SetProgramParameters$_(t, s, i, e, n, h, r, o, a, u, l) {
            const c = this._$_lastProgram$_;
            if (l %= 10800, !c._$_hasAnyOptionalUniforms$_ || c._$AreOptionalUniformsAlreadySetInBatch$_(s, i, e, n, h, r, o, a, u, l)) return;
            const f = this._$PushBatch$_();
            f._$InitSetProgramParameters$_(), c._$SetOptionalUniformsInBatch$_(s, i, e, n, h, r, o, a, u, l);
            const d = f._$_mat4param$_;
            d[0] = h, d[1] = r, s._$writeToTypedArray$_(d, 2), d[6] = a, d[7] = u, i._$writeToTypedArray$_(d, 12);
            const p = f._$_colorParam$_;
            n._$writeToTypedArray$_(p, 0);
            const m = p[1];
            p[1] = p[3], p[3] = m, e._$writeToTypedArray$_(f._$_srcOriginRect$_, 0), f._$_startIndex$_ = l, 
            f._$_indexCount$_ = o, c._$_uSamplerBack$_._$IsUsed$_() ? f._$_texParam$_ = t ? t._$GetTexture$_() : null : f._$_texParam$_ = null, 
            this._$_topOfBatch$_ = 0;
        }
        _$SetProgramCustomParameters$_(t) {
            const s = this._$_lastProgram$_;
            if (0 === t.length || s._$AreCustomParametersAlreadySetInBatch$_(t)) return;
            const i = this._$PushBatch$_();
            i._$InitSetProgramCustomParameters$_(), s._$SetCustomParametersInBatch$_(t), Dc._$shallowAssignArray$_(i._$_shaderParams$_, t), 
            this._$_topOfBatch$_ = 0;
        }
        _$ClearRgba$_(t, s, i, e) {
            this._$PushBatch$_()._$InitClearSurface2$_(t, s, i, e), this._$_topOfBatch$_ = 0;
        }
        _$Clear$_(t) {
            this._$PushBatch$_()._$InitClearSurface$_(t), this._$_topOfBatch$_ = 0;
        }
        _$Start$_() {}
        _$Finish$_() {
            super._$Finish$_(), this._$_gl$_.flush();
        }
        _$ClearDepth$_() {
            this._$_usesDepthBuffer$_ && this._$_currentRenderTarget$_ && this._$_currentRenderTarget$_._$HasDepthBuffer$_() && (this._$PushBatch$_()._$InitClearDepth$_(this._$_isDepthEnabled$_), 
            this._$_topOfBatch$_ = 0);
        }
        _$SetDepthEnabled$_(t) {
            t = !!t, this._$_isDepthEnabled$_ !== t && this._$_usesDepthBuffer$_ && (this._$_isDepthEnabled$_ = t, 
            this._$PushBatch$_()._$InitSetDepthEnabled$_(t), this._$_topOfBatch$_ = 0);
        }
        _$IsDepthEnabled$_() {
            return this._$_isDepthEnabled$_;
        }
        _$_GetDepthBuffer$_() {
            return this._$_depthBuffer$_;
        }
        _$_CanSampleDepth$_() {
            return this._$_canSampleDepth$_;
        }
        _$SetDepthSamplingEnabled$_(t) {
            if (t = !!t, this._$_canSampleDepth$_ && this._$_isDepthSamplingEnabled$_ !== t) {
                if (t && this._$IsDepthEnabled$_()) throw new Error("depth still enabled");
                this._$_isDepthSamplingEnabled$_ = t, this._$PushBatch$_()._$InitSetDepthSamplingEnabled$_(t), 
                this._$_topOfBatch$_ = 0;
            }
        }
        _$SetScissorRect$_(t, s, i, e, n = 0) {
            t = Math.floor(t), s = Math.floor(s), i = Math.floor(i), e = Math.floor(e), this._$_lastScissorRect$_._$equalsWH$_(t, s, i, e) || (this._$_lastScissorRect$_._$setWH$_(t, s, i, e), 
            s = (n || this._$GetRenderTargetSize$_(this._$GetRenderTarget$_())[1]) - s - e, 
            this._$PushBatch$_()._$InitSetScissor$_(!0, t, s, i, e), this._$_topOfBatch$_ = 0);
        }
        _$RemoveScissorRect$_() {
            -1 !== this._$_lastScissorRect$_._$getRight$_() && (this._$_lastScissorRect$_.set(0, 0, -1, -1), 
            this._$PushBatch$_()._$InitSetScissor$_(!1, 0, 0, 0, 0), this._$_topOfBatch$_ = 0);
        }
        _$CheckForQueryResults$_() {
            for (const t of this._$_allQueryResultBuffers$_) t._$CheckForResults$_(this._$_frameNumber$_);
        }
        _$IsContextLost$_() {
            return !this._$_gl$_ || this._$_gl$_.isContextLost() || this._$_isInitialisingAfterContextRestored$_;
        }
        _$OnContextLost$_() {
            super._$OnDeviceOrContextLost$_(), Dc._$Gfx$_._$WebGLRendererTexture$_._$OnContextLost$_(), 
            Dc._$Gfx$_._$WebGLRenderTarget$_._$OnContextLost$_(), Dc._$Gfx$_._$RendererText$_._$OnContextLost$_();
            for (const t of this._$_allQueryResultBuffers$_) t._$Clear$_();
            this._$_extensions$_ = [], this._$_timerExt$_ = null, this._$_parallelShaderCompileExt$_ = null, 
            this._$_conservativeDepthExt$_ = null, this._$_anisotropicExt$_ = null, this._$_depthTextureExt$_ = null, 
            this._$_fragDepthExt$_ = null, this._$_stdDerivativesExt$_ = null, this._$_textureLodExt$_ = null, 
            this._$_maxAnisotropy$_ = 0, this._$_unmaskedVendor$_ = "(unavailable)", this._$_unmaskedRenderer$_ = "(unavailable)", 
            this._$_lastProgram$_ = null, this._$_spDeviceTransformTextureFill$_ = null, this._$_depthBuffer$_ = null;
            for (const t of this._$_stateGroups$_.values()) t._$OnContextLost$_();
        }
        async _$OnContextRestored$_() {
            this._$_isInitialisingAfterContextRestored$_ = !0, await this._$InitState$_(), this._$_isInitialisingAfterContextRestored$_ = !1;
            for (const t of this._$_stateGroups$_.values()) t._$OnContextRestored$_(this);
            this._$SetSize$_(this._$_width$_, this._$_height$_, !0);
        }
        _$CreateStaticTexture$_(t, s) {
            if (this._$IsContextLost$_()) throw new Error("context lost");
            this._$EndBatch$_();
            const i = Dc._$New$_(Dc._$Gfx$_._$WebGLRendererTexture$_, this);
            return i._$_CreateStatic$_(t, s), i;
        }
        async _$CreateStaticTextureAsync$_(t, s) {
            if (this._$IsContextLost$_()) throw new Error("context lost");
            if (s = Object.assign({}, s), Dc._$Supports$_.ImageBitmapOptions) {
                let i = await createImageBitmap(t, {
                    premultiplyAlpha: "premultiply"
                });
                const e = s._$wrapX$_ && "clamp-to-edge" !== s._$wrapX$_ || s._$wrapY$_ && "clamp-to-edge" !== s._$wrapY$_, n = Dc._$isPOT$_(i.width) && Dc._$isPOT$_(i.height);
                return this._$SupportsNPOTTextures$_() || n || !e ? s._$premultiplyAlpha$_ = !1 : Dc._$Supports$_._$ImageBitmapOptionsResize$_ ? (i = await createImageBitmap(t, {
                    premultiplyAlpha: "premultiply",
                    resizeWidth: Dc._$nextHighestPowerOfTwo$_(i.width),
                    resizeHeight: Dc._$nextHighestPowerOfTwo$_(i.height)
                }), s._$premultiplyAlpha$_ = !1) : i = await createImageBitmap(t, {
                    premultiplyAlpha: "none"
                }), await Dc._$Asyncify$_((() => this._$CreateStaticTexture$_(i, s)));
            }
            if (t instanceof Blob) {
                if ("undefined" == typeof Image) throw new Error("texture upload variant not supported in worker");
                const s = await Dc._$BlobToImage$_(t);
                t = s;
            }
            return await Dc._$Asyncify$_((() => this._$CreateStaticTexture$_(t, s)));
        }
        _$CreateDynamicTexture$_(t, s, i) {
            this._$EndBatch$_();
            const e = Dc._$New$_(Dc._$Gfx$_._$WebGLRendererTexture$_, this);
            return e._$_CreateDynamic$_(t, s, i), e;
        }
        _$UpdateTexture$_(t, s, i) {
            this._$EndBatch$_(), s._$_Update$_(t, i);
        }
        _$DeleteTexture$_(t) {
            t && (t._$SubtractReference$_(), t._$GetReferenceCount$_() > 0 || (this._$EndBatch$_(), 
            t === this._$_lastTexture0$_ && (this._$_gl$_.bindTexture(this._$_gl$_.TEXTURE_2D, null), 
            this._$_lastTexture0$_ = null), t === this._$_lastTexture1$_ && (this._$_gl$_.activeTexture(this._$_gl$_.TEXTURE1), 
            this._$_gl$_.bindTexture(this._$_gl$_.TEXTURE_2D, null), this._$_gl$_.activeTexture(this._$_gl$_.TEXTURE0), 
            this._$_lastTexture1$_ = null), t._$_Delete$_()));
        }
        _$CreateRenderTarget$_(t) {
            let s = this._$_width$_, i = this._$_height$_, e = !0;
            if (t && ("number" == typeof t.width && (s = Math.floor(t.width), e = !1), "number" == typeof t.height && (i = Math.floor(t.height), 
            e = !1)), s <= 0 || i <= 0) throw new Error("invalid size");
            this._$EndBatch$_();
            const n = Dc._$New$_(Dc._$Gfx$_._$WebGLRenderTarget$_, this);
            return n._$_Create$_(s, i, Object.assign({
                _$isDefaultSize$_: e
            }, t)), this._$_currentRenderTarget$_ = null, this._$_batchState$_._$currentFramebuffer$_ = null, 
            this._$_batchState$_._$currentFramebufferNoDepth$_ = null, n;
        }
        _$SetRenderTarget$_(t, s = !0) {
            t !== this._$_currentRenderTarget$_ && (t && t._$IsDefaultSize$_() && t._$_Resize$_(this._$_width$_, this._$_height$_), 
            this._$PushBatch$_()._$InitSetRenderTarget$_(t), this._$_currentRenderTarget$_ = t, 
            this._$_topOfBatch$_ = 0, s && this._$SetDefaultRenderTargetProjectionState$_());
        }
        _$GetRenderTarget$_() {
            return this._$_currentRenderTarget$_;
        }
        _$GetRenderTargetSize$_(t) {
            return t ? [ t._$GetWidth$_(), t._$GetHeight$_() ] : [ this._$_width$_, this._$_height$_ ];
        }
        _$CopyRenderTarget$_(t, s = "stretch") {
            this._$_version$_ < 2 || this._$_currentRenderTarget$_ && this._$_currentRenderTarget$_._$GetMultisampling$_() > 0 ? (this._$SetCopyBlend$_(), 
            this._$ResetColor$_(), this._$DrawRenderTarget$_(t, s)) : (this._$PushBatch$_()._$InitBlitFramebuffer$_(t, this._$_currentRenderTarget$_, s), 
            this._$_topOfBatch$_ = 0);
        }
        _$DrawRenderTarget$_(t, s = "stretch") {
            const i = t._$GetTexture$_();
            if (!i) throw new Error("not a texture-backed render target");
            this._$SetTexture$_(i), this._$FullscreenQuad$_(s, i);
        }
        _$InvalidateRenderTarget$_(t) {
            this._$_version$_ < 2 || (this._$PushBatch$_()._$InitInvalidateFramebuffer$_(t._$_GetFramebuffer$_()), 
            this._$_topOfBatch$_ = 0);
        }
        _$DeleteRenderTarget$_(t) {
            this._$SetRenderTarget$_(null), this._$EndBatch$_();
            const s = t._$GetTexture$_();
            s === this._$_lastTexture0$_ && (this._$_gl$_.bindTexture(this._$_gl$_.TEXTURE_2D, null), 
            this._$_lastTexture0$_ = null), s === this._$_lastTexture1$_ && (this._$_gl$_.activeTexture(this._$_gl$_.TEXTURE1), 
            this._$_gl$_.bindTexture(this._$_gl$_.TEXTURE_2D, null), this._$_gl$_.activeTexture(this._$_gl$_.TEXTURE0), 
            this._$_lastTexture1$_ = null), t._$_Delete$_();
        }
        async _$ReadBackRenderTargetToImageData$_(t, s, i) {
            this._$EndBatch$_();
            const e = this._$_currentRenderTarget$_;
            let n, h, r;
            t ? (n = t._$GetWidth$_(), h = t._$GetHeight$_(), r = t._$_GetFramebuffer$_()) : (n = this._$GetWidth$_(), 
            h = this._$GetHeight$_(), r = null);
            let o = 0, a = 0, u = n, l = h;
            if (i) {
                o = Dc._$clamp$_(Math.floor(i._$getLeft$_()), 0, n - 1), a = Dc._$clamp$_(Math.floor(i._$getTop$_()), 0, h - 1);
                let t = i.width();
                t = 0 === t ? n - o : Dc._$clamp$_(Math.floor(t), 0, n - o);
                let s = i.height();
                s = 0 === s ? h - a : Dc._$clamp$_(Math.floor(s), 0, h - a), u = t, l = s, a = h - (a + l);
            }
            const c = this._$_gl$_;
            c.bindFramebuffer(c.FRAMEBUFFER, r);
            const f = () => {
                c.bindFramebuffer(c.FRAMEBUFFER, null), this._$_currentRenderTarget$_ = null, this._$_batchState$_._$currentFramebuffer$_ = null, 
                this._$_batchState$_._$currentFramebufferNoDepth$_ = null, this._$SetRenderTarget$_(e);
            };
            let d;
            if (!s && this._$GetWebGLVersionNumber$_() >= 2) {
                c.bindFramebuffer(c.READ_FRAMEBUFFER, r);
                const t = c.createBuffer(), s = u * l * 4, i = c.PIXEL_PACK_BUFFER;
                c.bindBuffer(i, t), c.bufferData(i, s, c.STREAM_READ), c.readPixels(o, a, u, l, c.RGBA, c.UNSIGNED_BYTE, 0), 
                c.bindFramebuffer(c.READ_FRAMEBUFFER, null), c.bindBuffer(i, null), f();
                const e = c.fenceSync(c.SYNC_GPU_COMMANDS_COMPLETE, 0);
                await this._$_WaitForObjectReady$_((() => c.getSyncParameter(e, c.SYNC_STATUS) === c.SIGNALED)), 
                c.deleteSync(e), d = new ImageData(u, l), c.bindBuffer(i, t), c.getBufferSubData(i, 0, new Uint8Array(d.data.buffer), 0, s), 
                c.bindBuffer(i, null), c.deleteBuffer(t);
            } else d = new ImageData(u, l), c.readPixels(o, a, u, l, c.RGBA, c.UNSIGNED_BYTE, new Uint8Array(d.data.buffer)), 
            f();
            return d;
        }
        _$CoplanarStartStencilPass$_() {
            this._$SetDepthEnabled$_(!0), this._$PushBatch$_()._$InitCoplanarStartStencilPass$_(), 
            this._$_topOfBatch$_ = 0, this._$_coplanarMode$_ = 1;
        }
        _$CoplanarStartColorPass$_() {
            this._$SetDepthEnabled$_(!1), this._$PushBatch$_()._$InitCoplanarStartColorPass$_(), 
            this._$_topOfBatch$_ = 0, this._$_coplanarMode$_ = 2;
        }
        _$IsCoplanarColorPass$_() {
            return 2 === this._$_coplanarMode$_;
        }
        _$CoplanarRestoreStandardRendering$_() {
            this._$SetDepthEnabled$_(!0), this._$PushBatch$_()._$InitCoplanarRestore$_(), this._$_topOfBatch$_ = 0, 
            this._$_coplanarMode$_ = 0;
        }
        _$StartQuery$_(t) {
            this._$SupportsGPUProfiling$_() && (this._$PushBatch$_()._$InitStartQuery$_(t), 
            this._$_topOfBatch$_ = 0);
        }
        _$EndQuery$_(t) {
            this._$SupportsGPUProfiling$_() && (this._$PushBatch$_()._$InitEndQuery$_(t), this._$_topOfBatch$_ = 0);
        }
        _$_WaitForObjectReady$_(t) {
            const s = new Promise((s => Uc.add({
                resolve: s,
                _$checkFunc$_: t
            })));
            return -1 === Wc && (Wc = self.requestAnimationFrame(Ec)), s;
        }
        _$GetEstimatedBackBufferMemoryUsage$_() {
            return this._$_width$_ * this._$_height$_ * (this._$_attribs$_.alpha ? 4 : 3);
        }
        _$GetEstimatedRenderBufferMemoryUsage$_() {
            let t = 0;
            for (const s of Dc._$Gfx$_._$WebGLRenderTarget$_._$allRenderTargets$_()) s._$GetTexture$_() || (t += s._$GetEstimatedMemoryUsage$_());
            return t;
        }
        _$GetEstimatedTextureMemoryUsage$_() {
            let t = 0;
            for (const s of Dc._$Gfx$_._$WebGLRendererTexture$_._$allTextures$_()) t += s._$GetEstimatedMemoryUsage$_();
            return t;
        }
        _$GetWebGLVersionString$_() {
            return this._$_versionString$_;
        }
        _$GetWebGLVersionNumber$_() {
            return this._$_version$_;
        }
        _$GetDisplayName$_() {
            return "webgl" + this._$GetWebGLVersionNumber$_();
        }
        _$SupportsNPOTTextures$_() {
            return this._$GetWebGLVersionNumber$_() >= 2;
        }
        _$GetMaxTextureSize$_() {
            return this._$_maxTextureSize$_;
        }
        _$GetMinPointSize$_() {
            return this._$_minPointSize$_;
        }
        _$GetMaxPointSize$_() {
            return this._$_maxPointSize$_;
        }
        _$SupportsHighP$_() {
            return 0 !== this._$_highpPrecision$_;
        }
        _$GetHighPPrecision$_() {
            return this._$_highpPrecision$_;
        }
        _$GetUnmaskedVendor$_() {
            return this._$_unmaskedVendor$_;
        }
        _$GetUnmaskedRenderer$_() {
            return this._$_unmaskedRenderer$_;
        }
        _$GetWebGLExtensionsAnalyticsString$_() {
            if (this._$GetWebGLVersionNumber$_() >= 2) return "webgl2";
            {
                const t = [];
                return this._$_fragDepthExt$_ && t.push("EXT_frag_depth"), this._$_stdDerivativesExt$_ && t.push("OES_standard_derivatives"), 
                this._$_textureLodExt$_ && t.push("EXT_shader_texture_lod"), t.length > 0 ? "webgl1:" + t.join(",") : "webgl1:none";
            }
        }
        _$GetExtensions$_() {
            return this._$_extensions$_;
        }
        _$SupportsGPUProfiling$_() {
            return !!this._$_timerExt$_;
        }
        _$_GetDisjointTimerQueryExtension$_() {
            return this._$_timerExt$_;
        }
        _$_GetParallelShaderCompileExtension$_() {
            return this._$_parallelShaderCompileExt$_;
        }
        _$_SupportsConservativeDepth$_() {
            return !!this._$_conservativeDepthExt$_;
        }
        _$_GetAnisotropicExtension$_() {
            return this._$_anisotropicExt$_;
        }
        _$_GetMaxAnisotropy$_() {
            return this._$_maxAnisotropy$_;
        }
        _$_AddQueryResultBuffer$_(t) {
            this._$_allQueryResultBuffers$_.add(t);
        }
        _$_RemoveQueryResultBuffer$_(t) {
            this._$_allQueryResultBuffers$_.delete(t);
        }
        _$_GetTimeQueryStack$_() {
            return this._$_timeQueryStack$_;
        }
        _$GetContext$_() {
            return this._$_gl$_;
        }
        _$_InitBlendModes$_(t) {
            this._$_InitBlendModeData$_([ [ "normal", t.ONE, t.ONE_MINUS_SRC_ALPHA ], [ "additive", t.ONE, t.ONE ], [ "xor", t.ONE, t.ONE_MINUS_SRC_ALPHA ], [ "copy", t.ONE, t.ZERO ], [ "destination-over", t.ONE_MINUS_DST_ALPHA, t.ONE ], [ "source-in", t.DST_ALPHA, t.ZERO ], [ "destination-in", t.ZERO, t.SRC_ALPHA ], [ "source-out", t.ONE_MINUS_DST_ALPHA, t.ZERO ], [ "destination-out", t.ZERO, t.ONE_MINUS_SRC_ALPHA ], [ "source-atop", t.DST_ALPHA, t.ONE_MINUS_SRC_ALPHA ], [ "destination-atop", t.ONE_MINUS_DST_ALPHA, t.SRC_ALPHA ] ]);
        }
        _$CreateWebGLText$_() {
            return this._$CreateRendererText$_();
        }
    };
}

{
    const Jc = self._$C3$_, Qc = {
        _$getDrawSize$_: null,
        _$getRenderTarget$_: null,
        _$releaseRenderTarget$_: null,
        getTime: null,
        _$redraw$_: null
    };
    Jc._$Gfx$_._$EffectChainManager$_ = class {
        constructor(t) {
            t = Object.assign({}, Qc, t), this._$_cbGetDrawSize$_ = t._$getDrawSize$_, this._$_cbGetRenderTarget$_ = t._$getRenderTarget$_, 
            this._$_cbReleaseRenderTarget$_ = t._$releaseRenderTarget$_, this._$_cbGetTime$_ = t.getTime, 
            this._$_cbRedraw$_ = t._$redraw$_, this._$_webgpuBackTexture$_ = null, this._$_allEffectChains$_ = new Set;
        }
        _$_AddEffectChain$_(t) {
            this._$_allEffectChains$_.add(t);
        }
        _$_RemoveEffectChain$_(t) {
            this._$_allEffectChains$_.delete(t);
        }
        _$OnContextLost$_() {
            this._$_webgpuBackTexture$_ = null;
            for (const t of this._$_allEffectChains$_) t._$OnContextLost$_();
        }
        _$GetDrawSize$_(t) {
            return this._$_cbGetDrawSize$_ ? this._$_cbGetDrawSize$_(t) : [ t._$GetWidth$_(), t._$GetHeight$_() ];
        }
        _$GetRenderTarget$_(t) {
            return this._$_cbGetRenderTarget$_(t);
        }
        _$ReleaseRenderTarget$_(t, s) {
            this._$_cbReleaseRenderTarget$_(t, s);
        }
        _$GetTime$_() {
            return this._$_cbGetTime$_();
        }
        _$Redraw$_(t) {
            this._$_cbRedraw$_(t);
        }
        _$_GetWebGPUBackTexture$_(t, s, i) {
            return s = Math.floor(s), i = Math.floor(i), !this._$_webgpuBackTexture$_ || this._$_webgpuBackTexture$_._$GetWidth$_() === s && this._$_webgpuBackTexture$_._$GetHeight$_() === i || (t._$DeleteTexture$_(this._$_webgpuBackTexture$_), 
            this._$_webgpuBackTexture$_ = null), null === this._$_webgpuBackTexture$_ && (this._$_webgpuBackTexture$_ = t._$CreateStaticTexture$_(null, {
                width: s,
                height: i,
                _$sampling$_: "nearest",
                _$mipMap$_: !1
            })), this._$_webgpuBackTexture$_;
        }
    };
}

{
    const Yc = self._$C3$_, Vc = (self.assert, self._$glMatrix$_._$mat4$_), Hc = Yc._$New$_(Yc.Rect), qc = Yc._$New$_(Yc.Rect), Xc = Yc._$New$_(Yc.Rect), Zc = Yc._$New$_(Yc.Rect), Kc = Vc.create(), $c = Vc.create(), tf = {
        _$drawContent$_: null,
        _$getSourceTextureInfo$_: null,
        _$getShaderParameters$_: null,
        _$invalidateRenderTargets$_: !1
    }, sf = {
        _$indexMap$_: null,
        _$forcePreDraw$_: !1,
        _$forcePostDraw$_: !1,
        _$is3D$_: !1,
        _$isSourceTextureRotated$_: !1,
        _$isRotatedOrNegativeSizeInstance$_: !1,
        _$useFullSurface$_: !1
    };
    Yc._$Gfx$_._$EffectChain$_ = class {
        constructor(t, s) {
            s = Object.assign({}, tf, s), this._$_manager$_ = t, this._$_cbDrawContent$_ = s._$drawContent$_, 
            this._$_cbGetSourceTextureInfo$_ = s._$getSourceTextureInfo$_, this._$_cbGetShaderParameters$_ = s._$getShaderParameters$_, 
            this._$_cbDrawContentHook$_ = null, this._$_shaderProgramList$_ = [], this._$_shaderProgramIndices$_ = [], 
            this._$_steps$_ = [], this._$_needsRebuild$_ = !1, this._$_blendMode$_ = 0, this._$_isAnyShaderAnimated$_ = !1, 
            this._$_isAnyShaderDepthSampling$_ = !1, this._$_isAnyShaderBackgroundBlending$_ = !1, 
            this._$_isAnyShaderCrossSampling$_ = !1, this._$_isAnyIsSrcTexRotated$_ = !1, this._$_useCopyTextureBackgroundSampling$_ = !1, 
            this._$_didChangeTransform$_ = !1, this._$_depthEnabledAtStart$_ = !1, this._$_coplanarColorPassAtStart$_ = !1, 
            this._$_canUseFastPath$_ = !1, this._$_useFullSurface$_ = !1, this._$_isSourceTextureRotated$_ = !1, 
            this._$_numTempSurfacesRequired$_ = 0, this._$_renderTargets$_ = [ null, null, null ], 
            this._$_invalidateRenderTargets$_ = !!s._$invalidateRenderTargets$_, this._$_boxExtendHorizontal$_ = 0, 
            this._$_boxExtendVertical$_ = 0, this._$_drawWidth$_ = 0, this._$_drawHeight$_ = 0, 
            this._$_contentObject$_ = null, this._$_contextObject$_ = null, this._$_layoutRect$_ = Yc._$New$_(Yc.Rect), 
            this._$_drawSurfaceRect$_ = Yc._$New$_(Yc.Rect), this._$_rcTexOriginal$_ = Yc._$New$_(Yc.Rect), 
            this._$_rcTexBounce$_ = Yc._$New$_(Yc.Rect), this._$_rcTexDest$_ = Yc._$New$_(Yc.Rect), 
            this._$_devicePixelRatio$_ = 1, this._$_layerScale$_ = 1, this._$_layerAngle$_ = 0, 
            this._$_time$_ = 0, this._$_destRenderTarget$_ = null, this._$_backTex$_ = null, 
            this._$_compositOffX$_ = 0, this._$_compositOffY$_ = 0, this._$_compositRtWidth$_ = 0, 
            this._$_compositRtHeight$_ = 0, this._$_updateOwnProjection$_ = !1, this._$_projectionMatrix$_ = Vc.create(), 
            this._$_modelViewMatrix$_ = Vc.create(), this._$_manager$_._$_AddEffectChain$_(this);
        }
        _$Release$_() {
            this._$_manager$_._$_RemoveEffectChain$_(this), Yc._$clearArray$_(this._$_steps$_), 
            Yc._$clearArray$_(this._$_shaderProgramList$_), Yc._$clearArray$_(this._$_shaderProgramIndices$_), 
            this._$_contentObject$_ = null, this._$_contextObject$_ = null, this._$_cbDrawContent$_ = null, 
            this._$_cbGetSourceTextureInfo$_ = null, this._$_cbGetShaderParameters$_ = null;
        }
        _$OnContextLost$_() {
            this._$_needsRebuild$_ = !0, Yc._$clearArray$_(this._$_steps$_), Yc._$clearArray$_(this._$_shaderProgramList$_), 
            Yc._$clearArray$_(this._$_shaderProgramIndices$_);
        }
        _$NeedsRebuild$_() {
            return this._$_needsRebuild$_;
        }
        _$BuildSteps$_(t, s) {
            if (s = Object.assign({}, sf, s), Yc._$clearArray$_(this._$_steps$_), this._$_boxExtendHorizontal$_ = 0, 
            this._$_boxExtendVertical$_ = 0, this._$_isAnyShaderAnimated$_ = !1, this._$_isAnyShaderDepthSampling$_ = !1, 
            this._$_isAnyShaderBackgroundBlending$_ = !1, this._$_isAnyShaderCrossSampling$_ = !1, 
            this._$_isAnyIsSrcTexRotated$_ = !1, this._$_useCopyTextureBackgroundSampling$_ = !1, 
            this._$_numTempSurfacesRequired$_ = 0, this._$_isSourceTextureRotated$_ = !!s._$isSourceTextureRotated$_, 
            this._$_useFullSurface$_ = !!s._$useFullSurface$_, this._$_needsRebuild$_ = !1, 
            Yc._$shallowAssignArray$_(this._$_shaderProgramList$_, t), 0 === t.length) return;
            if (s._$indexMap$_) {
                if (s._$indexMap$_.length !== t.length) throw new Error("incorrect indexMap length");
                Yc._$shallowAssignArray$_(this._$_shaderProgramIndices$_, s._$indexMap$_);
            } else {
                Yc._$clearArray$_(this._$_shaderProgramIndices$_);
                for (let s = 0, i = t.length; s < i; ++s) this._$_shaderProgramIndices$_.push(s);
            }
            for (const s of t) this._$_boxExtendHorizontal$_ += s._$GetBoxExtendHorizontal$_(), 
            this._$_boxExtendVertical$_ += s._$GetBoxExtendVertical$_(), s._$IsAnimated$_() && (this._$_isAnyShaderAnimated$_ = !0), 
            s._$UsesDepth$_() && (this._$_isAnyShaderDepthSampling$_ = !0), s._$BlendsBackground$_() && (this._$_isAnyShaderBackgroundBlending$_ = !0), 
            s._$UsesCrossSampling$_() && (this._$_isAnyShaderCrossSampling$_ = !0), s._$UsesIsSrcTexRotated$_() && (this._$_isAnyIsSrcTexRotated$_ = !0);
            this._$_useCopyTextureBackgroundSampling$_ = this._$_ShouldUseCopyTextureBackgroundSampling$_(t[0]._$GetRenderer$_());
            const i = this._$_ShouldPreDraw$_(t[0], s), e = this._$_ShouldPostDraw$_(t.at(-1), s);
            if (1 === t.length && !i && !e) return void (this._$_canUseFastPath$_ = !0);
            this._$_canUseFastPath$_ = !1;
            let n = 0;
            i && (this._$_numTempSurfacesRequired$_ = 1, this._$_steps$_.push(Yc._$New$_(Yc._$Gfx$_._$EffectChain$_._$Step$_._$PreDraw$_, this, -1, 1)), 
            n = 1);
            for (let s = 0, h = t.length; s < h; ++s) if (0 !== s || i) {
                let t = 1 === n ? 2 : 1;
                s !== h - 1 || e || (t = 0), this._$_numTempSurfacesRequired$_ = Math.max(this._$_numTempSurfacesRequired$_, t), 
                this._$_steps$_.push(Yc._$New$_(Yc._$Gfx$_._$EffectChain$_._$Step$_._$Bounce$_, this, n, t, s)), 
                n = t;
            } else this._$_numTempSurfacesRequired$_ = 1, this._$_steps$_.push(Yc._$New$_(Yc._$Gfx$_._$EffectChain$_._$Step$_._$FirstBounce$_, this, -1, 1, s)), 
            n = 1;
            e && this._$_steps$_.push(Yc._$New$_(Yc._$Gfx$_._$EffectChain$_._$Step$_._$PostDraw$_, this, n, 0));
        }
        _$_ShouldPreDraw$_(t, s) {
            return !!(s._$forcePreDraw$_ || t._$MustPreDraw$_() || s._$is3D$_ && !t._$Supports3DDirectRendering$_() || t._$UsesDepth$_() && !this._$_useFullSurface$_ || 0 !== this._$_boxExtendHorizontal$_ || 0 !== this._$_boxExtendVertical$_) || (t._$GetRenderer$_()._$IsWebGL$_() ? t._$BlendsBackground$_() && (s._$isRotatedOrNegativeSizeInstance$_ || s._$isSourceTextureRotated$_) || t._$UsesAnySrcRectOrPixelSize$_() && s._$isSourceTextureRotated$_ : t._$BlendsBackground$_() && !this._$_useCopyTextureBackgroundSampling$_ && s._$isRotatedOrNegativeSizeInstance$_);
        }
        _$_ShouldPostDraw$_(t, s) {
            return !!s._$forcePostDraw$_ || (t._$GetRenderer$_()._$IsWebGL$_() ? t._$BlendsBackground$_() || t._$UsesCrossSampling$_() : (t._$BlendsBackground$_() || t._$UsesCrossSampling$_()) && this._$_UseRenderTargetBackgroundSampling$_());
        }
        _$_ShouldUseCopyTextureBackgroundSampling$_(t) {
            return t._$IsWebGPU$_() && this._$_isAnyShaderBackgroundBlending$_ && !this._$_isAnyShaderCrossSampling$_;
        }
        _$Render$_(t, s, i) {
            t._$IsWebGPU$_() && null === s && (s = t._$GetBackbufferRenderTarget$_()), this._$_destRenderTarget$_ = s, 
            this._$_contentObject$_ = i._$contentObject$_ || null, this._$_contextObject$_ = i._$contextObject$_ || null, 
            this._$_blendMode$_ = i._$blendMode$_ || 0, this._$_devicePixelRatio$_ = i.devicePixelRatio || 1, 
            this._$_layerScale$_ = i._$layerScale$_ || 1, this._$_layerAngle$_ = i._$layerAngle$_ || 0, 
            this._$_time$_ = "number" == typeof i.time ? i.time : this._$_manager$_._$GetTime$_(), 
            this._$_didChangeTransform$_ = !1, t._$ResetDidChangeTransformFlag$_(), this._$_isAnyShaderAnimated$_ && this._$_Redraw$_();
            let e = !1;
            if (this._$_UseCopyTextureBackgroundSampling$_() && (this._$_CalculateDrawSizeAndRectangles$_(t, i), 
            e = !0, this._$_backTex$_ = this._$_manager$_._$_GetWebGPUBackTexture$_(t, this._$_drawWidth$_, this._$_drawHeight$_), 
            Hc._$copy$_(this._$_drawSurfaceRect$_), Hc._$roundOuter$_(), t._$IsWebGPU$_() && t._$_MaybeDoPendingClearRenderPass$_(this._$_destRenderTarget$_), 
            t._$CopyTextureToTexture$_(this._$_destRenderTarget$_._$GetTexture$_(), this._$_backTex$_, Hc._$getLeft$_(), Hc._$getTop$_(), Hc.width(), Hc.height())), 
            this._$_canUseFastPath$_) this._$_Render_FastPath$_(t, i); else if (e || this._$_CalculateDrawSizeAndRectangles$_(t, i), 
            0 !== this._$_rcTexOriginal$_.width() || 0 !== this._$_rcTexOriginal$_.height()) {
                t._$SetAlphaBlend$_(), t._$ResetColor$_(), t._$SetBaseZ$_(0), t._$SetCurrentZ$_(0), 
                this._$_cbDrawContentHook$_ = i._$drawContentHook$_ || null, this._$_compositOffX$_ = i._$compositOffX$_ || 0, 
                this._$_compositOffY$_ = i._$compositOffY$_ || 0, this._$_compositRtWidth$_ = i._$compositRtWidth$_ || 0, 
                this._$_compositRtHeight$_ = i._$compositRtHeight$_ || 0, this._$_updateOwnProjection$_ = !!i._$updateOwnProjection$_, 
                this._$_OnBeforeStartEffectChain$_(t), this._$_renderTargets$_[0] = s, this._$_renderTargets$_[1] = this._$_numTempSurfacesRequired$_ >= 1 ? this._$_GetRenderTarget$_() : null, 
                this._$_renderTargets$_[2] = 2 === this._$_numTempSurfacesRequired$_ ? this._$_GetRenderTarget$_() : null;
                for (const s of this._$_steps$_) {
                    const i = this._$_GetRenderTargetForId$_(s._$GetSrcTargetId$_()), e = this._$_GetRenderTargetForId$_(s._$GetDestTargetId$_());
                    t._$IsWebGPU$_() ? s._$Run_WebGPU$_(t, i, e) : s._$Run_WebGL$_(t, i, e);
                }
                t._$SetTexture$_(null), this._$_renderTargets$_[1] && this._$_ReleaseRenderTarget$_(this._$_renderTargets$_[1]), 
                this._$_renderTargets$_[2] && this._$_ReleaseRenderTarget$_(this._$_renderTargets$_[2]), 
                this._$_renderTargets$_.fill(null), this._$_OnAfterEndEffectChain$_(t), this._$_destRenderTarget$_ = null, 
                this._$_backTex$_ = null, this._$_contentObject$_ = null, this._$_contextObject$_ = null, 
                this._$_cbDrawContentHook$_ = null;
            }
        }
        _$_CalculateDrawSizeAndRectangles$_(t, s) {
            const [i, e] = this._$_manager$_._$GetDrawSize$_(t);
            this._$_SetDrawSize$_(t, i, e), this._$_CalculateRectangles$_(s);
        }
        _$_SetDrawSize$_(t, s, i) {
            if (s <= 0 || i <= 0) throw new Error("invalid draw size");
            this._$_drawWidth$_ === s && this._$_drawHeight$_ === i || this._$_CalculateDeviceTransformMatrices$_(t, s, i, 0, 0, this._$_projectionMatrix$_, this._$_modelViewMatrix$_), 
            this._$_drawWidth$_ = s, this._$_drawHeight$_ = i;
        }
        _$_CalculateDeviceTransformMatrices$_(t, s, i, e, n, h, r) {
            const o = s / 2 + e, a = i / 2 + n;
            t._$CalculatePerspectiveMatrix$_(h, s / i);
            const u = t._$CalculateLookAtModelView2$_(o, a, t._$GetDefaultCameraZ$_(i), o, a, 0, i);
            Vc._$copy$_(r, u);
        }
        _$_CalculateRectangles$_(t) {
            this._$_layoutRect$_._$copy$_(t._$layoutRect$_), t._$drawSurfaceRect$_ ? this._$_drawSurfaceRect$_._$copy$_(t._$drawSurfaceRect$_) : this._$_drawSurfaceRect$_.set(0, 0, this._$_drawWidth$_, this._$_drawHeight$_), 
            this._$_rcTexOriginal$_._$copy$_(this._$_drawSurfaceRect$_), this._$_rcTexOriginal$_._$divide$_(this._$_drawWidth$_, this._$_drawHeight$_);
            const s = this._$_layerScale$_ * this._$_devicePixelRatio$_;
            this._$_drawSurfaceRect$_._$inflate$_(this._$_boxExtendHorizontal$_ * s, this._$_boxExtendVertical$_ * s), 
            this._$_rcTexDest$_._$copy$_(this._$_drawSurfaceRect$_), this._$_rcTexDest$_._$divide$_(this._$_drawWidth$_, this._$_drawHeight$_), 
            this._$_drawSurfaceRect$_._$clampBoth$_(0, 0, this._$_drawWidth$_, this._$_drawHeight$_), 
            this._$_rcTexBounce$_._$copy$_(this._$_drawSurfaceRect$_), this._$_rcTexBounce$_._$divide$_(this._$_drawWidth$_, this._$_drawHeight$_);
        }
        _$_OnBeforeStartEffectChain$_(t) {
            if (this._$_depthEnabledAtStart$_ = t._$IsDepthEnabled$_(), this._$_coplanarColorPassAtStart$_ = t._$IsCoplanarColorPass$_(), 
            this._$_useFullSurface$_) t._$SetDepthEnabled$_(!1), this._$_isAnyShaderDepthSampling$_ && t._$SetDepthSamplingEnabled$_(!0); else {
                if (Hc._$copy$_(this._$_drawSurfaceRect$_), t._$IsWebGL$_()) {
                    const t = this._$_layerScale$_ * this._$_devicePixelRatio$_;
                    Hc._$inflate$_(Math.max(this._$_boxExtendHorizontal$_, 1) * t, Math.max(this._$_boxExtendVertical$_, 1) * t), 
                    Hc._$roundOuter$_(), Hc._$clamp$_(0, 0, this._$_drawWidth$_, this._$_drawHeight$_);
                } else Hc._$roundOuter$_();
                t._$SetScissorRect$_(Hc._$getLeft$_(), Hc._$getTop$_(), Hc.width(), Hc.height(), this._$_drawHeight$_);
            }
        }
        _$_OnAfterEffectChainDrawContent$_(t) {
            t._$ResetColor$_(), this._$_useFullSurface$_ || (this._$_coplanarColorPassAtStart$_ && t._$CoplanarRestoreStandardRendering$_(), 
            t._$SetDepthEnabled$_(!1), this._$_isAnyShaderDepthSampling$_ && t._$SetDepthSamplingEnabled$_(!0)), 
            t._$IsWebGPU$_() && t._$SetNormalizedCoordsProgramVariant$_(!0);
        }
        _$_OnAfterEndEffectChain$_(t) {
            t._$SetDepthSamplingEnabled$_(!1), this._$_coplanarColorPassAtStart$_ && t._$CoplanarStartColorPass$_(), 
            t._$SetDepthEnabled$_(this._$_depthEnabledAtStart$_), this._$_useFullSurface$_ || t._$RemoveScissorRect$_(), 
            t._$IsWebGPU$_() && t._$SetNormalizedCoordsProgramVariant$_(!1), this._$_didChangeTransform$_ = t._$DidChangeTransform$_();
        }
        _$_ClampRcTexDest$_() {
            this._$_rcTexDest$_._$clamp$_(0, 0, 1, 1);
        }
        _$_GetRenderTargetForId$_(t) {
            return t < 0 ? null : this._$_renderTargets$_[t];
        }
        _$_GetRenderTarget$_() {
            return this._$_manager$_._$GetRenderTarget$_(this);
        }
        _$_GetDestRenderTarget$_() {
            return this._$_destRenderTarget$_;
        }
        _$_ReleaseRenderTarget$_(t) {
            this._$_manager$_._$ReleaseRenderTarget$_(t, this);
        }
        _$_GetShaderProgramAt$_(t) {
            return this._$_shaderProgramList$_[t];
        }
        _$_DrawContent$_(t) {
            this._$_cbDrawContentHook$_ ? this._$_cbDrawContentHook$_(this, t, (() => this._$_cbDrawContent$_(t, this))) : this._$_cbDrawContent$_(t, this), 
            this._$_canUseFastPath$_ || this._$_OnAfterEffectChainDrawContent$_(t);
        }
        _$_IsRenderTargetSameSizeAndOffset$_(t) {
            if (this._$_useFullSurface$_) return !0;
            if (0 !== this._$_compositOffX$_ || 0 !== this._$_compositOffY$_ || 0 !== this._$_compositRtWidth$_ || 0 !== this._$_compositRtHeight$_) return !1;
            const [s, i] = t._$GetRenderTargetSize$_(t._$GetRenderTarget$_());
            return s === this._$_drawWidth$_ && i === this._$_drawHeight$_;
        }
        _$_SetDeviceTransform$_(t, s) {
            let i = this._$_projectionMatrix$_, e = this._$_modelViewMatrix$_;
            if (s && !this._$_IsRenderTargetSameSizeAndOffset$_(t)) {
                let s, n;
                i = Kc, e = $c, 0 !== this._$_compositRtWidth$_ && 0 !== this._$_compositRtHeight$_ ? [s, n] = [ this._$_compositRtWidth$_, this._$_compositRtHeight$_ ] : [s, n] = t._$GetRenderTargetSize$_(t._$GetRenderTarget$_()), 
                this._$_CalculateDeviceTransformMatrices$_(t, s, n, this._$_compositOffX$_, this._$_compositOffY$_, i, e), 
                this._$_useFullSurface$_ || t._$RemoveScissorRect$_();
            }
            t._$SetProjectionMatrix$_(i), t._$SetModelViewMatrix$_(e);
        }
        _$_Redraw$_() {
            this._$_manager$_._$Redraw$_(this);
        }
        _$_GetShaderParameters$_(t, s) {
            return this._$_cbGetShaderParameters$_(this._$_shaderProgramIndices$_[t], s);
        }
        _$_SetProgramParameters$_(t, s) {
            let i = this._$_rcTexDest$_, e = this._$_rcTexBounce$_, n = this._$_rcTexOriginal$_;
            t._$IsWebGL$_() && (qc._$copy$_(i), qc._$flipAround$_(1), i = qc, Xc._$copy$_(e), 
            Xc._$flipAround$_(1), e = Xc, Zc._$copy$_(n), Zc._$flipAround$_(1), n = Zc), this._$_DoSetProgramParameters$_(t, s, e, n, i, 1 / this._$_drawWidth$_, 1 / this._$_drawHeight$_);
        }
        _$_SetFirstBounceProgramParameters$_(t, s) {
            let i = this._$_rcTexBounce$_, e = this._$_rcTexOriginal$_, n = 1 / this._$_drawWidth$_, h = 1 / this._$_drawHeight$_;
            if (this._$_cbGetSourceTextureInfo$_) {
                let {_$srcTexRect$_: t, _$srcWidth$_: s, _$srcHeight$_: r} = this._$_cbGetSourceTextureInfo$_(this._$_contentObject$_);
                t || (Hc.set(0, 0, 0, 0), t = Hc), s || (s = this._$_drawWidth$_), r || (r = this._$_drawHeight$_), 
                i = t, e = t, n = 1 / s, h = 1 / r;
            } else t._$IsWebGL$_() && (Xc._$copy$_(i), Xc._$flipAround$_(1), i = Xc, Zc._$copy$_(e), 
            Zc._$flipAround$_(1), e = Zc);
            let r = this._$_rcTexDest$_;
            t._$IsWebGL$_() && (r = qc, r._$copy$_(this._$_rcTexDest$_), r._$flipAround$_(1)), 
            this._$_DoSetProgramParameters$_(t, s, i, e, r, n, h), t._$IsWebGPU$_() && this._$_isAnyIsSrcTexRotated$_ && t._$SetProgramParameter_IsSrcTexRotated$_(this._$_isSourceTextureRotated$_);
        }
        _$_GetBackTex$_(t) {
            return this._$_isAnyShaderBackgroundBlending$_ ? t._$IsWebGPU$_() ? this._$_UseCopyTextureBackgroundSampling$_() ? this._$_backTex$_ : this._$_destRenderTarget$_._$GetTexture$_() : this._$_destRenderTarget$_ : null;
        }
        _$_DoSetProgramParameters$_(t, s, i, e, n, h, r) {
            t._$SetProgramParameters$_(this._$_GetBackTex$_(t), n, i, e, this._$_layoutRect$_, h, r, this._$_devicePixelRatio$_, this._$_layerScale$_, this._$_layerAngle$_, this._$_time$_), 
            t._$SetProgramCustomParameters$_(this._$_GetShaderParameters$_(s, t));
        }
        _$_Render_FastPath$_(t, s) {
            const i = this._$_shaderProgramList$_[0], e = t._$IsDepthEnabled$_(), n = i._$UsesDepth$_();
            n && (t._$SetDepthEnabled$_(!1), t._$SetDepthSamplingEnabled$_(!0), this._$_rcTexDest$_.set(0, 0, 1, 1), 
            this._$_rcTexOriginal$_.set(0, 0, 1, 1)), t._$SetProgram$_(i), t._$SetBlendMode$_(this._$_blendMode$_), 
            t._$SetRenderTarget$_(this._$_destRenderTarget$_);
            let h = 0, r = 1;
            if (this._$_rcTexOriginal$_.set(0, 0, 1, 1), i._$UsesAnySrcRectOrPixelSize$_() && this._$_cbGetSourceTextureInfo$_) {
                const {_$srcTexRect$_: t, _$srcWidth$_: s, _$srcHeight$_: i} = this._$_cbGetSourceTextureInfo$_(this._$_contentObject$_);
                t && this._$_rcTexOriginal$_._$copy$_(t), h = Number.isFinite(s) ? 1 / s : 0, r = Number.isFinite(i) ? 1 / i : 0;
            } else {
                const [s, i] = this._$_manager$_._$GetDrawSize$_(t);
                h = 1 / s, r = 1 / i;
            }
            s._$layoutRect$_ ? this._$_layoutRect$_._$copy$_(s._$layoutRect$_) : this._$_layoutRect$_.set(0, 0, 0, 0), 
            t._$SetProgramParameters$_(this._$_GetBackTex$_(t), this._$_rcTexDest$_, this._$_rcTexOriginal$_, this._$_rcTexOriginal$_, this._$_layoutRect$_, h, r, this._$_devicePixelRatio$_, this._$_layerScale$_, this._$_layerAngle$_, this._$_time$_), 
            t._$SetProgramCustomParameters$_(this._$_GetShaderParameters$_(0, t)), t._$IsWebGPU$_() && this._$_isAnyIsSrcTexRotated$_ && t._$SetProgramParameter_IsSrcTexRotated$_(this._$_isSourceTextureRotated$_), 
            t._$SetBaseZ$_(0), this._$_DrawContent$_(t), n && (t._$SetDepthSamplingEnabled$_(!1), 
            t._$SetDepthEnabled$_(e));
        }
        _$_UseCopyTextureBackgroundSampling$_() {
            return this._$_useCopyTextureBackgroundSampling$_;
        }
        _$_UseRenderTargetBackgroundSampling$_() {
            return !this._$_useCopyTextureBackgroundSampling$_;
        }
        _$IsAnyShaderBackgroundBlending$_() {
            return this._$_isAnyShaderBackgroundBlending$_;
        }
        _$CanSkipCalculatingDrawSurfaceRect$_() {
            return !!this._$_canUseFastPath$_ && !this._$_UseCopyTextureBackgroundSampling$_();
        }
        _$UseFullSurface$_() {
            return this._$_useFullSurface$_;
        }
        _$GetContentObject$_() {
            return this._$_contentObject$_;
        }
        _$GetContextObject$_() {
            return this._$_contextObject$_;
        }
        _$_GetBlendMode$_() {
            return this._$_blendMode$_;
        }
        _$_UpdateOwnProjection$_() {
            return this._$_updateOwnProjection$_;
        }
        _$DidChangeTransform$_() {
            return this._$_didChangeTransform$_;
        }
        _$_GetDrawSurfaceRect$_() {
            return this._$_drawSurfaceRect$_;
        }
        _$_GetRcTexBounce$_() {
            return this._$_rcTexBounce$_;
        }
        _$_ShouldInvalidateRenderTargets$_() {
            return this._$_invalidateRenderTargets$_;
        }
        async _$DebugLogRenderTargetContents$_(t, s, i) {}
    };
}

self._$C3$_._$Gfx$_._$EffectChain$_._$Step$_ = class {
    constructor(t, s, i, e = -1) {
        this._$_effectChain$_ = t, this._$_srcTargetId$_ = s, this._$_destTargetId$_ = i, 
        this._$_index$_ = e;
    }
    _$GetEffectChain$_() {
        return this._$_effectChain$_;
    }
    _$GetSrcTargetId$_() {
        return this._$_srcTargetId$_;
    }
    _$GetDestTargetId$_() {
        return this._$_destTargetId$_;
    }
    _$GetIndex$_() {
        return this._$_index$_;
    }
    _$GetShaderProgram$_() {
        return this._$GetEffectChain$_()._$_GetShaderProgramAt$_(this._$GetIndex$_());
    }
    _$Run_WebGL$_(t, s, i) {}
    _$Run_WebGPU$_(t, s, i) {}
};

{
    const ef = self._$C3$_;
    ef._$Gfx$_._$EffectChain$_._$Step$_._$PreDraw$_ = class extends ef._$Gfx$_._$EffectChain$_._$Step$_ {
        constructor(t, s, i, e) {
            super(t, s, i, e);
        }
        _$Run_WebGL$_(t, s, i) {
            const e = this._$GetEffectChain$_();
            t._$SetAlphaBlend$_(), t._$SetTextureFillMode$_(), t._$SetRenderTarget$_(i, e._$_UpdateOwnProjection$_()), 
            t._$ClearRgba$_(0, 0, 0, 0), e._$_DrawContent$_(t), e._$_ClampRcTexDest$_();
        }
        _$Run_WebGPU$_(t, s, i) {
            const e = this._$GetEffectChain$_();
            t._$SetAlphaBlend$_(), t._$SetTextureFillMode$_(), t._$SetRenderTarget$_(i, !1), 
            t._$ClearRgba$_(0, 0, 0, 0), e._$_DrawContent$_(t), e._$_ClampRcTexDest$_();
        }
    };
}

{
    const nf = self._$C3$_, hf = nf._$New$_(nf.Rect), rf = nf._$New$_(nf._$Quad$_);
    nf._$Gfx$_._$EffectChain$_._$Step$_._$PostDraw$_ = class extends nf._$Gfx$_._$EffectChain$_._$Step$_ {
        constructor(t, s, i, e) {
            super(t, s, i, e);
        }
        _$Run_WebGL$_(t, s, i) {
            const e = this._$GetEffectChain$_();
            t._$SetTextureFillMode$_(), t._$SetRenderTarget$_(i), e._$_SetDeviceTransform$_(t, !0), 
            t._$SetBlendMode$_(e._$_GetBlendMode$_()), t._$SetTexture$_(s._$GetTexture$_()), 
            rf._$setFromRect$_(e._$_GetDrawSurfaceRect$_()), hf._$copy$_(e._$_GetRcTexBounce$_()), 
            hf._$flipAround$_(1), t._$Quad3$_(rf, hf), e._$_ShouldInvalidateRenderTargets$_() && t._$InvalidateRenderTarget$_(s);
        }
        _$Run_WebGPU$_(t, s, i) {
            const e = this._$GetEffectChain$_();
            t._$SetTextureFillMode$_(), t._$SetRenderTarget$_(i, !1), e._$_IsRenderTargetSameSizeAndOffset$_(t) ? rf._$setFromRect$_(e._$_GetRcTexBounce$_()) : (t._$SetNormalizedCoordsProgramVariant$_(!1), 
            e._$_SetDeviceTransform$_(t, !0), rf._$setFromRect$_(e._$_GetDrawSurfaceRect$_())), 
            t._$SetBackTexture$_(null), t._$SetBlendMode$_(e._$_GetBlendMode$_()), t._$SetTexture$_(s._$GetTexture$_()), 
            e._$UseFullSurface$_() ? t._$FullscreenQuad$_() : t._$Quad3$_(rf, e._$_GetRcTexBounce$_());
        }
    };
}

{
    const of = self._$C3$_;
    of._$Gfx$_._$EffectChain$_._$Step$_._$FirstBounce$_ = class extends of._$Gfx$_._$EffectChain$_._$Step$_ {
        constructor(t, s, i, e) {
            super(t, s, i, e);
        }
        _$Run_WebGL$_(t, s, i) {
            const e = this._$GetEffectChain$_();
            t._$SetRenderTarget$_(i, e._$_UpdateOwnProjection$_()), t._$ClearRgba$_(0, 0, 0, 0), 
            t._$SetCopyBlend$_(), t._$SetProgram$_(this._$GetShaderProgram$_()), e._$_SetFirstBounceProgramParameters$_(t, this._$GetIndex$_()), 
            e._$_DrawContent$_(t), e._$_ClampRcTexDest$_();
        }
        _$Run_WebGPU$_(t, s, i) {
            const e = this._$GetEffectChain$_();
            t._$SetRenderTarget$_(i, !1), t._$ClearRgba$_(0, 0, 0, 0), t._$SetCopyBlend$_(), 
            t._$SetProgram$_(this._$GetShaderProgram$_()), e._$_SetFirstBounceProgramParameters$_(t, this._$GetIndex$_()), 
            e._$_DrawContent$_(t), e._$_ClampRcTexDest$_();
        }
    };
}

{
    const af = self._$C3$_, uf = af._$New$_(af.Rect), lf = af._$New$_(af._$Quad$_);
    af._$Gfx$_._$EffectChain$_._$Step$_._$Bounce$_ = class extends af._$Gfx$_._$EffectChain$_._$Step$_ {
        constructor(t, s, i, e) {
            super(t, s, i, e);
        }
        _$Run_WebGL$_(t, s, i) {
            const e = this._$GetEffectChain$_();
            t._$SetRenderTarget$_(i);
            const n = 0 === this._$GetDestTargetId$_();
            n ? t._$SetBlendMode$_(e._$_GetBlendMode$_()) : (t._$ClearRgba$_(0, 0, 0, 0), t._$SetCopyBlend$_()), 
            t._$SetProgram$_(this._$GetShaderProgram$_()), e._$_SetProgramParameters$_(t, this._$GetIndex$_()), 
            t._$SetTexture$_(s._$GetTexture$_()), e._$_SetDeviceTransform$_(t, n), lf._$setFromRect$_(e._$_GetDrawSurfaceRect$_()), 
            uf._$copy$_(e._$_GetRcTexBounce$_()), uf._$flipAround$_(1), t._$Quad3$_(lf, uf), 
            e._$_ShouldInvalidateRenderTargets$_() && t._$InvalidateRenderTarget$_(s);
        }
        _$Run_WebGPU$_(t, s, i) {
            const e = this._$GetEffectChain$_();
            t._$SetRenderTarget$_(i, !1), 0 === this._$GetDestTargetId$_() ? (t._$SetBlendMode$_(e._$_GetBlendMode$_()), 
            t._$SetBackTexture$_(null), e._$_IsRenderTargetSameSizeAndOffset$_(t) ? lf._$setFromRect$_(e._$_GetRcTexBounce$_()) : (t._$SetNormalizedCoordsProgramVariant$_(!1), 
            e._$_SetDeviceTransform$_(t, !0), lf._$setFromRect$_(e._$_GetDrawSurfaceRect$_()))) : (t._$ClearRgba$_(0, 0, 0, 0), 
            t._$SetCopyBlend$_(), lf._$setFromRect$_(e._$_GetRcTexBounce$_())), t._$SetProgram$_(this._$GetShaderProgram$_()), 
            e._$_SetProgramParameters$_(t, this._$GetIndex$_()), t._$SetTexture$_(s._$GetTexture$_()), 
            e._$UseFullSurface$_() ? t._$FullscreenQuad$_() : t._$Quad3$_(lf, e._$_GetRcTexBounce$_());
        }
    };
}

{
    let cf = function(t, s) {
        const i = t[0] - s[0];
        return 0 !== i ? i : t[1] - s[1];
    };
    0;
    const ff = self._$C3$_, df = self._$C3X$_;
    let pf = null;
    const mf = new Set, gf = [], yf = [];
    let Mf = !1, wf = !1, Sf = !1;
    const bf = new Set([ "vsync", "unlimited-tick", "unlimited-frame" ]);
    self._$IRuntime$_ = class {
        constructor(t) {
            pf = t, Object.defineProperties(this, {
                _$assets$_: {
                    value: pf._$GetAssetManager$_()._$GetIAssetManager$_(),
                    writable: !1
                },
                _$collisions$_: {
                    value: pf._$GetCollisionEngine$_()._$GetICollisionEngine$_(),
                    writable: !1
                },
                _$objects$_: {
                    value: {},
                    writable: !1
                },
                _$globalVars$_: {
                    value: {},
                    writable: !1
                },
                _$projectName$_: {
                    value: pf._$GetProjectName$_(),
                    writable: !1
                },
                _$projectVersion$_: {
                    value: pf._$GetProjectVersion$_(),
                    writable: !1
                },
                _$exportDate$_: {
                    value: new Date(pf._$GetExportTimestamp$_()),
                    writable: !1
                },
                storage: {
                    value: new self._$IStorage$_(pf),
                    writable: !1
                },
                _$isInWorker$_: {
                    value: pf._$IsInWorker$_(),
                    writable: !1
                },
                _$viewportWidth$_: {
                    value: pf._$GetOriginalViewportWidth$_(),
                    writable: !1
                },
                _$viewportHeight$_: {
                    value: pf._$GetOriginalViewportHeight$_(),
                    writable: !1
                },
                _$sampling$_: {
                    value: pf._$GetSampling$_(),
                    writable: !1
                },
                _$isPixelRoundingEnabled$_: {
                    value: pf._$IsPixelRoundingEnabled$_(),
                    writable: !1
                },
                _$platformInfo$_: {
                    value: new self._$IPlatformInfo$_(t),
                    writable: !1
                },
                _$sdk$_: {
                    value: new self._$ISDKUtils$_(t),
                    writable: !1
                }
            }), pf._$UserScriptDispatcher$_().addEventListener("keydown", (t => {
                mf.has(t.key) ? t.stopPropagation() : mf.add(t.key);
            })), pf._$UserScriptDispatcher$_().addEventListener("keyup", (t => mf.delete(t.key))), 
            pf._$Dispatcher$_().addEventListener("window-blur", (() => mf.clear())), pf._$IsInWorker$_() && (self.alert = t => (Mf || (Mf = !0, 
            console.warn("[Construct] alert() was called from a Web Worker, because the project 'Use worker' setting is enabled. This method is not normally available in a Web Worker. Construct has implemented the alert for you, but note that other features may be missing in worker mode. You may wish to disable 'Use worker', or use a more convenient function like console.log(). For more information please refer to the scripting section of the manual.")), 
            this.alert(t)));
        }
        _$_InitObjects$_(t) {
            Object.defineProperties(this._$objects$_, t);
        }
        _$_InitGlobalVars$_(t) {
            Object.defineProperties(this._$globalVars$_, t);
        }
        addEventListener(t, s) {
            pf._$UserScriptDispatcher$_().addEventListener(t, s);
        }
        removeEventListener(t, s) {
            pf._$UserScriptDispatcher$_().removeEventListener(t, s);
        }
        _$callFunction$_(t, ...s) {
            df._$RequireString$_(t);
            const i = pf._$GetEventSheetManager$_(), e = i._$GetFunctionBlockByName$_(t);
            if (!e) throw new Error(`cannot find function name '${t}'`);
            if (!e._$IsEnabled$_()) return e._$GetDefaultReturnValue$_();
            if (s.length < e._$GetFunctionParameterCount$_()) throw new Error(`not enough function parameters passed for '${t}' (${s.length} passed, ${e._$GetFunctionParameterCount$_()} expected)`);
            const n = e._$GetEventBlock$_();
            let h = n._$GetSolModifiersIncludingParents$_();
            const r = i._$GetCurrentEvent$_();
            if (r) {
                h = h.slice(0);
                const t = new Set(h);
                for (const s of r._$GetSolModifiersIncludingParents$_()) t.has(s) || (h.push(s), 
                t.add(s));
                for (const s of i._$GetDynamicSolModifiersSet$_()) t.has(s) || (h.push(s), t.add(s));
            }
            return n._$RunAsExpressionFunctionCall$_(h, e._$IsCopyPicked$_(), e._$GetReturnType$_(), e._$GetDefaultReturnValue$_(), ...s);
        }
        _$setReturnValue$_(t) {
            const s = pf._$GetEventStack$_()._$GetCurrentExpFuncStackFrame$_();
            if (!s) throw new Error("not in a function which returns a value");
            switch (s._$GetFunctionReturnType$_()) {
              case 1:
                "number" == typeof t && s._$SetFunctionReturnValue$_(t);
                break;

              case 2:
                "string" == typeof t && s._$SetFunctionReturnValue$_(t);
                break;

              case 3:
                "number" != typeof t && "string" != typeof t || s._$SetFunctionReturnValue$_(t);
            }
        }
        signal(t) {
            df._$RequireString$_(t), pf._$GetEventSheetManager$_()._$Signal$_(t);
        }
        _$waitForSignal$_(t) {
            return df._$RequireString$_(t), pf._$GetEventSheetManager$_()._$WaitForSignal$_(t);
        }
        _$getViewportSize$_() {
            return [ pf._$GetOriginalViewportWidth$_(), pf._$GetOriginalViewportHeight$_() ];
        }
        get _$isSuspended$_() {
            return pf._$IsSuspended$_();
        }
        get _$dt$_() {
            return pf._$GetDt$_();
        }
        get _$dtRaw$_() {
            return pf._$GetDtRaw$_();
        }
        get _$gameTime$_() {
            return pf._$GetGameTime$_();
        }
        get _$wallTime$_() {
            return pf._$GetWallTime$_();
        }
        get _$timeScale$_() {
            return pf._$GetTimeScale$_();
        }
        set _$timeScale$_(t) {
            df._$RequireFiniteNumber$_(t), pf._$SetTimeScale$_(t);
        }
        get _$fps$_() {
            return wf || (console.warn("IRuntime.fps is deprecated. Use IRuntime.framesPerSecond instead."), 
            wf = !0), pf._$GetFramesPerSecond$_();
        }
        get framesPerSecond() {
            return pf._$GetFramesPerSecond$_();
        }
        get _$ticksPerSecond$_() {
            return pf._$GetTicksPerSecond$_();
        }
        get _$cpuUtilisation$_() {
            return pf._$GetMainThreadTime$_();
        }
        get _$gpuUtilisation$_() {
            return pf._$GetGPUUtilisation$_();
        }
        get _$framerateMode$_() {
            return pf._$GetFramerateMode$_();
        }
        set _$framerateMode$_(t) {
            if (!bf.has(t)) throw new Error("invalid framerate mode");
            pf._$_SetFramerateMode$_(t);
        }
        get _$minDt$_() {
            return pf._$GetMinDt$_();
        }
        set _$minDt$_(t) {
            df._$RequireFiniteNumber$_(t), pf._$SetMinDt$_(t);
        }
        get _$maxDt$_() {
            return pf._$GetMaxDt$_();
        }
        set _$maxDt$_(t) {
            pf._$SetMaxDt$_(t);
        }
        get _$loadingProgress$_() {
            return pf._$GetAssetManager$_()._$GetLoadProgress$_();
        }
        get _$imageLoadingProgress$_() {
            return pf._$GetAssetManager$_()._$GetImageLoadProgress$_();
        }
        random() {
            return pf._$Random$_();
        }
        get layout() {
            const t = pf._$GetMainRunningLayout$_();
            if (!t) throw new Error("no layout is running - make sure a layout is loaded before accessing");
            return t._$GetILayout$_();
        }
        _$getLayout$_(t) {
            const s = pf._$GetLayoutManager$_();
            let i = null;
            if ("number" != typeof t && "string" != typeof t) throw new TypeError("expected string or number");
            if (i = s._$GetLayout$_(t), !i) throw new Error("invalid layout");
            return i._$GetILayout$_();
        }
        _$getAllLayouts$_() {
            return pf._$GetLayoutManager$_()._$GetAllLayouts$_().map((t => t._$GetILayout$_()));
        }
        _$goToLayout$_(t) {
            const s = pf._$GetLayoutManager$_();
            let i = null;
            if ("number" != typeof t && "string" != typeof t) throw new TypeError("expected string or number");
            if (i = s._$GetLayout$_(t), !i) throw new Error("invalid layout");
            s._$IsPendingChangeMainLayout$_() || s._$ChangeMainLayout$_(i);
        }
        get keyboard() {
            const t = pf._$_GetCommonScriptInterfaces$_().keyboard;
            if (!t) throw new Error("runtime.keyboard used but Keyboard object missing - add it to your project first");
            return t;
        }
        get _$mouse$_() {
            const t = pf._$_GetCommonScriptInterfaces$_()._$mouse$_;
            if (!t) throw new Error("runtime.mouse used but Mouse object missing - add it to your project first");
            return t;
        }
        get _$touch$_() {
            const t = pf._$_GetCommonScriptInterfaces$_()._$touch$_;
            if (!t) throw new Error("runtime.touch used but Touch object missing - add it to your project first");
            return t;
        }
        get _$timelineController$_() {
            const t = pf._$_GetCommonScriptInterfaces$_()._$timelineController$_;
            if (!t) throw new Error("runtime.timelineController used but Timeline Controller object missing - add it to your project first");
            return t;
        }
        _$invokeDownload$_(t, s) {
            df._$RequireString$_(t), df._$RequireString$_(s), pf._$InvokeDownload$_(t, s);
        }
        _$getInstanceByUid$_(t) {
            df._$RequireFiniteNumber$_(t);
            const s = pf._$GetInstanceByUID$_(t);
            return s ? s._$GetInterfaceClass$_() : null;
        }
        _$sortZOrder$_(t, s) {
            df._$RequireFunction$_(s);
            const i = pf._$GetCurrentLayout$_();
            for (const s of t) {
                const t = pf._$_UnwrapIWorldInstance$_(s), i = t._$GetWorldInfo$_();
                gf.push([ i._$GetLayer$_()._$GetIndex$_(), i._$GetZIndex$_() ]), yf.push(t);
            }
            if (0 === gf.length) return;
            gf.sort(cf), yf.sort(((t, i) => s(t._$GetInterfaceClass$_(), i._$GetInterfaceClass$_())));
            let e = !1;
            for (let t = 0, s = gf.length; t < s; ++t) {
                const s = yf[t], n = i._$GetLayerByIndex$_(gf[t][0]), h = gf[t][1], r = n._$_GetInstances$_();
                r[h] !== s && (r[h] = s, s._$GetWorldInfo$_()._$_SetLayer$_(n, !0), n._$SetZIndicesChanged$_(s), 
                e = !0);
            }
            e && pf._$UpdateRender$_(), ff._$clearArray$_(gf), ff._$clearArray$_(yf);
        }
        async _$createWorker$_(t, s) {
            Sf || (console.warn("IRuntime.createWorker() is deprecated. All modern browsers now support nested workers so this method is no longer needed."), 
            Sf = !0);
            const i = new MessageChannel, e = i.port1, n = i.port2;
            return await pf._$PostComponentMessageToDOMAsync$_("runtime", "script-create-worker", {
                url: t,
                opts: s,
                port2: n
            }, [ n ]), e;
        }
        alert(t) {
            return pf._$PostComponentMessageToDOMAsync$_("runtime", "alert", {
                message: t + (pf._$IsInWorker$_() ? " [via Web Worker]" : "")
            });
        }
        _$getHTMLLayer$_(t) {
            return df._$RequireFiniteNumber$_(t), pf._$_GetHTMLLayerWrapElement$_(t);
        }
        _$addLoadPromise$_(t) {
            pf._$AddLoadPromise$_(t);
        }
        async _$saveCanvasImage$_(t, s, i) {
            df._$RequireOptionalString$_(t), df._$RequireOptionalNumber$_(s), df._$RequireOptionalInstanceOf$_(i, DOMRect), 
            i || (i = new DOMRect(0, 0, 0, 0));
            const e = pf._$GetCanvasManager$_();
            if (!e) return;
            pf._$UpdateRender$_();
            const n = await e._$SnapshotCanvas$_(t || "image/png", s, i.x, i.y, i.width, i.height);
            return await pf._$TriggerAsync$_(ff._$Plugins$_._$System$_._$Cnds$_._$OnCanvasSnapshot$_, null), 
            n;
        }
    };
}

{
    const Tf = self._$C3$_;
    self._$C3X$_;
    let vf = null;
    self._$IAssetManager$_ = class {
        constructor(t) {
            vf = t, Object.defineProperties(this, {
                _$isWebMOpusSupported$_: {
                    value: !0,
                    writable: !1
                }
            });
        }
        _$loadImageAsset$_(t) {
            const s = self._$IImageInfo$_._$_Unwrap$_(t);
            if (!s) throw new Error("invalid IImageInfo");
            s._$LoadAsset$_(vf._$GetRuntime$_());
        }
        _$fetchText$_(t) {
            return vf._$FetchText$_(t);
        }
        _$fetchJson$_(t) {
            return vf._$FetchJson$_(t);
        }
        _$fetchBlob$_(t) {
            return vf._$FetchBlob$_(t);
        }
        _$fetchArrayBuffer$_(t) {
            return vf._$FetchArrayBuffer$_(t);
        }
        _$getProjectFileUrl$_(t) {
            return vf._$GetProjectFileUrl$_(t);
        }
        _$getMediaFileUrl$_(t) {
            return "flat" === vf._$GetFileStructure$_() && Tf._$IsRelativeURL$_(t) && (t = t.toLowerCase()), 
            vf._$GetMediaFileUrl$_(t);
        }
        get _$mediaFolder$_() {
            return vf._$GetMediaSubfolder$_();
        }
        async _$decodeWebMOpus$_(t, s) {
            throw new Error("decodeWebMOpus() is no longer supported - use Web Audio's decodeAudioData() directly as all supported platforms now support WebM Opus");
        }
        _$loadScripts$_(...t) {
            return vf._$LoadScripts$_(...t);
        }
        _$compileWebAssembly$_(t) {
            return vf._$CompileWebAssembly$_(t);
        }
        _$loadStyleSheet$_(t) {
            return vf._$LoadStyleSheet$_(t);
        }
    };
}

{
    const xf = self._$C3$_, If = self._$C3X$_;
    let Gf = null;
    self._$ICollisionEngine$_ = class {
        constructor(t) {
            Gf = t, Object.defineProperties(this, {
                runtime: {
                    value: Gf._$GetRuntime$_(),
                    writable: !1
                }
            });
        }
        _$testOverlap$_(t, s) {
            const i = Gf._$GetRuntime$_(), e = i._$_UnwrapIWorldInstance$_(t), n = i._$_UnwrapIWorldInstance$_(s);
            return Gf._$TestOverlap$_(e, n);
        }
        _$testOverlapAny$_(t, s) {
            const i = Gf._$GetRuntime$_(), e = i._$_UnwrapIWorldInstance$_(t);
            for (const t of s) {
                const s = i._$_UnwrapIWorldInstance$_(t);
                if (Gf._$TestOverlap$_(e, s)) return t;
            }
            return null;
        }
        _$testOverlapSolid$_(t) {
            const s = Gf._$GetRuntime$_()._$_UnwrapIWorldInstance$_(t), i = Gf._$TestOverlapSolid$_(s);
            return i ? i._$GetInterfaceClass$_() : null;
        }
        _$setCollisionCellSize$_(t, s) {
            if (If._$RequireFiniteNumber$_(t), If._$RequireFiniteNumber$_(s), t = Math.floor(t), 
            s = Math.floor(s), t <= 0 || s <= 0) throw new Error("invalid cell size");
            Gf._$SetCollisionCellSize$_(t, s);
        }
        _$getCollisionCellSize$_() {
            return Gf._$GetCollisionCellSize$_();
        }
        _$getCollisionCandidates$_(t, s) {
            const i = Gf._$GetRuntime$_();
            let e;
            e = Array.isArray(t) ? t.map((t => i._$_UnwrapIObjectClass$_(t))) : [ i._$_UnwrapIObjectClass$_(t) ];
            const n = xf.Rect._$FromObject$_(s), h = [];
            return Gf._$GetObjectClassesCollisionCandidates$_(null, e, n, h), h.map((t => t._$GetInterfaceClass$_()));
        }
    };
}

{
    const Cf = self._$C3$_;
    self._$C3X$_;
    let _f = null;
    const Ef = new Map([ [ "Windows", "windows" ], [ "macOS", "macos" ], [ "Linux", "linux" ], [ "Chrome OS", "chrome-os" ], [ "Android", "android" ], [ "iOS", "ios" ] ]), Df = new Map([ [ "Chrome", "chrome" ], [ "Chromium", "chromium" ], [ "Edge", "edge" ], [ "Opera", "opera" ], [ "NW.js", "nwjs" ], [ "Firefox", "firefox" ], [ "Safari", "safari" ] ]), Af = new Map([ [ "Chromium", "chromium" ], [ "Gecko", "gecko" ], [ "WebKit", "webkit" ] ]);
    self._$IPlatformInfo$_ = class {
        constructor(t) {
            _f = t, Object.defineProperties(this, {
                _$isMobile$_: {
                    value: Cf._$Platform$_._$IsMobile$_,
                    writable: !1
                },
                os: {
                    value: Ef.get(Cf._$Platform$_._$OS$_) || "unknown",
                    writable: !1
                },
                _$osVersion$_: {
                    value: Cf._$Platform$_._$OSVersion$_,
                    writable: !1
                },
                browser: {
                    value: Df.get(Cf._$Platform$_._$Browser$_) || "unknown",
                    writable: !1
                },
                _$browserVersion$_: {
                    value: Cf._$Platform$_._$BrowserVersion$_,
                    writable: !1
                },
                _$browserEngine$_: {
                    value: Af.get(Cf._$Platform$_._$BrowserEngine$_) || "unknown",
                    writable: !1
                }
            });
        }
        get _$exportType$_() {
            let t = _f._$GetExportType$_();
            return _f._$IsNWjs$_() ? t = "nwjs" : _f._$IsWindowsWebView2$_() ? t = "windows-webview2" : "cordova" === t ? t = "Android" === Cf._$Platform$_._$OS$_ ? "cordova-android" : "cordova-ios" : "playable-ad-single-file" !== t && "playable-ad-zip" !== t || (t = "playable-ad"), 
            t;
        }
        get _$renderer$_() {
            return _f._$GetCanvasManager$_()._$GetRendererString$_();
        }
        get _$rendererDetail$_() {
            return _f._$GetCanvasManager$_()._$GetRendererDetailString$_();
        }
        get _$canvasClientX$_() {
            return _f._$GetCanvasManager$_()._$GetCanvasClientX$_();
        }
        get _$canvasClientY$_() {
            return _f._$GetCanvasManager$_()._$GetCanvasClientY$_();
        }
        get _$canvasCssWidth$_() {
            return _f._$GetCanvasManager$_()._$GetCssWidth$_();
        }
        get _$canvasCssHeight$_() {
            return _f._$GetCanvasManager$_()._$GetCssHeight$_();
        }
        get _$canvasDeviceWidth$_() {
            return _f._$GetCanvasManager$_()._$GetDeviceWidth$_();
        }
        get _$canvasDeviceHeight$_() {
            return _f._$GetCanvasManager$_()._$GetDeviceHeight$_();
        }
        get devicePixelRatio() {
            return _f._$GetDevicePixelRatio$_();
        }
    };
}

{
    self._$C3$_;
    const Nf = self._$C3X$_;
    self._$IStorage$_ = class {
        constructor(t) {
            this._$_storage$_ = t._$_GetProjectStorage$_();
        }
        getItem(t) {
            return Nf._$RequireString$_(t), this._$_storage$_.getItem(t);
        }
        setItem(t, s) {
            return Nf._$RequireString$_(t), this._$_storage$_.setItem(t, s);
        }
        removeItem(t) {
            return Nf._$RequireString$_(t), this._$_storage$_.removeItem(t);
        }
        clear() {
            return this._$_storage$_.clear();
        }
        keys() {
            return this._$_storage$_.keys();
        }
    };
}

{
    const Lf = self._$C3$_, Of = (self._$C3X$_, Lf._$_GetInternalAPIToken$_());
    self._$IPlugin$_ = class {
        #t;
        constructor() {
            const t = Lf._$AddonManager$_._$_GetInitObject2$_(Of);
            this.#t = t, Object.defineProperties(this, {
                runtime: {
                    value: t._$GetRuntime$_()._$GetIRuntime$_(),
                    writable: !1
                },
                id: {
                    value: t._$GetID$_(),
                    writable: !1
                },
                _$isSingleGlobal$_: {
                    value: t._$IsSingleGlobal$_(),
                    writable: !1
                },
                _$isWorldType$_: {
                    value: t._$IsWorldType$_(),
                    writable: !1
                },
                _$isHTMLElementType$_: {
                    value: t._$IsHTMLElementType$_(),
                    writable: !1
                },
                _$isRotatable$_: {
                    value: t._$IsRotatable$_(),
                    writable: !1
                },
                _$hasEffects$_: {
                    value: t._$HasEffects$_(),
                    writable: !1
                },
                _$is3d$_: {
                    value: t._$Is3D$_(),
                    writable: !1
                },
                _$supportsHierarchies$_: {
                    value: t._$SupportsSceneGraph$_(),
                    writable: !1
                },
                _$supportsMesh$_: {
                    value: t._$SupportsMesh$_(),
                    writable: !1
                }
            }), t._$GetRuntime$_()._$_MapScriptInterface$_(this, t);
        }
        static _$getByConstructor$_(t) {
            if (!t) return null;
            const s = Lf._$AddonManager$_._$GetPluginByConstructorFunction$_(t);
            return s ? s._$GetIPlugin$_() : null;
        }
        _$getSingleGlobalObjectType$_() {
            return this.#t._$GetSingleGlobalObjectClass$_()._$GetIObjectClass$_();
        }
        _$getSingleGlobalInstance$_() {
            return this.#t._$GetSingleGlobalInstance$_()._$GetInterfaceClass$_();
        }
    };
}

{
    const Rf = self._$C3$_, Pf = self._$C3X$_, kf = Rf._$_GetInternalAPIToken$_();
    self._$IObjectClass$_ = class {
        #t;
        constructor() {
            const t = Rf._$AddonManager$_._$_GetInitObject2$_(kf);
            this.#t = t, Object.defineProperties(this, {
                name: {
                    value: t._$GetName$_(),
                    writable: !1
                },
                runtime: {
                    value: t._$GetRuntime$_()._$GetIRuntime$_(),
                    writable: !1
                },
                _$plugin$_: {
                    value: t._$GetPlugin$_()._$GetIPlugin$_(),
                    writable: !1
                }
            }), t._$GetRuntime$_()._$_MapScriptInterface$_(this, t);
        }
        addEventListener(t, s) {
            Pf._$RequireString$_(t), Pf._$RequireFunction$_(s), this.#t._$UserScriptDispatcher$_().addEventListener(t, s);
        }
        removeEventListener(t, s) {
            Pf._$RequireString$_(t), Pf._$RequireFunction$_(s), this.#t._$UserScriptDispatcher$_().removeEventListener(t, s);
        }
        _$getAllInstances$_() {
            return [ ...this._$instances$_() ];
        }
        _$getFirstInstance$_() {
            return Rf._$first$_(this._$instances$_());
        }
        _$getPickedInstances$_() {
            return [ ...this._$pickedInstances$_() ];
        }
        _$getFirstPickedInstance$_() {
            return Rf._$first$_(this._$pickedInstances$_());
        }
        _$getPairedInstance$_(t) {
            const s = this.#t, i = s._$GetRuntime$_()._$_UnwrapIInstance$_(t), e = s._$GetPairedInstance$_(i);
            return e ? e._$GetInterfaceClass$_() : null;
        }
        * _$instances$_() {
            for (const t of this.#t._$instancesIncludingPendingCreate$_()) yield t._$GetInterfaceClass$_();
        }
        * _$pickedInstances$_() {
            for (const t of this.#t._$GetCurrentSol$_()._$GetInstances$_()) yield t._$GetInterfaceClass$_();
        }
        _$setInstanceClass$_(t) {
            Pf._$RequireFunction$_(t);
            const s = this.#t;
            if (s._$GetInstanceCount$_() > 0) throw new Error("setInstanceClass() called too late, because instances have already been created - call in runOnStartup");
            s._$_SetUserScriptInstanceClass$_(t);
        }
        _$createInstance$_(t, s, i, e, n) {
            if (Pf._$RequireNumber$_(s), Pf._$RequireNumber$_(i), "number" != typeof t && "string" != typeof t) throw new TypeError("invalid layer parameter");
            const h = this.#t, r = h._$GetRuntime$_(), o = r._$GetMainRunningLayout$_()._$GetLayer$_(t);
            if (!o) throw new Error("invalid layer");
            const a = r._$CreateInstance$_(h, o, s, i, e, n);
            e && o._$SortAndAddInstancesByZIndex$_(a);
            const u = r._$GetEventSheetManager$_();
            return u._$BlockFlushingInstances$_(!0), a._$_TriggerOnCreatedOnSelfAndRelated$_(), 
            u._$BlockFlushingInstances$_(!1), u._$IsInEventEngine$_() || r._$GetLayoutManager$_()._$IsEndingLayout$_() || r._$FlushPendingInstances$_(), 
            a._$GetInterfaceClass$_();
        }
    };
}

{
    self._$C3$_;
    const Ff = self._$C3X$_, jf = new WeakMap, Bf = [ "above", "below", "top-sublayer", "bottom-sublayer" ];
    self._$ILayout$_ = class {
        constructor(t) {
            jf.set(this, t);
            const s = [], i = t._$GetEffectList$_(), e = i._$GetAllEffectTypes$_().length;
            for (let t = 0; t < e; ++t) s.push(new self._$IEffectInstance$_(i, t));
            Object.defineProperties(this, {
                name: {
                    value: t._$GetName$_(),
                    writable: !1
                },
                index: {
                    value: t._$GetIndex$_(),
                    writable: !1
                },
                effects: {
                    value: s,
                    writable: !1
                }
            });
        }
        addEventListener(t, s) {
            Ff._$RequireString$_(t), Ff._$RequireFunction$_(s), jf.get(this)._$UserScriptDispatcher$_().addEventListener(t, s);
        }
        removeEventListener(t, s) {
            Ff._$RequireString$_(t), Ff._$RequireFunction$_(s), jf.get(this)._$UserScriptDispatcher$_().removeEventListener(t, s);
        }
        get width() {
            return jf.get(this)._$GetWidth$_();
        }
        set width(t) {
            Ff._$RequireFiniteNumber$_(t), jf.get(this)._$SetWidth$_(t);
        }
        get height() {
            return jf.get(this)._$GetHeight$_();
        }
        set height(t) {
            Ff._$RequireFiniteNumber$_(t), jf.get(this)._$SetHeight$_(t);
        }
        _$setSize$_(t, s) {
            Ff._$RequireFiniteNumber$_(t), Ff._$RequireFiniteNumber$_(s);
            const i = jf.get(this);
            i._$SetWidth$_(t), i._$SetHeight$_(s);
        }
        getSize() {
            const t = jf.get(this);
            return [ t._$GetWidth$_(), t._$GetHeight$_() ];
        }
        set scale(t) {
            Ff._$RequireFiniteNumber$_(t), jf.get(this)._$SetScale$_(t);
        }
        get scale() {
            return jf.get(this)._$GetScale$_();
        }
        set angle(t) {
            Ff._$RequireFiniteNumber$_(t), jf.get(this)._$SetAngle$_(t);
        }
        get angle() {
            return jf.get(this)._$GetAngle$_();
        }
        set scrollX(t) {
            Ff._$RequireNumber$_(t), jf.get(this)._$SetScrollX$_(t);
        }
        get scrollX() {
            return jf.get(this)._$GetScrollX$_();
        }
        set scrollY(t) {
            Ff._$RequireNumber$_(t), jf.get(this)._$SetScrollY$_(t);
        }
        get scrollY() {
            return jf.get(this)._$GetScrollY$_();
        }
        scrollTo(t, s) {
            Ff._$RequireNumber$_(t), Ff._$RequireNumber$_(s);
            const i = jf.get(this);
            i._$SetScrollX$_(t), i._$SetScrollY$_(s);
        }
        _$getScrollPosition$_() {
            const t = jf.get(this);
            return [ t._$GetScrollX$_(), t._$GetScrollY$_() ];
        }
        _$getLayer$_(t) {
            const s = jf.get(this);
            let i = null;
            if ("number" != typeof t && "string" != typeof t) throw new TypeError("expected string or number");
            return i = s._$GetLayer$_(t), i ? i._$GetILayer$_() : null;
        }
        _$getAllLayers$_() {
            return jf.get(this)._$GetLayers$_().map((t => t._$GetILayer$_()));
        }
        * _$allLayers$_() {
            for (const t of jf.get(this)._$allLayers$_()) yield t._$GetILayer$_();
        }
        _$addLayer$_(t, s, i) {
            const e = jf.get(this), n = self._$ILayer$_;
            Ff._$RequireString$_(t), Ff._$RequireOptionalInstanceOf$_(s, n);
            const h = s ? e._$GetRuntime$_()._$_UnwrapScriptInterface$_(s) : null, r = Bf.indexOf(i);
            if (r < 0) throw new Error("invalid location");
            e._$AddLayer$_(t, h, r);
        }
        _$moveLayer$_(t, s, i) {
            const e = jf.get(this), n = e._$GetRuntime$_(), h = self._$ILayer$_;
            Ff._$RequireInstanceOf$_(t, h);
            const r = n._$_UnwrapScriptInterface$_(t);
            if (!r) throw new Error("invalid layer");
            Ff._$RequireOptionalInstanceOf$_(s, h);
            const o = s ? n._$_UnwrapScriptInterface$_(s) : null, a = Bf.indexOf(i);
            if (a < 0) throw new Error("invalid location");
            e._$MoveLayer$_(r, o, a);
        }
        _$removeLayer$_(t) {
            const s = jf.get(this), i = self._$ILayer$_;
            Ff._$RequireInstanceOf$_(t, i);
            const e = s._$GetRuntime$_()._$_UnwrapScriptInterface$_(t);
            if (!e) throw new Error("invalid layer");
            const n = e._$GetRuntime$_();
            s._$RemoveLayer$_(e), n._$GetEventSheetManager$_()._$IsInEventEngine$_() || n._$FlushPendingInstances$_();
        }
        _$removeAllDynamicLayers$_() {
            const t = jf.get(this), s = t._$GetRuntime$_();
            t._$RemoveAllDynamicLayers$_(), s._$GetEventSheetManager$_()._$IsInEventEngine$_() || s._$FlushPendingInstances$_();
        }
        _$setVanishingPoint$_(t, s) {
            Ff._$RequireFiniteNumber$_(t), Ff._$RequireFiniteNumber$_(s), jf.get(this)._$SetVanishingPointXY$_(t, s);
        }
        _$getVanishingPoint$_() {
            return jf.get(this)._$_GetVanishingPoint$_();
        }
        set _$projection$_(t) {
            Ff._$RequireString$_(t);
            const s = jf.get(this);
            if ("perspective" === t) s._$SetPerspectiveProjection$_(); else {
                if ("orthographic" !== t) throw new Error("invalid projection");
                s._$SetOrthographicProjection$_();
            }
        }
        get _$projection$_() {
            return jf.get(this)._$IsOrthographicProjection$_() ? "orthographic" : "perspective";
        }
    };
}

{
    const zf = self._$C3$_, Uf = self._$C3X$_, Wf = new WeakMap, Jf = new Map([ [ "normal", 0 ], [ "additive", 1 ], [ "copy", 3 ], [ "destination-over", 4 ], [ "source-in", 5 ], [ "destination-in", 6 ], [ "source-out", 7 ], [ "destination-out", 8 ], [ "source-atop", 9 ], [ "destination-atop", 10 ] ]), Qf = new Map([ ...Jf.entries() ].map((t => [ t[1], t[0] ]))), Yf = new Set([ "2d", "3d" ]), Vf = zf._$New$_(zf._$Color$_);
    self._$ILayer$_ = class {
        constructor(t) {
            Wf.set(this, t);
            const s = [], i = t._$GetEffectList$_(), e = i._$GetAllEffectTypes$_().length;
            for (let t = 0; t < e; ++t) s.push(new self._$IEffectInstance$_(i, t));
            Object.defineProperties(this, {
                name: {
                    value: t._$GetName$_(),
                    writable: !1
                },
                layout: {
                    value: t._$GetLayout$_()._$GetILayout$_(),
                    writable: !1
                },
                effects: {
                    value: s,
                    writable: !1
                }
            }), t._$GetRuntime$_()._$_MapScriptInterface$_(this, t);
        }
        get _$parentLayer$_() {
            const t = Wf.get(this)._$GetParentLayer$_();
            return t ? t._$GetILayer$_() : null;
        }
        * _$parentLayers$_() {
            for (const t of Wf.get(this)._$parentLayers$_()) yield t._$GetILayer$_();
        }
        * _$subLayers$_() {
            for (const t of Wf.get(this)._$GetSubLayers$_()) yield t._$GetILayer$_();
        }
        * _$allSubLayers$_() {
            for (const t of Wf.get(this)._$GetSubLayers$_()) for (const s of t._$selfAndAllSubLayers$_()) yield s._$GetILayer$_();
        }
        get index() {
            return Wf.get(this)._$GetIndex$_();
        }
        get isVisible() {
            return Wf.get(this)._$_IsVisibleFlagSet$_();
        }
        set isVisible(t) {
            Wf.get(this)._$SetVisible$_(t);
        }
        get _$isSelfAndParentsVisible$_() {
            return Wf.get(this)._$IsVisible$_();
        }
        get _$isInteractive$_() {
            return Wf.get(this)._$IsInteractive$_();
        }
        set _$isInteractive$_(t) {
            Wf.get(this)._$SetInteractive$_(t);
        }
        get _$isHTMLElementsLayer$_() {
            return Wf.get(this)._$IsHTMLElementsLayer$_();
        }
        set _$isHTMLElementsLayer$_(t) {
            Wf.get(this)._$SetIsHTMLElementsLayer$_(!!t);
        }
        get _$isSelfAndParentsInteractive$_() {
            return Wf.get(this)._$IsSelfAndParentsInteractive$_();
        }
        get opacity() {
            return Wf.get(this)._$GetOpacity$_();
        }
        set opacity(t) {
            t = zf._$clamp$_(+t, 0, 1), isNaN(t) || Wf.get(this)._$SetOpacity$_(t);
        }
        set scale(t) {
            Uf._$RequireFiniteNumber$_(t), Wf.get(this)._$SetOwnScale$_(t);
        }
        get scale() {
            return Wf.get(this)._$GetOwnScale$_();
        }
        set _$scaleRate$_(t) {
            Uf._$RequireFiniteNumber$_(t), Wf.get(this)._$SetScaleRate$_(t);
        }
        get _$scaleRate$_() {
            return Wf.get(this)._$GetScaleRate$_();
        }
        set angle(t) {
            Uf._$RequireFiniteNumber$_(t), Wf.get(this)._$SetAngle$_(t);
        }
        get angle() {
            return Wf.get(this)._$GetOwnAngle$_();
        }
        set _$parallaxX$_(t) {
            Uf._$RequireFiniteNumber$_(t), Wf.get(this)._$SetParallaxX$_(t);
        }
        get _$parallaxX$_() {
            return Wf.get(this)._$GetParallaxX$_();
        }
        set _$parallaxY$_(t) {
            Uf._$RequireFiniteNumber$_(t), Wf.get(this)._$SetParallaxY$_(t);
        }
        get _$parallaxY$_() {
            return Wf.get(this)._$GetParallaxY$_();
        }
        set _$zElevation$_(t) {
            Uf._$RequireFiniteNumber$_(t), Wf.get(this)._$SetZElevation$_(t);
        }
        get _$zElevation$_() {
            return Wf.get(this)._$GetZElevation$_();
        }
        set renderingMode(t) {
            if (!Yf.has(t)) throw TypeError("invalid rendering mode");
            Wf.get(this)._$SetRenderAs3D$_("3d" === t);
        }
        get renderingMode() {
            return Wf.get(this)._$IsRenderAs3D$_() ? "3d" : "2d";
        }
        set _$isTransparent$_(t) {
            Wf.get(this)._$SetTransparent$_(t);
        }
        get _$isTransparent$_() {
            return Wf.get(this)._$IsTransparent$_();
        }
        set _$isForceOwnTexture$_(t) {
            Wf.get(this)._$SetForceOwnTexture$_(t);
        }
        get _$isForceOwnTexture$_() {
            return Wf.get(this)._$IsForceOwnTexture$_();
        }
        set _$blendMode$_(t) {
            Uf._$RequireString$_(t);
            const s = Jf.get(t);
            if ("number" != typeof s) throw new Error("invalid blend mode");
            Wf.get(this)._$SetBlendMode$_(s);
        }
        get _$blendMode$_() {
            return Qf.get(Wf.get(this)._$GetBlendMode$_());
        }
        set backgroundColor(t) {
            if (Uf._$RequireArray$_(t), t.length < 3) throw new Error("expected 3 elements");
            Vf._$setRgb$_(t[0], t[1], t[2]);
            const s = Wf.get(this), i = s._$GetBackgroundColor$_();
            i._$equalsIgnoringAlpha$_(Vf) || (i._$copyRgb$_(Vf), s._$GetRuntime$_()._$UpdateRender$_());
        }
        get backgroundColor() {
            const t = Wf.get(this)._$GetBackgroundColor$_();
            return [ t._$getR$_(), t._$getG$_(), t._$getB$_() ];
        }
        set scrollX(t) {
            Uf._$RequireNumber$_(t);
            const s = Wf.get(this);
            s._$SetOwnScrollPositionEnabled$_(!0), s._$SetScrollX$_(t);
        }
        get scrollX() {
            return Wf.get(this)._$GetScrollX$_();
        }
        set scrollY(t) {
            Uf._$RequireNumber$_(t);
            const s = Wf.get(this);
            s._$SetOwnScrollPositionEnabled$_(!0), s._$SetScrollY$_(t);
        }
        get scrollY() {
            return Wf.get(this)._$GetScrollY$_();
        }
        scrollTo(t, s) {
            Uf._$RequireNumber$_(t), Uf._$RequireNumber$_(s);
            const i = Wf.get(this);
            i._$SetOwnScrollPositionEnabled$_(!0), i._$SetScrollX$_(t), i._$SetScrollY$_(s);
        }
        _$getScrollPosition$_() {
            const t = Wf.get(this);
            return [ t._$GetScrollX$_(), t._$GetScrollY$_() ];
        }
        _$restoreScrollPosition$_() {
            Wf.get(this)._$SetOwnScrollPositionEnabled$_(!1);
        }
        getViewport() {
            return Wf.get(this)._$GetViewport$_()._$toDOMRect$_();
        }
        _$cssPxToLayer$_(t, s, i = 0) {
            Uf._$RequireNumber$_(t), Uf._$RequireNumber$_(s), Uf._$RequireNumber$_(i);
            const e = Wf.get(this), n = e._$GetRuntime$_();
            return e._$CanvasCssToLayer$_(t - n._$GetCanvasClientX$_(), s - n._$GetCanvasClientY$_(), i);
        }
        _$layerToCssPx$_(t, s, i = 0) {
            Uf._$RequireNumber$_(t), Uf._$RequireNumber$_(s), Uf._$RequireNumber$_(i);
            const e = Wf.get(this), n = e._$GetRuntime$_(), [h, r] = e._$LayerToCanvasCss$_(t, s, i);
            return [ h + n._$GetCanvasClientX$_(), r + n._$GetCanvasClientY$_() ];
        }
        _$drawSurfaceToLayer$_(t, s, i = 0) {
            return Uf._$RequireNumber$_(t), Uf._$RequireNumber$_(s), Uf._$RequireNumber$_(i), 
            Wf.get(this)._$DrawSurfaceToLayer$_(t, s, i);
        }
        _$layerToDrawSurface$_(t, s, i = 0) {
            return Uf._$RequireNumber$_(t), Uf._$RequireNumber$_(s), Uf._$RequireNumber$_(i), 
            Wf.get(this)._$LayerToDrawSurface$_(t, s, i);
        }
        get _$renderScale$_() {
            return Wf.get(this)._$GetRenderScale$_();
        }
    };
}

{
    let Hf = function(t) {
        let s = Zf.get(t);
        return s || (s = qf._$New$_(qf.Event._$Dispatcher$_), Zf.set(t, s), s);
    };
    0;
    const qf = self._$C3$_, Xf = self._$C3X$_, Zf = new WeakMap, Kf = qf._$_GetInternalAPIToken$_();
    self._$IInstance$_ = class {
        #t;
        constructor() {
            const t = qf._$AddonManager$_._$_GetInitObject2$_(Kf);
            this.#t = t;
            const s = {
                runtime: {
                    value: t._$GetRuntime$_()._$GetIRuntime$_(),
                    writable: !1
                },
                objectType: {
                    value: t._$GetObjectClass$_()._$GetIObjectClass$_(),
                    writable: !1
                },
                _$plugin$_: {
                    value: t._$GetPlugin$_()._$GetIPlugin$_(),
                    writable: !1
                }
            };
            t._$_GetInstVarsScriptDescriptor$_(s), t._$_GetBehaviorsScriptDescriptor$_(s), Object.defineProperties(this, s), 
            t._$GetRuntime$_()._$_MapScriptInterface$_(this, t);
        }
        static _$_GetInitInst$_() {
            return qf._$AddonManager$_._$_GetInitObject$_();
        }
        _$_release$_() {
            const t = Zf.get(this);
            t && (t._$Release$_(), Zf.delete(this));
        }
        addEventListener(t, s, i) {
            Xf._$RequireString$_(t), Xf._$RequireFunction$_(s), Hf(this).addEventListener(t, s, i);
        }
        removeEventListener(t, s, i) {
            Xf._$RequireString$_(t), Xf._$RequireFunction$_(s), Hf(this).removeEventListener(t, s, i);
        }
        dispatchEvent(t) {
            Hf(this).dispatchEvent(t);
        }
        destroy() {
            const t = this.#t, s = t._$GetRuntime$_();
            s._$DestroyInstance$_(t), s._$GetEventSheetManager$_()._$IsInEventEngine$_() || s._$GetLayoutManager$_()._$IsEndingLayout$_() || s._$GetEventSheetManager$_()._$IsFlushingBlocked$_() || s._$FlushPendingInstances$_();
        }
        _$getOtherContainerInstances$_() {
            const t = this.#t._$GetSiblings$_();
            return t ? t.map((t => t._$GetInterfaceClass$_())) : [];
        }
        * _$otherContainerInstances$_() {
            const t = this.#t;
            if (t._$IsInContainer$_()) for (const s of t._$siblings$_()) yield s._$GetInterfaceClass$_();
        }
        get uid() {
            return this.#t._$GetUID$_();
        }
        get _$iid$_() {
            return this.#t._$GetIID$_();
        }
        get _$templateName$_() {
            return this.#t._$GetTemplateName$_();
        }
        set _$timeScale$_(t) {
            Xf._$RequireFiniteNumber$_(t), this.#t._$SetTimeScale$_(t);
        }
        get _$timeScale$_() {
            return this.#t._$GetActiveTimeScale$_();
        }
        _$restoreTimeScale$_() {
            this.#t._$RestoreTimeScale$_();
        }
        get _$dt$_() {
            const t = this.#t;
            return t._$GetRuntime$_()._$GetDt$_(t);
        }
        _$hasTags$_(...t) {
            Xf._$RequireArray$_(t);
            const s = new Set(t), i = this.#t._$GetTagsSet$_();
            return s.isSubsetOf(i);
        }
        _$setAllTags$_(t) {
            Xf._$RequireInstanceOf$_(t, Set), this.#t._$SetTagsSet$_(t);
        }
        _$getAllTags$_() {
            return new Set(this.#t._$GetTagsSet$_());
        }
        signal(t) {
            Xf._$RequireString$_(t);
            const s = this.#t;
            s._$GetRuntime$_()._$GetEventSheetManager$_()._$InstanceSignal$_(s, t);
        }
        _$waitForSignal$_(t) {
            Xf._$RequireString$_(t);
            const s = this.#t;
            return s._$GetRuntime$_()._$GetEventSheetManager$_()._$WaitForInstanceSignal$_(s, t);
        }
    };
}

{
    const $f = self._$C3$_, td = self._$C3X$_, sd = $f._$_GetInternalAPIToken$_();
    self._$ISDKInstanceBase$_ = class extends self._$IInstance$_ {
        #t;
        #s=!1;
        #i=null;
        #e=!1;
        #n=null;
        #h;
        #r;
        constructor(t) {
            super(), this.#t = $f._$AddonManager$_._$_GetInitObject2$_(sd), this.#s = !1, this.#i = null, 
            this.#e = !1, this.#n = null, this.#h = t?._$domComponentId$_, this.#r = t?._$wrapperComponentId$_;
        }
        _$_release$_() {
            this._$_setTicking$_(!1), this._$_setTicking2$_(!1), super._$_release$_();
        }
        _$_getInitProperties$_() {
            return $f._$AddonManager$_._$_GetInitProperties$_();
        }
        _$_trigger$_(t) {
            const s = this.#t;
            s._$GetRuntime$_()._$Trigger$_(t, s);
        }
        _$_triggerAsync$_(t) {
            const s = this.#t;
            return s._$GetRuntime$_()._$TriggerAsync$_(t, s);
        }
        _$_addDOMMessageHandler$_(t, s) {
            if (td._$RequireString$_(t), td._$RequireFunction$_(s), !this.#h) throw new Error("no DOM component id set");
            this.#t._$GetRuntime$_()._$AddDOMComponentMessageHandler$_(this.#h, t, s);
        }
        _$_addDOMMessageHandlers$_(t) {
            td._$RequireArray$_(t);
            for (const [s, i] of t) this._$_addDOMMessageHandler$_(s, i);
        }
        _$_postToDOM$_(t, s) {
            if (td._$RequireString$_(t), !this.#h) throw new Error("no DOM component id set");
            this.#t._$GetRuntime$_()._$PostComponentMessageToDOM$_(this.#h, t, s);
        }
        _$_postToDOMAsync$_(t, s) {
            if (td._$RequireString$_(t), !this.#h) throw new Error("no DOM component id set");
            return this.#t._$GetRuntime$_()._$PostComponentMessageToDOMAsync$_(this.#h, t, s);
        }
        _$_postToDOMMaybeSync$_(t, s) {
            if (!this.#t._$GetRuntime$_()._$IsInWorker$_()) return window.c3_runtimeInterface._OnMessageFromRuntime({
                type: "event",
                component: this.#h,
                handler: t,
                data: s,
                responseId: null
            });
            this._$_postToDOM$_(t, s);
        }
        _$_setTicking$_(t) {
            if (t = !!t, this.#s === t) return;
            this.#s = t;
            const s = this.#t._$GetRuntime$_();
            if (t) {
                if (!this.#i) if (this.#t._$GetRuntime$_()._$IsDebug$_()) {
                    const t = globalThis._$C3Debugger$_, s = this._$plugin$_;
                    this.#i = () => {
                        const i = performance.now();
                        this._$_tick$_(), t._$AddIndividualPluginTickTime$_(s, performance.now() - i);
                    };
                } else this.#i = () => this._$_tick$_();
                s._$Dispatcher$_().addEventListener("tick", this.#i);
            } else s._$Dispatcher$_().removeEventListener("tick", this.#i);
        }
        _$_isTicking$_() {
            return this.#s;
        }
        _$_tick$_() {}
        _$_setTicking2$_(t) {
            if (t = !!t, this.#e === t) return;
            this.#e = t;
            const s = this.#t._$GetRuntime$_();
            if (t) {
                if (!this.#n) if (this.#t._$GetRuntime$_()._$IsDebug$_()) {
                    const t = globalThis._$C3Debugger$_, s = this._$plugin$_;
                    this.#n = () => {
                        const i = performance.now();
                        this._$_tick2$_(), t._$AddIndividualPluginTickTime$_(s, performance.now() - i);
                    };
                } else this.#n = () => this._$_tick2$_();
                s._$Dispatcher$_().addEventListener("tick2", this.#n);
            } else s._$Dispatcher$_().removeEventListener("tick2", this.#n);
        }
        _$_isTicking2$_() {
            return this.#e;
        }
        _$_tick2$_() {}
        _$_getDebuggerProperties$_() {
            return [];
        }
        _$_saveToJson$_() {
            return null;
        }
        _$_loadFromJson$_(t) {}
        _$_isWrapperExtensionAvailable$_() {
            if (!this.#r) throw new Error("no wrapper component id set");
            return this.#t._$GetRuntime$_()._$HasWrapperComponentId$_(this.#r);
        }
        _$_addWrapperExtensionMessageHandler$_(t, s) {
            if (td._$RequireString$_(t), td._$RequireFunction$_(s), !this.#r) throw new Error("no wrapper component id set");
            this.#t._$GetRuntime$_()._$AddWrapperExtensionMessageHandler$_(this.#r, t, s);
        }
        _$_addWrapperMessageHandlers$_(t) {
            td._$RequireArray$_(t);
            for (const [s, i] of t) this._$_addWrapperExtensionMessageHandler$_(s, i);
        }
        _$_sendWrapperExtensionMessage$_(t, s) {
            if (!this.#r) throw new Error("no wrapper component id set");
            this.runtime._$sdk$_._$sendWrapperExtensionMessage$_(this.#r, t, s);
        }
        _$_sendWrapperExtensionMessageAsync$_(t, s) {
            if (!this.#r) throw new Error("no wrapper component id set");
            return this.runtime._$sdk$_._$sendWrapperExtensionMessageAsync$_(this.#r, t, s);
        }
    };
}

{
    let id = function(t) {
        return class s extends t {
            #t;
            #s;
            constructor(t) {
                super(t);
                const s = ed._$AddonManager$_._$_GetInitObject2$_(ud), i = s._$GetWorldInfo$_();
                this.#t = s, this.#s = i, ad.set(this, s);
                const e = [], n = i._$GetInstanceEffectList$_();
                if (n) {
                    const t = i._$GetObjectClass$_()._$GetEffectList$_()._$GetAllEffectTypes$_().length;
                    for (let s = 0; s < t; ++s) e.push(new self._$IEffectInstance$_(n, s));
                }
                const h = {
                    effects: {
                        value: e,
                        writable: !1
                    }
                };
                Object.defineProperties(this, h);
            }
            get layout() {
                return this.#s._$GetLayout$_()._$GetILayout$_();
            }
            get _$layer$_() {
                return this.#s._$GetLayer$_()._$GetILayer$_();
            }
            get x() {
                return this.#s._$GetX$_();
            }
            set x(t) {
                t = +t;
                const s = this.#s;
                isNaN(t) || s._$GetX$_() === t || (s._$SetX$_(t), s._$SetBboxChanged$_());
            }
            get y() {
                return this.#s._$GetY$_();
            }
            set y(t) {
                t = +t;
                const s = this.#s;
                isNaN(t) || s._$GetY$_() === t || (s._$SetY$_(t), s._$SetBboxChanged$_());
            }
            setPosition(t, s) {
                t = +t, s = +s;
                const i = this.#s;
                isNaN(t) || isNaN(s) || i._$GetX$_() === t && i._$GetY$_() === s || (i._$SetXY$_(t, s), 
                i._$SetBboxChanged$_());
            }
            _$getPosition$_() {
                const t = this.#s;
                return [ t._$GetX$_(), t._$GetY$_() ];
            }
            offsetPosition(t, s) {
                if (t = +t, s = +s, isNaN(t) || isNaN(s) || 0 === t && 0 === s) return;
                const i = this.#s;
                i._$OffsetXY$_(t, s), i._$SetBboxChanged$_();
            }
            set _$originX$_(t) {
                t = +t;
                const s = this.#s;
                isNaN(t) || s._$GetOriginX$_() === t || (s._$SetOriginX$_(t), s._$SetBboxChanged$_());
            }
            get _$originX$_() {
                return this.#s._$GetOriginX$_();
            }
            set _$originY$_(t) {
                t = +t;
                const s = this.#s;
                isNaN(t) || s._$GetOriginY$_() === t || (s._$SetOriginY$_(t), s._$SetBboxChanged$_());
            }
            get _$originY$_() {
                return this.#s._$GetOriginY$_();
            }
            _$setOrigin$_(t, s) {
                t = +t, s = +s;
                const i = this.#s;
                isNaN(t) || isNaN(s) || i._$GetOriginX$_() === t && i._$GetOriginY$_() === s || (i._$SetOriginX$_(t), 
                i._$SetOriginY$_(s), i._$SetBboxChanged$_());
            }
            _$getOrigin$_() {
                const t = this.#s;
                return [ t._$GetOriginX$_(), t._$GetOriginY$_() ];
            }
            get _$zElevation$_() {
                return this.#s._$GetZElevation$_();
            }
            set _$zElevation$_(t) {
                t = +t;
                const s = this.#t, i = this.#s;
                isNaN(t) || i._$GetZElevation$_() === t || (i._$SetZElevation$_(t), s._$GetRuntime$_()._$UpdateRender$_());
            }
            get _$totalZElevation$_() {
                return this.#s._$GetTotalZElevation$_();
            }
            get width() {
                return this.#s._$GetWidth$_();
            }
            set width(t) {
                t = +t;
                const s = this.#s;
                isNaN(t) || s._$GetWidth$_() === t || (s._$SetWidth$_(t), s._$SetBboxChanged$_());
            }
            get height() {
                return this.#s._$GetHeight$_();
            }
            set height(t) {
                t = +t;
                const s = this.#s;
                isNaN(t) || s._$GetHeight$_() === t || (s._$SetHeight$_(t), s._$SetBboxChanged$_());
            }
            _$setSize$_(t, s) {
                t = +t, s = +s;
                const i = this.#s;
                isNaN(t) || isNaN(s) || i._$GetWidth$_() === t && i._$GetHeight$_() === s || (i._$SetSize$_(t, s), 
                i._$SetBboxChanged$_());
            }
            getSize() {
                const t = this.#s;
                return [ t._$GetWidth$_(), t._$GetHeight$_() ];
            }
            get angle() {
                return this.#s._$GetAngle$_();
            }
            set angle(t) {
                t = ed._$clampAngle$_(+t);
                const s = this.#s;
                isNaN(t) || s._$GetAngle$_() === t || (s._$SetAngle$_(t), s._$SetBboxChanged$_());
            }
            get _$angleDegrees$_() {
                return ed._$toDegrees$_(this.angle);
            }
            set _$angleDegrees$_(t) {
                this.angle = ed._$toRadians$_(t);
            }
            _$getBoundingBox$_(t) {
                return t ? (this.#s._$CalculateBbox$_(rd, od, !1), rd._$toDOMRect$_()) : this.#s._$GetBoundingBox$_()._$toDOMRect$_();
            }
            _$getBoundingQuad$_(t) {
                return t ? (this.#s._$CalculateBbox$_(rd, od, !1), od._$toDOMQuad$_()) : this.#s._$GetBoundingQuad$_()._$toDOMQuad$_();
            }
            _$isOnScreen$_() {
                return this.#s._$IsInViewport2$_();
            }
            get isVisible() {
                return this.#s._$IsVisible$_();
            }
            set isVisible(t) {
                t = !!t;
                const s = this.#t, i = this.#s;
                i._$IsVisible$_() !== t && (i._$SetVisible$_(t), s._$GetRuntime$_()._$UpdateRender$_());
            }
            get opacity() {
                return this.#s._$GetOpacity$_();
            }
            set opacity(t) {
                t = ed._$clamp$_(+t, 0, 1);
                const s = this.#t, i = this.#s;
                isNaN(t) || i._$GetOpacity$_() === t || (i._$SetOpacity$_(t), s._$GetRuntime$_()._$UpdateRender$_());
            }
            set _$colorRgb$_(t) {
                if (nd._$RequireArray$_(t), t.length < 3) throw new Error("expected 3 elements");
                fd._$setRgb$_(t[0], t[1], t[2]);
                const s = this.#t, i = this.#s;
                i._$GetUnpremultipliedColor$_()._$equalsIgnoringAlpha$_(fd) || (i._$SetUnpremultipliedColor$_(fd), 
                s._$GetRuntime$_()._$UpdateRender$_());
            }
            get _$colorRgb$_() {
                const t = this.#s._$GetUnpremultipliedColor$_();
                return [ t._$getR$_(), t._$getG$_(), t._$getB$_() ];
            }
            set _$blendMode$_(t) {
                nd._$RequireString$_(t);
                const s = ld.get(t);
                if ("number" != typeof s) throw new Error("invalid blend mode");
                const i = this.#t;
                this.#s._$SetBlendMode$_(s), i._$GetRuntime$_()._$UpdateRender$_();
            }
            get _$blendMode$_() {
                return cd.get(this.#s._$GetBlendMode$_());
            }
            _$moveToTop$_() {
                this.#s._$ZOrderMoveToTop$_();
            }
            _$moveToBottom$_() {
                this.#s._$ZOrderMoveToBottom$_();
            }
            _$moveToLayer$_(t) {
                nd._$RequireInstanceOf$_(t, hd);
                const s = this.#t, i = s._$GetRuntime$_()._$_UnwrapScriptInterface$_(t);
                if (!i) throw new Error("invalid layer");
                s._$GetWorldInfo$_()._$ZOrderMoveToLayer$_(i);
            }
            _$moveAdjacentToInstance$_(t, i) {
                nd._$RequireInstanceOf$_(t, s), this.#s._$ZOrderMoveAdjacentToInstance$_(ad.get(t), i);
            }
            get zIndex() {
                return this.#s._$GetZIndex$_();
            }
            get _$isCollisionEnabled$_() {
                return this.#s._$IsCollisionEnabled$_();
            }
            set _$isCollisionEnabled$_(t) {
                this.#s._$SetCollisionEnabled$_(!!t);
            }
            _$containsPoint$_(t, s) {
                return nd._$RequireNumber$_(t), nd._$RequireNumber$_(s), this.#s._$ContainsPoint$_(+t, +s);
            }
            _$testOverlap$_(t) {
                nd._$RequireInstanceOf$_(t, s);
                const i = this.#t, e = ad.get(t);
                return i._$GetRuntime$_()._$GetCollisionEngine$_()._$TestOverlap$_(i, e);
            }
            _$testOverlapSolid$_() {
                const t = this.#t, s = t._$GetRuntime$_()._$GetCollisionEngine$_()._$TestOverlapSolid$_(t);
                return s ? s._$GetInterfaceClass$_() : null;
            }
            getParent() {
                const t = this.#t._$GetParent$_();
                return t ? t._$GetInterfaceClass$_() : null;
            }
            _$getTopParent$_() {
                const t = this.#t._$GetTopParent$_();
                return t ? t._$GetInterfaceClass$_() : null;
            }
            * _$parents$_() {
                for (const t of this.#t._$parents$_()) yield t._$GetInterfaceClass$_();
            }
            _$getChildCount$_() {
                return this.#t._$GetChildCount$_();
            }
            _$getChildAt$_(t) {
                const s = this.#t._$GetChildAt$_(t);
                return s ? s._$GetInterfaceClass$_() : null;
            }
            * children() {
                for (const t of this.#t.children()) yield t._$GetInterfaceClass$_();
            }
            * _$allChildren$_() {
                for (const t of this.#t._$allChildren$_()) yield t._$GetInterfaceClass$_();
            }
            _$addChild$_(t, i) {
                nd._$RequireInstanceOf$_(t, s), nd._$RequireOptionalObject$_(i), i || (i = {});
                const e = this.#t, n = ad.get(t);
                e._$AddChild$_(n, i);
            }
            removeChild(t) {
                nd._$RequireInstanceOf$_(t, s);
                const i = this.#t, e = ad.get(t);
                i._$RemoveChild$_(e);
            }
            _$removeFromParent$_() {
                const t = this.#t;
                t._$HasParent$_() && t._$GetParent$_()._$RemoveChild$_(t);
            }
            _$getHierarchyOpts$_() {
                const t = this.#s;
                return {
                    _$transformX$_: t._$GetTransformWithParentX$_(),
                    _$transformY$_: t._$GetTransformWithParentY$_(),
                    _$transformWidth$_: t._$GetTransformWithParentWidth$_(),
                    _$transformHeight$_: t._$GetTransformWithParentHeight$_(),
                    _$transformAngle$_: t._$GetTransformWithParentAngle$_(),
                    _$transformZElevation$_: t._$GetTransformWithParentZElevation$_(),
                    _$transformOpacity$_: t._$GetTransformWithParentOpacity$_(),
                    _$transformVisibility$_: t._$GetTransformWithParentVisibility$_(),
                    _$destroyWithParent$_: t._$GetDestroyWithParent$_()
                };
            }
            _$createMesh$_(t, s) {
                nd._$RequireFiniteNumber$_(t), nd._$RequireFiniteNumber$_(s), this.#s._$CreateMesh$_(t, s);
            }
            _$releaseMesh$_() {
                const t = this.#s;
                t._$ReleaseMesh$_(), t._$SetBboxChanged$_();
            }
            _$setMeshPoint$_(t, s, i) {
                nd._$RequireFiniteNumber$_(t), nd._$RequireFiniteNumber$_(s), nd._$RequireObject$_(i);
                const e = this.#s;
                e._$SetMeshPoint$_(t, s, i) && e._$SetBboxChanged$_();
            }
            _$getMeshPoint$_(t, s) {
                let i = NaN, e = NaN, n = NaN, h = NaN, r = NaN;
                const o = this.#s;
                if (o._$HasMesh$_()) {
                    const a = o._$GetSourceMesh$_()._$GetMeshPointAt$_(t, s);
                    null !== a && (i = a._$GetX$_(), e = a._$GetY$_(), n = a._$GetZElevation$_(), h = a._$GetU$_(), 
                    r = a._$GetV$_());
                }
                return {
                    x: i,
                    y: e,
                    _$zElevation$_: n,
                    _$u$_: h,
                    _$v$_: r
                };
            }
            _$getMeshSize$_() {
                const t = this.#s;
                if (!t._$HasMesh$_()) return [ 0, 0 ];
                const s = t._$GetSourceMesh$_();
                return [ s._$GetHSize$_(), s._$GetVSize$_() ];
            }
        };
    };
    0;
    const ed = self._$C3$_, nd = self._$C3X$_, hd = (self._$IInstance$_, self._$ILayer$_), rd = ed._$New$_(ed.Rect), od = ed._$New$_(ed._$Quad$_), ad = new WeakMap, ud = ed._$_GetInternalAPIToken$_(), ld = new Map([ [ "normal", 0 ], [ "additive", 1 ], [ "copy", 3 ], [ "destination-over", 4 ], [ "source-in", 5 ], [ "destination-in", 6 ], [ "source-out", 7 ], [ "destination-out", 8 ], [ "source-atop", 9 ], [ "destination-atop", 10 ] ]), cd = new Map([ ...ld.entries() ].map((t => [ t[1], t[0] ]))), fd = ed._$New$_(ed._$Color$_);
    self._$IWorldInstance$_ = id(self._$IInstance$_), self._$IWorldInstanceSDKBase$_ = id(self._$ISDKInstanceBase$_);
}

{
    self._$C3$_;
    const dd = self._$C3X$_;
    self._$IDOMInstance$_ = class extends self._$IWorldInstance$_ {
        #t;
        constructor() {
            super(), this.#t = self._$IInstance$_._$_GetInitInst$_();
        }
        _$getElement$_() {
            return this.#t._$GetSdkInstance$_()._$_GetElementInDOMMode$_();
        }
        focus() {
            this.#t._$GetSdkInstance$_()._$FocusElement$_();
        }
        blur() {
            this.#t._$GetSdkInstance$_()._$BlurElement$_();
        }
        _$setCssStyle$_(t, s) {
            dd._$RequireString$_(t), this.#t._$GetSdkInstance$_()._$SetElementCSSStyle$_(t, s);
        }
    };
}

{
    let pd = function(t) {
        let s = yd.get(t);
        return s || (s = md._$New$_(md.Event._$Dispatcher$_), yd.set(t, s), s);
    };
    0;
    const md = self._$C3$_, gd = self._$C3X$_, yd = new WeakMap, Md = md._$_GetInternalAPIToken$_();
    self._$IBehaviorInstance$_ = class {
        #t;
        constructor() {
            const t = md._$AddonManager$_._$_GetInitObject2$_(Md);
            this.#t = t;
            const s = {
                runtime: {
                    value: t._$GetRuntime$_()._$GetIRuntime$_(),
                    writable: !1
                },
                behavior: {
                    value: t._$GetBehavior$_()._$GetIBehavior$_(),
                    writable: !1
                },
                _$behaviorType$_: {
                    value: t._$GetBehaviorType$_()._$GetIBehaviorType$_(),
                    writable: !1
                }
            };
            Object.defineProperties(this, s), t._$GetRuntime$_()._$_MapScriptInterface$_(this, t);
        }
        static _$_GetInitInst$_() {
            return md._$AddonManager$_._$_GetInitObject$_();
        }
        get _$instance$_() {
            return this.#t._$GetObjectInstance$_()._$GetInterfaceClass$_();
        }
        _$_release$_() {
            const t = yd.get(this);
            t && (t._$Release$_(), yd.delete(this));
        }
        addEventListener(t, s, i) {
            gd._$RequireString$_(t), gd._$RequireFunction$_(s), pd(this).addEventListener(t, s, i);
        }
        removeEventListener(t, s, i) {
            gd._$RequireString$_(t), gd._$RequireFunction$_(s), pd(this).removeEventListener(t, s, i);
        }
        dispatchEvent(t) {
            pd(this).dispatchEvent(t);
        }
    };
}

{
    const wd = self._$C3$_, Sd = (self._$C3X$_, wd._$_GetInternalAPIToken$_());
    self._$IBehaviorType$_ = class {
        constructor() {
            const t = wd._$AddonManager$_._$_GetInitObject2$_(Sd), s = {
                runtime: {
                    value: t._$GetRuntime$_()._$GetIRuntime$_(),
                    writable: !1
                },
                behavior: {
                    value: t._$GetBehavior$_()._$GetIBehavior$_(),
                    writable: !1
                },
                name: {
                    value: t._$GetName$_(),
                    writable: !1
                }
            };
            Object.defineProperties(this, s);
        }
    };
}

{
    const bd = self._$C3$_, Td = (self._$C3X$_, bd._$_GetInternalAPIToken$_());
    self._$IBehavior$_ = class {
        #s;
        constructor() {
            const t = bd._$AddonManager$_._$_GetInitObject2$_(Td);
            this.#s = t;
            const s = {
                runtime: {
                    value: t._$GetRuntime$_()._$GetIRuntime$_(),
                    writable: !1
                },
                id: {
                    value: t._$GetID$_(),
                    writable: !1
                }
            };
            Object.defineProperties(this, s), t._$GetRuntime$_()._$_MapScriptInterface$_(this, t);
        }
        _$getAllInstances$_() {
            return this.#s._$GetInstances$_().map((t => t._$GetInterfaceClass$_()));
        }
        static _$getByConstructor$_(t) {
            if (!t) return null;
            const s = bd._$AddonManager$_._$GetBehaviorByConstructorFunction$_(t);
            return s ? s._$GetIBehavior$_() : null;
        }
    };
}

{
    const vd = self._$C3$_, xd = self._$C3X$_, Id = vd._$New$_(vd._$Color$_);
    self._$IEffectInstance$_ = class {
        #t;
        constructor(t, s) {
            this.#t = t;
            const i = {
                index: {
                    value: s,
                    writable: !1
                }
            };
            Object.defineProperties(this, i);
        }
        get name() {
            return this.#t._$GetAllEffectTypes$_()[this.index]._$GetName$_();
        }
        get isActive() {
            return this.#t._$IsEffectIndexActive$_(this.index);
        }
        set isActive(t) {
            t = !!t;
            const s = this.#t;
            s._$IsEffectIndexActive$_(this.index) !== t && (s._$SetEffectIndexActive$_(this.index, t), 
            s._$UpdateActiveEffects$_(), s._$GetRuntime$_()._$UpdateRender$_());
        }
        setParameter(t, s) {
            xd._$RequireFiniteNumber$_(t), t = Math.floor(+t);
            const i = this.#t, e = i._$GetEffectParameter$_(this.index, t);
            if (null === e) throw new RangeError("invalid index");
            if (e instanceof vd._$Color$_) {
                if (!Array.isArray(s) || s.length < 3) throw new TypeError("expected array with 3 elements");
                Id._$setRgb$_(s[0], s[1], s[2]), s = Id;
            } else if ("number" != typeof s) throw new TypeError("expected number");
            i._$SetEffectParameter$_(this.index, t, s) && i._$IsEffectIndexActive$_(this.index) && i._$GetRuntime$_()._$UpdateRender$_();
        }
        getParameter(t) {
            xd._$RequireFiniteNumber$_(t), t = Math.floor(+t);
            const s = this.#t._$GetEffectParameter$_(this.index, t);
            if (null === s) throw new RangeError("invalid index");
            return s instanceof vd._$Color$_ ? [ s._$getR$_(), s._$getG$_(), s._$getB$_() ] : s;
        }
    };
}

self._$C3$_, self._$C3X$_;

self._$IAnimation$_ = class {
    #t;
    constructor(t) {
        this.#t = t, Object.defineProperties(this, {
            name: {
                value: t._$GetName$_(),
                writable: !1
            }
        });
    }
    get speed() {
        return this.#t._$GetSpeed$_();
    }
    get _$isLooping$_() {
        return this.#t._$IsLooping$_();
    }
    get _$repeatCount$_() {
        return this.#t._$GetRepeatCount$_();
    }
    get _$repeatTo$_() {
        return this.#t._$GetRepeatTo$_();
    }
    get _$isPingPong$_() {
        return this.#t._$IsPingPong$_();
    }
    get frameCount() {
        return this.#t._$GetFrameCount$_();
    }
    _$getFrames$_() {
        return this.#t._$GetFrames$_().map((t => t._$GetIAnimationFrame$_()));
    }
    * frames() {
        for (const t of this.#t._$GetFrames$_()) yield t._$GetIAnimationFrame$_();
    }
};

self._$C3$_, self._$C3X$_;

self._$IImageInfo$_ = class {
    #s;
    constructor(t) {
        this.#s = t;
    }
    static _$_Unwrap$_(t) {
        return t.#s;
    }
    get width() {
        return this.#s._$GetWidth$_();
    }
    get height() {
        return this.#s._$GetHeight$_();
    }
    getSize() {
        const t = this.#s;
        return [ t._$GetWidth$_(), t._$GetHeight$_() ];
    }
    _$getTexture$_(t) {
        return t._$getTextureForImageInfo$_(this);
    }
    _$getTexRect$_() {
        return this.#s._$GetTexRect$_()._$toDOMRect$_();
    }
};

{
    self._$C3$_;
    const Gd = self._$C3X$_;
    self._$IAnimationFrame$_ = class extends self._$IImageInfo$_ {
        #s;
        constructor(t) {
            super(t._$GetImageInfo$_()), this.#s = t, Object.defineProperties(this, {
                duration: {
                    value: t._$GetDuration$_(),
                    writable: !1
                },
                _$originX$_: {
                    value: t._$GetOriginX$_(),
                    writable: !1
                },
                _$originY$_: {
                    value: t._$GetOriginY$_(),
                    writable: !1
                }
            });
        }
        _$getOrigin$_() {
            const t = this.#s;
            return [ t._$GetOriginX$_(), t._$GetOriginY$_() ];
        }
        _$getImagePointCount$_() {
            return this.#s._$GetImagePointCount$_();
        }
        _$getImagePointX$_(t) {
            return this._$getImagePoint$_(t)[0];
        }
        _$getImagePointY$_(t) {
            return this._$getImagePoint$_(t)[1];
        }
        _$getImagePoint$_(t) {
            const s = this.#s;
            let i = null;
            if ("number" == typeof t) i = s._$GetImagePointByIndex$_(Math.floor(t)); else {
                if ("string" != typeof t) throw new TypeError("expected string or number");
                i = s._$GetImagePointByName$_(t);
            }
            return i ? [ i._$GetX$_(), i._$GetY$_() ] : this._$getOrigin$_();
        }
        _$getPolyPointCount$_() {
            const t = this.#s._$GetCollisionPoly$_();
            return t ? t._$pointCount$_() : 0;
        }
        _$getPolyPointX$_(t) {
            return this._$getPolyPoint$_(t)[0];
        }
        _$getPolyPointY$_(t) {
            return this._$getPolyPoint$_(t)[1];
        }
        _$getPolyPoint$_(t) {
            Gd._$RequireFiniteNumber$_(t), t = Math.floor(t);
            const s = this.#s._$GetCollisionPoly$_();
            if (!s || t < 0 || t >= s._$pointCount$_()) return [ 0, 0 ];
            const i = s._$pointsArr$_();
            return [ i[2 * t], i[2 * t + 1] ];
        }
        get tag() {
            return this.#s._$GetTag$_();
        }
    };
}

{
    let Cd = function(t) {
        const s = Ed.get(t);
        if (s._$IsReleased$_()) throw new Error("timeline/tween was released and is no longer valid");
        return s;
    };
    0;
    self._$C3$_;
    const _d = self._$C3X$_, Ed = new WeakMap;
    self._$ITimelineStateBase$_ = class {
        constructor(t) {
            Ed.set(this, t), t._$GetRuntime$_()._$_MapScriptInterface$_(this, t);
        }
        pause() {
            Cd(this)._$Stop$_();
        }
        resume() {
            Cd(this)._$Resume$_();
        }
        stop() {
            Cd(this)._$Reset$_();
        }
        _$hasTags$_(t) {
            return Cd(this)._$HasTags$_(t);
        }
        set time(t) {
            _d._$RequireFiniteNumber$_(t), Cd(this)._$SetTime$_(t);
        }
        get time() {
            return Cd(this)._$GetTime$_();
        }
        set totalTime(t) {
            _d._$RequireFiniteNumber$_(t), Cd(this)._$SetTotalTime$_(t);
        }
        get totalTime() {
            return Cd(this)._$GetTotalTime$_();
        }
        set _$isLooping$_(t) {
            Cd(this)._$SetLoop$_(!!t);
        }
        get _$isLooping$_() {
            return Cd(this)._$GetLoop$_();
        }
        set _$isPingPong$_(t) {
            Cd(this)._$SetPingPong$_(!!t);
        }
        get _$isPingPong$_() {
            return Cd(this)._$GetPingPong$_();
        }
        set playbackRate(t) {
            _d._$RequireFiniteNumber$_(t), Cd(this)._$SetPlaybackRate$_(t);
        }
        get playbackRate() {
            return Cd(this)._$GetPlaybackRate$_();
        }
        get progress() {
            const t = Cd(this);
            return t._$GetTime$_() / t._$GetTotalTime$_();
        }
        get tags() {
            return Cd(this)._$GetTags$_();
        }
        get finished() {
            return Cd(this)._$GetPlayPromise$_();
        }
        get _$isPlaying$_() {
            return Cd(this).IsPlaying();
        }
        get _$isPaused$_() {
            return Cd(this)._$IsPaused$_();
        }
        get _$isReleased$_() {
            return Ed.get(this)._$IsReleased$_();
        }
    };
}

{
    let Dd = function(t) {
        const s = Ad.get(t);
        if (s._$IsReleased$_()) throw new Error("timeline was released and is no longer valid");
        return s;
    };
    0;
    self._$C3$_, self._$C3X$_;
    const Ad = new WeakMap;
    self._$ITimelineState$_ = class extends self._$ITimelineStateBase$_ {
        constructor(t) {
            super(t), Ad.set(this, t);
            const s = {
                name: {
                    value: t._$GetName$_(),
                    writable: !1
                }
            };
            Object.defineProperties(this, s);
        }
    };
}

{
    let Nd = function(t) {
        const s = Od.get(t);
        if (s._$IsReleased$_()) throw new Error("tween was released and is no longer valid");
        return s;
    };
    0;
    self._$C3$_;
    const Ld = self._$C3X$_, Od = new WeakMap, Rd = new WeakMap;
    let Pd = null;
    self._$ITweenState$_ = class extends self._$ITimelineStateBase$_ {
        constructor(t, s, i) {
            super(t), Pd || (Pd = i._$easeToIndexFunc$_), Od.set(this, t), s && Rd.set(this, s);
        }
        stop() {
            const t = Nd(this);
            Rd.get(this)._$ReleaseTween$_(t);
        }
        _$setEase$_(t) {
            Ld._$RequireString$_(t);
            const s = self._$Ease$_._$GetEaseFromIndex$_(Pd(t));
            Nd(this)._$SetEase$_(s);
        }
        get _$instance$_() {
            const t = Nd(this)._$GetInstance$_();
            return t ? t._$GetInterfaceClass$_() : null;
        }
        get _$isDestroyOnComplete$_() {
            return Nd(this)._$GetDestroyInstanceOnComplete$_();
        }
        set _$isDestroyOnComplete$_(t) {
            Nd(this)._$SetDestroyInstanceOnComplete$_(!!t);
        }
        get value() {
            const t = Nd(this);
            if ("value" !== t._$GetId$_()) throw new Error("not a value tween");
            return t._$GetPropertyTrack$_("value")._$GetSourceAdapterValue$_();
        }
    };
}

self._$C3$_, self._$C3X$_;

self._$ISDKPluginBase$_ = class extends self._$IPlugin$_ {
    constructor() {
        super();
    }
};

{
    const kd = self._$C3$_, Fd = self._$C3X$_, jd = kd._$_GetInternalAPIToken$_();
    self._$ISDKDOMPluginBase$_ = class extends self._$ISDKPluginBase$_ {
        #t;
        #i;
        #s=0;
        #h=new Map;
        constructor(t) {
            if (super(), this.#t = kd._$AddonManager$_._$_GetInitObject2$_(jd), !t?._$domComponentId$_) throw new Error("no DOM component ID specified");
            this.#i = t._$domComponentId$_, this._$_addElementMessageHandler$_("elem-focused", (t => t._$_onElemFocused$_())), 
            this._$_addElementMessageHandler$_("elem-blurred", (t => {
                t && t._$_onElemBlurred$_();
            }));
        }
        _$_addElement$_(t) {
            const s = this.#s++;
            return this.#h.set(s, t), s;
        }
        _$_removeElement$_(t) {
            this.#h.delete(t);
        }
        _$_addElementMessageHandler$_(t, s) {
            this.#t._$GetRuntime$_()._$AddDOMComponentMessageHandler$_(this.#i, t, (t => {
                const i = this.#h.get(t.elementId);
                s(i, t);
            }));
        }
        _$_addElementMessageHandlers$_(t) {
            Fd._$RequireArray$_(t);
            for (const [s, i] of t) this._$_addElementMessageHandlers$_(s, i);
        }
    };
}

{
    const Bd = self._$C3$_, zd = (self._$C3X$_, Bd._$_GetInternalAPIToken$_());
    self._$ISDKObjectTypeBase$_ = class extends self._$IObjectClass$_ {
        #t;
        constructor() {
            super(), this.#t = Bd._$AddonManager$_._$_GetInitObject2$_(zd);
        }
        _$_onCreate$_() {}
        _$getImageInfo$_() {
            return this.#t._$GetImageInfo$_()._$GetIImageInfo$_();
        }
        _$_loadTextures$_(t) {}
        _$_releaseTextures$_(t) {}
        _$_onDynamicTextureLoadComplete$_() {}
        _$_preloadTexturesWithInstances$_(t) {}
    };
}

{
    const Ud = self._$C3$_, Wd = (self._$C3X$_, Ud._$_GetInternalAPIToken$_());
    self._$ISDKWorldInstanceBase$_ = class extends self._$IWorldInstanceSDKBase$_ {
        #t;
        #n=null;
        #s=null;
        constructor(t) {
            super(t), this.#t = Ud._$AddonManager$_._$_GetInitObject2$_(Wd);
        }
        _$_release$_() {
            if (super._$_release$_(), this.#n) {
                const t = this.#t._$GetRuntime$_()._$Dispatcher$_();
                t.removeEventListener("renderercontextlost", this.#n), t.removeEventListener("renderercontextrestored", this.#s), 
                this.#n = null, this.#s = null;
            }
        }
        _$_handleRendererContextLoss$_() {
            if (this.#n) return;
            this.#n = () => this._$_onRendererContextLost$_(), this.#s = () => this._$_onRendererContextRestored$_();
            const t = this.#t._$GetRuntime$_()._$Dispatcher$_();
            t.addEventListener("renderercontextlost", this.#n), t.addEventListener("renderercontextrestored", this.#s);
        }
        _$_onRendererContextLost$_() {}
        _$_onRendererContextRestored$_() {}
        _$_draw$_(t) {}
    };
}

{
    const Jd = self._$C3$_, Qd = (self._$C3X$_, Jd._$New$_(Jd.Rect)), Yd = new WeakMap, Vd = Jd._$_GetInternalAPIToken$_();
    self._$ISDKDOMInstanceBase$_ = class extends self._$ISDKWorldInstanceBase$_ {
        #t=-1;
        #s=!0;
        #h=!1;
        #e=!1;
        #i=-.2;
        #r=Jd._$New$_(Jd.Rect, 0, 0, -1, -1);
        #o=0;
        #a=0;
        #u=-1;
        #l=-1;
        #c=!1;
        constructor(t) {
            if (!t?._$domComponentId$_) throw new Error("no DOM component ID specified");
            super(t);
            const s = Jd._$AddonManager$_._$_GetInitObject2$_(Vd);
            Yd.set(this, s), this.#t = this._$plugin$_._$_addElement$_(this);
            const i = s._$GetRuntime$_()._$GetCanvasManager$_();
            this.#o = i._$GetLastWidth$_(), this.#a = i._$GetLastHeight$_(), this._$_setTicking$_(!0);
        }
        _$_release$_() {
            super._$_release$_(), this._$plugin$_._$_removeElement$_(this.#t), this._$_postToDOMElement$_("destroy"), 
            this.#t = -1, Yd.delete(this);
        }
        _$_getElementInDOMMode$_() {
            if (Yd.get(this)._$GetRuntime$_()._$IsInWorker$_()) throw new Error("not valid in worker mode");
            return this._$_postToDOMElementMaybeSync$_("get-element");
        }
        _$_postToDOMElement$_(t, s) {
            s || (s = {}), s.elementId = this.#t, this._$_postToDOM$_(t, s);
        }
        _$_postToDOMElementMaybeSync$_(t, s) {
            return s || (s = {}), s.elementId = this.#t, this._$_postToDOMMaybeSync$_(t, s);
        }
        _$_postToDOMElementAsync$_(t, s) {
            return s || (s = {}), s.elementId = this.#t, this._$_postToDOMAsync$_(t, s);
        }
        _$_createElement$_(t) {
            t || (t = {});
            const s = Yd.get(this)._$GetWorldInfo$_();
            t.elementId = this.#t, t.isVisible = s._$IsVisible$_(), t.htmlIndex = s._$GetLayer$_()._$GetHTMLIndex$_(), 
            t.htmlZIndex = s._$GetHTMLZIndex$_(), Object.assign(t, this._$_getElementState$_()), 
            this.#s = !!t.isVisible, this._$_postToDOMMaybeSync$_("create", t), this._$_updatePosition$_(!0);
        }
        _$setElementVisible$_(t) {
            t = !!t, this.#s !== t && (this.#s = t, this._$_postToDOMElement$_("set-visible", {
                isVisible: t
            }));
        }
        _$_tick$_() {
            this._$_updatePosition$_(!1);
        }
        _$_shouldPreserveElement$_() {
            const t = Yd.get(this)._$GetRuntime$_()._$GetCanvasManager$_()._$GetFullscreenMode$_();
            return "Android" === Jd._$Platform$_._$OS$_ && ("scale-inner" === t || "scale-outer" === t || "crop" === t);
        }
        _$_updatePosition$_(t) {
            const s = Yd.get(this);
            if (s._$IsDestroyed$_()) return;
            const i = s._$GetWorldInfo$_(), e = i._$GetLayer$_(), n = i._$GetBoundingBox$_();
            let [h, r] = e._$LayerToCanvasCss$_(n._$getLeft$_(), n._$getTop$_()), [o, a] = e._$LayerToCanvasCss$_(n._$getRight$_(), n._$getBottom$_());
            const u = s._$GetRuntime$_()._$GetCanvasManager$_(), l = u._$GetCssWidth$_(), c = u._$GetCssHeight$_();
            if (!i._$IsVisible$_() || !e._$IsVisible$_()) return void this._$setElementVisible$_(!1);
            if (!this._$_shouldPreserveElement$_() && (o <= 0 || a <= 0 || h >= l || r >= c)) return void this._$setElementVisible$_(!1);
            Qd.set(h, r, o, a);
            const f = u._$GetLastWidth$_(), d = u._$GetLastHeight$_(), p = e._$GetHTMLIndex$_(), m = i._$GetHTMLZIndex$_();
            if (!t && Qd.equals(this.#r) && this.#o === f && this.#a === d && this.#u === p && this.#l === m) return void this._$setElementVisible$_(!0);
            this.#r._$copy$_(Qd), this.#o = f, this.#a = d, this.#u = p, this.#l = m, this._$setElementVisible$_(!0);
            let g = null;
            this.#e && (g = e._$GetDisplayScale$_() + this.#i), this._$_postToDOMElement$_("update-position", {
                left: Math.round(this.#r._$getLeft$_()),
                top: Math.round(this.#r._$getTop$_()),
                width: Math.round(this.#r.width()),
                height: Math.round(this.#r.height()),
                htmlIndex: p,
                htmlZIndex: m,
                fontSize: g
            });
        }
        _$focusElement$_() {
            this._$_postToDOMElementMaybeSync$_("focus", {
                focus: !0
            });
        }
        _$blurElement$_() {
            this._$_postToDOMElementMaybeSync$_("focus", {
                focus: !1
            });
        }
        _$_onElemFocused$_() {
            this.#h = !0;
        }
        _$_onElemBlurred$_() {
            this.#h = !1;
        }
        _$isElementFocused$_() {
            return this.#h;
        }
        _$setElementCSSStyle$_(t, s) {
            this._$postToDOMElement$_("set-css-style", {
                prop: Jd._$CSSToCamelCase$_(t),
                val: s
            });
        }
        _$setElementAttribute$_(t, s) {
            this._$postToDOMElement$_("set-attribute", {
                name: t,
                val: s
            });
        }
        _$removeElementAttribute$_(t) {
            this._$postToDOMElement$_("remove-attribute", {
                name: t
            });
        }
        _$_updateElementState$_() {
            this.#c || (this.#c = !0, Promise.resolve().then((() => {
                this.#c = !1, this._$_postToDOMElement$_("update-state", this._$_getElementState$_());
            })));
        }
        _$_getElementState$_() {}
        _$_getElementId$_() {
            return this.#t;
        }
    };
}

self._$C3$_, self._$C3X$_;

self._$ISDKBehaviorBase$_ = class extends self._$IBehavior$_ {
    constructor() {
        super();
    }
};

self._$C3$_, self._$C3X$_;

self._$ISDKBehaviorTypeBase$_ = class extends globalThis._$IBehaviorType$_ {
    constructor() {
        super();
    }
    _$_onCreate$_() {}
};

{
    const Hd = self._$C3$_, qd = (self._$C3X$_, new WeakMap), Xd = Hd._$_GetInternalAPIToken$_();
    self._$ISDKBehaviorInstanceBase$_ = class extends self._$IBehaviorInstance$_ {
        #e=!1;
        #s=!1;
        #t=!1;
        constructor() {
            super(), qd.set(this, Hd._$AddonManager$_._$_GetInitObject2$_(Xd));
        }
        _$_release$_() {
            super._$_release$_(), this._$_setTicking$_(!1), this._$_setTicking2$_(!1), this._$_setPostTicking$_(!1), 
            qd.delete(this);
        }
        _$_getInitProperties$_() {
            return Hd._$AddonManager$_._$_GetInitProperties$_();
        }
        _$_postCreate$_() {}
        _$_trigger$_(t) {
            const s = qd.get(this);
            s._$GetRuntime$_()._$Trigger$_(t, s._$GetObjectInstance$_(), s._$GetBehaviorType$_());
        }
        _$_triggerAsync$_(t) {
            const s = qd.get(this);
            return s._$GetRuntime$_()._$TriggerAsync$_(t, s._$GetObjectInstance$_(), s._$GetBehaviorType$_());
        }
        _$_setTicking$_(t) {
            if (t = !!t, this.#e === t) return;
            this.#e = t;
            const s = qd.get(this)._$GetRuntime$_();
            t ? s._$_AddBehInstToTick$_(this) : s._$_RemoveBehInstToTick$_(this);
        }
        _$_isTicking$_() {
            return this.#e;
        }
        _$_tick$_() {}
        _$_setTicking2$_(t) {
            if (t = !!t, this.#s === t) return;
            this.#s = t;
            const s = qd.get(this)._$GetRuntime$_();
            t ? s._$_AddBehInstToTick2$_(this) : s._$_RemoveBehInstToTick2$_(this);
        }
        _$_isTicking2$_() {
            return this.#s;
        }
        _$_tick2$_() {}
        _$_setPostTicking$_(t) {
            if (t = !!t, this.#t === t) return;
            this.#t = t;
            const s = qd.get(this)._$GetRuntime$_();
            t ? s._$_AddBehInstToPostTick$_(this) : s._$_RemoveBehInstToPostTick$_(this);
        }
        _$_isPostTicking$_() {
            return this.#t;
        }
        _$_postTick$_() {}
        _$_getDebuggerProperties$_() {
            return [];
        }
        _$_saveToJson$_() {
            return null;
        }
        _$_loadFromJson$_(t) {}
    };
}

{
    self._$C3$_;
    const Zd = self._$C3X$_;
    let Kd = null;
    self._$ISDKUtils$_ = class {
        constructor(t) {
            Kd = t;
        }
        _$addLoadPromise$_(t) {
            Kd._$AddLoadPromise$_(t);
        }
        _$sendWrapperExtensionMessage$_(t, s, i) {
            Zd._$RequireString$_(t), Zd._$RequireString$_(s), Zd._$RequireOptionalArray$_(i), 
            Kd._$SendWrapperExtensionMessage$_(t, s, i);
        }
        _$sendWrapperExtensionMessageAsync$_(t, s, i) {
            return Zd._$RequireString$_(t), Zd._$RequireString$_(s), Zd._$RequireOptionalArray$_(i), 
            Kd._$SendWrapperExtensionMessageAsync$_(t, s, i);
        }
        _$createLoopingConditionContext$_(t) {
            return Zd._$RequireOptionalString$_(t), new self._$ILoopingConditionContext$_(Kd, t);
        }
        set _$isAutoSuspendEnabled$_(t) {
            Kd._$_SetAutoSuspendEnabled$_(!!t);
        }
        get _$isAutoSuspendEnabled$_() {
            return Kd._$_IsAutoSuspendEnabled$_();
        }
        _$setSuspended$_(t) {
            Kd._$SetSuspended$_(!!t);
        }
        _$getObjectClassBySid$_(t) {
            Zd._$RequireNumber$_(t);
            const s = Kd._$GetObjectClassBySID$_(t);
            return s ? s._$GetIObjectClass$_() : null;
        }
    };
}

self._$C3$_, self._$C3X$_;

self._$ILoopingConditionContext$_ = class {
    #t;
    #s;
    #r;
    #i;
    #h;
    #n;
    constructor(t, s) {
        this.#t = t;
        const i = t._$GetEventSheetManager$_(), e = t._$GetCurrentEvent$_();
        this.#s = e, this.#r = e._$GetSolModifiers$_();
        const n = t._$GetEventStack$_();
        this.#i = n._$GetCurrentStackFrame$_(), this.#h = n._$Push$_(e);
        const h = i._$GetLoopStack$_()._$Push$_();
        this.#n = h, s && h._$SetName$_(s), t._$SetDebuggingEnabled$_(!1);
    }
    _$retrigger$_() {
        const t = this.#t._$GetEventSheetManager$_(), s = this.#r, i = this.#n;
        t._$PushCopySol$_(s), this.#s._$Retrigger$_(this.#i, this.#h), t._$PopSol$_(s), 
        i._$SetIndex$_(i._$GetIndex$_() + 1);
    }
    get _$isStopped$_() {
        return this.#n._$IsStopped$_();
    }
    release() {
        const t = this.#t, s = t._$GetEventStack$_(), i = t._$GetEventSheetManager$_()._$GetLoopStack$_();
        t._$SetDebuggingEnabled$_(!0), i._$Pop$_(), s._$Pop$_();
    }
};

{
    const $d = self._$C3$_, tp = self._$C3X$_;
    let sp = null, ip = null;
    self._$IRenderer$_ = class {
        constructor(t, s) {
            ip = t, sp = s;
        }
        _$setAlphaBlendMode$_() {
            sp._$SetAlphaBlend$_();
        }
        _$setBlendMode$_(t) {
            sp._$SetNamedBlendMode$_(t);
        }
        _$setColorFillMode$_() {
            sp._$SetColorFillMode$_();
        }
        _$setTextureFillMode$_() {
            sp._$SetTextureFillMode$_();
        }
        _$setSmoothLineFillMode$_() {
            sp._$SetSmoothLineFillMode$_();
        }
        setColor(t) {
            sp._$SetColorRgba$_(t[0], t[1], t[2], t[3]);
        }
        _$setColorRgba$_(t, s, i, e) {
            sp._$SetColorRgba$_(t, s, i, e);
        }
        _$resetColor$_() {
            sp._$ResetColor$_();
        }
        _$setOpacity$_(t) {
            sp._$SetOpacity$_(t);
        }
        _$setCurrentZ$_(t) {
            sp._$SetCurrentZ$_(t);
        }
        _$getCurrentZ$_() {
            sp._$GetCurrentZ$_();
        }
        rect(t) {
            sp._$Rect2$_(t.left, t.top, t.right, t.bottom);
        }
        _$rect2$_(t, s, i, e) {
            sp._$Rect2$_(t, s, i, e);
        }
        _$quad$_(t) {
            sp._$Quad$_($d._$Quad$_._$fromDOMQuad$_(t));
        }
        _$quad2$_(t, s, i, e, n, h, r, o) {
            sp._$Quad2$_(t, s, i, e, n, h, r, o);
        }
        _$quad3$_(t, s) {
            sp._$Quad3$_($d._$Quad$_._$fromDOMQuad$_(t), $d.Rect._$fromDOMRect$_(s));
        }
        _$quad4$_(t, s) {
            sp._$Quad4$_($d._$Quad$_._$fromDOMQuad$_(t), $d._$Quad$_._$fromDOMQuad$_(s));
        }
        _$quad3D$_(t, s, i, e, n, h, r, o, a, u, l, c, f) {
            sp._$Quad3D$_(t, s, i, e, n, h, r, o, a, u, l, c, $d.Rect._$fromDOMRect$_(f));
        }
        _$quad3D2$_(t, s, i, e, n, h, r, o, a, u, l, c, f) {
            sp._$Quad3D2$_(t, s, i, e, n, h, r, o, a, u, l, c, $d._$Quad$_._$fromDOMQuad$_(f));
        }
        _$drawMesh$_(t, s, i) {
            sp._$DrawMesh$_(t, s, i);
        }
        _$convexPoly$_(t) {
            sp._$ConvexPoly$_(t);
        }
        line(t, s, i, e) {
            sp._$Line$_(t, s, i, e);
        }
        _$texturedLine$_(t, s, i, e, n, h) {
            sp._$TexturedLine$_(t, s, i, e, n, h);
        }
        _$lineRect$_(t, s, i, e) {
            sp._$LineRect$_(t, s, i, e);
        }
        _$lineRect2$_(t) {
            sp._$LineRect2$_($d.Rect._$fromDOMRect$_(t));
        }
        _$lineQuad$_(t) {
            sp._$LineQuad$_($d._$Quad$_._$fromDOMQuad$_(t));
        }
        _$pushLineWidth$_(t) {
            sp._$PushLineWidth$_(t);
        }
        _$popLineWidth$_() {
            sp._$PopLineWidth$_();
        }
        _$pushLineCap$_(t) {
            sp._$PushLineCap$_(t);
        }
        _$popLineCap$_() {
            sp._$PopLineCap$_();
        }
        _$setTexture$_(t) {
            tp._$RequireOptionalInstanceOf$_(t, self._$ITexture$_);
            const s = t ? ip._$_UnwrapScriptInterface$_(t) : null;
            sp._$SetTexture$_(s);
        }
        _$loadTextureForImageInfo$_(t, s) {
            const i = self._$IImageInfo$_._$_Unwrap$_(t);
            if (!i) throw new Error("invalid IImageInfo");
            return i._$LoadStaticTexture$_(sp, {
                _$wrapX$_: s?._$wrapX$_ ?? "clamp-to-edge",
                _$wrapY$_: s?._$wrapY$_ ?? "clamp-to-edge",
                _$sampling$_: s?._$sampling$_ ?? "trilinear",
                _$mipMap$_: s?._$mipMap$_ ?? !0
            });
        }
        _$releaseTextureForImageInfo$_(t) {
            const s = self._$IImageInfo$_._$_Unwrap$_(t);
            if (!s) throw new Error("invalid IImageInfo");
            s._$ReleaseTexture$_();
        }
        _$getTextureForImageInfo$_(t) {
            const s = self._$IImageInfo$_._$_Unwrap$_(t);
            if (!s) throw new Error("invalid IImageInfo");
            const i = s._$GetTexture$_();
            return self._$ITexture$_._$GetInterface$_(ip, i);
        }
        _$createDynamicTexture$_(t, s, i) {
            tp._$RequireFiniteNumber$_(t), tp._$RequireFiniteNumber$_(s);
            const e = sp._$CreateDynamicTexture$_(t, s, {
                _$wrapX$_: i?._$wrapX$_ ?? "clamp-to-edge",
                _$wrapY$_: i?._$wrapY$_ ?? "clamp-to-edge",
                _$sampling$_: i?._$sampling$_ ?? "trilinear",
                _$mipMap$_: i?._$mipMap$_ ?? !0
            });
            return self._$ITexture$_._$GetInterface$_(ip, e);
        }
        _$updateTexture$_(t, s, i) {
            tp._$RequireInstanceOf$_(s, self._$ITexture$_);
            const e = ip._$_UnwrapScriptInterface$_(s);
            sp._$UpdateTexture$_(t, e, {
                _$premultiplyAlpha$_: i?._$premultiplyAlpha$_ ?? !0
            });
        }
        deleteTexture(t) {
            tp._$RequireInstanceOf$_(t, self._$ITexture$_);
            const s = ip._$_UnwrapScriptInterface$_(t);
            sp._$DeleteTexture$_(s);
        }
        _$createRendererText$_() {
            const t = sp._$CreateRendererText$_();
            return new self._$IRendererText$_(ip, t);
        }
        _$setDeviceTransform$_() {
            ip._$GetCanvasManager$_()._$SetDeviceTransform$_(sp);
        }
        _$setLayerTransform$_(t) {
            tp._$RequireInstanceOf$_(t, globalThis._$ILayer$_), ip._$_UnwrapScriptInterface$_(t)._$_SetTransform$_(sp);
        }
    };
}

{
    self._$C3$_, self._$C3X$_;
    const ep = new WeakMap, np = new WeakMap;
    self._$ITexture$_ = class {
        constructor(t, s) {
            ep.set(this, {
                runtime: t,
                texture: s
            }), np.set(s, this), t._$_MapScriptInterface$_(this, s), Object.defineProperties(this, {
                width: {
                    value: s._$GetWidth$_(),
                    writable: !1
                },
                height: {
                    value: s._$GetHeight$_(),
                    writable: !1
                }
            });
        }
        static _$GetInterface$_(t, s) {
            if (!s) return null;
            return np.get(s) || new self._$ITexture$_(t, s);
        }
    };
}

{
    let hp = function(t) {
        return op.get(t)._$rendererText$_;
    };
    0;
    self._$C3$_;
    const rp = self._$C3X$_, op = new WeakMap;
    self._$IRendererText$_ = class {
        constructor(t, s) {
            op.set(this, {
                runtime: t,
                _$rendererText$_: s
            }), t._$_MapScriptInterface$_(this, s);
        }
        release() {
            hp(this)._$Release$_();
        }
        set _$fontFace$_(t) {
            rp._$RequireString$_(t), hp(this)._$SetFontName$_(t);
        }
        get _$fontFace$_() {
            return hp(this)._$GetFontName$_();
        }
        set _$sizePt$_(t) {
            rp._$RequireFiniteNumber$_(t), hp(this)._$SetFontSize$_(t);
        }
        get _$sizePt$_() {
            return hp(this)._$GetFontSize$_();
        }
        set lineHeight(t) {
            rp._$RequireFiniteNumber$_(t), hp(this)._$SetLineHeight$_(t);
        }
        get lineHeight() {
            return hp(this)._$GetLineHeight$_();
        }
        set _$isBold$_(t) {
            hp(this)._$SetBold$_(t);
        }
        get _$isBold$_() {
            return hp(this)._$IsBold$_();
        }
        set _$isItalic$_(t) {
            hp(this)._$SetItalic$_(t);
        }
        get _$isItalic$_() {
            return hp(this)._$IsItalic$_();
        }
        setColor(t) {
            rp._$RequireArray$_(t), this._$setColorRgb$_(t[0], t[1], t[2]);
        }
        _$setColorRgb$_(t, s, i) {
            hp(this)._$SetColorRgb$_(t, s, i);
        }
        _$setCssColor$_(t) {
            rp._$RequireString$_(t), hp(this)._$SetColor$_(t);
        }
        set _$horizontalAlign$_(t) {
            hp(this)._$SetHorizontalAlignment$_(t);
        }
        get _$horizontalAlign$_() {
            return hp(this)._$GetHorizontalAlignment$_();
        }
        set verticalAlign(t) {
            hp(this)._$SetVerticalAlignment$_(t);
        }
        get verticalAlign() {
            return hp(this)._$GetVerticalAlignment$_();
        }
        set _$wordWrapMode$_(t) {
            hp(this)._$SetWordWrapMode$_(t);
        }
        get _$wordWrapMode$_() {
            return hp(this)._$GetWordWrapMode$_();
        }
        set _$textDirection$_(t) {
            hp(this)._$SetTextDirection$_(t);
        }
        get _$textDirection$_() {
            return hp(this)._$GetTextDirection$_();
        }
        set text(t) {
            rp._$RequireString$_(t), hp(this)._$SetText$_(t);
        }
        get text() {
            return hp(this)._$GetText$_();
        }
        _$setSize$_(t, s, i) {
            rp._$RequireFiniteNumber$_(t), rp._$RequireFiniteNumber$_(s), rp._$RequireFiniteNumber$_(i), 
            hp(this)._$SetSize$_(t, s, i);
        }
        _$getTexture$_() {
            const {runtime: t, _$rendererText$_: s} = op.get(this), i = s._$GetTexture$_();
            return self._$ITexture$_._$GetInterface$_(t, i);
        }
        _$getTexRect$_() {
            return hp(this)._$GetTexRect$_()._$toDOMRect$_();
        }
        _$setTextureUpdateCallback$_(t) {
            rp._$RequireFunction$_(t), hp(this)._$ontextureupdate$_ = t;
        }
        _$releaseTexture$_() {
            hp(this)._$ReleaseTexture$_();
        }
        get _$textWidth$_() {
            return hp(this)._$GetTextWidth$_();
        }
        get _$textHeight$_() {
            return hp(this)._$GetTextHeight$_();
        }
    };
}

{
    let ap = function(t) {
        if (!t) return "";
        const s = t.split(".");
        if (s.length < 2) return "";
        const i = s.at(-1).toLowerCase();
        return fp.get(i) || "";
    }, up = function(t) {
        return new Promise(((s, i) => {
            const e = document.createElement("script");
            e.onload = s, e.onerror = i, e.async = !1, e.type = "module", e.src = t, document.head.appendChild(e);
        }));
    };
    0;
    const lp = self._$C3$_, cp = new Set([ "local", "remote" ]), fp = new Map([ [ "mp4", "video/mp4" ], [ "webm", "video/webm" ], [ "m4a", "audio/mp4" ], [ "mp3", "audio/mpeg" ], [ "js", "application/javascript" ], [ "wasm", "application/wasm" ], [ "svg", "image/svg+xml" ], [ "html", "text/html" ] ]);
    lp._$AssetManager$_ = class extends lp._$DefendedBase$_ {
        constructor(t, s) {
            super();
            const i = s.exportType;
            this._$_runtime$_ = t, this._$_fileStructure$_ = "folders", this._$_cordovaBlobUrlCache$_ = new Map, 
            this._$_isCordova$_ = "cordova" === i, this._$_isiOSCordova$_ = !!s.isiOSCordova, 
            this._$_isFileProtocol$_ = !!s.isFileProtocol, this._$_swClientId$_ = s.swClientId, 
            this._$_supportedAudioFormats$_ = s.supportedAudioFormats || {}, this._$_audioFiles$_ = new Map, 
            this._$_preloadSounds$_ = !1, this._$_scriptSubfolder$_ = s.scriptFolder, this._$_mediaSubfolder$_ = "", 
            this._$_fontsSubfolder$_ = "", this._$_iconsSubfolder$_ = "", this._$_fileMap$_ = s.fileMap || new Map, 
            this._$_fileMapBlobUrls$_ = new Map;
            const e = "html5" === i || "scirra-arcade" === i || "instant-games" === i;
            this._$_defaultLoadPolicy$_ = e ? "remote" : "local", this._$_assetsByUrl$_ = new Map, 
            this._$_webFonts$_ = [], this._$_loadPromises$_ = [], this._$_hasFinishedInitialLoad$_ = !1, 
            this._$_totalAssetSizeToLoad$_ = 0, this._$_assetSizeLoaded$_ = 0, this._$_lastLoadProgress$_ = 0, 
            this._$_hasHadErrorLoading$_ = !1, this._$_loadingRateLimiter$_ = lp._$New$_(lp._$RateLimiter$_, (() => this._$_FireLoadingProgressEvent$_()), 50), 
            this._$_localPromiseThrottle$_ = lp._$New$_(lp._$PromiseThrottle$_, Math.max(lp.hardwareConcurrency, 8)), 
            this._$_remotePromiseThrottle$_ = lp._$New$_(lp._$PromiseThrottle$_, 20), this._$_iAssetManager$_ = new self._$IAssetManager$_(this);
        }
        _$Release$_() {
            for (const t of this._$_assetsByUrl$_.values()) t._$Release$_();
            this._$_assetsByUrl$_.clear(), lp._$clearArray$_(this._$_loadPromises$_), this._$_runtime$_ = null;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$_SetFileStructure$_(t) {
            this._$_fileStructure$_ = t;
        }
        _$GetFileStructure$_() {
            return this._$_fileStructure$_;
        }
        _$GetScriptSubfolder$_() {
            return this._$_scriptSubfolder$_;
        }
        _$_SetMediaSubfolder$_(t) {
            this._$_mediaSubfolder$_ = t;
        }
        _$GetMediaSubfolder$_() {
            return this._$_mediaSubfolder$_;
        }
        _$_SetFontsSubfolder$_(t) {
            this._$_fontsSubfolder$_ = t;
        }
        _$GetFontsSubfolder$_() {
            return this._$_fontsSubfolder$_;
        }
        _$_SetIconsSubfolder$_(t) {
            this._$_iconsSubfolder$_ = t;
        }
        _$GetIconsSubfolder$_() {
            return this._$_iconsSubfolder$_;
        }
        _$IsFileProtocol$_() {
            return this._$_isFileProtocol$_;
        }
        _$FetchBlob$_(t, s) {
            return s = s || this._$_defaultLoadPolicy$_, lp._$IsRelativeURL$_(t) ? ("flat" === this._$_fileStructure$_ && (t = t.toLowerCase()), 
            this._$_isCordova$_ && this._$_isFileProtocol$_ ? this._$CordovaFetchLocalFileAsBlob$_(t) : "playable-ad-single-file" === this._$_runtime$_._$GetExportType$_() ? self.c3_runtimeInterface._PlayableAdFetchBlob(t) : "local" === s ? this._$_localPromiseThrottle$_._$Add$_((() => lp._$FetchBlob$_(t))) : this._$_remotePromiseThrottle$_._$Add$_((() => lp._$FetchBlob$_(t)))) : lp._$FetchBlob$_(t);
        }
        _$FetchArrayBuffer$_(t) {
            return lp._$IsRelativeURL$_(t) ? ("flat" === this._$_fileStructure$_ && (t = t.toLowerCase()), 
            this._$_isCordova$_ && this._$_isFileProtocol$_ ? this._$CordovaFetchLocalFileAsArrayBuffer$_(t) : "playable-ad-single-file" === this._$_runtime$_._$GetExportType$_() ? lp._$BlobToArrayBuffer$_(self.c3_runtimeInterface._PlayableAdFetchBlob(t)) : "local" === this._$_defaultLoadPolicy$_ ? this._$_localPromiseThrottle$_._$Add$_((() => lp._$FetchArrayBuffer$_(t))) : this._$_remotePromiseThrottle$_._$Add$_((() => lp._$FetchArrayBuffer$_(t)))) : lp._$FetchArrayBuffer$_(t);
        }
        _$FetchText$_(t) {
            return lp._$IsRelativeURL$_(t) ? ("flat" === this._$_fileStructure$_ && (t = t.toLowerCase()), 
            this._$_isCordova$_ && this._$_isFileProtocol$_ ? this._$CordovaFetchLocalFileAsText$_(t) : "playable-ad-single-file" === this._$_runtime$_._$GetExportType$_() ? lp._$BlobToString$_(self.c3_runtimeInterface._PlayableAdFetchBlob(t)) : "local" === this._$_defaultLoadPolicy$_ ? this._$_localPromiseThrottle$_._$Add$_((() => lp._$FetchText$_(t))) : this._$_remotePromiseThrottle$_._$Add$_((() => lp._$FetchText$_(t)))) : lp._$FetchText$_(t);
        }
        async _$FetchJson$_(t) {
            const s = await this._$FetchText$_(t);
            return JSON.parse(s);
        }
        _$_CordovaFetchLocalFileAs$_(t, s) {
            return "flat" === this._$_fileStructure$_ && (t = t.toLowerCase()), this._$_runtime$_._$PostComponentMessageToDOMAsync$_("runtime", "cordova-fetch-local-file", {
                filename: t,
                as: s
            });
        }
        _$CordovaFetchLocalFileAsText$_(t) {
            return this._$_CordovaFetchLocalFileAs$_(t, "text");
        }
        async _$CordovaFetchLocalFileAsBlob$_(t) {
            const s = await this._$_CordovaFetchLocalFileAs$_(t, "buffer"), i = ap(t);
            return new Blob([ s ], {
                type: i
            });
        }
        async _$CordovaFetchLocalFileAsBlobURL$_(t) {
            "flat" === this._$_fileStructure$_ && (t = t.toLowerCase());
            let s = this._$_cordovaBlobUrlCache$_.get(t);
            if (s) return s;
            const i = await this._$CordovaFetchLocalFileAsBlob$_(t);
            return s = URL.createObjectURL(i), this._$_cordovaBlobUrlCache$_.set(t, s), s;
        }
        _$CordovaFetchLocalFileAsArrayBuffer$_(t) {
            return this._$_CordovaFetchLocalFileAs$_(t, "buffer");
        }
        _$GetMediaFileUrl$_(t) {
            "flat" === this._$_fileStructure$_ && (t = t.toLowerCase());
            let s = this._$_mediaSubfolder$_ + t;
            return "Gecko" === lp._$Platform$_._$BrowserEngine$_ && "preview" === this._$_runtime$_._$GetExportType$_() && (s = this._$_GetLocalBlobURLFromFileMap$_(s)), 
            s;
        }
        _$GetProjectFileUrl$_(t) {
            return lp._$IsAbsoluteURL$_(t) ? Promise.resolve(t) : this._$_isCordova$_ && this._$_isFileProtocol$_ ? this._$CordovaFetchLocalFileAsBlobURL$_(t) : "playable-ad-single-file" === this._$_runtime$_._$GetExportType$_() ? URL.createObjectURL(self.c3_runtimeInterface._PlayableAdFetchBlob(t)) : ("flat" === this._$_fileStructure$_ && (t = t.toLowerCase()), 
            Promise.resolve(t));
        }
        _$GetProjectFileIframeUrl$_(t) {
            if (lp._$IsAbsoluteURL$_(t) || "preview" !== this._$_runtime$_._$GetExportType$_() || !this._$_swClientId$_ || !t) return t;
            try {
                const s = new URL(t, location.href);
                return s.searchParams.set("__c3_client_id", this._$_swClientId$_), s.toString();
            } catch (s) {
                return console.warn("Invalid iframe URL: " + t), t;
            }
        }
        _$LoadProjectFileUrl$_(t) {
            return this._$GetProjectFileUrl$_(t);
        }
        _$LoadImage$_(t) {
            if (t._$loadPolicy$_ && !cp.has(t._$loadPolicy$_)) throw new Error("invalid load policy");
            let s = this._$_assetsByUrl$_.get(t.url);
            return s || (s = lp._$New$_(lp._$ImageAsset$_, this, {
                url: t.url,
                size: t.size || 0,
                _$loadPolicy$_: t._$loadPolicy$_ || this._$_defaultLoadPolicy$_
            }), this._$_assetsByUrl$_.set(s._$GetURL$_(), s), this._$_hasFinishedInitialLoad$_ || (this._$_totalAssetSizeToLoad$_ += s._$GetSize$_(), 
            this._$_loadPromises$_.push(s._$Load$_().then((() => this._$_AddLoadedSize$_(s._$GetSize$_()))))), 
            s);
        }
        _$_ReleaseAsset$_(t) {
            this._$_assetsByUrl$_.delete(t._$GetURL$_());
        }
        async _$WaitForAllToLoad$_() {
            try {
                await Promise.all(this._$_loadPromises$_), this._$_lastLoadProgress$_ = 1;
            } catch (t) {
                console.error("Error loading: ", t), this._$_hasHadErrorLoading$_ = !0, this._$_FireLoadingProgressEvent$_();
            }
        }
        _$SetInitialLoadFinished$_() {
            this._$_hasFinishedInitialLoad$_ = !0;
        }
        _$HasHadErrorLoading$_() {
            return this._$_hasHadErrorLoading$_;
        }
        _$_AddLoadedSize$_(t) {
            this._$_assetSizeLoaded$_ += t, this._$_loadingRateLimiter$_._$Call$_();
        }
        _$_FireLoadingProgressEvent$_() {
            const t = lp._$New$_(lp.Event, "loadingprogress");
            this._$_lastLoadProgress$_ = lp._$clamp$_(this._$_assetSizeLoaded$_ / this._$_totalAssetSizeToLoad$_, 0, 1), 
            t.progress = this._$_lastLoadProgress$_, this._$_runtime$_._$Dispatcher$_().dispatchEvent(t);
        }
        _$GetLoadProgress$_() {
            return this._$_lastLoadProgress$_;
        }
        _$GetImageLoadProgress$_() {
            return this._$_runtime$_._$GetSystemPlugin$_()._$GetImageLoadingProgress$_();
        }
        _$_SetWebFonts$_(t) {
            lp._$shallowAssignArray$_(this._$_webFonts$_, t), this._$_webFonts$_.length && this._$_loadPromises$_.push(this._$_LoadWebFonts$_());
        }
        async _$_LoadWebFonts$_() {
            const t = [], s = [];
            for (const [i, e, n] of this._$_webFonts$_) this._$_totalAssetSizeToLoad$_ += n, 
            t.push(this._$_LoadWebFont$_(i, e, s).then((() => this._$_AddLoadedSize$_(n))));
            await Promise.all(t), this._$_runtime$_._$IsInWorker$_() && s.length > 0 && await this._$_runtime$_._$PostComponentMessageToDOMAsync$_("runtime", "load-webfonts", {
                webfonts: s
            });
        }
        async _$_LoadWebFont$_(t, s, i) {
            try {
                let e = await this._$GetProjectFileUrl$_(s);
                "Gecko" === lp._$Platform$_._$BrowserEngine$_ && (t = `'${t}'`), ("Gecko" === lp._$Platform$_._$BrowserEngine$_ && "preview" === this._$_runtime$_._$GetExportType$_() || "playable-ad-single-file" === this._$_runtime$_._$GetExportType$_()) && (e = this._$_GetLocalBlobURLFromFileMap$_(e));
                const n = new FontFace(t, `url('${e}')`);
                this._$_runtime$_._$IsInWorker$_() ? self.fonts.add(n) : document.fonts.add(n), 
                await n.load(), this._$_runtime$_._$IsInWorker$_() && i.push({
                    name: t,
                    url: e
                });
            } catch (s) {
                console.warn(`[C3 runtime] Failed to load web font '${t}': `, s);
            }
        }
        _$IsAudioFormatSupported$_(t) {
            return !!this._$_supportedAudioFormats$_[t];
        }
        _$_SetAudioFiles$_(t, s) {
            this._$_preloadSounds$_ = !!s;
            for (const [s, i, e] of t) this._$_audioFiles$_.set(s, {
                fileName: s,
                _$formats$_: i.map((t => ({
                    type: t[0],
                    _$fileExtension$_: t[1],
                    fullName: s + t[1],
                    fileSize: t[2]
                }))),
                _$isMusic$_: e
            });
        }
        _$GetPreferredAudioFile$_(t) {
            "flat" === this._$_fileStructure$_ && (t = t.toLowerCase());
            const s = this._$_audioFiles$_.get(t);
            if (!s) return null;
            let i = null;
            for (const t of s._$formats$_) if (i || "audio/webm; codecs=opus" !== t.type || (i = t), 
            this._$IsAudioFormatSupported$_(t.type)) return t;
            return i;
        }
        _$GetProjectAudioFileUrl$_(t) {
            const s = this._$GetPreferredAudioFile$_(t);
            return s ? {
                url: this._$GetMediaFileUrl$_(s.fullName),
                type: s.type
            } : null;
        }
        _$GetAudioToPreload$_() {
            if (this._$_preloadSounds$_) {
                const t = [];
                for (const s of this._$_audioFiles$_.values()) {
                    if (s._$isMusic$_) continue;
                    const i = this._$GetPreferredAudioFile$_(s.fileName);
                    i && t.push({
                        _$originalUrl$_: s.fileName,
                        url: this._$GetMediaFileUrl$_(i.fullName),
                        type: i.type,
                        fileSize: i.fileSize
                    });
                }
                return t;
            }
            return [];
        }
        _$_GetLocalBlobFromFileMap$_(t) {
            return "preview" === this._$_runtime$_._$GetExportType$_() && (t = new URL(t, location.href).toString()), 
            this._$_fileMap$_.get(t) || null;
        }
        _$_GetLocalBlobURLFromFileMap$_(t) {
            let s = this._$_fileMapBlobUrls$_.get(t);
            if (s) return s;
            const i = this._$_GetLocalBlobFromFileMap$_(t);
            return i ? (s = URL.createObjectURL(i), this._$_fileMapBlobUrls$_.set(t, s), s) : t;
        }
        _$GetIAssetManager$_() {
            return this._$_iAssetManager$_;
        }
        async _$LoadScripts$_(...t) {
            const s = await Promise.all(t.map((t => this._$GetProjectFileUrl$_(t))));
            if (this._$_runtime$_._$IsInWorker$_()) if (1 === t.length) {
                const s = t[0];
                await import((lp._$IsRelativeURL$_(s) ? "./" : "") + s);
            } else {
                const s = t.map((t => `import "${lp._$IsRelativeURL$_(t) ? "./" : ""}${t}";`)).join("\n"), i = URL.createObjectURL(new Blob([ s ], {
                    type: "application/javascript"
                }));
                await import(i);
            } else await Promise.all(s.map((t => up(t))));
        }
        async _$CompileWebAssembly$_(t) {
            if (WebAssembly.compileStreaming) {
                const s = await this._$GetProjectFileUrl$_(t);
                return await WebAssembly.compileStreaming(fetch(s));
            }
            {
                const s = await lp._$FetchArrayBuffer$_(t);
                return await WebAssembly.compile(s);
            }
        }
        async _$LoadStyleSheet$_(t) {
            const s = await this._$GetProjectFileUrl$_(t);
            return await this._$_runtime$_._$PostComponentMessageToDOMAsync$_("runtime", "add-stylesheet", {
                url: s
            });
        }
    };
}

{
    const dp = self._$C3$_;
    dp._$Asset$_ = class extends dp._$DefendedBase$_ {
        constructor(t, s) {
            super(), this._$_assetManager$_ = t, this._$_runtime$_ = t._$GetRuntime$_(), this._$_url$_ = s.url || "", 
            this._$_size$_ = s.size, this._$_loadPolicy$_ = s._$loadPolicy$_, this._$_blob$_ = s.blob || null, 
            this._$_isLoaded$_ = !!this._$_blob$_, this._$_loadPromise$_ = null;
        }
        _$Release$_() {
            this._$_loadPromise$_ = null, this._$_assetManager$_ = null, this._$_runtime$_ = null, 
            this._$_blob$_ = null;
        }
        _$GetURL$_() {
            return this._$_url$_;
        }
        _$GetSize$_() {
            return this._$_size$_;
        }
        _$Load$_() {
            return "local" === this._$_loadPolicy$_ || this._$_blob$_ ? (this._$_isLoaded$_ = !0, 
            Promise.resolve()) : (this._$_loadPromise$_ || (this._$_loadPromise$_ = this._$_assetManager$_._$FetchBlob$_(this._$_url$_, this._$_loadPolicy$_).then((t => (this._$_isLoaded$_ = !0, 
            this._$_loadPromise$_ = null, this._$_blob$_ = t, t))).catch((t => {
                console.error("Error loading resource: ", t), this._$_loadPromise$_ = null;
            }))), this._$_loadPromise$_);
        }
        _$IsLoaded$_() {
            return this._$_isLoaded$_;
        }
        _$GetBlob$_() {
            return this._$_blob$_ ? Promise.resolve(this._$_blob$_) : this._$_loadPromise$_ ? this._$_loadPromise$_ : this._$_assetManager$_._$FetchBlob$_(this._$_url$_, this._$_loadPolicy$_);
        }
    };
}

{
    const pp = self._$C3$_, mp = new pp._$PromiseThrottle$_, gp = new Set;
    pp._$ImageAsset$_ = class extends pp._$Asset$_ {
        constructor(t, s) {
            super(t, s), this._$_texturePromise$_ = null, this._$_webglTexture$_ = null, this._$_refCount$_ = 0, 
            this._$_imageWidth$_ = -1, this._$_imageHeight$_ = -1, gp.add(this);
        }
        _$Release$_() {
            if (0 !== this._$_refCount$_) throw new Error("released image asset which still has texture references");
            this._$_assetManager$_._$_ReleaseAsset$_(this), this._$_texturePromise$_ = null, 
            gp.delete(this), super._$Release$_();
        }
        static _$OnRendererContextLost$_() {
            for (const t of gp) t._$_texturePromise$_ = null, t._$_webglTexture$_ = null, t._$_refCount$_ = 0;
        }
        _$LoadStaticTexture$_(t, s) {
            return s = s || {}, this._$_refCount$_++, this._$_webglTexture$_ ? Promise.resolve(this._$_webglTexture$_) : (this._$_texturePromise$_ || (s._$anisotropy$_ = this._$_runtime$_._$GetCanvasManager$_()._$GetTextureAnisotropy$_(), 
            this._$_texturePromise$_ = this._$_DoLoadStaticTexture$_(t, s)), this._$_texturePromise$_);
        }
        async _$_DoLoadStaticTexture$_(t, s) {
            try {
                const i = await this._$GetBlob$_();
                return 0 === this._$_refCount$_ ? (this._$_texturePromise$_ = null, null) : await mp._$Add$_((async () => {
                    const e = await t._$CreateStaticTextureAsync$_(i, s);
                    return this._$_texturePromise$_ = null, 0 === this._$_refCount$_ ? (t._$DeleteTexture$_(e), 
                    null) : (this._$_webglTexture$_ = e, this._$_imageWidth$_ = e._$GetWidth$_(), this._$_imageHeight$_ = e._$GetHeight$_(), 
                    this._$_webglTexture$_);
                }));
            } catch (t) {
                throw console.error("Failed to load texture: ", t), t;
            }
        }
        _$ReleaseTexture$_() {
            if (this._$_refCount$_ <= 0) throw new Error("texture released too many times");
            this._$_refCount$_--, 0 === this._$_refCount$_ && this._$_webglTexture$_ && (this._$_webglTexture$_._$GetRenderer$_()._$DeleteTexture$_(this._$_webglTexture$_), 
            this._$_webglTexture$_ = null);
        }
        _$GetRefCount$_() {
            return this._$_refCount$_;
        }
        _$GetTexture$_() {
            return this._$_webglTexture$_;
        }
        _$GetWidth$_() {
            return this._$_imageWidth$_;
        }
        _$GetHeight$_() {
            return this._$_imageHeight$_;
        }
        async _$LoadToDrawable$_() {
            const t = await this._$GetBlob$_();
            return pp._$Supports$_.ImageBitmap ? await createImageBitmap(t) : await pp._$BlobToImage$_(t);
        }
    };
}

{
    let yp = function(t, s) {
        return t._$GetWorldInfo$_()._$_GetLastCachedZIndex$_() - s._$GetWorldInfo$_()._$_GetLastCachedZIndex$_();
    };
    0;
    const Mp = self._$C3$_;
    self.assert;
    Mp._$RenderCell$_ = class extends Mp._$DefendedBase$_ {
        constructor(t, s, i) {
            super(), this._$_grid$_ = t, this._$_x$_ = s, this._$_y$_ = i, this._$_instances$_ = [], 
            this._$_isSorted$_ = !0, this._$_pendingRemoval$_ = new Set, this._$_isAnyPendingRemoval$_ = !1;
        }
        _$Release$_() {
            Mp._$clearArray$_(this._$_instances$_), this._$_pendingRemoval$_.clear(), this._$_grid$_ = null;
        }
        _$Reset$_() {
            Mp._$clearArray$_(this._$_instances$_), this._$_isSorted$_ = !0, this._$_pendingRemoval$_.clear(), 
            this._$_isAnyPendingRemoval$_ = !1;
        }
        _$SetChanged$_() {
            this._$_isSorted$_ = !1;
        }
        _$IsEmpty$_() {
            return !this._$_instances$_.length || !(this._$_instances$_.length > this._$_pendingRemoval$_.size) && (this._$_FlushPending$_(), 
            !0);
        }
        _$Insert$_(t) {
            if (this._$_pendingRemoval$_.has(t)) return this._$_pendingRemoval$_.delete(t), 
            void (0 === this._$_pendingRemoval$_.size && (this._$_isAnyPendingRemoval$_ = !1));
            this._$_instances$_.push(t), this._$_isSorted$_ = 1 === this._$_instances$_.length;
        }
        _$Remove$_(t) {
            this._$_pendingRemoval$_.add(t), this._$_isAnyPendingRemoval$_ = !0, this._$_pendingRemoval$_.size >= 50 && this._$_FlushPending$_();
        }
        _$_FlushPending$_() {
            this._$_isAnyPendingRemoval$_ && (this._$_instances$_.length !== this._$_pendingRemoval$_.size ? (Mp._$arrayRemoveAllInSet$_(this._$_instances$_, this._$_pendingRemoval$_), 
            this._$_pendingRemoval$_.clear(), this._$_isAnyPendingRemoval$_ = !1) : this._$Reset$_());
        }
        _$_EnsureSorted$_() {
            this._$_isSorted$_ || (this._$_instances$_.sort(yp), this._$_isSorted$_ = !0);
        }
        _$Dump$_(t) {
            this._$_FlushPending$_(), this._$_EnsureSorted$_(), this._$_instances$_.length && t.push(this._$_instances$_);
        }
    };
}

{
    const wp = self._$C3$_;
    wp._$RenderGrid$_ = class extends wp._$DefendedBase$_ {
        constructor(t, s) {
            super(), this._$_cellWidth$_ = t, this._$_cellHeight$_ = s, this._$_cells$_ = wp._$New$_(wp._$PairMap$_);
        }
        _$Release$_() {
            this._$_cells$_._$Release$_(), this._$_cells$_ = null;
        }
        _$GetCell$_(t, s, i) {
            let e = this._$_cells$_._$Get$_(t, s);
            return e || (i ? (e = wp._$New$_(wp._$RenderCell$_, this, t, s), this._$_cells$_.Set(t, s, e), 
            e) : null);
        }
        _$XToCell$_(t) {
            return Math.floor(t / this._$_cellWidth$_);
        }
        _$YToCell$_(t) {
            return Math.floor(t / this._$_cellHeight$_);
        }
        _$Update$_(t, s, i) {
            if (s) for (let e = s._$getLeft$_(), n = s._$getRight$_(); e <= n; ++e) for (let n = s._$getTop$_(), h = s._$getBottom$_(); n <= h; ++n) {
                if (i && i._$containsPoint$_(e, n)) continue;
                const s = this._$GetCell$_(e, n, !1);
                s && (s._$Remove$_(t), s._$IsEmpty$_() && this._$_cells$_._$Delete$_(e, n));
            }
            if (i) for (let e = i._$getLeft$_(), n = i._$getRight$_(); e <= n; ++e) for (let n = i._$getTop$_(), h = i._$getBottom$_(); n <= h; ++n) s && s._$containsPoint$_(e, n) || this._$GetCell$_(e, n, !0)._$Insert$_(t);
        }
        _$QueryRange$_(t, s) {
            let i = this._$XToCell$_(t._$getLeft$_());
            const e = this._$YToCell$_(t._$getTop$_()), n = this._$XToCell$_(t._$getRight$_()), h = this._$YToCell$_(t._$getBottom$_());
            for (;i <= n; ++i) for (let t = e; t <= h; ++t) {
                const e = this._$GetCell$_(i, t, !1);
                e && e._$Dump$_(s);
            }
        }
        _$MarkRangeChanged$_(t) {
            let s = t._$getLeft$_();
            const i = t._$getTop$_(), e = t._$getRight$_(), n = t._$getBottom$_();
            for (;s <= e; ++s) for (let t = i; t <= n; ++t) {
                const i = this._$GetCell$_(s, t, !1);
                i && i._$SetChanged$_();
            }
        }
    };
}

{
    let Sp = function(t, s) {
        return t._$GetWorldInfo$_()._$_GetLastCachedZIndex$_() - s._$GetWorldInfo$_()._$_GetLastCachedZIndex$_();
    }, bp = function(t, s) {
        return t._$GetWorldInfo$_()._$GetZElevation$_() - s._$GetWorldInfo$_()._$GetZElevation$_();
    };
    0;
    const Tp = self._$C3$_, vp = (self.assert, new Tp.Rect), xp = new Tp._$Quad$_, Ip = [], Gp = (new Tp.Rect, 
    new Tp.Rect, self._$glMatrix$_), Cp = Gp._$vec3$_, _p = Gp._$vec4$_, Ep = Gp._$mat4$_, Dp = Ep.create(), Ap = Cp.create(), Np = _p.create(), Lp = Cp.create(), Op = Cp.create(), Rp = Cp.create(), Pp = Tp._$New$_(Tp._$Vector2$_), kp = (Tp._$New$_(Tp.Rect), 
    []), Fp = [], jp = [], Bp = {
        name: "",
        _$sid$_: -1,
        _$isDynamic$_: !1,
        isVisible: !0,
        _$isInteractive$_: !0,
        _$isHTMLElementsLayer$_: !1,
        backgroundColor: [ 1, 1, 1, 1 ],
        _$isTransparent$_: !0,
        _$parallax$_: [ 1, 1 ],
        opacity: 1,
        _$isForceOwnTexture$_: !1,
        _$renderAs3d$_: !1,
        _$useCameraDistanceDrawOrder$_: !1,
        _$useRenderCells$_: !1,
        _$scaleRate$_: 1,
        _$blendMode$_: 0,
        _$zElevation$_: 0,
        _$initialInstancesData$_: [],
        _$effectListData$_: [],
        _$subLayersData$_: []
    };
    Tp._$Layer$_ = class extends Tp._$DefendedBase$_ {
        constructor(t, s, i) {
            super(), i = Object.assign({}, Bp, i), this._$_layout$_ = t, this._$_runtime$_ = t._$GetRuntime$_(), 
            this._$_parentLayer$_ = s, this._$_name$_ = i.name, this._$_index$_ = -1, this._$_isHTMLElementsLayer$_ = !!i._$isHTMLElementsLayer$_, 
            this._$_htmlIndex$_ = -1, this._$_sid$_ = i._$sid$_, this._$_isDynamic$_ = !!i._$isDynamic$_, 
            this._$_isVisible$_ = !!i.isVisible, this._$_isInteractive$_ = !!i._$isInteractive$_, 
            this._$_backgroundColor$_ = Tp._$New$_(Tp._$Color$_), this._$_backgroundColor$_._$setFromJSON$_(i.backgroundColor), 
            this._$_isTransparent$_ = !!i._$isTransparent$_, this._$_parallaxX$_ = i._$parallax$_[0], 
            this._$_parallaxY$_ = i._$parallax$_[1], this._$_color$_ = Tp._$New$_(Tp._$Color$_, 1, 1, 1, i.opacity), 
            this._$_premultipliedColor$_ = Tp._$New$_(Tp._$Color$_), this._$_isForceOwnTexture$_ = !!i._$isForceOwnTexture$_, 
            this._$_renderAs3d$_ = !!i._$renderAs3d$_, this._$_useCameraDistanceDrawOrder$_ = !!i._$useCameraDistanceDrawOrder$_, 
            this._$_useRenderCells$_ = !!i._$useRenderCells$_, this._$_scaleRate$_ = i._$scaleRate$_, 
            this._$_blendMode$_ = i._$blendMode$_, this._$_curRenderTarget$_ = null, this._$_scale$_ = 1, 
            this._$_zElevation$_ = i._$zElevation$_, this._$_angle$_ = 0, this._$_scrollX$_ = 0, 
            this._$_scrollY$_ = 0, this._$_hasOwnScrollPosition$_ = !1, this._$_viewport$_ = Tp._$New$_(Tp.Rect), 
            this._$_viewportZ0$_ = Tp._$New$_(Tp.Rect), this._$_viewport3D$_ = Tp._$New$_(Tp.Rect), 
            this._$_isViewportChanged$_ = !0, this._$_projectionMatrix$_ = Ep.create(), this._$_isProjectionMatrixChanged$_ = !0, 
            this._$_modelViewMatrix$_ = Ep.create(), this._$_isMVMatrixChanged$_ = !0, this._$_viewFrustum$_ = Tp._$New$_(Tp._$Gfx$_._$ViewFrustum$_), 
            this._$_isViewFrustumChanged$_ = !0, this._$_startupInitialInstances$_ = [], this._$_initialInstancesData$_ = i._$initialInstancesData$_, 
            this._$_initialInstances$_ = [], this._$_createdGlobalUids$_ = [], this._$_initialUIDsToInstanceData$_ = new Map, 
            this._$_instances$_ = [], this._$_zIndicesUpToDate$_ = !1, this._$_htmlZIndicesUpToDate$_ = !1, 
            this._$_anyInstanceZElevated$_ = !1;
            const e = this._$_runtime$_._$GetCanvasManager$_();
            this._$_effectList$_ = Tp._$New$_(Tp._$EffectList$_, this, i._$effectListData$_), 
            this._$_effectChain$_ = Tp._$New$_(Tp._$Gfx$_._$EffectChain$_, e._$GetEffectChainManager$_(), {
                _$drawContent$_: (t, s) => {
                    const i = s._$GetContentObject$_(), n = i._$GetRenderTarget$_();
                    t._$SetColor$_(i._$GetPremultipliedColor$_()), t._$DrawRenderTarget$_(n), t._$InvalidateRenderTarget$_(n), 
                    e._$ReleaseAdditionalRenderTarget$_(n);
                },
                _$getShaderParameters$_: t => this._$GetEffectList$_()._$_GetEffectChainShaderParametersForIndex$_(t)
            }), this._$_needsRebuildEffectChainSteps$_ = !0, this._$_wasDefaultColor$_ = !0, 
            this._$_renderGrid$_ = null, this._$_lastRenderList$_ = [], this._$_isRenderListUpToDate$_ = !1, 
            this._$_lastRenderCells$_ = Tp._$New$_(Tp.Rect, 0, 0, -1, -1), this._$_curRenderCells$_ = Tp._$New$_(Tp.Rect, 0, 0, -1, -1), 
            this._$_iLayer$_ = new self._$ILayer$_(this), this._$_UpdatePremultipliedColor$_(), 
            this._$UsesRenderCells$_() && (this._$_renderGrid$_ = Tp._$New$_(Tp._$RenderGrid$_, this._$_runtime$_._$GetOriginalViewportWidth$_(), this._$_runtime$_._$GetOriginalViewportHeight$_())), 
            this._$_subLayers$_ = i._$subLayersData$_.map((t => Tp._$Layer$_._$CreateFromExportData$_(this._$_layout$_, this, t)));
        }
        _$_InitInitialInstances$_() {
            for (const t of this._$_initialInstancesData$_) {
                const s = this._$_runtime$_._$GetObjectClassByIndex$_(t[1]);
                this._$_layout$_._$_AddInitialObjectClass$_(s), s._$GetDefaultInstanceData$_() || (s._$SetDefaultInstanceData$_(t), 
                s._$_SetDefaultLayerIndex$_(this._$_index$_)), this._$_initialInstances$_.push(t), 
                this._$_initialUIDsToInstanceData$_.set(t[2], t);
            }
            Tp._$shallowAssignArray$_(this._$_startupInitialInstances$_, this._$_initialInstances$_), 
            this._$_initialInstancesData$_ = null;
        }
        static _$CreateFromExportData$_(t, s, i) {
            return Tp._$New$_(Tp._$Layer$_, t, s, {
                name: i[0],
                _$sid$_: i[2],
                isVisible: i[3],
                _$isInteractive$_: i[13],
                _$isHTMLElementsLayer$_: i[19],
                backgroundColor: i[4].map((t => t / 255)),
                _$isTransparent$_: i[5],
                _$parallax$_: [ i[6], i[7] ],
                opacity: i[8],
                _$isForceOwnTexture$_: i[9],
                _$renderAs3d$_: i[17],
                _$useCameraDistanceDrawOrder$_: i[18],
                _$useRenderCells$_: i[10],
                _$scaleRate$_: i[11],
                _$blendMode$_: i[12],
                _$zElevation$_: i[16],
                _$initialInstancesData$_: i[14],
                _$effectListData$_: i[15],
                _$subLayersData$_: i[20]
            });
        }
        _$Release$_() {
            for (const t of this._$_subLayers$_) t._$Release$_();
            Tp._$clearArray$_(this._$_subLayers$_);
            for (const t of this._$_instances$_) this._$_runtime$_._$DestroyInstance$_(t);
            Tp._$clearArray$_(this._$_instances$_), this._$_effectList$_._$Release$_(), this._$_effectList$_ = null, 
            this._$_effectChain$_._$Release$_(), this._$_effectChain$_ = null, this._$_iLayer$_ = null, 
            this._$_parentLayer$_ = null, this._$_layout$_ = null, this._$_runtime$_ = null;
        }
        _$GetInitialInstanceData$_(t) {
            return this._$_initialUIDsToInstanceData$_.get(t);
        }
        _$CreateInitialInstances$_(t) {
            const s = this._$_layout$_._$IsFirstVisit$_();
            let i = 0;
            const e = this._$_initialInstances$_;
            for (let n = 0, h = e.length; n < h; ++n) {
                const h = e[n], r = this._$_runtime$_._$GetObjectClassByIndex$_(h[1]);
                let o = !0;
                if (!r._$HasPersistBehavior$_() || s) {
                    const s = this._$_runtime$_._$CreateInstanceFromData$_(h, this, !0);
                    t.push(s), r._$IsGlobal$_() && (o = !1, this._$_createdGlobalUids$_.push(s._$GetUID$_()));
                }
                o && (e[i] = e[n], ++i);
            }
            Tp._$truncateArray$_(e, i), this._$_runtime$_._$FlushPendingInstances$_(), this._$SetZIndicesChanged$_();
        }
        _$_AddInstance$_(t, s) {
            if (!t._$GetPlugin$_()._$IsWorldType$_()) throw new Error("instance is not of world type");
            const i = t._$GetWorldInfo$_();
            if (i._$GetLayer$_() !== this) throw new Error("instance added to wrong layer");
            this._$_instances$_.push(t), 0 !== i._$GetZElevation$_() && (this._$_anyInstanceZElevated$_ = !0), 
            s && this._$UsesRenderCells$_() && t._$GetWorldInfo$_()._$SetBboxChanged$_(), this._$SetZIndicesChanged$_(t);
        }
        _$_MaybeAddInstance$_(t) {
            this._$_instances$_.includes(t) || (this._$_instances$_.push(t), 0 !== t._$GetWorldInfo$_()._$GetZElevation$_() && (this._$_anyInstanceZElevated$_ = !0), 
            this._$SetZIndicesChanged$_(t));
        }
        _$_PrependInstance$_(t, s) {
            const i = t._$GetWorldInfo$_();
            if (i._$GetLayer$_() !== this) throw new Error("instance added to wrong layer");
            this._$_instances$_.unshift(t), 0 !== i._$GetZElevation$_() && (this._$_anyInstanceZElevated$_ = !0), 
            this._$SetZIndicesChanged$_(t), s && this._$UsesRenderCells$_() && t._$GetWorldInfo$_()._$SetBboxChanged$_();
        }
        _$_RemoveInstance$_(t, s) {
            const i = this._$_instances$_.indexOf(t);
            i < 0 || (s && this._$UsesRenderCells$_() && t._$GetWorldInfo$_()._$_RemoveFromRenderCells$_(), 
            this._$_instances$_.splice(i, 1), this._$SetZIndicesChanged$_(t), this._$_MaybeResetAnyInstanceZElevatedFlag$_());
        }
        _$_SetAnyInstanceZElevated$_() {
            this._$_anyInstanceZElevated$_ = !0;
        }
        _$_MaybeResetAnyInstanceZElevatedFlag$_() {
            0 === this._$_instances$_.length && (this._$_anyInstanceZElevated$_ = !1);
        }
        _$_SortInstancesByLastCachedZIndex$_(t) {
            if (t) {
                const t = new Set;
                for (const s of this._$_instances$_) {
                    const i = s._$GetWorldInfo$_()._$_GetLastCachedZIndex$_();
                    i >= 0 && t.add(i);
                }
                let s = -1;
                for (const i of this._$_instances$_) {
                    const e = i._$GetWorldInfo$_();
                    if (!(e._$_GetLastCachedZIndex$_() >= 0)) {
                        for (++s; t.has(s); ) ++s;
                        e._$_SetZIndex$_(s);
                    }
                }
            }
            this._$_instances$_.sort(Sp);
        }
        _$_Start$_() {}
        _$_End$_() {
            for (const t of this._$_instances$_) t._$GetObjectClass$_()._$IsGlobal$_() || this._$_runtime$_._$DestroyInstance$_(t);
            this._$_runtime$_._$FlushPendingInstances$_(), Tp._$clearArray$_(this._$_instances$_), 
            this._$_anyInstanceZElevated$_ = !1, this._$SetZIndicesChanged$_();
        }
        _$RecreateInitialObjects$_(t, s, i, e, n, h) {
            const r = this._$_runtime$_._$GetEventSheetManager$_(), o = this._$_runtime$_._$GetAllObjectClasses$_(), a = t._$IsFamily$_(), u = [];
            for (const l of this._$_initialInstances$_) {
                const c = l[0], f = c[0], d = c[1];
                if (!s._$containsPoint$_(f, d)) continue;
                const p = o[l[1]];
                if (p !== t) {
                    if (!a) continue;
                    if (!t._$FamilyHasMember$_(p)) continue;
                }
                let m = n;
                if (!m) {
                    const t = this._$_runtime$_._$GetCurrentLayout$_();
                    this._$GetLayout$_() === t ? m = this : (m = t._$GetLayerByName$_(this._$GetName$_()), 
                    m || (m = t._$GetLayerByIndex$_(this._$GetIndex$_())));
                }
                const g = this._$_runtime$_._$CreateInstanceFromData$_(l, m, !1, void 0, void 0, !1, h);
                m._$SortAndAddInstancesByZIndex$_(g);
                const y = g._$GetWorldInfo$_();
                y._$OffsetXY$_(i, e), y._$SetBboxChanged$_(), r._$BlockFlushingInstances$_(!0), 
                g._$_TriggerOnCreatedOnSelfAndRelated$_(), r._$BlockFlushingInstances$_(!1), u.push(g);
            }
            return u;
        }
        _$GetInstanceCount$_() {
            return this._$_instances$_.length;
        }
        _$GetLayout$_() {
            return this._$_layout$_;
        }
        _$GetName$_() {
            return this._$_name$_;
        }
        _$_SetIndex$_(t) {
            this._$_index$_ = t;
        }
        _$GetIndex$_() {
            return this._$_index$_;
        }
        _$_SetHTMLIndex$_(t) {
            this._$_htmlIndex$_ = t;
        }
        _$GetHTMLIndex$_() {
            return this._$_htmlIndex$_;
        }
        _$IsHTMLElementsLayer$_() {
            return this._$_isHTMLElementsLayer$_;
        }
        _$SetIsHTMLElementsLayer$_(t) {
            t = !!t, this._$_isHTMLElementsLayer$_ !== t && (this._$_isHTMLElementsLayer$_ = t, 
            this._$_layout$_._$_ReindexAndUpdateAllLayers$_(), this._$_runtime$_._$UpdateRender$_());
        }
        _$_GetSiblingIndex$_() {
            let t = -1;
            const s = this._$GetParentLayer$_();
            return t = s ? s._$GetSubLayers$_().indexOf(this) : this._$GetLayout$_()._$_GetRootLayers$_().indexOf(this), 
            t;
        }
        _$GetSID$_() {
            return this._$_sid$_;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$IsDynamic$_() {
            return this._$_isDynamic$_;
        }
        _$HasAnyDynamicParentLayer$_() {
            for (const t of this._$parentLayers$_()) if (t._$IsDynamic$_()) return !0;
            return !1;
        }
        _$GetDevicePixelRatio$_() {
            return this._$_runtime$_._$GetDevicePixelRatio$_();
        }
        _$GetEffectList$_() {
            return this._$_effectList$_;
        }
        _$GetEffectChain$_() {
            return this._$_MaybeRebuildEffectChainSteps$_(), this._$_effectChain$_;
        }
        _$_MaybeRebuildEffectChainSteps$_() {
            const t = this._$HasDefaultColor$_();
            if (!this._$_needsRebuildEffectChainSteps$_ && t === this._$_wasDefaultColor$_ && !this._$_effectChain$_._$NeedsRebuild$_()) return;
            const s = this._$GetEffectList$_()._$GetActiveEffectTypes$_();
            this._$_effectChain$_._$BuildSteps$_(s.map((t => t._$GetShaderProgram$_())), {
                _$indexMap$_: s.map((t => t._$GetIndex$_())),
                _$forcePreDraw$_: !t,
                _$useFullSurface$_: !0
            }), this._$_needsRebuildEffectChainSteps$_ = !1, this._$_wasDefaultColor$_ = t;
        }
        _$UpdateActiveEffects$_() {
            this._$GetEffectList$_()._$UpdateActiveEffects$_(), this._$_needsRebuildEffectChainSteps$_ = !0;
        }
        _$UsesRenderCells$_() {
            return this._$_useRenderCells$_ && !this._$_useCameraDistanceDrawOrder$_;
        }
        _$GetRenderGrid$_() {
            return this._$_renderGrid$_;
        }
        _$SetRenderListStale$_() {
            this._$_isRenderListUpToDate$_ = !1;
        }
        _$IsVisible$_() {
            for (const t of this._$selfAndParentLayers$_()) if (!t._$_IsVisibleFlagSet$_()) return !1;
            return !0;
        }
        _$_IsVisibleFlagSet$_() {
            return this._$_isVisible$_;
        }
        _$SetVisible$_(t) {
            t = !!t, this._$_isVisible$_ !== t && (this._$_isVisible$_ = t, this._$_runtime$_._$UpdateRender$_());
        }
        _$SetInteractive$_(t) {
            this._$_isInteractive$_ = !!t;
        }
        _$IsInteractive$_() {
            return this._$_isInteractive$_;
        }
        _$IsSelfAndParentsInteractive$_() {
            for (const t of this._$selfAndParentLayers$_()) if (!t._$IsInteractive$_()) return !1;
            return !0;
        }
        _$SetOwnScrollPositionEnabled$_(t) {
            if (t = !!t, this._$_hasOwnScrollPosition$_ !== t) {
                if (this._$_hasOwnScrollPosition$_ = t, t) {
                    const t = this._$GetLayout$_();
                    this._$_scrollX$_ = t._$GetScrollX$_(), this._$_scrollY$_ = t._$GetScrollY$_();
                }
                this._$_SetMVMatrixChanged$_(), this._$_runtime$_._$UpdateRender$_();
            }
        }
        _$IsOwnScrollPositionEnabled$_() {
            return this._$_hasOwnScrollPosition$_;
        }
        _$SetScrollX$_(t) {
            const s = this._$GetLayout$_(), i = s._$GetScrollLeftBound$_(), e = s._$GetScrollRightBound$_();
            t > e && (t = e), t < i && (t = i), this._$_scrollX$_ !== t && (this._$_scrollX$_ = t, 
            this._$IsOwnScrollPositionEnabled$_() && (this._$_SetMVMatrixChanged$_(), this._$_runtime$_._$UpdateRender$_()));
        }
        _$SetScrollY$_(t) {
            const s = this._$GetLayout$_(), i = s._$GetScrollTopBound$_(), e = s._$GetScrollBottomBound$_();
            t > e && (t = e), t < i && (t = i), this._$_scrollY$_ !== t && (this._$_scrollY$_ = t, 
            this._$IsOwnScrollPositionEnabled$_() && (this._$_SetMVMatrixChanged$_(), this._$_runtime$_._$UpdateRender$_()));
        }
        _$GetScrollX$_() {
            return this._$IsOwnScrollPositionEnabled$_() ? this._$_scrollX$_ : this._$GetLayout$_()._$GetScrollX$_();
        }
        _$GetScrollY$_() {
            return this._$IsOwnScrollPositionEnabled$_() ? this._$_scrollY$_ : this._$GetLayout$_()._$GetScrollY$_();
        }
        _$GetViewport$_() {
            return this._$_MaybeUpdateViewport$_(), this._$_viewport$_;
        }
        _$_GetViewportZ0$_() {
            return this._$_MaybeUpdateViewport$_(), this._$_viewportZ0$_;
        }
        _$GetViewport3D$_() {
            return this._$_MaybeUpdateViewport$_(), this._$_viewport3D$_;
        }
        _$_GetVanishingPoint$_() {
            const t = this._$GetLayout$_();
            return [ t._$GetVanishingPointX$_(), t._$GetVanishingPointY$_() ];
        }
        _$GetDefaultCameraZ$_(t) {
            return this._$_runtime$_._$GetDefaultCameraZ$_(t);
        }
        _$GetViewportForZ$_(t, s) {
            const i = this._$_GetViewportZ0$_();
            if (0 === t) s._$copy$_(i); else {
                let e = i._$midX$_(), n = i._$midY$_();
                const h = this._$Get2DScaleFactorToZ$_(t), r = i.width() / h, o = i.height() / h, [a, u] = this._$_GetVanishingPoint$_();
                if (.5 !== a || .5 !== u) {
                    const s = this._$Get2DCameraZ$_(), i = this._$_runtime$_, h = this._$GetDefaultCameraZ$_() / s;
                    let r = (a - .5) * i._$GetViewportWidth$_() / h, o = (u - .5) * i._$GetViewportHeight$_() / h;
                    const l = this._$GetAngle$_();
                    0 !== l && (Pp.set(r, o), Pp.rotate(l), r = Pp._$getX$_(), o = Pp._$getY$_());
                    const c = Tp._$unlerp$_(s, 0, t);
                    e += Tp._$lerp$_(r, 0, c), n += Tp._$lerp$_(o, 0, c);
                }
                s.set(e - r / 2, n - o / 2, e + r / 2, n + o / 2);
            }
        }
        _$GetOpacity$_() {
            return this._$_color$_._$getA$_();
        }
        _$SetOpacity$_(t) {
            t = Tp._$clamp$_(t, 0, 1), this._$_color$_._$getA$_() !== t && (this._$_color$_._$setA$_(t), 
            this._$_UpdatePremultipliedColor$_(), this._$_runtime$_._$UpdateRender$_());
        }
        _$_UpdatePremultipliedColor$_() {
            this._$_premultipliedColor$_._$copy$_(this._$_color$_), this._$_premultipliedColor$_._$premultiply$_();
        }
        _$GetPremultipliedColor$_() {
            return this._$_premultipliedColor$_;
        }
        _$HasDefaultColor$_() {
            return this._$_color$_._$equalsRgba$_(1, 1, 1, 1);
        }
        _$GetScaleRate$_() {
            return this._$_scaleRate$_;
        }
        _$SetScaleRate$_(t) {
            this._$_scaleRate$_ !== t && (this._$_scaleRate$_ = t, this._$_SetMVMatrixChanged$_(), 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$GetParallaxX$_() {
            return this._$_parallaxX$_;
        }
        _$GetParallaxY$_() {
            return this._$_parallaxY$_;
        }
        _$SetParallax$_(t, s) {
            this._$_parallaxX$_ === t && this._$_parallaxY$_ === s || (this._$_parallaxX$_ = t, 
            this._$_parallaxY$_ = s, this._$_SetMVMatrixChanged$_(), this._$_runtime$_._$UpdateRender$_());
        }
        _$SetParallaxX$_(t) {
            this._$SetParallax$_(t, this._$GetParallaxY$_());
        }
        _$SetParallaxY$_(t) {
            this._$SetParallax$_(this._$GetParallaxX$_(), t);
        }
        _$SetZElevation$_(t) {
            this._$_zElevation$_ !== t && (this._$_zElevation$_ = t, this._$_runtime$_._$UpdateRender$_());
        }
        _$GetZElevation$_() {
            return this._$_zElevation$_;
        }
        _$SetAngle$_(t) {
            t = Tp._$clampAngle$_(t), this._$_angle$_ !== t && (this._$_angle$_ = t, this._$_SetMVMatrixChanged$_(), 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$GetAngle$_() {
            return Tp._$clampAngle$_(this._$_layout$_._$GetAngle$_() + this._$_angle$_);
        }
        _$GetOwnAngle$_() {
            return this._$_angle$_;
        }
        _$HasInstances$_() {
            return this._$_instances$_.length > 0;
        }
        _$_GetInstances$_() {
            return this._$_instances$_;
        }
        _$_GetInstancesInDrawOrder$_() {
            return this._$RendersIn3DMode$_() && this._$_useCameraDistanceDrawOrder$_ ? (Tp._$shallowAssignArray$_(jp, this._$_GetInstances$_()), 
            jp.sort(((t, s) => this._$_SortInstancesByCameraDistance$_(t, s))), jp) : this._$_GetInstances$_();
        }
        _$_AppendAllInstancesIncludingSubLayersInDrawOrder$_(t) {
            Tp._$appendArray$_(t, this._$_GetInstancesInDrawOrder$_());
            for (const s of this._$_subLayers$_) s._$IsVisible$_() && s._$GetOpacity$_() > 0 && s._$_AppendAllInstancesIncludingSubLayersInDrawOrder$_(t);
        }
        _$_SortInstancesByCameraDistance$_(t, s) {
            const i = this._$GetLayout$_()._$Get3DCameraPosition$_(), e = i[0], n = i[1], h = i[2], r = t._$GetWorldInfo$_(), o = s._$GetWorldInfo$_(), a = r._$GetX$_() - e, u = r._$GetY$_() - n, l = r._$GetZElevation$_() - h, c = o._$GetX$_() - e, f = o._$GetY$_() - n, d = o._$GetZElevation$_() - h;
            return c * c + f * f + d * d - (a * a + u * u + l * l);
        }
        _$GetBackgroundColor$_() {
            return this._$_backgroundColor$_;
        }
        _$IsTransparent$_() {
            return this._$_isTransparent$_;
        }
        _$SetTransparent$_(t) {
            t = !!t, this._$_isTransparent$_ !== t && (this._$_isTransparent$_ = t, this._$_runtime$_._$UpdateRender$_());
        }
        _$IsForceOwnTexture$_() {
            return this._$_isForceOwnTexture$_;
        }
        _$SetForceOwnTexture$_(t) {
            t = !!t, this._$_isForceOwnTexture$_ !== t && (this._$_isForceOwnTexture$_ = t, 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$SetRenderAs3D$_(t) {
            t = !!t, this._$_renderAs3d$_ !== t && (this._$_renderAs3d$_ = t, this._$_SetMVMatrixChanged$_(), 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$IsRenderAs3D$_() {
            return this._$_renderAs3d$_;
        }
        _$RendersIn2DMode$_() {
            return !this._$GetRuntime$_()._$Uses3DFeatures$_() || !this._$_renderAs3d$_;
        }
        _$RendersIn3DMode$_() {
            return !this._$RendersIn2DMode$_();
        }
        _$Has3DCamera$_() {
            return this._$RendersIn3DMode$_() && this._$GetLayout$_()._$Is3DCameraEnabled$_();
        }
        _$SelfAndAllSubLayersHave3DCamera$_() {
            if (!this._$Has3DCamera$_()) return !1;
            for (const t of this._$_subLayers$_) if (!t._$SelfAndAllSubLayersHave3DCamera$_()) return !1;
            return !0;
        }
        _$SetBlendMode$_(t) {
            this._$_blendMode$_ !== t && (this._$_blendMode$_ = t, this._$_runtime$_._$UpdateRender$_());
        }
        _$GetBlendMode$_() {
            return this._$_blendMode$_;
        }
        _$IsRootLayer$_() {
            return !this._$_parentLayer$_;
        }
        _$GetParentLayer$_() {
            return this._$_parentLayer$_;
        }
        _$_SetParentLayer$_(t) {
            this._$_parentLayer$_ = t;
        }
        _$GetSubLayers$_() {
            return this._$_subLayers$_;
        }
        _$HasAnySubLayers$_() {
            return this._$_subLayers$_.length > 0;
        }
        _$_AddSubLayer$_(t, s = !0) {
            s ? this._$_subLayers$_.push(t) : this._$_subLayers$_.unshift(t);
        }
        _$_InsertSubLayer$_(t, s, i) {
            let e = this._$_subLayers$_.indexOf(s);
            if (-1 === e) throw new Error("cannot find layer to insert by");
            i && ++e, this._$_subLayers$_.splice(e, 0, t);
        }
        _$_RemoveSubLayer$_(t) {
            const s = this._$_subLayers$_.indexOf(t);
            if (-1 === s) throw new Error("cannot find layer to remove");
            this._$_subLayers$_.splice(s, 1);
        }
        _$HasAnyVisibleSubLayer$_() {
            for (const t of this._$_subLayers$_) if (t._$ShouldDraw$_()) return !0;
            return !1;
        }
        * _$selfAndAllSubLayers$_() {
            for (const t of this._$_subLayers$_) yield* t._$selfAndAllSubLayers$_();
            yield this;
        }
        * _$parentLayers$_() {
            let t = this._$GetParentLayer$_();
            for (;t; ) yield t, t = t._$GetParentLayer$_();
        }
        * _$selfAndParentLayers$_() {
            yield this, yield* this._$parentLayers$_();
        }
        _$HasParentLayer$_(t) {
            for (const s of this._$parentLayers$_()) if (s === t) return !0;
            return !1;
        }
        _$IsTransformCompatibleWith$_(t) {
            return this === t || this._$_parallaxX$_ === t._$_parallaxX$_ && this._$_parallaxY$_ === t._$_parallaxY$_ && this._$_scale$_ === t._$_scale$_ && this._$_scaleRate$_ === t._$_scaleRate$_ && this._$_angle$_ === t._$_angle$_ && this._$GetScrollX$_() === t._$GetScrollX$_() && this._$GetScrollY$_() === t._$GetScrollY$_();
        }
        _$SaveTransform$_() {
            return {
                parallaxX: this._$GetParallaxX$_(),
                parallaxY: this._$GetParallaxY$_(),
                scale: this._$GetOwnScale$_(),
                scaleRate: this._$GetScaleRate$_(),
                angle: this._$GetOwnAngle$_(),
                hasOwnScroll: this._$IsOwnScrollPositionEnabled$_(),
                scrollX: this._$GetScrollX$_(),
                scrollY: this._$GetScrollY$_()
            };
        }
        _$RestoreTransform$_(t) {
            this._$SetParallax$_(t.parallaxX, t.parallaxY), this._$SetOwnScale$_(t.scale), this._$SetScaleRate$_(t.scaleRate), 
            this._$SetAngle$_(t.angle), this._$SetOwnScrollPositionEnabled$_(t.hasOwnScroll), 
            this._$SetScrollX$_(t.scrollX), this._$SetScrollY$_(t.scrollY), this._$_MaybeUpdateViewport$_();
        }
        _$_RemoveAllInstancesInSet$_(t) {
            0 !== t.size && Tp._$arrayRemoveAllInSet$_(this._$_instances$_, t) > 0 && (this._$_MaybeResetAnyInstanceZElevatedFlag$_(), 
            this._$SetZIndicesChanged$_());
        }
        _$SetZIndicesChanged$_(t) {
            this._$_zIndicesUpToDate$_ = !1, this._$_isRenderListUpToDate$_ = !1, t && !t._$GetObjectClass$_()._$GetPlugin$_()._$IsHTMLElementType$_() || (this._$_htmlZIndicesUpToDate$_ = !1);
        }
        _$_UpdateZIndices$_() {
            if (!this._$_zIndicesUpToDate$_) {
                if (this._$_instances$_.sort(bp), this._$UsesRenderCells$_()) for (let t = 0, s = this._$_instances$_.length; t < s; ++t) {
                    const s = this._$_instances$_[t]._$GetWorldInfo$_();
                    s._$_SetZIndex$_(t), this._$_renderGrid$_._$MarkRangeChanged$_(s._$GetRenderCellRange$_());
                } else for (let t = 0, s = this._$_instances$_.length; t < s; ++t) this._$_instances$_[t]._$GetWorldInfo$_()._$_SetZIndex$_(t);
                this._$_zIndicesUpToDate$_ = !0;
            }
        }
        _$_UpdateHTMLZIndices$_() {
            if (this._$_htmlZIndicesUpToDate$_) return;
            const t = this._$_layout$_._$GetRootLayersForHTMLLayer$_(this._$GetHTMLIndex$_()).map((t => [ ...t._$selfAndAllSubLayers$_() ])).flat();
            let s = 0;
            for (const i of t) {
                for (const t of i._$_GetInstances$_()) t._$GetObjectClass$_()._$GetPlugin$_()._$IsHTMLElementType$_() && t._$GetWorldInfo$_()._$_SetHTMLZIndex$_(s++);
                i._$_SetHTMLZIndicesUpToDate$_();
            }
        }
        _$_SetHTMLZIndicesUpToDate$_() {
            this._$_htmlZIndicesUpToDate$_ = !0;
        }
        _$_GetHTMLLayerDOMState$_() {
            return {
                isVisible: this._$IsVisible$_(),
                opacity: this._$GetOpacity$_(),
                isInteractive: this._$IsInteractive$_()
            };
        }
        _$MoveInstanceAdjacent$_(t, s, i) {
            const e = t._$GetWorldInfo$_(), n = s._$GetWorldInfo$_();
            if (e._$GetLayer$_() !== this || n._$GetLayer$_() !== this) throw new Error("can't arrange Z order unless both objects on this layer");
            const h = e._$GetZIndex$_();
            let r = n._$GetZIndex$_();
            return h !== r + (i ? 1 : -1) && (Tp._$arrayRemove$_(this._$_instances$_, h), h < r && r--, 
            i && r++, r === this._$_instances$_.length ? this._$_instances$_.push(t) : this._$_instances$_.splice(r, 0, t), 
            this._$SetZIndicesChanged$_(t), !0);
        }
        _$_MergeSortedZArrays$_(t, s) {
            const i = [];
            let e = 0, n = 0, h = t.length, r = s.length;
            for (;e < h && n < r; ) {
                const h = t[e], r = s[n];
                h._$GetWorldInfo$_()._$_GetLastCachedZIndex$_() < r._$GetWorldInfo$_()._$_GetLastCachedZIndex$_() ? (i.push(h), 
                ++e) : (i.push(r), ++n);
            }
            for (;e < h; ++e) i.push(t[e]);
            for (;n < r; ++n) i.push(s[n]);
            return i;
        }
        _$_MergeAllSortedZArrays_pass$_(t) {
            const s = [], i = t.length;
            for (let e = 0; e < i - 1; e += 2) {
                const i = t[e], n = t[e + 1];
                s.push(this._$_MergeSortedZArrays$_(i, n));
            }
            return i % 2 == 1 && s.push(t[i - 1]), s;
        }
        _$_MergeAllSortedZArrays$_(t) {
            for (;t.length > 1; ) t = this._$_MergeAllSortedZArrays_pass$_(t);
            return t[0];
        }
        _$_GetRenderCellInstancesToDraw$_() {
            return this._$_UpdateZIndices$_(), Tp._$clearArray$_(Ip), this._$_renderGrid$_._$QueryRange$_(this._$GetViewport$_(), Ip), 
            Ip.length ? 1 === Ip.length ? Ip[0] : this._$_MergeAllSortedZArrays$_(Ip) : [];
        }
        _$ShouldDraw$_() {
            return this._$IsVisible$_() && this._$GetOpacity$_() > 0 && this._$_DrawsAnyContentInSelfOrSubLayers$_();
        }
        _$_DrawsAnyContentInSelfOrSubLayers$_() {
            if (this._$HasInstances$_() || !this._$IsTransparent$_()) return !0;
            for (const t of this._$_subLayers$_) if (t._$_DrawsAnyContentInSelfOrSubLayers$_()) return !0;
            return !1;
        }
        _$UsesOwnTexture$_() {
            return this._$IsForceOwnTexture$_() || !this._$HasDefaultColor$_() || 0 !== this._$GetBlendMode$_() || this._$_effectList$_._$HasAnyActiveEffect$_();
        }
        _$SelfOrAnySubLayerUsesOwnTexture$_() {
            if (this._$UsesOwnTexture$_()) return !0;
            for (const t of this._$_subLayers$_) if (t._$SelfOrAnySubLayerUsesOwnTexture$_()) return !0;
            return !1;
        }
        _$GetRenderTarget$_() {
            return this._$_curRenderTarget$_;
        }
        _$Get2DScaleFactorToZ$_(t) {
            if (this._$_layout$_._$IsOrthographicProjection$_()) return 1;
            {
                const s = this._$Get3DCameraZ$_();
                return s / (s - t);
            }
        }
        _$GetResolutionScaleFactorToZ$_(t) {
            const s = this._$_runtime$_._$GetRenderScale$_();
            if (this._$_layout$_._$IsOrthographicProjection$_()) return s;
            {
                const i = this._$Get3DCameraZ$_();
                return this._$GetDefaultCameraZ$_() / Math.abs(i - t) * s;
            }
        }
        _$_SetMVMatrixChanged$_() {
            this._$_isMVMatrixChanged$_ = !0, this._$_isViewFrustumChanged$_ = !0, this._$_isViewportChanged$_ = !0;
        }
        _$_GetModelViewMatrix$_(t) {
            return this._$_isMVMatrixChanged$_ && (this._$_CalculateModelViewMatrix$_(t, this._$_modelViewMatrix$_, 0, 0, null), 
            this._$_isMVMatrixChanged$_ = !1), this._$_modelViewMatrix$_;
        }
        _$Get2DCameraZ$_(t) {
            return this._$GetDefaultCameraZ$_(t) / this._$GetNormalScale$_();
        }
        _$Get3DCameraZ$_() {
            return this._$Has3DCamera$_() ? this._$GetLayout$_()._$Get3DCameraPosition$_()[2] : this._$Get2DCameraZ$_();
        }
        _$GetCameraPosition$_() {
            if (this._$Has3DCamera$_()) {
                const t = this._$GetLayout$_()._$Get3DCameraPosition$_();
                return [ t[0], t[1], t[2] ];
            }
            return this._$_Get2DCameraPosition$_();
        }
        _$_Get2DCameraPosition$_(t = 0, s = 0, i = 0) {
            const e = this._$_runtime$_, n = this._$GetLayout$_(), h = e._$GetParallaxXOrigin$_(), r = e._$GetParallaxYOrigin$_();
            let o = (this._$GetScrollX$_() - h) * this._$_parallaxX$_ + h, a = (this._$GetScrollY$_() - r) * this._$_parallaxY$_ + r;
            e._$IsPixelRoundingEnabled$_() && (o = Math.round(o), a = Math.round(a));
            let u = o + t, l = a + s;
            const c = n._$IsOrthographicProjection$_() ? this._$GetDefaultCameraZ$_(i) : this._$Get2DCameraZ$_(i), [f, d] = this._$_GetVanishingPoint$_();
            if (.5 !== f || .5 !== d) {
                const t = this._$GetDefaultCameraZ$_(i) / c;
                let s = (f - .5) * e._$GetViewportWidth$_() / t, n = (d - .5) * e._$GetViewportHeight$_() / t;
                const h = this._$GetAngle$_();
                0 !== h && (Pp.set(s, n), Pp.rotate(h), s = Pp._$getX$_(), n = Pp._$getY$_()), u += s, 
                l += n;
            }
            return [ u, l, c ];
        }
        _$_CalculateModelViewMatrix$_(t, s, i, e, n) {
            const h = this._$_runtime$_, r = this._$GetLayout$_();
            if (this._$Has3DCamera$_()) {
                Cp._$copy$_(Lp, r._$Get3DCameraPosition$_()), Cp._$copy$_(Op, r._$Get3DCameraLookAt$_()), 
                Cp._$copy$_(Rp, r._$Get3DCameraUpVector$_());
                const t = h._$GetParallaxXOrigin$_(), s = h._$GetParallaxYOrigin$_(), i = Op[0] - Lp[0], e = Op[1] - Lp[1], n = Op[2] - Lp[2];
                Lp[0] = (Lp[0] - t) * this._$_parallaxX$_ + t, Lp[1] = (Lp[1] - s) * this._$_parallaxY$_ + s, 
                Lp[2] *= Math.max(this._$_parallaxX$_, this._$_parallaxY$_), Op[0] = Lp[0] + i, 
                Op[1] = Lp[1] + e, Op[2] = Lp[2] + n;
            } else {
                const [t, s, h] = this._$_Get2DCameraPosition$_(i, e, n);
                Cp.set(Lp, t, s, h), Cp.set(Op, t, s, h - 100);
                const r = this._$GetAngle$_();
                0 === r ? Cp.set(Rp, 0, 1, 0) : Cp.set(Rp, Math.sin(r), Math.cos(r), 0);
            }
            t._$CalculateLookAtModelView$_(s, Lp, Op, Rp, n || h._$GetViewportHeight$_());
        }
        _$_SetProjectionMatrixChanged$_() {
            this._$_isProjectionMatrixChanged$_ = !0, this._$_isViewFrustumChanged$_ = !0, this._$_isViewportChanged$_ = !0;
        }
        _$_GetProjectionMatrix$_(t) {
            return this._$_isProjectionMatrixChanged$_ && (this._$_CalculateProjectionMatrix$_(t), 
            this._$_isProjectionMatrixChanged$_ = !1), this._$_projectionMatrix$_;
        }
        _$_CalculateProjectionMatrix$_(t) {
            const s = this._$_runtime$_._$GetCanvasManager$_(), [i, e] = this._$_GetVanishingPoint$_();
            if (this._$_layout$_._$IsOrthographicProjection$_()) t._$CalculateOrthographicMatrix$_(this._$_projectionMatrix$_, s._$GetDrawWidth$_(), s._$GetDrawHeight$_()); else if (.5 === i && .5 === e) Ep._$copy$_(this._$_projectionMatrix$_, s._$GetDefaultProjectionMatrix$_()); else {
                const n = s._$GetDrawWidth$_(), h = s._$GetDrawHeight$_();
                t._$CalculatePerspectiveMatrix$_(this._$_projectionMatrix$_, n / h, i, e);
            }
        }
        _$_SetTransform$_(t, s = !0, i = 0, e = 0, n = 0) {
            s && t._$SetProjectionMatrix$_(this._$_GetProjectionMatrix$_(t));
            let h = null;
            0 === i && 0 === e && 0 === n ? h = this._$_GetModelViewMatrix$_(t) : (this._$_CalculateModelViewMatrix$_(t, Dp, i, e, n), 
            h = Dp), t._$SetModelViewMatrix$_(h);
        }
        _$PrepareForDraw$_(t) {
            this._$_SetTransform$_(t), t._$SetBaseZ$_(this._$GetZElevation$_());
        }
        _$_MaybeStartWebGLProfiling$_(t) {
            let s = null;
            if (t._$IsWebGL$_() && this._$_runtime$_._$IsGPUProfiling$_()) {
                const i = this._$_runtime$_._$GetCanvasManager$_()._$GetLayerTimingsBuffer$_(this);
                i && (s = i._$AddTimeElapsedQuery$_(), t._$StartQuery$_(s));
            }
            return s;
        }
        _$_MaybeStartWebGPUProfiling$_(t) {
            if (t._$IsWebGPU$_() && this._$_runtime$_._$IsGPUProfiling$_()) {
                const s = 2 * (this._$GetIndex$_() + 1);
                t._$StartMeasuringRenderPassTime$_(s, s + 1);
            }
        }
        _$Draw$_(t, s, i) {
            const e = this._$_runtime$_._$GetCanvasManager$_(), n = this._$UsesOwnTexture$_();
            let h = null;
            const r = this._$_MaybeStartWebGLProfiling$_(t);
            if (this._$_MaybeStartWebGPUProfiling$_(t), n) {
                const s = {
                    _$sampling$_: this._$_runtime$_._$GetSampling$_(),
                    _$isSampled$_: !0,
                    _$canReadPixels$_: !!t._$IsWebGPU$_() && this._$_runtime$_._$UsesAnyBackgroundBlending$_()
                };
                "low" === e._$GetCurrentFullscreenScalingQuality$_() && (s.width = e._$GetDrawWidth$_(), 
                s.height = e._$GetDrawHeight$_()), h = this._$_runtime$_._$GetAdditionalRenderTarget$_(s), 
                this._$_curRenderTarget$_ = h, t._$SetRenderTarget$_(h), this._$IsTransparent$_() && t._$ClearRgba$_(0, 0, 0, 0);
            } else this._$_curRenderTarget$_ = s, t._$SetRenderTarget$_(s);
            if (this._$IsTransparent$_() || t._$Clear$_(this._$_backgroundColor$_), this._$_layout$_._$_DrawLayerList$_(t, this._$_curRenderTarget$_, this._$_subLayers$_, n && this._$IsTransparent$_()), 
            this._$_MaybeStartWebGPUProfiling$_(t), this._$_SetTransform$_(t), t._$SetBaseZ$_(this._$GetZElevation$_()), 
            t._$SetDepthEnabled$_(this._$RendersIn3DMode$_()), this._$GetNormalScale$_() > Number.EPSILON) {
                this._$_UpdateZIndices$_();
                const s = this._$UsesRenderCells$_() && 0 === this._$GetZElevation$_() && !this._$_anyInstanceZElevated$_;
                this._$Has3DCamera$_() ? this._$_DrawInstances_3DCamera$_(t) : s ? this._$_DrawInstances_RenderCells$_(t) : this._$_DrawInstances$_(t, this._$_GetInstancesInDrawOrder$_());
            }
            t._$SetBaseZ$_(0), t._$SetCurrentZ$_(0), n && (t._$SetDepthEnabled$_(!1), this._$_DrawLayerOwnTextureToRenderTarget$_(t, h, s, i)), 
            r && t._$EndQuery$_(r), this._$_curRenderTarget$_ = null;
        }
        _$_DrawInstances$_(t, s) {
            const i = this._$GetViewport$_(), e = this._$_curRenderTarget$_, n = this._$GetLayout$_()._$IsOrthographicProjection$_(), h = this._$GetLayout$_()._$HasVanishingPointOutsideViewport$_();
            let r = null;
            for (let o = 0, a = s.length; o < a; ++o) {
                const a = s[o];
                if (a === r) continue;
                r = a;
                const u = a._$GetWorldInfo$_();
                u._$IsVisible$_() && u._$IsInViewport$_(i, h, n) && this._$_DrawInstanceMaybeWithEffects$_(a, u, t, e);
            }
        }
        _$_DrawInstances_3DCamera$_(t) {
            const s = this._$_curRenderTarget$_, i = this._$_GetViewFrustum$_(), e = kp, n = Fp, h = this._$_GetInstancesInDrawOrder$_();
            for (let r = 0, o = h.length; r < o; ) {
                const a = h[r], u = a._$GetWorldInfo$_();
                if (!u._$IsVisible$_() || !u._$IsInViewport3D$_(i)) {
                    ++r;
                    continue;
                }
                (!a._$RendersToOwnZPlane$_() || u._$GetDepth$_() > 0) && n.push(a);
                const l = a._$GetWorldInfo$_()._$GetTotalZElevation$_();
                e.push(a);
                let c = r + 1;
                for (;c < o; ++c) {
                    const t = h[c], s = t._$GetWorldInfo$_();
                    if (s._$IsVisible$_() && s._$IsInViewport3D$_(i)) {
                        if (s._$GetTotalZElevation$_() !== l) break;
                        t._$RendersToOwnZPlane$_() ? (s._$GetDepth$_() > 0 && n.push(t), e.push(t)) : n.push(t);
                    }
                }
                if (1 !== e.length || e[0]._$MustMitigateZFighting$_()) {
                    this._$_DrawCoplanarInstances_3DCamera$_(t, e);
                    for (let i = 0, e = n.length; i < e; ++i) {
                        const e = n[i], h = e._$GetWorldInfo$_();
                        h._$_SetDrawNonBackFacesOnly$_(!0), this._$_DrawInstanceMaybeWithEffects$_(e, h, t, s), 
                        h._$_SetDrawNonBackFacesOnly$_(!1);
                    }
                } else {
                    this._$_DrawInstanceMaybeWithEffects$_(a, u, t, s);
                    for (let i = 0, e = n.length; i < e; ++i) {
                        const e = n[i];
                        if (e === a) continue;
                        const h = e._$GetWorldInfo$_();
                        h._$GetLayer$_()._$_DrawInstanceMaybeWithEffects$_(e, h, t, s);
                    }
                }
                r = c, Tp._$clearArray$_(e), Tp._$clearArray$_(n);
            }
        }
        _$_DrawCoplanarInstances_3DCamera$_(t, s) {
            const i = this._$_curRenderTarget$_;
            t._$CoplanarStartStencilPass$_();
            for (let i = 0, e = s.length; i < e; ++i) {
                const e = s[i], n = e._$GetWorldInfo$_();
                n._$_SetDrawBackFaceOnly$_(!0), this._$_DrawInstance$_(e, n, t);
            }
            t._$CoplanarStartColorPass$_();
            for (let e = 0, n = s.length; e < n; ++e) {
                const n = s[e], h = n._$GetWorldInfo$_();
                this._$_DrawInstanceMaybeWithEffects$_(n, h, t, i), h._$_SetDrawBackFaceOnly$_(!1);
            }
            t._$CoplanarRestoreStandardRendering$_();
        }
        _$_DrawInstances_RenderCells$_(t) {
            const s = this._$_renderGrid$_, i = this._$_curRenderCells$_, e = this._$_lastRenderCells$_, n = this._$GetViewport$_();
            let h;
            i.set(s._$XToCell$_(n._$getLeft$_()), s._$YToCell$_(n._$getTop$_()), s._$XToCell$_(n._$getRight$_()), s._$YToCell$_(n._$getBottom$_())), 
            this._$_isRenderListUpToDate$_ && i.equals(e) ? h = this._$_lastRenderList$_ : (h = this._$_GetRenderCellInstancesToDraw$_(), 
            this._$_isRenderListUpToDate$_ = !0, e._$copy$_(i)), this._$_DrawInstances$_(t, h), 
            h !== this._$_lastRenderList$_ && Tp._$shallowAssignArray$_(this._$_lastRenderList$_, h);
        }
        _$_DrawInstanceMaybeWithEffects$_(t, s, i, e) {
            s._$HasAnyActiveEffect$_() ? this._$_DrawInstanceWithEffectsAndRestore$_(t, s, i, e) : this._$_DrawInstance$_(t, s, i);
        }
        _$_DrawInstance$_(t, s, i) {
            const e = s._$GetRendererStateGroup$_();
            i._$GetCurrentStateGroup$_() !== e && e._$Apply$_(), t._$Draw$_(i);
        }
        _$_DrawInstanceWithEffectsAndRestore$_(t, s, i, e) {
            this._$_DrawInstanceWithEffects$_(t, s, i, e, null) && this._$_SetTransform$_(i);
        }
        _$_DrawInstanceWithEffects$_(t, s, i, e, n) {
            const h = s._$GetInstanceEffectList$_()._$GetEffectChain$_();
            return h._$Render$_(i, e, {
                _$contentObject$_: t,
                _$blendMode$_: s._$GetBlendMode$_(),
                devicePixelRatio: this._$_runtime$_._$GetEffectDevicePixelRatioParam$_(),
                time: t._$GetInstanceGameTime$_(),
                _$layerScale$_: this._$_runtime$_._$GetEffectLayerScaleParam$_() * this._$GetNormalScale$_(),
                _$layerAngle$_: this._$GetAngle$_(),
                _$layoutRect$_: s._$GetBoundingBox$_(),
                _$drawSurfaceRect$_: h._$CanSkipCalculatingDrawSurfaceRect$_() ? null : this._$_InstanceBoxToDrawSurface$_(s),
                _$drawContentHook$_: n && n._$drawContentHook$_,
                _$compositOffX$_: n && n._$compositOffX$_,
                _$compositOffY$_: n && n._$compositOffY$_,
                _$compositRtWidth$_: n && n._$compositRtWidth$_,
                _$compositRtHeight$_: n && n._$compositRtHeight$_,
                _$updateOwnProjection$_: n && n._$updateOwnProjection$_
            }), i._$SetBaseZ$_(this._$GetZElevation$_()), h._$DidChangeTransform$_();
        }
        _$_DrawLayerOwnTextureToRenderTarget$_(t, s, i, e) {
            const n = this._$_effectList$_._$GetActiveEffectTypes$_(), h = this._$_runtime$_;
            0 === n.length ? (t._$SetRenderTarget$_(i), t._$SetTextureFillMode$_(), e && 0 === this._$_blendMode$_ && this._$HasDefaultColor$_() ? t._$CopyRenderTarget$_(s) : (t._$SetBlendMode$_(this._$_blendMode$_), 
            t._$SetColor$_(this._$_premultipliedColor$_), t._$DrawRenderTarget$_(s)), t._$InvalidateRenderTarget$_(s), 
            h._$ReleaseAdditionalRenderTarget$_(s)) : this._$GetEffectChain$_()._$Render$_(t, i, {
                _$contentObject$_: this,
                _$blendMode$_: this._$GetBlendMode$_(),
                devicePixelRatio: h._$GetEffectDevicePixelRatioParam$_(),
                _$layerScale$_: h._$GetEffectLayerScaleParam$_() * this._$GetNormalScale$_(),
                _$layerAngle$_: this._$GetAngle$_(),
                _$layoutRect$_: this._$GetViewport$_(),
                _$drawSurfaceRect$_: null,
                _$invalidateRenderTargets$_: !0
            });
        }
        _$GetOwnScale$_() {
            return this._$_scale$_;
        }
        _$SetOwnScale$_(t) {
            this._$_scale$_ !== t && (this._$_scale$_ = t, this._$_layout$_._$BoundScrolling$_(), 
            this._$_SetMVMatrixChanged$_(), this._$_runtime$_._$UpdateRender$_());
        }
        _$GetRenderScale$_() {
            return this._$GetNormalScale$_() * this._$_runtime$_._$GetRenderScale$_();
        }
        _$GetDisplayScale$_() {
            return this._$GetNormalScale$_() * this._$_runtime$_._$GetDisplayScale$_();
        }
        _$GetNormalScale$_() {
            return (this._$_scale$_ * this._$_layout$_._$GetScale$_() - 1) * this._$_scaleRate$_ + 1;
        }
        _$_MaybeUpdateViewport$_() {
            if (!this._$_isViewportChanged$_) return;
            this._$_isViewportChanged$_ = !1;
            const t = this._$_runtime$_._$GetParallaxXOrigin$_(), s = this._$_runtime$_._$GetParallaxYOrigin$_(), i = (this._$GetScrollX$_() - t) * this._$_parallaxX$_ + t, e = (this._$GetScrollY$_() - s) * this._$_parallaxY$_ + s, n = this._$GetNormalScale$_(), h = this._$_runtime$_._$GetViewportWidth$_() / n, r = this._$_runtime$_._$GetViewportHeight$_() / n;
            let o = i - h / 2, a = e - r / 2;
            this._$_runtime$_._$IsPixelRoundingEnabled$_() && (o = Math.round(o), a = Math.round(a));
            const u = this._$_viewportZ0$_;
            u.set(o, a, o + h, a + r);
            const l = this._$GetAngle$_();
            0 !== l && (vp._$copy$_(u), vp.offset(-u._$midX$_(), -u._$midY$_()), xp._$setFromRotatedRect$_(vp, l), 
            xp._$getBoundingBox$_(vp), vp.offset(u._$midX$_(), u._$midY$_()), u._$copy$_(vp));
            const c = this._$_zElevation$_;
            this._$GetViewportForZ$_(c, this._$_viewport$_), this._$Has3DCamera$_() ? this._$CalculateViewport3D$_(c, this._$_viewport3D$_) : this._$_viewport3D$_._$copy$_(this._$_viewport$_);
        }
        _$CalculateViewport3D$_(t, s) {
            const i = this._$_runtime$_._$GetCanvasManager$_(), e = i._$GetCssWidth$_(), n = i._$GetCssHeight$_(), [h, r] = this._$CanvasCssToLayer$_(0, 0, t), [o, a] = this._$CanvasCssToLayer$_(e, 0, t), [u, l] = this._$CanvasCssToLayer$_(e, n, t), [c, f] = this._$CanvasCssToLayer$_(0, n, t);
            let d = Math.min(h, o, u, c), p = Math.min(r, a, l, f), m = Math.max(h, o, u, c), g = Math.max(r, a, l, f);
            isFinite(d) || (d = -1 / 0), isFinite(p) || (p = -1 / 0), isFinite(m) || (m = 1 / 0), 
            isFinite(g) || (g = 1 / 0), s.set(d, p, m, g);
        }
        _$CanvasCssToLayer$_(t, s, i = 0) {
            return this._$_CanvasToLayer$_(t, s, i, this._$GetDisplayScale$_());
        }
        _$DrawSurfaceToLayer$_(t, s, i = 0) {
            return this._$_CanvasToLayer$_(t, s, i, this._$GetRenderScale$_() * this._$GetDevicePixelRatio$_());
        }
        _$_CanvasToLayer$_(t, s, i, e) {
            const n = this._$_runtime$_, h = n._$GetRenderer$_(), r = this._$GetNormalScale$_(), o = n._$GetViewportWidth$_() / r, a = n._$GetViewportHeight$_() / r, u = Np;
            _p.set(u, 0, 0, o, a), t /= e, s = u[3] - s / e;
            const l = this._$_GetProjectionMatrix$_(h), c = this._$_GetModelViewMatrix$_(h), f = Ap;
            return Tp._$Gfx$_._$UnprojectScreenToWorldZ$_(t, s, i, c, l, u, f) ? [ f[0], f[1] ] : [ NaN, NaN ];
        }
        _$CanvasCssToLayer_DefaultTransform$_(t, s) {
            const i = this._$_scale$_, e = this._$_scaleRate$_, n = this._$_parallaxX$_, h = this._$_parallaxY$_, r = this._$_angle$_;
            this._$_scale$_ = 1, this._$_scaleRate$_ = 1, this._$_parallaxX$_ = 1, this._$_parallaxY$_ = 1, 
            this._$_angle$_ = 0, this._$_SetMVMatrixChanged$_();
            const o = this._$CanvasCssToLayer$_(t, s);
            return this._$_scale$_ = i, this._$_scaleRate$_ = e, this._$_parallaxX$_ = n, this._$_parallaxY$_ = h, 
            this._$_angle$_ = r, this._$_SetMVMatrixChanged$_(), o;
        }
        _$LayerToCanvasCss$_(t, s, i = 0) {
            return this._$_LayerToCanvas$_(t, s, i, this._$GetDisplayScale$_());
        }
        _$LayerToDrawSurface$_(t, s, i = 0) {
            return this._$_LayerToCanvas$_(t, s, i, this._$GetRenderScale$_() * this._$GetDevicePixelRatio$_());
        }
        _$_LayerToCanvas$_(t, s, i, e) {
            const n = this._$_runtime$_, h = n._$GetRenderer$_(), r = this._$GetNormalScale$_(), o = n._$GetViewportWidth$_() / r, a = n._$GetViewportHeight$_() / r, u = Np;
            _p.set(u, 0, 0, o, a);
            const l = this._$_GetProjectionMatrix$_(h), c = this._$_GetModelViewMatrix$_(h), f = Ap;
            return Tp._$Gfx$_._$Project$_(t, s, i, c, l, u, f) ? [ f[0] * e, (u[3] - f[1]) * e ] : [ NaN, NaN ];
        }
        _$_GetLayerToDrawSurfaceScale$_(t, s) {
            return t *= this._$GetRenderScale$_() * this._$GetDevicePixelRatio$_(), 0 !== s && (t *= this._$Get2DScaleFactorToZ$_(s)), 
            t;
        }
        _$_InstanceBoxToDrawSurface$_(t) {
            const s = t._$GetBoundingBox$_(), i = t._$GetTotalZElevation$_(), e = t._$GetDepth$_(), n = i + e, h = s._$getLeft$_(), r = s._$getTop$_(), o = s._$getRight$_(), a = s._$getBottom$_();
            if (this._$Has3DCamera$_()) {
                if (this._$_IsPointBehindNearPlane$_(h, r, i) || this._$_IsPointBehindNearPlane$_(o, r, i) || this._$_IsPointBehindNearPlane$_(o, a, i) || this._$_IsPointBehindNearPlane$_(h, a, i)) return null;
                if (e > 0 && (this._$_IsPointBehindNearPlane$_(h, r, n) || this._$_IsPointBehindNearPlane$_(o, r, n) || this._$_IsPointBehindNearPlane$_(o, a, n) || this._$_IsPointBehindNearPlane$_(h, a, n))) return null;
            } else if (n >= this._$Get2DCameraZ$_()) return null;
            let [u, l] = this._$LayerToDrawSurface$_(h, r, i), [c, f] = this._$LayerToDrawSurface$_(o, a, i);
            if (0 !== this._$GetAngle$_() || e > 0 || this._$Has3DCamera$_()) {
                const [t, s] = this._$LayerToDrawSurface$_(o, r, i), [d, p] = this._$LayerToDrawSurface$_(h, a, i);
                if (e > 0) {
                    const [i, e] = this._$LayerToDrawSurface$_(h, r, n), [m, g] = this._$LayerToDrawSurface$_(o, r, n), [y, M] = this._$LayerToDrawSurface$_(o, a, n), [w, S] = this._$LayerToDrawSurface$_(h, a, n);
                    let b = Math.min(u, c, t, d, i, m, y, w);
                    c = Math.max(u, c, t, d, i, m, y, w), u = b, b = Math.min(l, f, s, p, e, g, M, S), 
                    f = Math.max(l, f, s, p, e, g, M, S), l = b;
                } else {
                    let i = Math.min(u, c, t, d);
                    c = Math.max(u, c, t, d), u = i, i = Math.min(l, f, s, p), f = Math.max(l, f, s, p), 
                    l = i;
                }
            }
            return vp.set(u, l, c, f), vp;
        }
        _$_GetViewFrustum$_() {
            return this._$_isViewFrustumChanged$_ && (this._$_UpdateViewFrustum$_(), this._$_isViewFrustumChanged$_ = !1), 
            this._$_viewFrustum$_;
        }
        _$_UpdateViewFrustum$_() {
            const t = this._$_runtime$_._$GetRenderer$_(), s = this._$_GetProjectionMatrix$_(t), i = this._$_GetModelViewMatrix$_(t);
            this._$_viewFrustum$_._$CalculatePlanes$_(i, s);
        }
        _$_IsPointBehindNearPlane$_(t, s, i) {
            return this._$_GetViewFrustum$_()._$IsBehindNearPlane$_(t, s, i);
        }
        _$_SaveToJson$_() {
            return {
                d: this._$IsDynamic$_(),
                s: this._$GetOwnScale$_(),
                a: this._$GetOwnAngle$_(),
                v: this._$_IsVisibleFlagSet$_(),
                i: this._$IsInteractive$_(),
                html: this._$IsHTMLElementsLayer$_(),
                bc: this._$_backgroundColor$_.toJSON(),
                t: this._$IsTransparent$_(),
                sx: this._$_scrollX$_,
                sy: this._$_scrollY$_,
                hosp: this._$_hasOwnScrollPosition$_,
                px: this._$GetParallaxX$_(),
                py: this._$GetParallaxY$_(),
                c: this._$_color$_.toJSON(),
                sr: this._$GetScaleRate$_(),
                fx: this._$_effectList$_._$SaveToJson$_(),
                cg: this._$_createdGlobalUids$_
            };
        }
        _$_LoadFromJson$_(t) {
            this._$_isDynamic$_ = !!t.d, this._$_scale$_ = t.s, this._$_angle$_ = t.a, this._$_isVisible$_ = !!t.v, 
            this._$_isInteractive$_ = !t.hasOwnProperty("i") || t.i, this._$_isHTMLElementsLayer$_ = !!t.html, 
            this._$_backgroundColor$_._$setFromJSON$_(t.bc), this._$_isTransparent$_ = !!t.t, 
            t.hasOwnProperty("sx") && (this._$_scrollX$_ = t.sx), t.hasOwnProperty("sy") && (this._$_scrollY$_ = t.sy), 
            t.hasOwnProperty("hosp") && (this._$_hasOwnScrollPosition$_ = !!t.hosp), this._$_parallaxX$_ = t.px, 
            this._$_parallaxY$_ = t.py, this._$_color$_._$setFromJSON$_(t.c), this._$_UpdatePremultipliedColor$_(), 
            this._$_scaleRate$_ = t.sr, Tp._$shallowAssignArray$_(this._$_createdGlobalUids$_, t.cg), 
            Tp._$shallowAssignArray$_(this._$_initialInstances$_, this._$_startupInitialInstances$_);
            const s = new Set(this._$_createdGlobalUids$_);
            let i = 0;
            for (let t = 0, e = this._$_initialInstances$_.length; t < e; ++t) s.has(this._$_initialInstances$_[t][2]) || (this._$_initialInstances$_[i] = this._$_initialInstances$_[t], 
            ++i);
            Tp._$truncateArray$_(this._$_initialInstances$_, i), this._$_effectList$_._$LoadFromJson$_(t.fx), 
            this._$_needsRebuildEffectChainSteps$_ = !0;
        }
        _$_LoadFromJsonAfterInstances$_() {
            this._$_SortInstancesByLastCachedZIndex$_(!1), this._$SetZIndicesChanged$_(), this._$_SetMVMatrixChanged$_(), 
            this._$_SetProjectionMatrixChanged$_();
        }
        _$GetILayer$_() {
            return this._$_iLayer$_;
        }
        _$SortAndAddInstancesByZIndex$_(t, s = !1) {
            if (this._$_instances$_.includes(t)) s && this._$_instances$_.sort(((t, s) => t._$GetWorldInfo$_()._$GetSceneGraphZIndex$_() - s._$GetWorldInfo$_()._$GetSceneGraphZIndex$_())); else if (t._$HasChildren$_()) {
                const s = [ ...t._$allChildren$_() ];
                s.push(t), s.sort(((t, s) => t._$GetWorldInfo$_()._$GetSceneGraphZIndex$_() - s._$GetWorldInfo$_()._$GetSceneGraphZIndex$_()));
                for (const t of s) if (t._$IsInContainer$_()) for (const i of t._$siblings$_()) {
                    if (s.includes(i)) continue;
                    const t = [ ...i._$allChildren$_() ];
                    t.push(i), t.sort(((t, s) => t._$GetWorldInfo$_()._$GetSceneGraphZIndex$_() - s._$GetWorldInfo$_()._$GetSceneGraphZIndex$_())), 
                    t && t.length && s.splice(s.length, 0, ...t);
                }
                for (const t of s) t._$GetPlugin$_()._$IsWorldType$_() && this._$_AddInstance$_(t, !0);
            } else {
                if (t._$GetPlugin$_()._$IsWorldType$_() && this._$_AddInstance$_(t, !0), !t._$IsInContainer$_()) return;
                for (const s of t._$siblings$_()) {
                    const t = [ ...s._$allChildren$_() ];
                    if (t.push(s), t.sort(((t, s) => t._$GetWorldInfo$_()._$GetSceneGraphZIndex$_() - s._$GetWorldInfo$_()._$GetSceneGraphZIndex$_())), 
                    t && t.length) for (const s of t) s._$GetPlugin$_()._$IsWorldType$_() && this._$_AddInstance$_(s, !0);
                }
            }
        }
    };
}

{
    let zp = function(t, s, i, e) {
        return t[0] === Math.fround(s) && t[1] === Math.fround(i) && t[2] === Math.fround(e);
    }, Up = function(t, s) {
        Kp !== t && (t._$PrepareForDraw$_(s), Kp = t);
    };
    0;
    const Wp = self._$C3$_, Jp = self._$C3Debugger$_, Qp = (self.assert, Wp._$New$_(Wp.Rect), 
    Wp._$New$_(Wp.Rect), Wp._$New$_(Wp.Rect)), Yp = Wp._$New$_(Wp._$Color$_), Vp = self._$glMatrix$_._$vec3$_, Hp = [], qp = [], Xp = [], Zp = [];
    let Kp = null;
    Wp._$Layout$_ = class extends Wp._$DefendedBase$_ {
        constructor(t, s, i) {
            super(), this._$_layoutManager$_ = t, this._$_runtime$_ = t._$GetRuntime$_(), this._$_name$_ = i[0], 
            this._$_originalWidth$_ = i[1], this._$_originalHeight$_ = i[2], this._$_width$_ = i[1], 
            this._$_height$_ = i[2], this._$_isUnboundedScrolling$_ = !!i[3], this._$_isOrthographicProjection$_ = !!i[4], 
            this._$_vanishingPointX$_ = i[5], this._$_vanishingPointY$_ = i[6], this._$_eventSheetName$_ = i[7], 
            this._$_eventSheet$_ = null, this._$_sid$_ = i[8], this._$_index$_ = s, this._$_scrollX$_ = 0, 
            this._$_scrollY$_ = 0, this._$_scale$_ = 1, this._$_angle$_ = 0, this._$_initialObjectClasses$_ = new Set, 
            this._$_textureLoadedTypes$_ = new Set, this._$_textureLoadPendingPromises$_ = new Set, 
            this._$_createdInstances$_ = [], this._$_createdPersistedInstances$_ = [], this._$_createdPersistedInstancesToDataMap$_ = new Map, 
            this._$_createdPersistedIndexToInstanceMap$_ = new Map, this._$_initialNonWorld$_ = [], 
            this._$_is3dCameraEnabled$_ = !1, this._$_cam3dposition$_ = Vp.create(), this._$_cam3dlook$_ = Vp.create(), 
            this._$_cam3dup$_ = Vp.create(), this._$_rootLayers$_ = [], this._$_allLayersFlat$_ = [], 
            this._$_layersByName$_ = new Map, this._$_layersBySid$_ = new Map, this._$_pendingSetHTMLLayerCount$_ = -1;
            const e = this._$_runtime$_._$GetCanvasManager$_();
            this._$_effectList$_ = Wp._$New$_(Wp._$EffectList$_, this, i[11]), this._$_effectChain$_ = Wp._$New$_(Wp._$Gfx$_._$EffectChain$_, e._$GetEffectChainManager$_(), {
                _$drawContent$_: (t, s) => {
                    const i = s._$GetContentObject$_()._$GetRenderTarget$_();
                    t._$ResetColor$_(), t._$DrawRenderTarget$_(i), t._$InvalidateRenderTarget$_(i), 
                    e._$ReleaseAdditionalRenderTarget$_(i);
                },
                _$getShaderParameters$_: t => this._$GetEffectList$_()._$_GetEffectChainShaderParametersForIndex$_(t)
            }), this._$_needsRebuildEffectChainSteps$_ = !0, this._$_wasFullScreenQualityLow$_ = !1, 
            this._$_curRenderTarget$_ = null, this._$_persistData$_ = {}, this._$_persistedIntances$_ = new Map, 
            this._$_isFirstVisit$_ = !0, this._$_iLayout$_ = new self._$ILayout$_(this), this._$_userScriptDispatcher$_ = Wp._$New$_(Wp.Event._$Dispatcher$_);
            for (const t of i[9]) this._$_rootLayers$_.push(Wp._$Layer$_._$CreateFromExportData$_(this, null, t));
            this._$_ReindexLayers$_();
            for (const t of this._$allLayers$_()) t._$_InitInitialInstances$_();
            for (const t of i[10]) {
                const s = this._$_runtime$_._$GetObjectClassByIndex$_(t[1]);
                if (!s) throw new Error("missing nonworld object class");
                s._$GetDefaultInstanceData$_() || s._$SetDefaultInstanceData$_(t), this._$_initialNonWorld$_.push(t), 
                this._$_AddInitialObjectClass$_(s);
            }
        }
        _$Release$_() {
            for (const t of this._$_allLayersFlat$_) t._$Release$_();
            Wp._$clearArray$_(this._$_allLayersFlat$_), this._$_textureLoadPendingPromises$_.clear(), 
            this._$_eventSheet$_ = null, this._$_layoutManager$_ = null, this._$_runtime$_ = null;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetName$_() {
            return this._$_name$_;
        }
        _$GetSID$_() {
            return this._$_sid$_;
        }
        _$GetIndex$_() {
            return this._$_index$_;
        }
        _$GetEffectList$_() {
            return this._$_effectList$_;
        }
        _$GetEffectChain$_() {
            return this._$_MaybeRebuildEffectChainSteps$_(), this._$_effectChain$_;
        }
        _$_MaybeRebuildEffectChainSteps$_() {
            const t = "low" === this._$_runtime$_._$GetCanvasManager$_()._$GetCurrentFullscreenScalingQuality$_();
            if (!this._$_needsRebuildEffectChainSteps$_ && this._$_wasFullScreenQualityLow$_ === t && !this._$_effectChain$_._$NeedsRebuild$_()) return;
            const s = this._$GetEffectList$_()._$GetActiveEffectTypes$_();
            this._$_effectChain$_._$BuildSteps$_(s.map((t => t._$GetShaderProgram$_())), {
                _$indexMap$_: s.map((t => t._$GetIndex$_())),
                _$forcePostDraw$_: t,
                _$useFullSurface$_: !0
            }), this._$_needsRebuildEffectChainSteps$_ = !1, this._$_wasFullScreenQualityLow$_ = t;
        }
        _$UpdateActiveEffects$_() {
            this._$GetEffectList$_()._$UpdateActiveEffects$_(), this._$_needsRebuildEffectChainSteps$_ = !0;
        }
        _$GetMinLayerScale$_() {
            let t = this._$_allLayersFlat$_[0]._$GetNormalScale$_();
            for (let s = 1, i = this._$_allLayersFlat$_.length; s < i; ++s) {
                const i = this._$_allLayersFlat$_[s];
                0 === i._$GetParallaxX$_() && 0 === i._$GetParallaxY$_() || (t = Math.min(t, i._$GetNormalScale$_()));
            }
            return t;
        }
        _$_GetScrollBoundMarginHorizontal$_() {
            return .5 * this._$_runtime$_._$GetViewportWidth$_() / this._$GetMinLayerScale$_();
        }
        _$_GetScrollBoundMarginVertical$_() {
            return .5 * this._$_runtime$_._$GetViewportHeight$_() / this._$GetMinLayerScale$_();
        }
        _$GetScrollLeftBound$_() {
            return this._$IsUnboundedScrolling$_() ? -1 / 0 : this._$_GetScrollBoundMarginHorizontal$_();
        }
        _$GetScrollRightBound$_() {
            return this._$IsUnboundedScrolling$_() ? 1 / 0 : this._$GetWidth$_() - this._$_GetScrollBoundMarginHorizontal$_();
        }
        _$GetScrollTopBound$_() {
            return this._$IsUnboundedScrolling$_() ? -1 / 0 : this._$_GetScrollBoundMarginVertical$_();
        }
        _$GetScrollBottomBound$_() {
            return this._$IsUnboundedScrolling$_() ? 1 / 0 : this._$GetHeight$_() - this._$_GetScrollBoundMarginVertical$_();
        }
        _$SetScrollX$_(t) {
            const s = this._$GetScrollLeftBound$_(), i = this._$GetScrollRightBound$_();
            t > i && (t = i), t < s && (t = s), this._$_scrollX$_ !== t && (this._$_scrollX$_ = t, 
            this._$_SetAllLayersMVChanged$_(), this._$_runtime$_._$UpdateRender$_());
        }
        _$GetScrollX$_() {
            return this._$_scrollX$_;
        }
        _$SetScrollY$_(t) {
            const s = this._$GetScrollTopBound$_(), i = this._$GetScrollBottomBound$_();
            t > i && (t = i), t < s && (t = s), this._$_scrollY$_ !== t && (this._$_scrollY$_ = t, 
            this._$_SetAllLayersMVChanged$_(), this._$_runtime$_._$UpdateRender$_());
        }
        _$GetScrollY$_() {
            return this._$_scrollY$_;
        }
        _$IsUnboundedScrolling$_() {
            return this._$_isUnboundedScrolling$_;
        }
        _$BoundScrolling$_() {
            this._$SetScrollX$_(this._$GetScrollX$_()), this._$SetScrollY$_(this._$GetScrollY$_());
            for (const t of this._$_allLayersFlat$_) t._$IsOwnScrollPositionEnabled$_() && (t._$SetScrollX$_(t._$GetScrollX$_()), 
            t._$SetScrollY$_(t._$GetScrollY$_()));
        }
        _$SetVanishingPointXY$_(t, s) {
            this._$_vanishingPointX$_ === t && this._$_vanishingPointY$_ === s || (this._$_vanishingPointX$_ = t, 
            this._$_vanishingPointY$_ = s, this._$IsPerspectiveProjection$_() && (this._$_SetAllLayersProjectionChanged$_(), 
            this._$_SetAllLayersMVChanged$_(), this._$_runtime$_._$UpdateRender$_()));
        }
        _$GetVanishingPointX$_() {
            return this._$IsOrthographicProjection$_() ? .5 : this._$_vanishingPointX$_;
        }
        _$GetVanishingPointY$_() {
            return this._$IsOrthographicProjection$_() ? .5 : this._$_vanishingPointY$_;
        }
        _$HasVanishingPointOutsideViewport$_() {
            const t = this._$GetVanishingPointX$_(), s = this._$GetVanishingPointY$_();
            return t < 0 || t > 1 || s < 0 || s > 1;
        }
        _$SetPerspectiveProjection$_() {
            this._$_isOrthographicProjection$_ && (this._$_isOrthographicProjection$_ = !1, 
            this._$_SetAllLayersProjectionChanged$_(), this._$_SetAllLayersMVChanged$_(), this._$_runtime$_._$UpdateRender$_());
        }
        _$SetOrthographicProjection$_() {
            this._$_isOrthographicProjection$_ || (this._$_isOrthographicProjection$_ = !0, 
            this._$_SetAllLayersProjectionChanged$_(), this._$_SetAllLayersMVChanged$_(), this._$_runtime$_._$UpdateRender$_());
        }
        _$IsOrthographicProjection$_() {
            return this._$_isOrthographicProjection$_;
        }
        _$IsPerspectiveProjection$_() {
            return !this._$IsOrthographicProjection$_();
        }
        _$Set3DCameraEnabled$_(t) {
            t = !!t, this._$_is3dCameraEnabled$_ !== t && (this._$_is3dCameraEnabled$_ = t, 
            this._$_SetAllLayersMVChanged$_(), this._$_runtime$_._$UpdateRender$_());
        }
        _$Is3DCameraEnabled$_() {
            return this._$_is3dCameraEnabled$_;
        }
        _$Set3DCameraOrientation$_(t, s, i, e, n, h, r, o, a) {
            zp(this._$_cam3dposition$_, t, s, i) && zp(this._$_cam3dlook$_, e, n, h) && zp(this._$_cam3dup$_, r, o, a) || (Vp.set(this._$_cam3dposition$_, t, s, i), 
            Vp.set(this._$_cam3dlook$_, e, n, h), Vp.set(this._$_cam3dup$_, r, o, a), this._$Set3DCameraChanged$_());
        }
        _$Set3DCameraChanged$_() {
            this._$_SetAllLayersMVChanged$_(), this._$_runtime$_._$UpdateRender$_();
        }
        _$Get3DCameraPosition$_() {
            return this._$_cam3dposition$_;
        }
        _$Get3DCameraLookAt$_() {
            return this._$_cam3dlook$_;
        }
        _$Get3DCameraUpVector$_() {
            return this._$_cam3dup$_;
        }
        _$GetScale$_() {
            return this._$_scale$_;
        }
        _$SetScale$_(t) {
            this._$_scale$_ !== t && (this._$_scale$_ = t, this._$_SetAllLayersMVChanged$_(), 
            this._$BoundScrolling$_(), this._$_runtime$_._$UpdateRender$_());
        }
        _$SetAngle$_(t) {
            t = Wp._$clampAngle$_(t), this._$_angle$_ !== t && (this._$_angle$_ = t, this._$_SetAllLayersMVChanged$_(), 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$GetAngle$_() {
            return this._$_angle$_;
        }
        _$GetWidth$_() {
            return this._$_width$_;
        }
        _$SetWidth$_(t) {
            !isFinite(t) || t < 1 || (this._$_width$_ = t);
        }
        _$GetHeight$_() {
            return this._$_height$_;
        }
        _$SetHeight$_(t) {
            !isFinite(t) || t < 1 || (this._$_height$_ = t);
        }
        _$GetEventSheet$_() {
            return this._$_eventSheet$_;
        }
        _$_GetRootLayers$_() {
            return this._$_rootLayers$_;
        }
        * _$allLayers$_() {
            for (const t of this._$_rootLayers$_) yield* t._$selfAndAllSubLayers$_();
        }
        _$GetLayers$_() {
            return this._$_allLayersFlat$_;
        }
        _$GetLayerCount$_() {
            return this._$_allLayersFlat$_.length;
        }
        _$GetLayer$_(t) {
            return "number" == typeof t ? this._$GetLayerByIndex$_(t) : this._$GetLayerByName$_(t.toString());
        }
        _$GetLayerByIndex$_(t) {
            return t = Wp._$clamp$_(Math.floor(t), 0, this._$_allLayersFlat$_.length - 1), this._$_allLayersFlat$_[t];
        }
        _$GetLayerByName$_(t) {
            return this._$_layersByName$_.get(t.toLowerCase()) || null;
        }
        _$HasLayerByName$_(t) {
            return !!this._$GetLayerByName$_(t);
        }
        _$GetLayerBySID$_(t) {
            return this._$_layersBySid$_.get(t) || null;
        }
        _$_SetAllLayersProjectionChanged$_() {
            for (const t of this._$_allLayersFlat$_) t._$_SetProjectionMatrixChanged$_();
        }
        _$_SetAllLayersMVChanged$_() {
            for (const t of this._$_allLayersFlat$_) t._$_SetMVMatrixChanged$_();
        }
        _$AddLayer$_(t, s, i) {
            if (this._$HasLayerByName$_(t)) throw new Error(`layer name '${t}' already in use`);
            if (!s && i < 2) throw new Error("invalid insert position");
            const e = i >= 2 ? s : s._$GetParentLayer$_(), n = Wp._$New$_(Wp._$Layer$_, this, e, {
                name: t,
                _$sid$_: Math.floor(1e15 * Math.random()),
                _$isDynamic$_: !0
            });
            this._$_InsertLayer$_(n, s, i), this._$GetRuntime$_()._$UpdateRender$_(), this._$_ReindexAndUpdateAllLayers$_();
        }
        _$MoveLayer$_(t, s, i) {
            if (!s && i < 2) throw new Error("invalid insert position");
            t === s && i < 2 || (this._$_RemoveLayer$_(t), this._$_InsertLayer$_(t, s, i), this._$GetRuntime$_()._$UpdateRender$_(), 
            this._$_ReindexAndUpdateAllLayers$_());
        }
        _$RemoveLayer$_(t) {
            if (this._$_RemoveLayer$_(t)) {
                const s = this._$_runtime$_._$GetEventSheetManager$_();
                s._$BlockFlushingInstances$_(!0), t._$Release$_(), s._$BlockFlushingInstances$_(!1), 
                this._$GetRuntime$_()._$UpdateRender$_(), this._$_ReindexAndUpdateAllLayers$_();
            }
        }
        _$RemoveAllDynamicLayers$_() {
            const t = new Set;
            for (const s of this._$allLayers$_()) s._$IsDynamic$_() && !s._$HasAnyDynamicParentLayer$_() && t.add(s);
            if (0 === t.size) return;
            const s = this._$_runtime$_._$GetEventSheetManager$_();
            s._$BlockFlushingInstances$_(!0);
            for (const s of t) this._$_RemoveLayer$_(s), s._$Release$_();
            s._$BlockFlushingInstances$_(!1), this._$GetRuntime$_()._$UpdateRender$_(), this._$_ReindexAndUpdateAllLayers$_();
        }
        _$_InsertLayer$_(t, s, i) {
            if (i >= 2) if (s) {
                if (s === t || s._$HasParentLayer$_(t)) throw new Error(`cannot move layer '${t._$GetName$_()}' to sub-layer of itself`);
                s._$_AddSubLayer$_(t, 2 === i), t._$_SetParentLayer$_(s);
            } else 2 === i ? this._$_rootLayers$_.push(t) : this._$_rootLayers$_.unshift(t), 
            t._$_SetParentLayer$_(null); else {
                const e = s._$GetParentLayer$_();
                if (e) {
                    if (s._$HasParentLayer$_(t)) throw new Error(`cannot move layer '${t._$GetName$_()}' to sub-layer of itself`);
                    e._$_InsertSubLayer$_(t, s, 0 === i), t._$_SetParentLayer$_(e);
                } else {
                    let e = this._$_rootLayers$_.indexOf(s);
                    if (-1 === e) throw new Error("cannot find layer to insert by");
                    0 === i && ++e, this._$_rootLayers$_.splice(e, 0, t), t._$_SetParentLayer$_(null);
                }
            }
        }
        _$_RemoveLayer$_(t) {
            const s = t._$GetParentLayer$_();
            if (s) return s._$_RemoveSubLayer$_(t), !0;
            if (this._$_rootLayers$_.length > 1) {
                const s = this._$_rootLayers$_.indexOf(t);
                if (-1 === s) throw new Error("cannot find layer to remove");
                return this._$_rootLayers$_.splice(s, 1), !0;
            }
            return !1;
        }
        _$_ReindexLayers$_() {
            this._$_allLayersFlat$_ = [ ...this._$allLayers$_() ], this._$_layersByName$_.clear(), 
            this._$_layersBySid$_.clear();
            for (let t = 0, s = this._$_allLayersFlat$_.length; t < s; ++t) {
                const s = this._$_allLayersFlat$_[t];
                s._$_SetIndex$_(t), this._$_layersByName$_.set(s._$GetName$_().toLowerCase(), s), 
                this._$_layersBySid$_.set(s._$GetSID$_(), s);
            }
        }
        _$_ReindexHTMLLayers$_() {
            let t = 0;
            for (const s of this._$_rootLayers$_) {
                for (const i of s._$selfAndAllSubLayers$_()) i._$_SetHTMLIndex$_(t);
                s._$IsHTMLElementsLayer$_() && t++;
            }
        }
        _$GetHTMLLayerCount$_() {
            return this._$_rootLayers$_.at(-1)._$GetHTMLIndex$_() + 1;
        }
        async _$_ReindexAndUpdateAllLayers$_() {
            this._$_ReindexLayers$_(), this._$_ReindexHTMLLayers$_(), this._$_pendingSetHTMLLayerCount$_ = this._$GetHTMLLayerCount$_();
        }
        _$_GetPendingSetHTMLLayerCount$_() {
            return this._$_pendingSetHTMLLayerCount$_;
        }
        _$_ResetPendingHTMLLayerCount$_() {
            this._$_pendingSetHTMLLayerCount$_ = -1;
        }
        _$GetRootLayersForHTMLLayer$_(t) {
            const s = [];
            for (const i of this._$_rootLayers$_) {
                const e = i._$GetHTMLIndex$_();
                if (e === t) s.push(i); else if (e > t) break;
            }
            return s;
        }
        _$SaveTransform$_() {
            return {
                scrollX: this._$GetScrollX$_(),
                scrollY: this._$GetScrollY$_(),
                scale: this._$GetScale$_(),
                angle: this._$GetAngle$_(),
                vpX: this._$GetVanishingPointX$_(),
                vpY: this._$GetVanishingPointY$_()
            };
        }
        _$RestoreTransform$_(t) {
            this._$SetScrollX$_(t.scrollX), this._$SetScrollY$_(t.scrollY), this._$SetScale$_(t.scale), 
            this._$SetAngle$_(t.angle), this._$SetVanishingPointXY$_(t.vpX, t.vpY);
        }
        _$GetLayoutBackgroundColor$_() {
            let t = this._$_rootLayers$_.filter((t => t._$ShouldDraw$_()))[0];
            for (;t; ) {
                if (!t._$IsTransparent$_()) return Yp._$copyRgb$_(t._$GetBackgroundColor$_()), Yp._$setA$_(1), 
                Yp;
                if (t._$UsesOwnTexture$_()) return Yp._$setRgba$_(0, 0, 0, 0), Yp;
                t = t._$GetSubLayers$_().filter((t => t._$ShouldDraw$_()))[0];
            }
            return Yp._$setRgba$_(0, 0, 0, 0), Yp;
        }
        _$IsFirstVisit$_() {
            return this._$_isFirstVisit$_;
        }
        _$_GetInitialObjectClasses$_() {
            return [ ...this._$_initialObjectClasses$_ ];
        }
        _$_AddInitialObjectClass$_(t) {
            if (t._$IsInContainer$_()) for (const s of t._$GetContainer$_()._$GetObjectTypes$_()) this._$_initialObjectClasses$_.add(s); else this._$_initialObjectClasses$_.add(t);
        }
        _$_GetTextureLoadedObjectTypes$_() {
            return [ ...this._$_textureLoadedTypes$_ ];
        }
        _$_Load$_(t, s) {
            if (t === this || !s) return Promise.resolve();
            t && (Wp._$CopySet$_(this._$_textureLoadedTypes$_, t._$_textureLoadedTypes$_), t._$_textureLoadedTypes$_.clear());
            const i = [];
            for (const t of this._$_initialObjectClasses$_) this._$_textureLoadedTypes$_.has(t) || (i.push(t._$LoadTextures$_(s)), 
            this._$_textureLoadedTypes$_.add(t));
            return Promise.all(i);
        }
        async _$MaybeLoadTexturesFor$_(t) {
            if (t._$IsFamily$_()) throw new Error("cannot load textures for family");
            const s = this._$_runtime$_._$GetRenderer$_();
            if (!s || s._$IsContextLost$_() || this._$_textureLoadedTypes$_.has(t)) return;
            this._$_textureLoadedTypes$_.add(t);
            const i = t._$LoadTextures$_(s);
            this._$_AddPendingTextureLoadPromise$_(i), await i, t._$OnDynamicTextureLoadComplete$_(), 
            this._$_runtime$_._$UpdateRender$_();
        }
        _$_AddPendingTextureLoadPromise$_(t) {
            this._$_textureLoadPendingPromises$_.add(t), t.then((() => this._$_textureLoadPendingPromises$_.delete(t))).catch((() => this._$_textureLoadPendingPromises$_.delete(t)));
        }
        _$WaitForPendingTextureLoadsToComplete$_() {
            return Promise.all([ ...this._$_textureLoadPendingPromises$_ ]);
        }
        _$MaybeUnloadTexturesFor$_(t) {
            if (t._$IsFamily$_() || t._$GetInstanceCount$_() > 0) throw new Error("cannot unload textures");
            const s = this._$_runtime$_._$GetRenderer$_();
            s && this._$_textureLoadedTypes$_.has(t) && (this._$_textureLoadedTypes$_.delete(t), 
            t._$ReleaseTextures$_(s));
        }
        _$_Unload$_(t, s) {
            if (t !== this && s) for (const s of this._$_textureLoadedTypes$_) s._$IsGlobal$_() || t._$_initialObjectClasses$_.has(s) || (s._$ReleaseTextures$_(), 
            this._$_textureLoadedTypes$_.delete(s));
        }
        _$_OnRendererContextLost$_() {
            this._$_textureLoadedTypes$_.clear();
        }
        async _$_StartRunning$_(t) {
            const s = this._$_runtime$_, i = this._$_layoutManager$_, e = s._$GetEventSheetManager$_();
            this._$_eventSheetName$_ && (this._$_eventSheet$_ = e._$GetEventSheetByName$_(this._$_eventSheetName$_), 
            this._$_eventSheet$_._$_UpdateDeepIncludes$_()), i._$_SetMainRunningLayout$_(this), 
            this._$_width$_ = this._$_originalWidth$_, this._$_height$_ = this._$_originalHeight$_, 
            this._$_scrollX$_ = s._$GetOriginalViewportWidth$_() / 2, this._$_scrollY$_ = s._$GetOriginalViewportHeight$_() / 2, 
            this._$BoundScrolling$_(), this._$_SetAllLayersProjectionChanged$_(), this._$_SetAllLayersMVChanged$_(), 
            this._$_ReindexHTMLLayers$_(), await this._$_runtime$_._$GetCanvasManager$_()._$SetHTMLLayerCount$_(this._$GetHTMLLayerCount$_(), !0), 
            this._$_MoveGlobalObjectsToThisLayout$_(t), this._$_runtime$_._$SetUsingCreatePromises$_(!0), 
            this._$_CreateInitialInstances$_(), this._$_isFirstVisit$_ || this._$_CreatePersistedInstances$_(), 
            this._$_CreateAndLinkContainerInstances$_(this._$_createdInstances$_), this._$_CreateAndLinkContainerInstances$_(this._$_createdPersistedInstances$_), 
            this._$_CreateInitialNonWorldInstances$_(), i._$ClearPendingChangeLayout$_(), s._$FlushPendingInstances$_(), 
            this._$_runtime$_._$SetUsingCreatePromises$_(!1);
            const n = this._$_runtime$_._$GetCreatePromises$_();
            if (await Promise.all(n), Wp._$clearArray$_(n), !s._$IsLoadingState$_()) {
                for (const t of this._$_createdInstances$_) t._$SetupInitialSceneGraphConnections$_();
                for (const t of this._$_createdPersistedInstances$_) t._$SetupPersistedSceneGraphConnections$_(this._$_createdPersistedInstancesToDataMap$_, this._$_createdPersistedIndexToInstanceMap$_);
                for (const [t, s] of Object.entries(this._$_persistData$_)) {
                    const i = this._$_runtime$_._$GetObjectClassBySID$_(parseInt(t, 10));
                    i && !i._$IsFamily$_() && i._$HasPersistBehavior$_() && Wp._$clearArray$_(s);
                }
                for (const t of this._$_createdInstances$_) t._$_TriggerOnCreated$_();
                for (const t of this._$_createdPersistedInstances$_) t._$_TriggerOnCreated$_();
                for (const t of this._$_createdInstances$_) t._$HasParent$_() || t._$_OnHierarchyReady$_();
                for (const t of this._$_createdPersistedInstances$_) t._$HasParent$_() || t._$_OnHierarchyReady$_();
            }
            Wp._$clearArray$_(this._$_createdInstances$_), Wp._$clearArray$_(this._$_createdPersistedInstances$_), 
            this._$_createdPersistedInstancesToDataMap$_.clear(), this._$_createdPersistedIndexToInstanceMap$_.clear(), 
            await Promise.all([ ...this._$_initialObjectClasses$_ ].map((t => t._$PreloadTexturesWithInstances$_(this._$_runtime$_._$GetRenderer$_())))), 
            t && (s._$Dispatcher$_().dispatchEvent(new Wp.Event("beforefirstlayoutstart")), 
            await s._$DispatchUserScriptEventAsyncWait$_(new Wp.Event("beforeprojectstart"))), 
            await this._$DispatchRuntimeUserScriptEventAsyncWait$_(new Wp.Event("beforeanylayoutstart")), 
            s._$Dispatcher$_().dispatchEvent(new Wp.Event("beforelayoutstart")), await this._$DispatchUserScriptEventAsyncWait$_(new Wp.Event("beforelayoutstart")), 
            s._$IsLoadingState$_() || await s._$TriggerAsync$_(Wp._$Plugins$_._$System$_._$Cnds$_._$OnLayoutStart$_, null, null), 
            s._$Dispatcher$_().dispatchEvent(new Wp.Event("afterlayoutstart")), await this._$DispatchUserScriptEventAsyncWait$_(new Wp.Event("afterlayoutstart")), 
            await this._$DispatchRuntimeUserScriptEventAsyncWait$_(new Wp.Event("afteranylayoutstart")), 
            t && (s._$Dispatcher$_().dispatchEvent(new Wp.Event("afterfirstlayoutstart")), await s._$DispatchUserScriptEventAsyncWait$_(new Wp.Event("afterprojectstart"))), 
            e._$_RunQueuedTriggers$_(i), await this._$WaitForPendingTextureLoadsToComplete$_(), 
            this._$_isFirstVisit$_ = !1;
        }
        _$_MoveGlobalObjectsToThisLayout$_(t) {
            for (const t of this._$_runtime$_._$GetAllObjectClasses$_()) if (!t._$IsFamily$_() && t._$IsWorldType$_()) for (const s of t._$GetInstances$_()) {
                const t = s._$GetWorldInfo$_(), i = t._$GetLayer$_(), e = Wp._$clamp$_(i._$GetIndex$_(), 0, this._$_allLayersFlat$_.length - 1), n = this._$_allLayersFlat$_[e];
                t._$_SetLayer$_(n, !0), n._$_MaybeAddInstance$_(s);
            }
            if (!t) for (const t of this._$_allLayersFlat$_) t._$_SortInstancesByLastCachedZIndex$_(!1);
        }
        _$_CreateInitialInstances$_() {
            for (const t of this._$_allLayersFlat$_) t._$CreateInitialInstances$_(this._$_createdInstances$_), 
            t._$_Start$_();
        }
        _$_CreatePersistedInstances$_() {
            let t = !1;
            for (const [s, i] of Object.entries(this._$_persistData$_)) {
                const e = this._$_runtime$_._$GetObjectClassBySID$_(parseInt(s, 10));
                if (e && !e._$IsFamily$_() && e._$HasPersistBehavior$_()) for (const s of i) {
                    let i = null;
                    if (e._$IsWorldType$_() && (i = s.hasOwnProperty("instJson") ? this._$GetLayerBySID$_(s.instJson.w.l) : this._$GetLayerBySID$_(s.w.l), 
                    !i)) continue;
                    const n = this._$_runtime$_._$CreateInstanceFromData$_(e, i, !1, 0, 0, !0);
                    s.hasOwnProperty("instJson") ? n._$LoadFromJson$_(s.instJson) : n._$LoadFromJson$_(s), 
                    t = !0, this._$_createdPersistedInstances$_.push(n), s.hasOwnProperty("instJson") && (this._$_createdPersistedInstancesToDataMap$_.set(n, s), 
                    this._$_createdPersistedIndexToInstanceMap$_.set(s.index, n));
                }
            }
            for (const t of this._$_allLayersFlat$_) t._$_SortInstancesByLastCachedZIndex$_(!0), 
            t._$SetZIndicesChanged$_();
            t && (this._$_runtime$_._$FlushPendingInstances$_(), this._$_runtime$_._$_RefreshUidMap$_());
        }
        _$_CreateAndLinkContainerInstances$_(t) {
            for (const s of t) {
                if (!s._$IsInContainer$_()) continue;
                const i = s._$GetWorldInfo$_(), e = s._$GetIID$_();
                for (const n of s._$GetObjectClass$_()._$GetContainer$_()._$objectTypes$_()) {
                    if (n === s._$GetObjectClass$_()) continue;
                    const h = n._$GetInstances$_();
                    if (h.length > e) s._$_AddSibling$_(h[e]); else {
                        let e;
                        e = i ? this._$_runtime$_._$CreateInstanceFromData$_(n, i._$GetLayer$_(), !0, i._$GetX$_(), i._$GetY$_(), !0) : this._$_runtime$_._$CreateInstanceFromData$_(n, null, !0, 0, 0, !0), 
                        this._$_runtime$_._$FlushPendingInstances$_(), n._$_UpdateIIDs$_(), s._$_AddSibling$_(e), 
                        t.push(e);
                    }
                }
            }
        }
        _$_CreateInitialNonWorldInstances$_() {
            for (const t of this._$_initialNonWorld$_) this._$_runtime$_._$GetObjectClassByIndex$_(t[1])._$IsInContainer$_() || this._$_runtime$_._$CreateInstanceFromData$_(t, null, !0);
        }
        _$_CreateGlobalNonWorlds$_() {
            const t = [], s = this._$_initialNonWorld$_;
            let i = 0;
            for (let e = 0, n = s.length; e < n; ++e) {
                const n = s[e], h = this._$_runtime$_._$GetObjectClassByIndex$_(n[1]);
                h._$IsGlobal$_() ? h._$IsInContainer$_() && h._$GetContainer$_()._$HasAnyWorldType$_() || t.push(this._$_runtime$_._$CreateInstanceFromData$_(n, null, !0)) : (s[i] = n, 
                ++i);
            }
            Wp._$truncateArray$_(s, i), this._$_runtime$_._$FlushPendingInstances$_(), this._$_CreateAndLinkContainerInstances$_(t);
        }
        _$RecreateInitialObjects$_(t, s, i, e, n, h, r) {
            if (i) return i._$RecreateInitialObjects$_(t, s, n, h, e, r);
            {
                const i = [];
                for (const o of this._$_allLayersFlat$_) i.push(o._$RecreateInitialObjects$_(t, s, n, h, e, r));
                return i.flat();
            }
        }
        async _$_StopRunning$_() {
            const t = this._$_layoutManager$_;
            this._$_runtime$_._$IsLoadingState$_() || (await this._$DispatchRuntimeUserScriptEventAsyncWait$_(new Wp.Event("beforeanylayoutend")), 
            await this._$DispatchUserScriptEventAsyncWait$_(new Wp.Event("beforelayoutend")), 
            await this._$_runtime$_._$TriggerAsync$_(Wp._$Plugins$_._$System$_._$Cnds$_._$OnLayoutEnd$_, null, null), 
            await this._$DispatchUserScriptEventAsyncWait$_(new Wp.Event("afterlayoutend")), 
            await this._$DispatchRuntimeUserScriptEventAsyncWait$_(new Wp.Event("afteranylayoutend"))), 
            t._$SetIsEndingLayout$_(!0), this._$_runtime$_._$GetEventSheetManager$_()._$ClearAllScheduledWaits$_(), 
            this._$_isFirstVisit$_ || this._$_SavePersistData$_();
            for (const t of this._$_allLayersFlat$_) t._$_End$_();
            for (const t of this._$_runtime$_._$GetAllObjectClasses$_()) if (!(t._$IsGlobal$_() || t._$IsWorldType$_() || t._$GetPlugin$_()._$IsSingleGlobal$_() || t._$IsFamily$_())) {
                for (const s of t._$GetInstances$_()) this._$_runtime$_._$DestroyInstance$_(s);
                this._$_runtime$_._$FlushPendingInstances$_();
            }
            t._$SetIsEndingLayout$_(!1), t._$GetMainRunningLayout$_() === this && t._$_SetMainRunningLayout$_(null);
        }
        _$_SaveInstanceToPersist$_(t, s) {
            const i = t._$GetObjectClass$_()._$GetSID$_().toString();
            this._$_persistData$_.hasOwnProperty(i) || (this._$_persistData$_[i] = []);
            const e = this._$_persistData$_[i], n = {
                index: s,
                instJson: t._$SaveToJson$_(),
                sceneGraphJson: {
                    children: []
                }
            };
            e.push(n), this._$_persistedIntances$_.set(t, n);
        }
        _$_SaveSceneGraphInfoToPersist$_(t) {
            const s = this._$_persistedIntances$_.get(t);
            for (const i of t._$GetChildren$_()) {
                const t = this._$_persistedIntances$_.get(i);
                t && s.sceneGraphJson.children.push({
                    index: t.index,
                    flags: Wp._$SceneGraphInfo$_._$_GetFlagsNumber$_(i._$GetWorldInfo$_())
                });
            }
        }
        _$_SavePersistData$_() {
            this._$_persistedIntances$_.clear();
            let t = 0;
            for (const s of this._$_allLayersFlat$_) {
                s._$_UpdateZIndices$_();
                for (const i of s._$_GetInstances$_()) {
                    const s = i._$GetObjectClass$_();
                    !s._$IsGlobal$_() && s._$HasPersistBehavior$_() && (this._$_SaveInstanceToPersist$_(i, t), 
                    t++);
                }
            }
            for (const t of this._$_allLayersFlat$_) for (const s of t._$_GetInstances$_()) {
                const t = s._$GetObjectClass$_();
                !t._$IsGlobal$_() && t._$HasPersistBehavior$_() && this._$_SaveSceneGraphInfoToPersist$_(s);
            }
            this._$_persistedIntances$_.clear();
        }
        _$ResetPersistData$_() {
            this._$_persistData$_ = {}, this._$_isFirstVisit$_ = !0;
        }
        _$GetRenderTarget$_() {
            return this._$_curRenderTarget$_;
        }
        _$UsesOwnTexture$_() {
            const t = this._$_runtime$_, s = t._$GetRenderer$_()._$IsWebGL$_();
            return "low" === t._$GetCanvasManager$_()._$GetCurrentFullscreenScalingQuality$_() || s && t._$UsesAnyBackgroundBlending$_() || this._$_effectList$_._$HasAnyActiveEffect$_() || s && t._$Uses3DFeatures$_();
        }
        _$_MaybeStartDrawToOwnTexture$_(t) {
            const s = this._$_runtime$_._$GetCanvasManager$_();
            if (this._$UsesOwnTexture$_()) {
                t._$SetRenderTarget$_(null), t._$ClearRgba$_(0, 0, 0, 0);
                const i = {
                    _$sampling$_: this._$_runtime$_._$GetSampling$_(),
                    _$isSampled$_: t._$IsWebGPU$_() || this._$_runtime$_._$UsesAnyBackgroundBlending$_() || this._$_effectList$_._$HasAnyActiveEffect$_(),
                    _$canReadPixels$_: !!t._$IsWebGPU$_() && this._$_runtime$_._$UsesAnyBackgroundBlending$_()
                };
                "low" === s._$GetCurrentFullscreenScalingQuality$_() && (i.width = s._$GetDrawWidth$_(), 
                i.height = s._$GetDrawHeight$_()), this._$_curRenderTarget$_ = this._$_runtime$_._$GetAdditionalRenderTarget$_(i);
            } else this._$_curRenderTarget$_ = null;
        }
        _$_MaybeCopyOwnTextureToBackbuffer$_(t) {
            this._$_runtime$_._$_NeedsHTMLLayerCompositing$_(t) && (t._$SetDepthEnabled$_(!1), 
            t._$SetRenderTarget$_(null), t._$SetTextureFillMode$_(), t._$CopyRenderTarget$_(this._$_curRenderTarget$_));
        }
        _$_MaybeEndDrawToOwnTexture$_(t) {
            this._$UsesOwnTexture$_() && (t._$SetDepthEnabled$_(!1), this._$_DrawLayoutOwnTextureToRenderTarget$_(t, this._$_curRenderTarget$_));
        }
        _$DrawMain$_(t) {
            t._$SetRenderTarget$_(this._$_curRenderTarget$_), t._$Clear$_(this._$GetLayoutBackgroundColor$_()), 
            this._$_runtime$_._$Uses3DFeatures$_() && t._$ClearDepth$_();
            const s = this._$GetRootLayersForHTMLLayer$_(0);
            this._$_DrawLayerList$_(t, this._$_curRenderTarget$_, s, !0), t._$IsWebGPU$_() && t._$StartMeasuringRenderPassTime$_(0, 1), 
            this._$_MaybeEndDrawToOwnTexture$_(t), this._$_curRenderTarget$_ = null;
        }
        _$DrawForHTMLLayerIndex$_(t, s) {
            let i = null;
            this._$_runtime$_._$_NeedsHTMLLayerCompositing$_(t) && (i = this._$_curRenderTarget$_), 
            t._$SetRenderTarget$_(i), t._$ClearRgba$_(0, 0, 0, 0), this._$_runtime$_._$Uses3DFeatures$_() && t._$ClearDepth$_();
            const e = this._$GetRootLayersForHTMLLayer$_(s);
            this._$_DrawLayerList$_(t, i, e, !0), this._$_MaybeCopyOwnTextureToBackbuffer$_(t), 
            t._$EndBatch$_(), this._$_runtime$_._$GetCanvasManager$_()._$BlitMainCanvasToHTMLLayerCanvas$_(s);
        }
        _$_DrawLayerList$_(t, s, i, e) {
            const n = i.filter((t => t._$ShouldDraw$_()));
            for (let i = 0, h = n.length; i < h; ) {
                const r = n[i];
                if (r._$SelfAndAllSubLayersHave3DCamera$_() && !r._$SelfOrAnySubLayerUsesOwnTexture$_()) {
                    Hp.push(r);
                    for (let t = i + 1; t < h; ++t) {
                        const s = n[t];
                        if (!s._$SelfAndAllSubLayersHave3DCamera$_() || s._$SelfOrAnySubLayerUsesOwnTexture$_()) break;
                        Hp.push(n[t]);
                    }
                    if (Hp.length >= 2 || 1 === Hp.length && Hp[0]._$HasAnyVisibleSubLayer$_()) {
                        this._$_Draw3DLayers$_(t, s, Hp), i += Hp.length, Wp._$clearArray$_(Hp);
                        continue;
                    }
                    Wp._$clearArray$_(Hp);
                }
                r._$Draw$_(t, s, e && 0 === i), ++i;
            }
        }
        _$_DrawLayoutOwnTextureToRenderTarget$_(t, s) {
            const i = this._$_effectList$_._$GetActiveEffectTypes$_(), e = this._$_runtime$_;
            0 === i.length ? (t._$SetRenderTarget$_(null), t._$SetTextureFillMode$_(), t._$CopyRenderTarget$_(s), 
            t._$InvalidateRenderTarget$_(s), e._$ReleaseAdditionalRenderTarget$_(s)) : (Qp.set(0, 0, e._$GetViewportWidth$_(), e._$GetViewportHeight$_()), 
            this._$GetEffectChain$_()._$Render$_(t, null, {
                _$contentObject$_: this,
                _$blendMode$_: 3,
                devicePixelRatio: this._$_runtime$_._$GetEffectDevicePixelRatioParam$_(),
                _$layerScale$_: this._$_runtime$_._$GetEffectLayerScaleParam$_() * this._$GetScale$_(),
                _$layerAngle$_: this._$GetAngle$_(),
                _$layoutRect$_: Qp,
                _$drawSurfaceRect$_: null,
                _$invalidateRenderTargets$_: !0
            }));
        }
        _$_Draw3DLayers$_(t, s, i) {
            i[0]._$IsTransparent$_() || (Yp._$copyRgb$_(i[0]._$GetBackgroundColor$_()), Yp._$setA$_(1), 
            t._$Clear$_(Yp)), this._$_runtime$_._$GetCanvasManager$_(), t._$SetDepthEnabled$_(!0);
            const e = qp, n = Xp, h = Zp;
            for (const t of i) t._$_UpdateZIndices$_(), t._$_AppendAllInstancesIncludingSubLayersInDrawOrder$_(e);
            const r = i[0], o = r._$_MaybeStartWebGLProfiling$_(t);
            r._$_MaybeStartWebGPUProfiling$_(t);
            for (let i = 0, r = e.length; i < r; ) {
                const o = e[i], a = o._$GetWorldInfo$_(), u = a._$GetLayer$_();
                if (!a._$IsVisible$_() || !a._$IsInViewport3D$_(u._$_GetViewFrustum$_())) {
                    ++i;
                    continue;
                }
                (!o._$RendersToOwnZPlane$_() || a._$GetDepth$_() > 0) && h.push(o);
                const l = o._$GetWorldInfo$_()._$GetTotalZElevation$_();
                n.push(o);
                let c = i + 1;
                for (;c < r; ++c) {
                    const t = e[c], s = t._$GetWorldInfo$_();
                    if (s._$IsVisible$_() && s._$IsInViewport3D$_(s._$GetLayer$_()._$_GetViewFrustum$_())) {
                        if (s._$GetTotalZElevation$_() !== l) break;
                        t._$RendersToOwnZPlane$_() ? (s._$GetDepth$_() > 0 && h.push(t), n.push(t)) : h.push(t);
                    }
                }
                if (1 !== n.length || n[0]._$MustMitigateZFighting$_()) {
                    this._$_Draw3DLayersCoplanarInstances$_(t, s, n);
                    for (let i = 0, e = h.length; i < e; ++i) {
                        const e = h[i], n = e._$GetWorldInfo$_(), r = n._$GetLayer$_();
                        n._$_SetDrawNonBackFacesOnly$_(!0), Up(r, t), r._$_DrawInstanceMaybeWithEffects$_(e, n, t, s), 
                        n._$_SetDrawNonBackFacesOnly$_(!1);
                    }
                } else {
                    Up(u, t), u._$_DrawInstanceMaybeWithEffects$_(o, a, t, s);
                    for (let i = 0, e = h.length; i < e; ++i) {
                        const e = h[i];
                        if (e === o) continue;
                        const n = e._$GetWorldInfo$_(), r = n._$GetLayer$_();
                        Up(r, t), r._$_DrawInstanceMaybeWithEffects$_(e, n, t, s);
                    }
                }
                i = c, Wp._$clearArray$_(n), Wp._$clearArray$_(h);
            }
            o && t._$EndQuery$_(o), Wp._$clearArray$_(e), Kp = null;
        }
        _$_Draw3DLayersCoplanarInstances$_(t, s, i) {
            t._$CoplanarStartStencilPass$_();
            for (let s = 0, e = i.length; s < e; ++s) {
                const e = i[s], n = e._$GetWorldInfo$_(), h = n._$GetLayer$_();
                n._$_SetDrawBackFaceOnly$_(!0), Up(h, t), h._$_DrawInstance$_(e, n, t);
            }
            t._$CoplanarStartColorPass$_();
            for (let e = 0, n = i.length; e < n; ++e) {
                const n = i[e], h = n._$GetWorldInfo$_(), r = h._$GetLayer$_();
                Up(r, t), r._$_DrawInstanceMaybeWithEffects$_(n, h, t, s), h._$_SetDrawBackFaceOnly$_(!1);
            }
            t._$CoplanarRestoreStandardRendering$_();
        }
        _$_SaveToJson$_() {
            const t = {
                sx: this._$GetScrollX$_(),
                sy: this._$GetScrollY$_(),
                s: this._$GetScale$_(),
                a: this._$GetAngle$_(),
                w: this._$GetWidth$_(),
                h: this._$GetHeight$_(),
                ortho: this._$IsOrthographicProjection$_(),
                vpX: this._$GetVanishingPointX$_(),
                vpY: this._$GetVanishingPointY$_(),
                fv: this._$_isFirstVisit$_,
                persist: this._$_persistData$_,
                fx: this._$_effectList$_._$SaveToJson$_(),
                layers: {},
                dynamicLayers: []
            };
            for (const s of this._$_allLayersFlat$_) if (s._$IsDynamic$_()) {
                const i = s._$GetParentLayer$_();
                t.dynamicLayers.push({
                    sid: s._$GetSID$_(),
                    name: s._$GetName$_(),
                    parentSid: i ? i._$GetSID$_() : null,
                    siblingIndex: s._$_GetSiblingIndex$_(),
                    data: s._$_SaveToJson$_()
                });
            } else t.layers[s._$GetSID$_().toString()] = s._$_SaveToJson$_();
            return t;
        }
        _$_LoadFromJson$_(t) {
            this._$_scrollX$_ = t.sx, this._$_scrollY$_ = t.sy, this._$_scale$_ = t.s, this._$_angle$_ = t.a, 
            this._$_width$_ = t.w, this._$_height$_ = t.h, this._$_isOrthographicProjection$_ = !!t.ortho, 
            t.hasOwnProperty("vpX") && (this._$_vanishingPointX$_ = t.vpX), t.hasOwnProperty("vpY") && (this._$_vanishingPointY$_ = t.vpY), 
            this._$_isFirstVisit$_ = !!t.fv, this._$_persistData$_ = t.persist, this._$_effectList$_._$LoadFromJson$_(t.fx), 
            this._$_needsRebuildEffectChainSteps$_ = !0;
            for (const [s, i] of Object.entries(t.layers)) {
                const t = parseInt(s, 10), e = this._$GetLayerBySID$_(t);
                e && e._$_LoadFromJson$_(i);
            }
            if (t.hasOwnProperty("dynamicLayers")) {
                this._$RemoveAllDynamicLayers$_(), this._$_runtime$_._$FlushPendingInstances$_();
                const s = new Map, i = t.dynamicLayers;
                for (let t = i.length - 1; t >= 0; --t) {
                    const e = i[t], n = e.sid, h = e.name, r = e.parentSid, o = e.siblingIndex, a = e.data;
                    if (this._$_ReindexLayers$_(), this._$HasLayerByName$_(h) || this._$GetLayerBySID$_(n)) continue;
                    let u, l;
                    if (null === r) u = null, l = this._$_rootLayers$_; else {
                        if (u = this._$GetLayerBySID$_(r), !u) continue;
                        l = u._$GetSubLayers$_();
                    }
                    const c = Wp._$New$_(Wp._$Layer$_, this, u, {
                        name: h,
                        _$sid$_: n,
                        _$isDynamic$_: !0
                    });
                    l.push(c);
                    let f = s.get(l);
                    f || (f = [], s.set(l, f)), f.push({
                        _$layer$_: c,
                        _$siblingIndex$_: o
                    }), c._$_LoadFromJson$_(a);
                }
                for (const [t, i] of s) {
                    i.sort(((t, s) => t._$siblingIndex$_ - s._$siblingIndex$_));
                    for (const s of i) {
                        const i = s._$layer$_, e = s._$siblingIndex$_;
                        let n = t.indexOf(i);
                        t.splice(n, 1), t.splice(e, 0, i);
                    }
                }
            }
            this._$_ReindexAndUpdateAllLayers$_(), this._$_SetAllLayersProjectionChanged$_(), 
            this._$_SetAllLayersMVChanged$_();
        }
        _$GetILayout$_() {
            return this._$_iLayout$_;
        }
        _$UserScriptDispatcher$_() {
            return this._$_userScriptDispatcher$_;
        }
        _$DispatchUserScriptEvent$_(t) {
            t.layout = this._$GetILayout$_();
            const s = this._$_runtime$_, i = s._$IsDebug$_() && !s._$GetEventSheetManager$_()._$IsInEventEngine$_();
            i && Jp._$StartMeasuringScriptTime$_(), this._$_userScriptDispatcher$_.dispatchEvent(t), 
            i && Jp._$AddScriptTime$_();
        }
        _$DispatchUserScriptEventAsyncWait$_(t) {
            return t.layout = this._$GetILayout$_(), this._$_userScriptDispatcher$_._$dispatchEventAndWaitAsync$_(t);
        }
        _$DispatchRuntimeUserScriptEventAsyncWait$_(t) {
            return t.layout = this._$GetILayout$_(), this._$_runtime$_._$DispatchUserScriptEventAsyncWait$_(t);
        }
        _$_LogLayerTree$_() {
            this._$_LogLayerList$_(this._$_rootLayers$_);
        }
        _$_LogLayerList$_(t, s = 0) {
            const i = t.slice(0);
            i.reverse();
            for (const t of i) console.log(`${"\t".repeat(s)}- ${t._$GetName$_()}`), this._$_LogLayerList$_(t._$GetSubLayers$_(), s + 1);
        }
    };
}

{
    const $p = self._$C3$_;
    $p._$LayoutManager$_ = class extends $p._$DefendedBase$_ {
        #s;
        #i=[];
        #f=new Map;
        #a=new Map;
        #e=null;
        #t=[];
        #h=null;
        #r=0;
        #d=null;
        constructor(t) {
            super(), this.#s = t;
        }
        _$Release$_() {
            this.#s = null, this.#e = null, this.#h = null, this.#d = null, $p._$clearArray$_(this.#i), 
            this.#f.clear(), this.#a.clear(), $p._$clearArray$_(this.#t);
        }
        _$Create$_(t) {
            const s = $p._$New$_($p._$Layout$_, this, this.#i.length, t);
            this.#i.push(s), this.#f.set(s._$GetName$_().toLowerCase(), s), this.#a.set(s._$GetSID$_(), s);
        }
        _$GetRuntime$_() {
            return this.#s;
        }
        _$SetFirstLayout$_(t) {
            this.#h = t;
        }
        _$GetFirstLayout$_() {
            if (this.#h) return this.#h;
            if (this.#i.length) return this.#i[0];
            throw new Error("no first layout");
        }
        _$GetLayoutByName$_(t) {
            return this.#f.get(t.toLowerCase()) || null;
        }
        _$GetLayoutBySID$_(t) {
            return this.#a.get(t) || null;
        }
        _$GetLayoutByIndex$_(t) {
            return t = $p._$clamp$_(Math.floor(t), 0, this.#i.length - 1), this.#i[t];
        }
        _$GetLayout$_(t) {
            return "number" == typeof t ? this._$GetLayoutByIndex$_(t) : this._$GetLayoutByName$_(t.toString());
        }
        _$GetAllLayouts$_() {
            return this.#i;
        }
        _$_SetMainRunningLayout$_(t) {
            this.#e = t;
        }
        _$GetMainRunningLayout$_() {
            return this.#e;
        }
        _$_AddRunningSubLayout$_(t) {
            if (this.#t.includes(t)) throw new Error("layout already running");
            this.#t.push(t);
        }
        _$_RemoveRunningSubLayout$_(t) {
            const s = this.#t.indexOf(t);
            if (-1 === s) throw new Error("layout not running");
            this.#t.splice(s, 1);
        }
        * _$runningLayouts$_() {
            this.#e && (yield this.#e), this.#t.length && (yield* this.#t);
        }
        _$IsLayoutRunning$_(t) {
            return this.#e === t || this.#t.includes(t);
        }
        _$SetIsEndingLayout$_(t) {
            if (t) this.#r++; else {
                if (this.#r <= 0) throw new Error("already unset");
                this.#r--;
            }
        }
        _$IsEndingLayout$_() {
            return this.#r > 0;
        }
        _$ChangeMainLayout$_(t) {
            this.#d = t;
        }
        _$ClearPendingChangeLayout$_() {
            this.#d = null;
        }
        _$IsPendingChangeMainLayout$_() {
            return !!this.#d;
        }
        _$GetPendingChangeMainLayout$_() {
            return this.#d;
        }
        _$SetAllLayerProjectionChanged$_() {
            const t = this._$GetMainRunningLayout$_();
            t && t._$_SetAllLayersProjectionChanged$_();
        }
        _$SetAllLayerMVChanged$_() {
            const t = this._$GetMainRunningLayout$_();
            t && t._$_SetAllLayersMVChanged$_();
        }
    };
}

{
    const tm = self._$C3$_, sm = new RegExp("<(.+?)>", "g");
    tm._$TimelineManager$_ = class extends tm._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_runtime$_ = t, this._$_timelineDataManager$_ = tm._$New$_(tm._$TimelineDataManager$_), 
            this._$_pluginInstance$_ = null, this._$_timelines$_ = [], this._$_timelinesByName$_ = new Map, 
            this._$_objectClassToTimelineMap$_ = new Map, this._$_timelinesCreatedByTemplate$_ = new Map, 
            this._$_scheduledTimelines$_ = [], this._$_playingTimelines$_ = [], this._$_markedForRemovalTimelines$_ = [], 
            this._$_hasRuntimeListeners$_ = !1, this._$_changingLayout$_ = !1, this._$_isTickingTimelines$_ = !1, 
            this._$_tickFunc$_ = () => this._$_OnTick$_(), this._$_tick2Func$_ = () => this._$_OnTick2$_(), 
            this._$_beforeLayoutChange$_ = () => this._$_OnBeforeChangeLayout$_(), this._$_layoutChange$_ = () => this._$_OnAfterChangeLayout$_(), 
            this._$_instanceDestroy$_ = t => this._$_OnInstanceDestroy$_(t._$instance$_), this._$_beforeLoad$_ = t => this._$_OnBeforeLoad$_(), 
            this._$_afterLoad$_ = t => this._$_OnAfterLoad$_(), this._$_afterLayoutStart$_ = t => this._$_OnAfterLayoutStart$_(), 
            this._$_destroyedWhileLoadingState$_ = [], this._$_renderChange$_ = 0;
        }
        _$Release$_() {
            this._$RemoveRuntimeListeners$_(), this._$_tickFunc$_ = null, this._$_tick2Func$_ = null, 
            this._$_beforeLayoutChange$_ = null, this._$_layoutChange$_ = null, this._$_instanceDestroy$_ = null, 
            this._$_afterLoad$_ = null;
            for (const t of this._$_timelines$_) t._$Stop$_(), t._$Release$_();
            tm._$clearArray$_(this._$_timelines$_), this._$_timelines$_ = null, this._$_timelineDataManager$_._$Release$_(), 
            this._$_timelineDataManager$_ = null, tm._$clearArray$_(this._$_scheduledTimelines$_), 
            this._$_scheduledTimelines$_ = null, tm._$clearArray$_(this._$_playingTimelines$_), 
            this._$_playingTimelines$_ = null, tm._$clearArray$_(this._$_markedForRemovalTimelines$_), 
            this._$_markedForRemovalTimelines$_ = null, this._$_timelinesByName$_.clear(), this._$_timelinesByName$_ = null, 
            this._$_objectClassToTimelineMap$_.clear(), this._$_objectClassToTimelineMap$_ = null, 
            this._$_timelinesCreatedByTemplate$_.clear(), this._$_timelinesCreatedByTemplate$_ = null, 
            tm._$clearArray$_(this._$_destroyedWhileLoadingState$_), this._$_destroyedWhileLoadingState$_ = null, 
            this._$_runtime$_ = null;
        }
        _$AddRuntimeListeners$_() {
            const t = this._$_runtime$_._$Dispatcher$_();
            t.addEventListener("pretick", this._$_tickFunc$_), t.addEventListener("tick2", this._$_tick2Func$_), 
            t.addEventListener("beforelayoutchange", this._$_beforeLayoutChange$_), t.addEventListener("layoutchange", this._$_layoutChange$_), 
            t.addEventListener("instancedestroy", this._$_instanceDestroy$_), t.addEventListener("beforeload", this._$_beforeLoad$_), 
            t.addEventListener("afterload", this._$_afterLoad$_), t.addEventListener("afterlayoutstart", this._$_afterLayoutStart$_);
        }
        _$RemoveRuntimeListeners$_() {
            const t = this._$_runtime$_._$Dispatcher$_();
            t.removeEventListener("pretick", this._$_tickFunc$_), t.removeEventListener("tick2", this._$_tick2Func$_), 
            t.removeEventListener("beforelayoutchange", this._$_beforeLayoutChange$_), t.removeEventListener("layoutchange", this._$_layoutChange$_), 
            t.removeEventListener("instancedestroy", this._$_instanceDestroy$_), t.removeEventListener("beforeload", this._$_beforeLoad$_), 
            t.removeEventListener("afterload", this._$_afterLoad$_), t.removeEventListener("afterlayoutstart", this._$_afterLayoutStart$_);
        }
        _$Create$_(t) {
            this._$_timelineDataManager$_._$Add$_(t);
            const s = tm._$TimelineState$_._$CreateInitial$_(t, this);
            this._$Add$_(s), this._$SetTimelineObjectClassesToMap$_(s), this._$_timelinesCreatedByTemplate$_.set(s._$GetName$_(), 0);
        }
        _$CreateFromTemplate$_(t) {
            const s = this._$GetTimelineDataManager$_(), i = t._$GetTemplateName$_(), e = s._$Get$_(i), n = tm._$TimelineState$_._$CreateFromTemplate$_(`${i}:${this._$_timelinesCreatedByTemplate$_.get(i)}`, e, this);
            return this._$_IncreaseTemplateTimelinesCount$_(i), this._$Add$_(n), n;
        }
        _$_IncreaseTemplateTimelinesCount$_(t) {
            this._$_timelinesCreatedByTemplate$_.set(t, this._$_timelinesCreatedByTemplate$_.get(t) + 1);
        }
        _$_SetCreatedTemplateTimelinesCount$_() {
            for (const t of this._$_timelines$_) {
                if (t._$IsTemplate$_()) continue;
                const s = t._$GetTemplateName$_();
                this._$_IncreaseTemplateTimelinesCount$_(s);
            }
        }
        _$_ClearCreatedTemplateTimelinesCount$_() {
            for (const t of this._$_timelinesCreatedByTemplate$_.keys()) this._$_timelinesCreatedByTemplate$_.set(t, 0);
        }
        _$Add$_(t) {
            this._$_timelines$_.push(t), this._$_timelinesByName$_.set(t._$GetName$_().toLowerCase(), t);
        }
        _$Remove$_(t) {
            t._$Removed$_(), t._$IsTemplate$_() || (tm._$arrayFindRemove$_(this._$_timelines$_, t), 
            tm._$arrayFindRemove$_(this._$_scheduledTimelines$_, t), tm._$arrayFindRemove$_(this._$_playingTimelines$_, t), 
            tm._$arrayFindRemove$_(this._$_markedForRemovalTimelines$_, t), this._$_timelinesByName$_.delete(t._$GetName$_().toLowerCase()), 
            this._$RemoveTimelineFromObjectClassMap$_(t), t._$IsReleased$_() || t._$Release$_());
        }
        _$Trigger$_(t) {
            this._$_runtime$_._$Trigger$_(t, this._$_pluginInstance$_, null);
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetTimelineDataManager$_() {
            return this._$_timelineDataManager$_;
        }
        _$SetPluginInstance$_(t) {
            this._$_pluginInstance$_ = t;
        }
        _$GetPluginInstance$_() {
            return this._$_pluginInstance$_;
        }
        * _$GetTimelines$_() {
            for (const t of this._$_timelines$_) yield t;
        }
        * _$GetPlayingTimelines$_() {
            for (const t of this._$_playingTimelines$_) yield t;
        }
        _$SetTimelineObjectClassToMap$_(t, s) {
            this._$_objectClassToTimelineMap$_.has(t) || this._$_objectClassToTimelineMap$_.set(t, new Set), 
            this._$_objectClassToTimelineMap$_.get(t).add(s);
        }
        _$SetTimelineObjectClassesToMap$_(t) {
            for (const s of t._$GetObjectClasses$_()) this._$SetTimelineObjectClassToMap$_(s, t);
        }
        _$RemoveTimelineFromObjectClassMap$_(t) {
            for (const [s, i] of this._$_objectClassToTimelineMap$_.entries()) i.has(t) && (i.delete(t), 
            0 === i.size && this._$_objectClassToTimelineMap$_.delete(s));
        }
        _$GetTimelinesForObjectClass$_(t) {
            if (this._$_objectClassToTimelineMap$_.has(t)) return this._$_objectClassToTimelineMap$_.get(t);
        }
        _$GetTimelineOfTemplateForInstances$_(t, s) {
            if (s) for (const i of this._$_timelines$_) if (s.every((t => i._$HasTrackInstance$_(t._$instance$_, t.trackId))) && i._$GetName$_().includes(t._$GetName$_())) return i;
        }
        _$GetTimelineByName$_(t) {
            return this._$_timelinesByName$_.get(t.toLowerCase()) || null;
        }
        _$GetScheduledOrPlayingTimelineByName$_(t) {
            for (const s of this._$_scheduledTimelines$_) if (s._$GetName$_() === t) return s;
            for (const s of this._$_playingTimelines$_) if (s._$GetName$_() === t) return s;
            return null;
        }
        * _$GetTimelinesByName$_(t) {
            if (sm.test(t)) {
                let s;
                sm.lastIndex = 0;
                const i = new Set;
                do {
                    if (s = sm.exec(t), s) {
                        const t = s[1].split(",");
                        for (const s of t) i.add(s);
                    }
                } while (s);
                for (const t of i.values()) {
                    const s = this._$GetTimelineByName$_(t);
                    s && (yield s);
                }
                i.clear();
            } else {
                const s = this._$GetTimelineByName$_(t);
                s && (yield s);
            }
        }
        * _$GetTimelinesByTags$_(t) {
            for (const s of this._$_timelines$_) s._$HasTags$_(t) && (yield s);
        }
        _$AddScheduledTimeline$_(t) {
            this._$_scheduledTimelines$_.includes(t) || this._$_scheduledTimelines$_.push(t), 
            this._$_MaybeEnableRuntimeListeners$_();
        }
        _$RemovePlayingTimeline$_(t) {
            tm._$arrayFindRemove$_(this._$_playingTimelines$_, t), this._$_MaybeDisableRuntimeListeners$_();
        }
        _$ScheduleTimeline$_(t) {
            this._$_playingTimelines$_.includes(t) ? (t._$SetPlaying$_(!0), t._$SetScheduled$_(!1), 
            t._$SetMarkedForRemoval$_(!1)) : (t._$SetPlaying$_(!1), t._$SetScheduled$_(!0), 
            t._$SetMarkedForRemoval$_(!1), this._$_scheduledTimelines$_.includes(t) || this._$_scheduledTimelines$_.push(t)), 
            this._$_MaybeEnableRuntimeListeners$_();
        }
        _$DeScheduleTimeline$_(t) {
            t._$SetPlaying$_(!1), t._$SetScheduled$_(!1), t._$ResolvePlayPromise$_(), tm._$arrayFindRemove$_(this._$_scheduledTimelines$_, t), 
            this._$_MaybeDisableRuntimeListeners$_();
        }
        _$CompleteTimeline$_(t) {
            t._$SetPlaying$_(!1), t._$SetScheduled$_(!1), this._$_playingTimelines$_.includes(t) && (t._$SetMarkedForRemoval$_(!0), 
            this._$_markedForRemovalTimelines$_.push(t), tm._$arrayFindRemove$_(this._$_playingTimelines$_, t)), 
            this._$_scheduledTimelines$_.includes(t) && t._$SetMarkedForRemoval$_(!0);
        }
        _$CompleteTimelineBeforeChangeOfLayout$_(t) {
            t._$SetPlaying$_(!1), t._$SetScheduled$_(!1), t._$SetMarkedForRemoval$_(!1), t._$SetPlaybackRate$_(1), 
            tm._$arrayFindRemove$_(this._$_playingTimelines$_, t);
        }
        _$CompleteTimelineAndResolve$_(t) {
            this._$CompleteTimeline$_(t), t._$ResolvePlayPromise$_();
        }
        _$_OnTick$_() {
            const t = this._$GetRuntime$_();
            if (t._$IsLoadingState$_()) return;
            if (!this._$_hasRuntimeListeners$_) return;
            if (this._$_changingLayout$_) return;
            let s = 0;
            for (t._$IsDebug$_() && (s = performance.now()), this._$_isTickingTimelines$_ = !0; this._$_scheduledTimelines$_.length; ) {
                const t = this._$_scheduledTimelines$_.pop();
                t._$IsMarkedForRemoval$_() ? (t._$SetInitialStateForce$_(), this._$_markedForRemovalTimelines$_.push(t)) : (t._$SetInitialState$_(), 
                this._$_playingTimelines$_.push(t)), 0 !== t._$GetRenderChange$_() && (this._$_renderChange$_ = 1);
            }
            const i = this._$_runtime$_._$_GetDtFast$_(), e = this._$_runtime$_._$GetDt1$_(), n = this._$_runtime$_._$GetTimeScale$_();
            for (let t = this._$_playingTimelines$_.length - 1; t >= 0; t--) {
                const s = this._$_playingTimelines$_[t];
                s && s._$Tick$_(i, n, e);
            }
            this._$_isTickingTimelines$_ = !1, t._$IsDebug$_() && globalThis._$C3Debugger$_._$AddTweensAndTimelinesTime$_(performance.now() - s), 
            0 !== this._$_renderChange$_ && t._$UpdateRender$_();
        }
        _$_OnTick2$_() {
            const t = this._$GetRuntime$_();
            if (t._$IsLoadingState$_()) return;
            if (!this._$_hasRuntimeListeners$_) return;
            if (this._$_changingLayout$_) return;
            let s, i = 0;
            t._$IsDebug$_() && (i = performance.now());
            for (let t = 0, i = this._$_markedForRemovalTimelines$_.length; t < i; t++) {
                const i = this._$_markedForRemovalTimelines$_[t];
                s || (s = new Set), i._$Removed$_(), this._$_MaybeExecuteTimelineFinishTriggers$_(i), 
                s.add(i);
            }
            if (s) {
                tm._$arrayRemoveAllInSet$_(this._$_markedForRemovalTimelines$_, s), this._$_renderChange$_ = 0;
                for (let t = 0, s = this._$_playingTimelines$_.length; t < s; t++) if (0 !== this._$_playingTimelines$_[t]._$GetRenderChange$_()) {
                    this._$_renderChange$_ = 1;
                    break;
                }
            }
            this._$_MaybeDisableRuntimeListeners$_(), t._$IsDebug$_() && globalThis._$C3Debugger$_._$AddTweensAndTimelinesTime$_(performance.now() - i);
        }
        _$_MaybeExecuteTimelineFinishTriggers$_(t) {
            t._$IsReleased$_() || t._$HasValidTracks$_() && t._$IsComplete$_() && t._$InitialStateSet$_() && t._$FinishTriggers$_();
        }
        _$_MaybeEnableRuntimeListeners$_() {
            this._$_hasRuntimeListeners$_ || (this._$_hasRuntimeListeners$_ = !0);
        }
        _$_MaybeDisableRuntimeListeners$_() {
            this._$_markedForRemovalTimelines$_.length || this._$_playingTimelines$_.length || this._$_scheduledTimelines$_.length || this._$_isTickingTimelines$_ || (this._$_hasRuntimeListeners$_ = !1);
        }
        _$_OnBeforeChangeLayout$_() {
            for (this._$_changingLayout$_ = !0; this._$_scheduledTimelines$_.length; ) this._$DeScheduleTimeline$_(this._$_scheduledTimelines$_.pop());
            const t = new Set;
            for (const s of this._$_playingTimelines$_) s._$_OnBeforeChangeLayout$_() && (s._$Removed$_(), 
            t.add(s));
            tm._$arrayRemoveAllInSet$_(this._$_playingTimelines$_, t), t.clear();
            for (const s of this._$_markedForRemovalTimelines$_) s._$_OnBeforeChangeLayout$_() && (s._$Removed$_(), 
            t.add(s));
            tm._$arrayRemoveAllInSet$_(this._$_markedForRemovalTimelines$_, t), this._$_MaybeDisableRuntimeListeners$_();
            for (const t of this._$_timelines$_) t._$CleanCaches$_();
        }
        _$_OnAfterChangeLayout$_() {
            this._$_changingLayout$_ = !1;
        }
        _$_OnInstanceDestroy$_(t) {
            const s = t._$GetObjectClass$_(), i = this._$GetTimelinesForObjectClass$_(s);
            if (i) if (this._$_runtime$_._$IsLoadingState$_()) this._$_destroyedWhileLoadingState$_.push(t); else for (const t of i) t._$IsTemplate$_() || (t._$IsReleased$_() ? this._$Remove$_(t) : t._$HasValidTracks$_() || (this._$_MaybeExecuteTimelineFinishTriggers$_(t), 
            this._$Remove$_(t)));
        }
        _$_OnBeforeLoad$_() {
            for (const t of this._$_scheduledTimelines$_.map((t => t))) this._$_MaybeExecuteTimelineFinishTriggers$_(t), 
            this._$Remove$_(t);
            for (const t of this._$_playingTimelines$_.map((t => t))) this._$_MaybeExecuteTimelineFinishTriggers$_(t), 
            this._$Remove$_(t);
        }
        _$_OnAfterLoad$_() {
            for (const t of this._$_destroyedWhileLoadingState$_) this._$_OnInstanceDestroy$_(t);
            tm._$clearArray$_(this._$_destroyedWhileLoadingState$_);
            for (const t of this._$_timelines$_) t._$_OnAfterLoad$_();
        }
        _$_OnAfterLayoutStart$_() {
            const t = this._$_runtime$_._$GetLayoutManager$_()._$GetMainRunningLayout$_();
            if (t) for (const s of this._$_timelines$_) {
                const i = s._$GetStartOnLayout$_();
                i && t._$GetName$_() === i && this._$ScheduleTimeline$_(s);
            }
        }
        _$_SaveToJson$_() {
            return {
                timelinesJson: this._$_SaveTimelinesToJson$_(),
                scheduledTimelinesJson: this._$_SaveScheduledTimelinesToJson$_(),
                playingTimelinesJson: this._$_SavePlayingTimelinesToJson$_(),
                markedForRemovalTimelinesJson: this._$_SaveMarkedForRemovalTimelinesToJson$_(),
                hasRuntimeListeners: this._$_hasRuntimeListeners$_,
                changingLayout: this._$_changingLayout$_,
                isTickingTimelines: this._$_isTickingTimelines$_
            };
        }
        _$_LoadFromJson$_(t) {
            t && (this._$_ClearCreatedTemplateTimelinesCount$_(), this._$_LoadTimelinesFromJson$_(t.timelinesJson), 
            this._$_LoadScheduledTimelinesFromJson$_(t.scheduledTimelinesJson), this._$_LoadPlayingTimelinesFromJson$_(t.playingTimelinesJson), 
            this._$_LoadMarkedForRemovalTimelinesFromJson$_(t.markedForRemovalTimelinesJson), 
            this._$_hasRuntimeListeners$_ = !t.hasRuntimeListeners, this._$_changingLayout$_ = !!t.changingLayout, 
            this._$_isTickingTimelines$_ = !!t.isTickingTimelines, this._$_SetCreatedTemplateTimelinesCount$_(), 
            this._$_MaybeEnableRuntimeListeners$_(), this._$_MaybeDisableRuntimeListeners$_());
        }
        _$_SaveTimelinesToJson$_() {
            return this._$_timelines$_.map((t => t._$_SaveToJson$_()));
        }
        _$_LoadTimelinesFromJson$_(t) {
            for (const s of t) {
                let t = this._$GetTimelineByName$_(s.name);
                if (t) t._$_LoadFromJson$_(s); else {
                    const i = this._$_GetTemplateNameFromJson$_(s);
                    if (!i) continue;
                    const e = this._$GetTimelineByName$_(i);
                    t = this._$CreateFromTemplate$_(e), t._$_LoadFromJson$_(s);
                }
                t._$HasTracks$_() || this._$Remove$_(t);
            }
        }
        _$_GetTemplateNameFromJson$_(t) {
            const s = t.name.split(":");
            return s && 2 === s.length ? s[0] : null;
        }
        _$_SaveScheduledTimelinesToJson$_() {
            return this._$_SaveTimelines$_(this._$_scheduledTimelines$_);
        }
        _$_LoadScheduledTimelinesFromJson$_(t) {
            this._$_LoadTimelines$_(t, this._$_scheduledTimelines$_);
        }
        _$_SavePlayingTimelinesToJson$_() {
            return this._$_SaveTimelines$_(this._$_playingTimelines$_);
        }
        _$_LoadPlayingTimelinesFromJson$_(t) {
            this._$_LoadTimelines$_(t, this._$_playingTimelines$_);
        }
        _$_SaveMarkedForRemovalTimelinesToJson$_() {
            return this._$_SaveTimelines$_(this._$_markedForRemovalTimelines$_);
        }
        _$_LoadMarkedForRemovalTimelinesFromJson$_(t) {
            this._$_LoadTimelines$_(t, this._$_markedForRemovalTimelines$_);
        }
        _$_IsTimelineInJson$_(t, s) {
            if (!s) return !1;
            for (const i of s) if (i === t._$GetName$_()) return !0;
            return !1;
        }
        _$_SaveTimelines$_(t) {
            return t.map((t => t._$GetName$_()));
        }
        _$_LoadTimelines$_(t, s) {
            const i = new Set;
            for (const e of s) this._$_IsTimelineInJson$_(e, t) || i.add(e);
            if (tm._$arrayRemoveAllInSet$_(s, i), t) {
                const i = t => s => s._$GetName$_() === t;
                for (const e of t) {
                    const t = this._$GetTimelineByName$_(e);
                    t && (s.find(i(e)) || s.push(t));
                }
            }
        }
    };
}

{
    const im = self._$C3$_, em = [ 0, 0 ], nm = [ 0, 0 ], hm = [ 0, 0 ], rm = [ 0, 0, 0, 0, 0 ], om = new Array(4), am = [ {
        x: 0,
        y: 0,
        t: 0,
        _$distance$_: 0
    }, {
        x: 0,
        y: 0,
        t: 0,
        _$distance$_: 0
    }, {
        x: 0,
        y: 0,
        t: 0,
        _$distance$_: 0
    } ], um = {
        x: 0,
        y: 0,
        t: 0,
        _$distance$_: 0
    };
    im._$TimelineInfo$_ = class {
        constructor(t, s) {
            this._$_initialized$_ = !1, this._$_timeline$_ = t, this._$_segments$_ = [];
            let i = null;
            if (i = s ? this._$_timeline$_._$GetTrackById$_(s) : im._$first$_(this._$_timeline$_._$GetTracks$_()), 
            !i) return;
            const e = i._$GetPropertyTrack$_("offsetX"), n = i._$GetPropertyTrack$_("offsetY");
            if (!e || !n) return;
            this._$_xTrack$_ = e, this._$_yTrack$_ = n;
            const h = e._$GetPropertyKeyframeDataItemArrayIncludingDisabled$_(), r = n._$GetPropertyKeyframeDataItemArrayIncludingDisabled$_();
            for (let t = 1, s = Math.min(h.length, r.length); t < s; ++t) {
                const s = h[t], i = (s._$GetNext$_(), s._$GetPrevious$_()), e = r[t], n = (e._$GetNext$_(), 
                e._$GetPrevious$_());
                i && "cubic-bezier" === i._$GetPathMode$_() && n && "cubic-bezier" === n._$GetPathMode$_() ? this._$_segments$_.push(im._$New$_(im._$TimelineCubicBezierSegmentInfo$_, i, n, s, e, this._$_segments$_.length)) : (i && "line" === i._$GetPathMode$_() && n && n._$GetPathMode$_(), 
                this._$_segments$_.push(im._$New$_(im._$TimelineLineSegmentInfo$_, s, e, this._$_segments$_.length)));
            }
            this._$_initialized$_ = !0;
        }
        _$Release$_() {
            for (const t of this._$_segments$_) t._$Release$_();
            im._$clearArray$_(this._$_segments$_), this._$_segments$_ = null, this._$_timeline$_ = null, 
            this._$_xTrack$_ = null, this._$_yTrack$_ = null;
        }
        _$WasInitialized$_() {
            return this._$_initialized$_;
        }
        _$segments$_() {
            return this._$_segments$_;
        }
        _$SetOrigin$_(t) {
            const s = "relative" === this._$_xTrack$_._$GetResultMode$_() ? t._$GetX$_() : 0, i = "relative" === this._$_yTrack$_._$GetResultMode$_() ? t._$GetY$_() : 0;
            for (const t of this._$_segments$_) t._$SetOrigin$_(s, i);
        }
        _$Project$_(t, s, i) {
            let e = NaN, n = this._$_segments$_.length;
            for (let i = 0; i < n; i++) {
                const n = this._$_segments$_[i];
                if ("cubic-bezier" === n._$GetType$_()) {
                    const i = n._$Project$_(t, s);
                    (isNaN(e) || i[3] < e) && (e = i[3], hm[0] = i[2], hm[1] = n._$GetIndex$_());
                }
            }
            return hm;
        }
        _$ProjectWithOptions$_(t, s, i) {
            const e = i._$tRange$_;
            im._$IsFiniteNumber$_(e[0]) || (e[0] = 0), im._$IsFiniteNumber$_(e[1]) || (e[1] = 1);
            let n = NaN, h = this._$_segments$_.length;
            for (let i = 0; i < h; i++) {
                const h = this._$_segments$_[i];
                if ("cubic-bezier" === h._$GetType$_()) {
                    const i = h._$ProjectWithRange$_(t, s, e);
                    (isNaN(n) || i[3] < n) && (n = i[3], hm[0] = i[2], hm[1] = h._$GetIndex$_());
                }
            }
            return hm;
        }
        _$Tangent$_(t, s) {
            return this._$_segments$_[s]._$Tangent$_(t);
        }
        _$TangentAngle$_(t, s) {
            return this._$_segments$_[s]._$TangentAngle$_(t);
        }
    }, im._$TimelineCubicBezierSegmentInfo$_ = class {
        constructor(t, s, i, e, n) {
            this._$_index$_ = n;
            const h = t._$GetAddOn$_("cubic-bezier"), r = i._$GetAddOn$_("cubic-bezier"), o = s._$GetAddOn$_("cubic-bezier"), a = e._$GetAddOn$_("cubic-bezier");
            this._$_aX$_ = t._$GetValueWithResultMode$_(), this._$_aY$_ = s._$GetValueWithResultMode$_(), 
            this._$_bX$_ = t._$GetValueWithResultMode$_() + h._$GetStartAnchor$_(), this._$_bY$_ = s._$GetValueWithResultMode$_() + o._$GetStartAnchor$_(), 
            this._$_cX$_ = i._$GetValueWithResultMode$_() + r._$GetEndAnchor$_(), this._$_cY$_ = e._$GetValueWithResultMode$_() + a._$GetEndAnchor$_(), 
            this._$_dX$_ = i._$GetValueWithResultMode$_(), this._$_dY$_ = e._$GetValueWithResultMode$_(), 
            this._$_aXO$_ = 0, this._$_aYO$_ = 0, this._$_bXO$_ = 0, this._$_bYO$_ = 0, this._$_cXO$_ = 0, 
            this._$_cYO$_ = 0, this._$_dXO$_ = 0, this._$_dYO$_ = 0, this._$_d0x$_ = 0, this._$_d0y$_ = 0, 
            this._$_d1x$_ = 0, this._$_d1y$_ = 0, this._$_d2x$_ = 0, this._$_d2y$_ = 0, this._$_x1Factor$_ = 0, 
            this._$_x2Factor$_ = 0, this._$_x3Factor$_ = 0, this._$_y1Factor$_ = 0, this._$_y2Factor$_ = 0, 
            this._$_y3Factor$_ = 0, this._$_lutIndex$_ = NaN, this._$_initialized$_ = !1, this._$_len$_ = 100, 
            this._$_arcLengths$_ = new Array(this._$_len$_ + 1), this._$_arcLengths$_[0] = 0, 
            this._$_length$_ = 0, this._$_lut$_ = [], this._$_lutObjects$_ = [];
            for (let t = 0; t < 100; t++) this._$_lutObjects$_.push({
                x: 0,
                y: 0,
                t: 0,
                _$distance$_: 0
            });
            this._$_CalculateLength$_();
        }
        _$Release$_() {
            im._$clearArray$_(this._$_arcLengths$_), this._$_arcLengths$_ = null, im._$clearArray$_(this._$_lut$_), 
            this._$_lut$_ = null, im._$clearArray$_(this._$_lutObjects$_), this._$_lutObjects$_ = null;
        }
        _$GetType$_() {
            return "cubic-bezier";
        }
        _$GetIndex$_() {
            return this._$_index$_;
        }
        _$GetStepCount$_() {
            return Math.floor(this._$_length$_ / 25);
        }
        _$GetStepIncrement$_() {
            return 1 / this._$GetStepCount$_();
        }
        _$SetOrigin$_(t, s) {
            this._$_originX$_ = t, this._$_originY$_ = s, this._$_arcLengths$_ = new Array(this._$_len$_ + 1), 
            this._$_arcLengths$_[0] = 0, this._$_CalculateLength$_(), this._$_aXO$_ = this._$_aX$_ + this._$_originX$_, 
            this._$_aYO$_ = this._$_aY$_ + this._$_originY$_, this._$_bXO$_ = this._$_bX$_ + this._$_originX$_, 
            this._$_bYO$_ = this._$_bY$_ + this._$_originY$_, this._$_cXO$_ = this._$_cX$_ + this._$_originX$_, 
            this._$_cYO$_ = this._$_cY$_ + this._$_originY$_, this._$_dXO$_ = this._$_dX$_ + this._$_originX$_, 
            this._$_dYO$_ = this._$_dY$_ + this._$_originY$_, this._$_d0x$_ = 3 * (this._$_bXO$_ - this._$_aXO$_), 
            this._$_d0y$_ = 3 * (this._$_bYO$_ - this._$_aYO$_), this._$_d1x$_ = 3 * (this._$_cXO$_ - this._$_bXO$_), 
            this._$_d1y$_ = 3 * (this._$_cYO$_ - this._$_bYO$_), this._$_d2x$_ = 3 * (this._$_dXO$_ - this._$_cXO$_), 
            this._$_d2y$_ = 3 * (this._$_dYO$_ - this._$_cYO$_), this._$_x1Factor$_ = 3 * (this._$_bXO$_ - this._$_aXO$_), 
            this._$_x2Factor$_ = 3 * (this._$_aXO$_ + this._$_cXO$_ - 2 * this._$_bXO$_), this._$_x3Factor$_ = this._$_dXO$_ - this._$_aXO$_ + 3 * (this._$_bXO$_ - this._$_cXO$_), 
            this._$_y1Factor$_ = 3 * (this._$_bYO$_ - this._$_aYO$_), this._$_y2Factor$_ = 3 * (this._$_aYO$_ + this._$_cYO$_ - 2 * this._$_bYO$_), 
            this._$_y3Factor$_ = this._$_dYO$_ - this._$_aYO$_ + 3 * (this._$_bYO$_ - this._$_cYO$_);
        }
        Map(t) {
            if (!this._$_initialized$_) return NaN;
            const s = this._$_Map$_(t);
            return nm[0] = this._$_X$_(s), nm[1] = this._$_Y$_(s), nm;
        }
        _$Project$_(t, s) {
            const i = this._$_GenerateLUT$_(100), e = this._$_FindClosestFromLUT$_(t, s, i), n = this._$_RefineProjection$_(t, s, i, e);
            return rm[0] = n.x, rm[1] = n.y, rm[2] = n.t, rm[3] = n._$distance$_, rm;
        }
        _$ProjectWithRange$_(t, s, i) {
            const e = this._$_GenerateLUT$_(100), n = this._$_FindClosestFromLUTWithRange$_(t, s, e, i), h = this._$_RefineProjection$_(t, s, e, n);
            return rm[0] = h.x, rm[1] = h.y, rm[2] = h.t, rm[3] = h._$distance$_, rm;
        }
        _$Tangent$_(t) {
            const s = 1 - t, i = s * s, e = 2 * s * t, n = t * t, h = i * this._$_d0x$_ + e * this._$_d1x$_ + n * this._$_d2x$_, r = i * this._$_d0y$_ + e * this._$_d1y$_ + n * this._$_d2y$_, o = im._$hypot2DFast$_(h, r);
            return em[0] = h / o, em[1] = r / o, em;
        }
        _$TangentAngle$_(t) {
            const s = 1 - t, i = s * s, e = 2 * s * t, n = t * t, h = i * this._$_d0x$_ + e * this._$_d1x$_ + n * this._$_d2x$_, r = i * this._$_d0y$_ + e * this._$_d1y$_ + n * this._$_d2y$_;
            return Math.atan2(r, h);
        }
        _$_Map$_(t) {
            if (!this._$_initialized$_) return;
            let s = t * this._$_arcLengths$_[this._$_len$_], i = 0, e = this._$_len$_, n = 0;
            for (;i < e; ) n = i + ((e - i) / 2 | 0), this._$_arcLengths$_[n] < s ? i = n + 1 : e = n;
            this._$_arcLengths$_[n] > s && n--;
            const h = this._$_arcLengths$_[n];
            return h === s ? n / this._$_len$_ : (n + (s - h) / (this._$_arcLengths$_[n + 1] - h)) / this._$_len$_;
        }
        _$_X$_(t) {
            return this._$_initialized$_ ? self._$Ease$_._$GetRuntimeEase$_("cubicbezier")(t, this._$_aX$_ + this._$_originX$_, this._$_bX$_ + this._$_originX$_, this._$_cX$_ + this._$_originX$_, this._$_dX$_ + this._$_originX$_) : NaN;
        }
        _$_Y$_(t) {
            return this._$_initialized$_ ? self._$Ease$_._$GetRuntimeEase$_("cubicbezier")(t, this._$_aY$_ + this._$_originY$_, this._$_bY$_ + this._$_originY$_, this._$_cY$_ + this._$_originY$_, this._$_dY$_ + this._$_originY$_) : NaN;
        }
        _$_GenerateLUT$_(t) {
            if (t = t || 100, this._$_lut$_.length >= t) return this._$_lut$_;
            this._$_lut$_ = new Array(t), t++;
            for (let s = 0; s < t - 1; s++) {
                const i = s / (t - 1), e = i ** 2, n = i ** 3, h = this._$_x1Factor$_ * i, r = this._$_x2Factor$_ * e, o = this._$_x3Factor$_ * n, a = this._$_y1Factor$_ * i, u = this._$_y2Factor$_ * e, l = this._$_y3Factor$_ * n, c = this._$_aXO$_ + h + r + o, f = this._$_aYO$_ + a + u + l;
                this._$_lutObjects$_[s].x = c, this._$_lutObjects$_[s].y = f, this._$_lutObjects$_[s].t = i, 
                this._$_lutObjects$_[s]._$distance$_ = 0, this._$_lut$_[s] = this._$_lutObjects$_[s];
            }
            return this._$_lut$_;
        }
        _$_FindClosestFromLUT$_(t, s, i, e = null, n = Number.MAX_SAFE_INTEGER) {
            let h = 0;
            if (isNaN(this._$_lutIndex$_)) for (let e = 0; e < 100; e++) {
                const r = i[e], o = r.x - t, a = r.y - s;
                r._$distance$_ = o * o + a * a, r._$distance$_ < n && (n = r._$distance$_, h = e);
            } else {
                for (let e = this._$_lutIndex$_; e < this._$_lutIndex$_ + 5 && !(e >= i.length); e++) {
                    const r = i[e], o = r.x - t, a = r.y - s;
                    r._$distance$_ = o * o + a * a, r._$distance$_ < n && (n = r._$distance$_, h = e);
                }
                for (let e = this._$_lutIndex$_; e > this._$_lutIndex$_ - 5 && !(e < 0); e--) {
                    const r = i[e], o = r.x - t, a = r.y - s;
                    r._$distance$_ = o * o + a * a, r._$distance$_ < n && (n = r._$distance$_, h = e);
                }
            }
            return this._$_lutIndex$_ = h, h;
        }
        _$_FindClosestFromLUTWithRange$_(t, s, i, e, n = Number.MAX_SAFE_INTEGER) {
            let h = 0;
            if (isNaN(this._$_lutIndex$_)) for (let r = 0; r < 100; r++) {
                const o = i[r], a = o.x - t, u = o.y - s;
                o._$distance$_ = a * a + u * u, o.t >= e[0] && o.t <= e[1] && o._$distance$_ < n && (n = o._$distance$_, 
                h = r);
            } else {
                for (let r = this._$_lutIndex$_; r < this._$_lutIndex$_ + 5 && !(r >= i.length); r++) {
                    const o = i[r], a = o.x - t, u = o.y - s;
                    o._$distance$_ = a * a + u * u, o.t >= e[0] && o.t <= e[1] && o._$distance$_ < n && (n = o._$distance$_, 
                    h = r);
                }
                for (let r = this._$_lutIndex$_; r > this._$_lutIndex$_ - 5 && !(r < 0); r--) {
                    const o = i[r], a = o.x - t, u = o.y - s;
                    o._$distance$_ = a * a + u * u, o.t >= e[0] && o.t <= e[1] && o._$distance$_ < n && (n = o._$distance$_, 
                    h = r);
                }
            }
            return this._$_lutIndex$_ = h, h;
        }
        _$_RefineProjection$_(t, s, i, e) {
            let n = i[e], h = 1, r = Number.MAX_SAFE_INTEGER;
            t: do {
                const h = i.length;
                let o = 0 === e ? 0 : e - 1, a = e === h - 1 ? h - 1 : e + 1, u = i[o].t, l = (i[a].t - u) / 4;
                if (l < .001) break;
                om[0] = i[o];
                for (let i = 1; i <= 2; i++) {
                    const h = u + i * l, o = h ** 2, a = h ** 3, c = this._$_x1Factor$_ * h, f = this._$_x2Factor$_ * o, d = this._$_x3Factor$_ * a, p = this._$_y1Factor$_ * h, m = this._$_y2Factor$_ * o, g = this._$_y3Factor$_ * a, y = this._$_aXO$_ + c + f + d, M = this._$_aYO$_ + p + m + g, w = y - t, S = M - s, b = w * w + S * S;
                    if (b < r) {
                        r = b, e = i, um.x = y, um.y = M, um.t = h, um._$distance$_ = b, n = um;
                        break t;
                    }
                    const T = am[i - 1];
                    T.x = y, T.y = M, T.t = h, T._$distance$_ = b, om[i] = T;
                }
                om[3] = i[a], i = om;
            } while (h++ < 20);
            return n;
        }
        _$_CalculateLength$_() {
            this._$_initialized$_ = !0;
            let t = this._$_X$_(0), s = this._$_Y$_(0), i = 0;
            for (let e = 1; e <= this._$_len$_; e++) {
                const n = this._$_X$_(.01 * e), h = this._$_Y$_(.01 * e), r = t - n, o = s - h;
                i += im._$hypot2DFast$_(r, o), this._$_arcLengths$_[e] = i, t = n, s = h;
            }
            this._$_length$_ = i;
        }
    }, im._$TimelineLineSegmentInfo$_ = class {
        constructor(t, s, i) {
            this._$_index$_ = i, this._$_targetX$_ = t._$GetValueWithResultMode$_(), this._$_targetY$_ = s._$GetValueWithResultMode$_(), 
            this._$_originX$_ = 0, this._$_originY$_ = 0;
        }
        _$Release$_() {}
        _$GetType$_() {
            return "line";
        }
        _$GetIndex$_() {
            return this._$_index$_;
        }
        _$SetOrigin$_(t, s) {
            this._$_originX$_ = t, this._$_originY$_ = s;
        }
        _$GetX$_() {
            return this._$_targetX$_ + this._$_originX$_;
        }
        _$GetY$_() {
            return this._$_targetY$_ + this._$_originY$_;
        }
    };
}

{
    const lm = self._$C3$_;
    lm._$TimelineState$_ = class extends lm._$DefendedBase$_ {
        constructor(t, s, i) {
            super(), this._$_runtime$_ = i._$GetRuntime$_(), this._$_timelineManager$_ = i, 
            this._$_timelineDataItem$_ = s, this._$_name$_ = t, this._$_tracks$_ = [], this._$_tracksLength$_ = 0, 
            this._$_beforeAndAfterTracks$_ = null, this._$_beforeAndAfterTracksLength$_ = 0, 
            this._$CreateTrackStates$_(), this._$_playPromise$_ = null, this._$_playResolve$_ = null, 
            this._$_playheadTime$_ = 0, this._$_overshoot$_ = 0, this._$_playbackRate$_ = 1, 
            this._$_pingPongState$_ = 0, this._$_resumePingPongState$_ = -1, this._$_currentRepeatCount$_ = 1, 
            this._$_isPlaying$_ = !1, this._$_isScheduled$_ = !1, this._$_initialStateSet$_ = !1, 
            this._$_complete$_ = !0, this._$_released$_ = !1, this._$_markedForRemoval$_ = !1, 
            this._$_completedTick$_ = -1, this._$_implicitPause$_ = !1, this._$_isTemplate$_ = !1, 
            this._$_finishedTriggers$_ = !1, this._$_firstTick$_ = !1, this._$_lastDelta$_ = NaN, 
            this._$_tags$_ = [ "" ], this._$_stringTags$_ = "", this._$_tagsChanged$_ = !1, 
            this._$_renderChange$_ = 0, this._$_hasNestedContent$_ = 0, this._$_stoppedKeyframeDataItem$_ = null, 
            this._$_iTimelineState$_ = null;
        }
        static _$CreateInitial$_(t, s) {
            const i = s._$GetTimelineDataManager$_(), e = i._$GetNameId$_(), n = i._$Get$_(t[e]), h = lm._$New$_(lm._$TimelineState$_, t[e], n, s);
            return h._$SetIsTemplate$_(!0), h;
        }
        static _$CreateFromTemplate$_(t, s, i) {
            return lm._$New$_(lm._$TimelineState$_, t, s, i);
        }
        _$Release$_() {
            if (this._$IsReleased$_()) return;
            const t = this._$_runtime$_._$Dispatcher$_();
            this._$_timelineManager$_._$DeScheduleTimeline$_(this), this._$_timelineManager$_._$CompleteTimelineAndResolve$_(this);
            for (const t of this._$_tracks$_) t._$Release$_();
            lm._$clearArray$_(this._$_tracks$_), this._$_tracks$_ = null, this._$_runtime$_ = null, 
            this._$_timelineManager$_ = null, this._$_timelineDataItem$_ = null, this._$_released$_ = !0, 
            this._$_playPromise$_ = null, this._$_playResolve$_ = null, this._$FireReleaseEvent$_(t);
        }
        _$FireReleaseEvent$_(t) {
            const s = lm._$New$_(lm.Event, "timelinestatereleased");
            s._$timelineState$_ = this, t.dispatchEvent(s);
        }
        _$GetType$_() {
            return 0;
        }
        _$CreateTrackStates$_() {
            for (const t of this._$_timelineDataItem$_._$GetTrackData$_()._$trackDataItems$_()) this._$_tracksLength$_ = this._$_tracks$_.push(lm._$TrackState$_._$Create$_(this, t));
        }
        _$GetTimelineManager$_() {
            return this._$_timelineManager$_;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetTracks$_() {
            return this._$_tracks$_;
        }
        _$GetSimilarPropertyTracks$_(t, s, i, e) {
            if (!this._$_hasNestedContent$_) return;
            let n;
            for (let h = 0; h < this._$_tracks$_.length; h++) {
                let r = this._$_tracks$_[h];
                if (t !== r._$GetInstance$_()) continue;
                const o = r._$GetPropertyTrack$_(i);
                o && s.constructor === o._$GetSourceAdapter$_().constructor && o._$GetResultMode$_() === e._$GetResultMode$_() && (n || (n = []), 
                n.push(o));
            }
            return n;
        }
        _$HasTracks$_() {
            return !!this._$_tracks$_.length;
        }
        _$GetTrackById$_(t) {
            for (const s of this._$_tracks$_) if (lm._$equalsNoCase$_(s._$GetId$_(), t)) return s;
            return null;
        }
        _$GetTrackByName$_(t) {
            for (const s of this._$_tracks$_) if (!s._$IsInstanceTrack$_() && lm._$equalsNoCase$_(s._$GetName$_(), t)) return s;
            return null;
        }
        _$SetName$_(t) {
            this._$_name$_ = t;
        }
        _$GetName$_() {
            return this._$_name$_;
        }
        _$GetTimelineDataItem$_() {
            return this._$_timelineDataItem$_;
        }
        _$GetTemplateName$_() {
            return this._$_timelineDataItem$_._$GetName$_();
        }
        _$GetTotalTime$_() {
            return this._$_timelineDataItem$_._$GetTotalTime$_();
        }
        _$SetTotalTime$_(t) {
            this._$_timelineDataItem$_._$SetTotalTime$_(t);
        }
        _$GetStep$_() {
            return this._$_timelineDataItem$_._$GetStep$_();
        }
        _$SetStep$_(t) {
            this._$_timelineDataItem$_._$SetStep$_(t);
        }
        _$GetInterpolationMode$_() {
            return this._$_timelineDataItem$_._$GetInterpolationMode$_();
        }
        _$SetInterpolationMode$_(t) {
            this._$_timelineDataItem$_._$SetInterpolationMode$_(t);
        }
        _$GetResultMode$_() {
            return this._$_timelineDataItem$_._$GetResultMode$_();
        }
        _$SetResultMode$_(t) {
            this._$_timelineDataItem$_._$GetResultMode$_(t);
        }
        _$SetEase$_(t) {
            for (const s of this._$GetTracks$_()) s._$SetEase$_(t);
        }
        _$GetLoop$_() {
            return this._$_timelineDataItem$_._$GetLoop$_();
        }
        _$SetLoop$_(t) {
            return this._$_timelineDataItem$_._$SetLoop$_(t);
        }
        _$GetPingPong$_() {
            return this._$_timelineDataItem$_._$GetPingPong$_();
        }
        _$SetPingPong$_(t) {
            return this._$_timelineDataItem$_._$SetPingPong$_(t);
        }
        _$GetRepeatCount$_() {
            return this._$_timelineDataItem$_._$GetRepeatCount$_();
        }
        _$SetRepeatCount$_(t) {
            return this._$_timelineDataItem$_._$SetRepeatCount$_(t);
        }
        _$SetPlaybackRate$_(t) {
            return this._$_playbackRate$_ = t;
        }
        _$GetPlaybackRate$_() {
            return this._$_playbackRate$_;
        }
        _$GetStartOnLayout$_() {
            return this._$_timelineDataItem$_._$GetStartOnLayout$_();
        }
        _$GetTransformWithSceneGraph$_() {
            return this._$_timelineDataItem$_._$GetTransformWithSceneGraph$_();
        }
        _$GetUseSystemTimescale$_() {
            return this._$_timelineDataItem$_._$GetUseSystemTimescale$_();
        }
        _$GetPingPongState$_() {
            return this._$_pingPongState$_;
        }
        _$IsForwardPlayBack$_() {
            return !this.IsPlaying() || this._$_playbackRate$_ > 0;
        }
        _$GetPlayPromise$_() {
            return this._$_playPromise$_ || (this._$_playPromise$_ = new Promise((t => {
                this._$_playResolve$_ = t;
            }))), this._$_playPromise$_;
        }
        _$ResolvePlayPromise$_() {
            this._$_playPromise$_ && (this._$_playResolve$_(), this._$_playPromise$_ = null, 
            this._$_playResolve$_ = null);
        }
        _$SetTags$_(t) {
            this._$_tags$_ = lm._$TimelineState$_._$_GetTagArray$_(t), this._$_tagsChanged$_ = !0;
        }
        _$GetTags$_() {
            return this._$_tags$_;
        }
        _$GetStringTags$_() {
            return this._$_tagsChanged$_ && (this._$_stringTags$_ = this._$_tags$_.join(" ")), 
            this._$_tagsChanged$_ = !1, this._$_stringTags$_;
        }
        _$HasTags$_(t) {
            if (!this._$_tags$_) return !1;
            if (!this._$_tags$_.length) return !1;
            const s = lm._$TimelineState$_._$_GetTagArray$_(t);
            return !!s && !!s.length && s.every(lm._$TimelineState$_._$_HasTag$_, this);
        }
        _$OnStarted$_() {
            lm._$Plugins$_._$Timeline$_ && this.constructor === lm._$TimelineState$_ && (lm._$Plugins$_._$Timeline$_._$Cnds$_._$PushTriggerTimeline$_(this), 
            this._$_timelineManager$_._$Trigger$_(lm._$Plugins$_._$Timeline$_._$Cnds$_._$OnTimelineStarted$_), 
            this._$_timelineManager$_._$Trigger$_(lm._$Plugins$_._$Timeline$_._$Cnds$_._$OnTimelineStartedByName$_), 
            this._$_timelineManager$_._$Trigger$_(lm._$Plugins$_._$Timeline$_._$Cnds$_._$OnTimelineStartedByTags$_), 
            this._$_timelineManager$_._$Trigger$_(lm._$Plugins$_._$Timeline$_._$Cnds$_._$OnAnyTimelineStarted$_), 
            lm._$Plugins$_._$Timeline$_._$Cnds$_._$PopTriggerTimeline$_());
        }
        _$OnCompleted$_() {
            this._$_completedTick$_ = this._$_runtime$_._$GetTickCount$_();
        }
        _$FinishTriggers$_() {
            this._$_finishedTriggers$_ || (this._$_finishedTriggers$_ = !0, lm._$Plugins$_._$Timeline$_ && this.constructor === lm._$TimelineState$_ && (lm._$Plugins$_._$Timeline$_._$Cnds$_._$PushTriggerTimeline$_(this), 
            this._$_timelineManager$_._$Trigger$_(lm._$Plugins$_._$Timeline$_._$Cnds$_._$OnTimelineFinished$_), 
            this._$_timelineManager$_._$Trigger$_(lm._$Plugins$_._$Timeline$_._$Cnds$_._$OnTimelineFinishedByName$_), 
            this._$_timelineManager$_._$Trigger$_(lm._$Plugins$_._$Timeline$_._$Cnds$_._$OnTimelineFinishedByTags$_), 
            this._$_timelineManager$_._$Trigger$_(lm._$Plugins$_._$Timeline$_._$Cnds$_._$OnAnyTimelineFinished$_), 
            lm._$Plugins$_._$Timeline$_._$Cnds$_._$PopTriggerTimeline$_()));
        }
        _$SetPlaying$_(t) {
            this._$_isPlaying$_ = t;
        }
        _$IsCompletedTick$_() {
            return this._$_completedTick$_ === this._$_runtime$_._$GetTickCount$_();
        }
        IsPlaying(t = !1) {
            return !!this._$IsCompletedTick$_() || !(!this._$IsScheduled$_() || t) || this._$_isPlaying$_;
        }
        _$_IsPlaying$_() {
            return this.IsPlaying(!0);
        }
        _$IsPaused$_() {
            return this._$_IsPaused$_();
        }
        _$_IsPaused$_() {
            return !(this._$IsReleased$_() || this._$IsScheduled$_() || this._$_IsPlaying$_() || this._$IsComplete$_());
        }
        _$SetScheduled$_(t) {
            this._$_isScheduled$_ = t;
        }
        _$IsScheduled$_() {
            return this._$_isScheduled$_;
        }
        _$SetComplete$_(t) {
            this._$_complete$_ = t;
            const s = this._$GetLoop$_(), i = this._$GetPingPong$_();
            if (s || i) {
                if (s && !i) ; else if (!s && i) {
                    const t = this._$GetTime$_();
                    1 === this._$_pingPongState$_ && (t <= 0 || t >= this._$GetTotalTime$_()) && (this._$_complete$_ = !0);
                }
            } else {
                const t = this._$GetTime$_();
                (t <= 0 || t >= this._$GetTotalTime$_()) && (this._$_complete$_ = !0);
            }
        }
        _$IsComplete$_() {
            return this._$_complete$_;
        }
        _$IsReleased$_() {
            return this._$_released$_;
        }
        _$SetMarkedForRemoval$_(t) {
            this._$_markedForRemoval$_ = t;
        }
        _$IsMarkedForRemoval$_() {
            return this._$_markedForRemoval$_;
        }
        _$SetImplicitPause$_(t) {
            this._$_implicitPause$_ = t;
        }
        _$IsImplicitPause$_() {
            return this._$_implicitPause$_;
        }
        _$SetIsTemplate$_(t) {
            this._$_isTemplate$_ = !!t;
        }
        _$IsTemplate$_() {
            return this._$_isTemplate$_;
        }
        _$InitialStateSet$_() {
            return this._$_initialStateSet$_;
        }
        _$GetTime$_() {
            return this._$_playheadTime$_;
        }
        _$SetTime$_(t) {
            const s = this._$GetTime$_();
            this._$_SetTime$_(t), this._$SetComplete$_(!1), this._$IsComplete$_() || this._$SetImplicitPause$_(!0), 
            (this._$_IsPlaying$_() || this._$IsScheduled$_() || !this._$_initialStateSet$_) && (this._$_IsPlaying$_() || this._$IsScheduled$_() || this._$_initialStateSet$_ ? this._$_IsPlaying$_() ? this._$Stop$_() : this._$IsScheduled$_() && (this._$_timelineManager$_._$DeScheduleTimeline$_(this), 
            this._$SetInitialStateFromSetTime$_()) : this._$SetInitialStateFromSetTime$_()), 
            this._$_SetUpdateStateBefore$_(), this._$_Interpolate$_(this._$GetTime$_(), !1, !0, !0, s), 
            this._$_SetUpdateStateAfter$_(), this._$_renderChange$_ && this._$GetRuntime$_()._$UpdateRender$_(), 
            this._$_OnSetTime$_();
        }
        _$_SetTime$_(t) {
            lm._$IsFiniteNumber$_(t) || (t = this._$GetTotalTime$_()), t < 0 ? this._$_playheadTime$_ = 0 : t >= this._$GetTotalTime$_() ? this._$_playheadTime$_ = this._$GetTotalTime$_() : this._$_playheadTime$_ = t;
        }
        _$_SetTimeAndReset$_(t) {
            lm._$IsFiniteNumber$_(t) || (t = this._$GetTotalTime$_()), t < 0 ? this._$_playheadTime$_ = 0 : t >= this._$GetTotalTime$_() ? this._$_playheadTime$_ = this._$GetTotalTime$_() : this._$_playheadTime$_ = t;
            for (const t of this._$_tracks$_) t._$SetResetState$_();
        }
        _$_OnSetTime$_() {
            lm._$Plugins$_._$Timeline$_ && this.constructor === lm._$TimelineState$_ && (lm._$Plugins$_._$Timeline$_._$Cnds$_._$PushTriggerTimeline$_(this), 
            this._$_timelineManager$_._$Trigger$_(lm._$Plugins$_._$Timeline$_._$Cnds$_._$OnTimeSet$_), 
            this._$_timelineManager$_._$Trigger$_(lm._$Plugins$_._$Timeline$_._$Cnds$_._$OnTimeSetByName$_), 
            this._$_timelineManager$_._$Trigger$_(lm._$Plugins$_._$Timeline$_._$Cnds$_._$OnTimeSetByTags$_), 
            lm._$Plugins$_._$Timeline$_._$Cnds$_._$PopTriggerTimeline$_());
        }
        _$_CanResume$_() {
            if (this._$GetLoop$_()) return !0;
            if (this._$GetPingPong$_() && 1 === this._$_pingPongState$_) {
                if (this._$IsForwardPlayBack$_()) {
                    if (this._$GetTime$_() >= this._$GetTotalTime$_()) return !1;
                } else if (this._$GetTime$_() <= 0) return !1;
            } else if (!this._$GetLoop$_() && !this._$GetPingPong$_()) if (this._$IsForwardPlayBack$_()) {
                if (this._$GetTime$_() >= this._$GetTotalTime$_()) return !1;
            } else if (this._$GetTime$_() <= 0) return !1;
            return !0;
        }
        _$Resume$_() {
            this._$IsReleased$_() || this._$_CanResume$_() && this.Play(!0);
        }
        Play(t = !1) {
            return !this._$IsReleased$_() && !this._$IsScheduled$_() && (this._$_IsPlaying$_() && this._$IsCompletedTick$_() ? this._$_SchedulePlayingTimeline$_() : !this._$_IsPlaying$_() && !!(this._$IsComplete$_() || t || this._$IsImplicitPause$_()) && this._$_ScheduleStoppedTimeline$_());
        }
        _$_SchedulePlayingTimeline$_() {
            return this._$SetImplicitPause$_(!1), this._$_timelineManager$_._$RemovePlayingTimeline$_(this), 
            this._$_timelineManager$_._$ScheduleTimeline$_(this), this._$GetPlayPromise$_(), 
            !0;
        }
        _$_ScheduleStoppedTimeline$_() {
            return this._$SetImplicitPause$_(!1), this._$_timelineManager$_._$ScheduleTimeline$_(this), 
            this._$GetPlayPromise$_(), !0;
        }
        _$Stop$_(t = !1) {
            this._$IsReleased$_() || (this._$SetComplete$_(t), this._$_timelineManager$_._$CompleteTimeline$_(this), 
            this._$IsComplete$_() && this._$ResolvePlayPromise$_());
        }
        _$Reset$_(t = !0, s = !1) {
            if (this._$IsReleased$_()) return;
            if (!this._$_IsPlaying$_() && this._$IsScheduled$_()) return this._$_timelineManager$_._$DeScheduleTimeline$_(this);
            if (this._$IsComplete$_()) return;
            this._$Stop$_(!0), this._$IsForwardPlayBack$_() ? this._$_SetTime$_(0) : this._$_SetTime$_(this._$GetTotalTime$_());
            const i = this._$GetTime$_();
            this._$_SetUpdateStateBefore$_(), s ? this._$_InterpolateBeforeChangeLayout$_(i) : this._$_Interpolate$_(i, !1, !1, !0), 
            t && this._$_OnSetTime$_(), this._$_SetUpdateStateAfter$_(), this._$_renderChange$_ && t && this._$GetRuntime$_()._$UpdateRender$_();
        }
        _$ResetBeforeChangeLayout$_() {
            this._$Reset$_(!1, !0);
        }
        _$_InterpolateBeforeChangeLayout$_(t) {
            this._$_Interpolate$_(t, !1, !1, !0, NaN, !1, !0);
        }
        _$_OnBeforeChangeLayout$_() {
            return !!this._$IsReleased$_() || !(!this._$GetRuntime$_()._$IsLoadingState$_() && this._$HasValidGlobalTracks$_()) && (this._$_timelineManager$_._$CompleteTimelineBeforeChangeOfLayout$_(this), 
            this._$GetRuntime$_()._$IsLoadingState$_() || this._$ResetBeforeChangeLayout$_(), 
            !0);
        }
        _$SetInitialStateFromSetTime$_() {
            this._$SetInitialState$_(!0);
        }
        _$SetInitialStateForce$_() {
            this._$SetInitialState$_(!1, !0), this._$SetPlaying$_(!1), this._$SetScheduled$_(!1);
        }
        _$SetInitialState$_(t = !1, s = !1) {
            if (!this._$IsMarkedForRemoval$_() || s) if (t) {
                this._$_finishedTriggers$_ = !1, this._$_initialStateSet$_ = !0, this._$_firstTick$_ = !0, 
                this._$_SetUpdateStateBefore$_();
                for (const t of this._$_tracks$_) t._$SetInitialState$_();
                this._$_SetUpdateStateAfter$_();
            } else if (this._$SetPlaying$_(!0), this._$SetScheduled$_(!1), this._$OnStarted$_(), 
            this._$IsComplete$_()) {
                this._$_completedTick$_ = -1, 0 !== this._$_pingPongState$_ && (this._$_playbackRate$_ = Math.abs(this._$_playbackRate$_)), 
                this._$_pingPongState$_ = 0, this._$_resumePingPongState$_ = -1, this._$_currentRepeatCount$_ = 1, 
                this._$_complete$_ = !1, this._$_finishedTriggers$_ = !1, this._$_initialStateSet$_ = !0, 
                this._$_firstTick$_ = !0, this._$IsForwardPlayBack$_() ? this._$_SetTime$_(0) : this._$_SetTime$_(this._$GetTotalTime$_()), 
                this._$_SetUpdateStateBefore$_();
                for (const t of this._$_tracks$_) t._$SetInitialState$_();
                this._$_SetUpdateStateAfter$_();
            } else {
                -1 !== this._$_resumePingPongState$_ && (this._$_pingPongState$_ = this._$_resumePingPongState$_), 
                this._$_firstTick$_ = !0, this._$_finishedTriggers$_ = !1, this._$_SetUpdateStateBefore$_();
                for (const t of this._$_tracks$_) t._$SetResumeState$_();
                this._$_SetUpdateStateAfter$_();
            }
        }
        _$GetRenderChange$_() {
            return this._$_renderChange$_;
        }
        _$_SetUpdateStateBefore$_() {
            this._$_hasNestedContent$_ = 0;
            for (const t of this._$_tracks$_) t._$IsNested$_() && (this._$_hasNestedContent$_ = 1);
        }
        _$_SetUpdateStateAfter$_() {
            this._$_renderChange$_ = 0;
            for (const t of this._$_tracks$_) t._$_SetUpdateState$_(), 0 === this._$_renderChange$_ && 1 === t._$GetRenderChange$_() && (this._$_renderChange$_ = 1), 
            this._$_beforeAndAfterTracks$_ || 1 !== t._$GetNeedsBeforeAndAfter$_() || (this._$_beforeAndAfterTracks$_ || (this._$_beforeAndAfterTracks$_ = []), 
            this._$_beforeAndAfterTracksLength$_ = this._$_beforeAndAfterTracks$_.push(t));
        }
        _$Tick$_(t, s, i) {
            if (this._$GetUseSystemTimescale$_()) {
                if (0 === t && 0 === this._$_lastDelta$_) return;
                this._$_lastDelta$_ = t, t = i;
            } else {
                if (0 === i && 0 === this._$_lastDelta$_) return;
                this._$_lastDelta$_ = i, t = i, s = 1;
            }
            const e = this._$_playheadTime$_ + this._$_overshoot$_, n = e + t * s * this._$_playbackRate$_, h = this._$_timelineDataItem$_._$_totalTime$_;
            n < 0 ? (this._$_playheadTime$_ = 0, this._$_overshoot$_ = -n) : n >= h ? (this._$_playheadTime$_ = h, 
            this._$_overshoot$_ = this._$_playheadTime$_ - n) : (this._$_playheadTime$_ = n, 
            this._$_overshoot$_ = 0);
            let r = !1, o = !1;
            const a = this._$GetLoop$_(), u = this._$GetPingPong$_();
            let l;
            a || u ? a && !u ? this._$_playbackRate$_ > 0 ? this._$_playheadTime$_ >= h && (this._$_SetTimeAndReset$_(0), 
            o = !0) : this._$_playheadTime$_ <= 0 && (this._$_SetTimeAndReset$_(h), o = !0) : !a && u ? this._$_playbackRate$_ > 0 ? this._$_playheadTime$_ >= h && (this._$_SetTime$_(h), 
            this._$SetPlaybackRate$_(-1 * this._$GetPlaybackRate$_()), o = !0, 1 === this._$_pingPongState$_ ? this._$_currentRepeatCount$_ < this._$GetRepeatCount$_() ? (this._$_currentRepeatCount$_++, 
            this._$_pingPongState$_ = 0) : r = !0 : 0 === this._$_pingPongState$_ && (this._$_pingPongState$_ = 1)) : this._$_playheadTime$_ <= 0 && (this._$_SetTime$_(0), 
            this._$SetPlaybackRate$_(-1 * this._$GetPlaybackRate$_()), o = !0, 1 === this._$_pingPongState$_ ? this._$_currentRepeatCount$_ < this._$GetRepeatCount$_() ? (this._$_currentRepeatCount$_++, 
            this._$_pingPongState$_ = 0) : r = !0 : 0 === this._$_pingPongState$_ && (this._$_pingPongState$_ = 1)) : a && u && (this._$_playbackRate$_ > 0 ? this._$_playheadTime$_ >= h && (this._$_SetTime$_(h), 
            this._$SetPlaybackRate$_(-1 * this._$GetPlaybackRate$_()), o = !0, this._$_pingPongState$_++, 
            lm.wrap(this._$_pingPongState$_, 0, 2)) : this._$_playheadTime$_ <= 0 && (this._$_SetTime$_(0), 
            this._$SetPlaybackRate$_(-1 * this._$GetPlaybackRate$_()), o = !0, this._$_pingPongState$_++, 
            lm.wrap(this._$_pingPongState$_, 0, 2))) : this._$_playbackRate$_ > 0 ? this._$_playheadTime$_ >= h && (this._$_currentRepeatCount$_ < this._$GetRepeatCount$_() ? (this._$_currentRepeatCount$_++, 
            this._$_SetTimeAndReset$_(0), o = !0) : (this._$_SetTime$_(h), r = !0)) : this._$_playheadTime$_ <= 0 && (this._$_currentRepeatCount$_ < this._$GetRepeatCount$_() ? (this._$_currentRepeatCount$_++, 
            this._$_SetTimeAndReset$_(h), o = !0) : (this._$_SetTime$_(0), r = !0));
            const c = this._$_tracksLength$_;
            if (r) {
                for (l = 0; l < c; l++) this._$_tracks$_[l]._$SetEndState$_();
                return this._$Stop$_(!0), void this._$OnCompleted$_();
            }
            const f = this._$_beforeAndAfterTracksLength$_;
            for (l = 0; l < f; l++) this._$_beforeAndAfterTracks$_[l]._$BeforeInterpolate$_();
            if (1 === this._$_hasNestedContent$_) for (l = 0; l < c; l++) {
                const t = this._$_tracks$_[l], s = t._$GetStartOffset$_();
                this._$_playheadTime$_ - s < 0 && e - s > 0 ? (this._$_playheadTime$_ = s < 0 ? 0 : s >= h ? h : s, 
                t._$Interpolate$_(s, !0, !1, o, this._$_firstTick$_, !1)) : t._$Interpolate$_(this._$_playheadTime$_, !0, !1, o, this._$_firstTick$_, !1);
            } else for (l = 0; l < c; l++) this._$_tracks$_[l]._$Interpolate$_(this._$_playheadTime$_, !0, !1, o, this._$_firstTick$_, !1);
            if (!this.IsPlaying() && this._$_stoppedKeyframeDataItem$_) {
                const t = this._$_stoppedKeyframeDataItem$_._$GetTime$_() + this._$_stoppedKeyframeDataItem$_._$GetKeyframeData$_()._$GetTrackDataItem$_()._$GetStartOffset$_(), s = this._$_playheadTime$_ - t;
                this._$_playheadTime$_ -= s, 0 !== this._$_overshoot$_ && (this._$_overshoot$_ -= s), 
                this._$_stoppedKeyframeDataItem$_ = null;
            }
            for (l = 0; l < f; l++) this._$_beforeAndAfterTracks$_[l]._$AfterInterpolate$_();
            this._$_firstTick$_ && (this._$_firstTick$_ = !1);
        }
        _$SetStoppedOnKeyframe$_(t) {
            this._$_stoppedKeyframeDataItem$_ = t;
        }
        _$GetStoppedOnKeyframe$_() {
            return this._$_stoppedKeyframeDataItem$_;
        }
        _$_Interpolate$_(t, s = !1, i = !1, e = !1, n = NaN, h = !1, r = !1) {
            for (const t of this._$_tracks$_) t._$BeforeInterpolate$_();
            for (const h of this._$_tracks$_) {
                let o = t;
                if ("number" == typeof n && !isNaN(n)) {
                    const t = this._$GetTime$_() - h._$GetStartOffset$_(), s = n - h._$GetStartOffset$_();
                    t < 0 && s > 0 && (o = h._$GetStartOffset$_(), this._$_SetTime$_(o));
                }
                h._$Interpolate$_(o, s, i, e, this._$_firstTick$_, r);
            }
            for (const t of this._$_tracks$_) t._$AfterInterpolate$_();
            this._$_firstTick$_ && h && (this._$_firstTick$_ = !1);
        }
        _$AddTrack$_() {
            const t = this._$_timelineDataItem$_._$GetTrackData$_()._$AddEmptyTrackDataItem$_(), s = lm._$TrackState$_._$Create$_(this, t);
            return this._$_tracksLength$_ = this._$_tracks$_.push(s), s;
        }
        _$Removed$_() {
            if (!this._$IsReleased$_()) for (const t of this._$_tracks$_) t._$TimelineRemoved$_();
        }
        _$CleanCaches$_() {
            for (const t of this._$_tracks$_) t._$CleanCaches$_();
        }
        _$ClearTrackInstances$_() {
            for (const t of this._$_tracks$_) t._$ClearInstance$_();
        }
        _$SetTrackInstance$_(t, s, i) {
            if (s) {
                if ("number" == typeof i && i >= 0) {
                    const t = this._$_tracks$_[i];
                    if (!t) return;
                    return t._$SetInstance$_(s), void this._$_timelineManager$_._$SetTimelineObjectClassToMap$_(s._$GetObjectClass$_(), this);
                }
                for (const i of this._$_tracks$_) if (i._$IsInstanceTrack$_()) {
                    if (t) {
                        if (i._$GetId$_() !== t) continue;
                        i._$SetInstance$_(s), this._$_timelineManager$_._$SetTimelineObjectClassToMap$_(s._$GetObjectClass$_(), this);
                        break;
                    }
                    if (!i._$HasInstance$_()) {
                        i._$SetInstance$_(s), this._$_timelineManager$_._$SetTimelineObjectClassToMap$_(s._$GetObjectClass$_(), this);
                        break;
                    }
                }
            }
        }
        _$HasTrackInstance$_(t, s) {
            for (const i of this._$_tracks$_) if (i._$IsInstanceTrack$_()) if (s) {
                if (s === i._$GetId$_() && t === i._$GetInstance$_()) return !0;
            } else if (t === i._$GetInstance$_()) return !0;
            return !1;
        }
        _$HasValidTracks$_() {
            return this._$_tracks$_.some((t => !t._$IsInstanceTrack$_() || t._$CanInstanceBeValid$_()));
        }
        _$HasValidGlobalTracks$_() {
            return this._$_tracks$_.some((t => {
                if (t._$IsInstanceTrack$_()) {
                    if (!t._$CanInstanceBeValid$_()) return !1;
                    const s = t._$GetObjectClass$_();
                    return !!s && s._$IsGlobal$_();
                }
                return !1;
            }));
        }
        _$GetPropertyTrack$_(t) {
            for (const s of this._$GetTracks$_()) for (const i of s._$GetPropertyTracks$_()) if (i._$GetPropertyName$_() === t) return i;
        }
        _$GetTrackFromInstance$_(t) {
            for (const s of this._$_tracks$_) if (t === s._$GetInstance$_()) return s;
            return null;
        }
        _$GetKeyframeWithTags$_(t) {
            let s = t ? t.split(" ") : [];
            const i = new Set(s.map((t => t.toLowerCase().trim())));
            s = [ ...i.values() ];
            for (const t of this._$GetTracks$_()) for (const i of t._$GetKeyframeDataItems$_()) if (s.every((t => i._$HasTag$_(t)))) return i;
        }
        _$GetObjectClasses$_() {
            const t = [];
            for (const s of this._$GetTracks$_()) t.push(s._$GetObjectClass$_());
            return t.filter((t => t));
        }
        _$_OnAfterLoad$_() {
            for (const t of this._$GetTracks$_()) t._$_OnAfterLoad$_();
        }
        _$_SaveToJson$_() {
            return {
                tracksJson: this._$_SaveTracksToJson$_(),
                name: this._$_name$_,
                playheadTime: this._$GetTime$_(),
                playbackRate: this._$_playbackRate$_,
                pingPongState: this._$_pingPongState$_,
                resumePingPongState: this._$_resumePingPongState$_,
                currentRepeatCount: this._$_currentRepeatCount$_,
                isPlaying: this._$_isPlaying$_,
                isScheduled: this._$_isScheduled$_,
                initialStateSet: this._$_initialStateSet$_,
                finishedTriggers: this._$_finishedTriggers$_,
                complete: this._$_complete$_,
                released: this._$_released$_,
                markedForRemoval: this._$_markedForRemoval$_,
                completedTick: this._$_completedTick$_,
                implicitPause: this._$_implicitPause$_,
                isTemplate: this._$_isTemplate$_,
                tags: this._$_tags$_.join(" "),
                stringTags: this._$_stringTags$_,
                tagsChanged: this._$_tagsChanged$_,
                firstTick: this._$_firstTick$_
            };
        }
        _$_LoadFromJson$_(t) {
            t && (this._$_LoadTracksFromJson$_(t.tracksJson), this._$_name$_ = t.name, this._$_playheadTime$_ = t.playheadTime, 
            this._$_playbackRate$_ = t.playbackRate, this._$_pingPongState$_ = t.pingPongState, 
            this._$_resumePingPongState$_ = t.hasOwnProperty("resumePingPongState") ? t.resumePingPongState : -1, 
            this._$_currentRepeatCount$_ = t.currentRepeatCount, this._$_isPlaying$_ = !!t.isPlaying, 
            this._$_isScheduled$_ = !!t.isScheduled, this._$_initialStateSet$_ = !!t.initialStateSet, 
            this._$_finishedTriggers$_ = !!t.hasOwnProperty("finishedTriggers") && !!t.finishedTriggers, 
            this._$_complete$_ = !!t.complete, this._$_released$_ = !!t.released, this._$_markedForRemoval$_ = !!t.markedForRemoval, 
            this._$_completedTick$_ = t.completedTick, this._$_implicitPause$_ = !!t.implicitPause, 
            this._$_isTemplate$_ = !!t.isTemplate, this._$_tags$_ = t.tags.split(" "), this._$_stringTags$_ = t.stringTags, 
            this._$_tagsChanged$_ = !!t.tagsChanged, this._$_firstTick$_ = !!t.firstTick);
        }
        _$_SaveTracksToJson$_() {
            return this._$_tracks$_.map((t => t._$_SaveToJson$_()));
        }
        _$_LoadTracksFromJson$_(t) {
            this._$ClearTrackInstances$_(), t.forEach(((t, s) => {
                this._$_tracks$_[s]._$_LoadFromJson$_(t);
            })), this._$_tracks$_.filter((t => t._$CanInstanceBeValid$_()));
        }
        static _$_HasTag$_(t) {
            const s = this._$GetTags$_();
            return "" === t ? 1 === s.length && "" === s[0] : s.map((t => t.toLowerCase())).includes(t.toLowerCase());
        }
        static _$_GetTagArray$_(t) {
            if (lm._$IsArray$_(t)) return t.slice(0);
            if (lm._$IsString$_(t)) return t.split(" ");
            throw new Error("invalid tags");
        }
        _$GetITimelineState$_() {
            return this._$_iTimelineState$_ || (this._$_iTimelineState$_ = lm._$New$_(self._$ITimelineState$_, this)), 
            this._$_iTimelineState$_;
        }
    };
}

{
    const cm = self._$C3$_;
    cm._$TrackState$_ = class extends cm._$DefendedBase$_ {
        constructor(t, s) {
            super(), this._$_timeline$_ = t, this._$_trackDataItem$_ = s, this._$_trackData$_ = s._$GetTrackData$_(), 
            this._$_instanceUid$_ = NaN, this._$_objectClassIndex$_ = NaN, this._$_instance$_ = null, 
            this._$_worldInfo$_ = null, this._$_cleared$_ = !1, this._$_isNested$_ = s._$GetStartOffset$_() > 0, 
            this._$_initialStateOfNestedSet$_ = !1, this._$_endStateOfNestedSet$_ = !1, this._$_instanceUidToLoad$_ = NaN, 
            this._$_lastKeyframeDataItem$_ = null, this._$_keyframeDataItems$_ = this._$_trackDataItem$_._$GetKeyframeData$_()._$GetKeyframeDataItemArray$_(), 
            this._$_propertyTracks$_ = [], this._$CreatePropertyTrackStates$_(), this._$_worldInfoChange$_ = 0, 
            this._$_renderChange$_ = 0, this._$_needsBeforeAndAfter$_ = 0;
        }
        static _$Create$_(t, s) {
            return cm._$New$_(cm._$TrackState$_, t, s);
        }
        _$Release$_() {
            this._$_keyframeDataItems$_ = null;
            for (const t of this._$_propertyTracks$_) t._$Release$_();
            cm._$clearArray$_(this._$_propertyTracks$_), this._$_propertyTracks$_ = null, this._$_timeline$_ = null, 
            this._$_instance$_ = null, this._$_worldInfo$_ = null, this._$_trackDataItem$_ = null, 
            this._$_lastKeyframeDataItem$_ = null;
        }
        _$CreatePropertyTrackStates$_() {
            for (const t of this._$_trackDataItem$_._$GetPropertyTrackData$_()._$propertyTrackDataItems$_()) this._$_propertyTracks$_.push(cm._$PropertyTrackState$_._$Create$_(this, t));
        }
        _$TimelineRemoved$_() {
            for (const t of this._$_propertyTracks$_) t._$TimelineRemoved$_();
        }
        _$CleanCaches$_() {
            for (const t of this._$_propertyTracks$_) t._$CleanCaches$_();
            this._$_instance$_ = null, this._$_worldInfo$_ = null;
        }
        _$GetTimeline$_() {
            return this._$_timeline$_;
        }
        _$GetRuntime$_() {
            return this._$_timeline$_._$GetRuntime$_();
        }
        _$GetKeyframeDataItems$_() {
            return this._$_keyframeDataItems$_ || (this._$_keyframeDataItems$_ = this._$_trackDataItem$_._$GetKeyframeData$_()._$GetKeyframeDataItemArray$_()), 
            this._$_keyframeDataItems$_;
        }
        _$GetPropertyTracks$_() {
            return this._$_propertyTracks$_;
        }
        _$GetPropertyTrack$_(t) {
            for (let s = 0; s < this._$_propertyTracks$_.length; s++) {
                const i = this._$_propertyTracks$_[s];
                if (i._$GetPropertyName$_() === t) return i;
            }
        }
        _$MaybeGetInstance$_() {
            this._$_instance$_ || this._$GetInstance$_();
        }
        _$IsInstanceValid$_() {
            return !!this._$_instance$_ && !this._$_instance$_._$IsDestroyed$_();
        }
        _$CanInstanceBeValid$_() {
            if (!this._$IsInstanceTrack$_()) return !1;
            const t = this._$GetInstanceUID$_(), s = this._$GetRuntime$_()._$GetInstanceByUID$_(t);
            return !!s && !s._$IsDestroyed$_();
        }
        _$GetObjectClass$_() {
            if (!this._$IsInstanceTrack$_()) return;
            const t = this._$GetObjectClassIndex$_();
            return -1 !== t ? this._$GetRuntime$_()._$GetObjectClassByIndex$_(t) : void 0;
        }
        _$GetTrackIndexInTimeline$_() {
            return this._$_timeline$_._$GetTracks$_().indexOf(this);
        }
        _$ClearInstance$_() {
            this._$_instance$_ = null, this._$_instanceUid$_ = NaN, this._$_worldInfo$_ = null, 
            this._$_objectClassIndex$_ = NaN, this._$_cleared$_ = !0;
        }
        _$HasInstance$_() {
            return !!this._$_instance$_;
        }
        _$GetInstance$_() {
            if (this._$_cleared$_) return;
            if (this._$_instance$_ && this._$IsInstanceValid$_()) return this._$_instance$_;
            const t = this._$GetInstanceUID$_();
            return this._$_instance$_ = this._$GetRuntime$_()._$GetInstanceByUID$_(t), this._$_instance$_;
        }
        _$SetInstance$_(t) {
            if (this._$_cleared$_ = !1, this._$_instance$_ !== t) {
                this._$CleanCaches$_(), this._$_instance$_ = t, this._$_objectClassIndex$_ = t._$GetObjectClass$_()._$GetIndex$_(), 
                this._$_instanceUid$_ = t._$GetUID$_(), this._$_worldInfo$_ = t._$GetWorldInfo$_();
                for (const s of this._$propertyTrackItems$_()) {
                    const i = s._$propertyTrack$_, e = s._$sourceAdapter$_;
                    switch (i._$GetSourceAdapterId$_()) {
                      case "instance-variable":
                        {
                            e._$GetEditorIndex$_();
                            const i = t._$GetObjectClass$_(), n = i._$GetInstanceVariableIndexByName$_(s.name), h = i._$GetInstanceVariableName$_(n), r = i._$GetInstanceVariableType$_(n);
                            h === s.name && r === s.type && e._$UpdateInstanceVariableIndex$_(n);
                            break;
                        }

                      case "behavior":
                        {
                            const i = s._$behaviorType$_, n = this._$GetObjectClass$_(), h = t._$GetObjectClass$_(), r = e._$GetBehaviorType$_(h);
                            if (i && r) {
                                const t = i._$GetName$_();
                                n._$GetBehaviorIndexByName$_(t), h._$GetBehaviorIndexByName$_(t), e._$GetEditorIndex$_(), 
                                e._$UpdateBehaviorTypeSid$_(r._$GetSID$_());
                            }
                            break;
                        }
                    }
                }
            }
        }
        * _$propertyTrackItems$_() {
            for (const t of this._$_propertyTracks$_) {
                const s = t._$GetSourceAdapter$_(), i = this._$GetObjectClass$_(), e = {
                    _$propertyTrack$_: t,
                    _$sourceAdapter$_: s
                };
                switch (t._$GetSourceAdapterId$_()) {
                  case "world-instance":
                    e._$property$_ = t._$GetPropertyName$_();
                    break;

                  case "instance-variable":
                    {
                        const t = s._$GetEditorIndex$_();
                        e.name = i._$GetInstanceVariableName$_(t), e.type = i._$GetInstanceVariableType$_(t);
                        break;
                    }

                  case "effect":
                    {
                        const t = i._$GetEffectList$_(), n = s._$GetEffectType$_(t);
                        e._$effectType$_ = n;
                        break;
                    }

                  case "behavior":
                    {
                        const t = s._$GetBehaviorType$_(i);
                        e._$behaviorType$_ = t;
                        break;
                    }

                  case "plugin":
                    e._$plugin$_ = i._$GetPlugin$_();
                }
                yield e;
            }
        }
        _$GetWorldInfo$_() {
            if (this._$_worldInfo$_ && this._$IsInstanceValid$_()) return this._$_worldInfo$_;
            const t = this._$GetInstance$_();
            return t && (this._$_worldInfo$_ = t._$GetWorldInfo$_()), this._$_worldInfo$_;
        }
        _$GetTrackDataItem$_() {
            return this._$_trackDataItem$_;
        }
        _$GetInstanceUID$_() {
            return isNaN(this._$_instanceUid$_) ? this._$_trackDataItem$_._$GetInstanceUID$_() : this._$_instanceUid$_;
        }
        _$SetInstanceUID$_(t) {
            this._$_trackDataItem$_._$SetInstanceUID$_(t);
        }
        _$GetInterpolationMode$_() {
            return this._$_trackDataItem$_._$GetInterpolationMode$_();
        }
        _$SetInterpolationMode$_(t) {
            this._$_trackDataItem$_._$SetInterpolationMode$_(t);
        }
        _$GetResultMode$_() {
            return this._$_trackDataItem$_._$GetResultMode$_();
        }
        _$GetId$_() {
            return this._$_trackDataItem$_._$GetId$_();
        }
        _$GetStartOffset$_() {
            return this._$_trackDataItem$_._$GetStartOffset$_();
        }
        _$GetLocalTotalTime$_() {
            return this._$_trackDataItem$_._$GetLocalTotalTime$_();
        }
        _$SetLocalTotalTime$_(t) {
            this._$_trackDataItem$_._$SetLocalTotalTime$_(t);
        }
        _$SetResultMode$_(t) {
            this._$_trackDataItem$_._$SetResultMode$_(t);
        }
        _$SetEase$_(t) {
            for (const s of this._$GetKeyframeDataItems$_()) s._$SetEase$_(t);
            for (const s of this._$GetPropertyTracks$_()) s._$SetEase$_(t);
        }
        _$GetEnable$_() {
            return this._$_trackDataItem$_._$GetEnable$_();
        }
        _$SetEnable$_(t) {
            this._$_trackDataItem$_._$SetEnable$_(t);
        }
        _$GetObjectClassIndex$_() {
            return isNaN(this._$_objectClassIndex$_) ? this._$_trackDataItem$_._$GetObjectClassIndex$_() : this._$_objectClassIndex$_;
        }
        _$SetObjectClassIndex$_(t) {
            this._$_trackDataItem$_._$SetObjectClassIndex$_(t);
        }
        _$SetOriginalWidth$_(t) {
            this._$_trackDataItem$_._$SetOriginalWidth$_(t);
        }
        _$GetOriginalWidth$_() {
            const t = this._$GetInstance$_();
            return t && t._$GetSdkInstance$_()._$IsOriginalSizeKnown$_() ? t._$GetSdkInstance$_()._$GetOriginalWidth$_() : this._$_trackDataItem$_._$GetOriginalWidth$_();
        }
        _$SetOriginalHeight$_(t) {
            this._$_trackDataItem$_._$SetOriginalHeight$_(t);
        }
        _$GetOriginalHeight$_() {
            const t = this._$GetInstance$_();
            return t && t._$GetSdkInstance$_()._$IsOriginalSizeKnown$_() ? t._$GetSdkInstance$_()._$GetOriginalHeight$_() : this._$_trackDataItem$_._$GetOriginalHeight$_();
        }
        _$GetType$_() {
            return this._$_trackDataItem$_._$GetType$_();
        }
        _$GetName$_() {
            return this._$_trackDataItem$_._$GetName$_();
        }
        _$IsInstanceTrack$_() {
            return 0 === this._$GetType$_();
        }
        _$IsValueTrack$_() {
            return 1 === this._$GetType$_();
        }
        _$IsAudioTrack$_() {
            return 2 === this._$GetType$_();
        }
        _$GetWorldInfoChange$_() {
            return this._$_worldInfoChange$_;
        }
        _$GetRenderChange$_() {
            return this._$_renderChange$_;
        }
        _$GetNeedsBeforeAndAfter$_() {
            return this._$_needsBeforeAndAfter$_;
        }
        _$IsNested$_() {
            return this._$_isNested$_;
        }
        _$SetResetState$_() {
            for (const t of this._$_propertyTracks$_) t._$SetResetState$_();
        }
        _$SetInitialState$_() {
            if (this._$MaybeGetInstance$_(), !this._$IsInstanceValid$_() && this._$IsInstanceTrack$_()) return;
            const t = this._$GetTimeline$_()._$IsForwardPlayBack$_(), s = t ? 0 : this._$GetLocalTotalTime$_();
            for (const t of this._$_propertyTracks$_) t._$SetInitialState$_(s), 0 === this._$_worldInfoChange$_ && 1 === t._$GetWorldInfoChange$_() && (this._$_worldInfoChange$_ = 1), 
            0 === this._$_renderChange$_ && 1 === t._$GetRenderChange$_() && (this._$_renderChange$_ = 1);
            this._$_needsBeforeAndAfter$_ = 0, this._$_propertyTracks$_.some((t => t._$GetNeedsBeforeAndAfter$_())) && (this._$_needsBeforeAndAfter$_ = 1), 
            this._$_lastKeyframeDataItem$_ = t ? this._$_GetLastKeyFrameBeforeTime$_(s) : this._$_GetFirstKeyFrameAfterTime$_(s), 
            this._$_initialStateOfNestedSet$_ = !1, this._$_endStateOfNestedSet$_ = !1, this._$Interpolate$_(s), 
            this._$OnKeyframeReached$_(this._$_lastKeyframeDataItem$_);
        }
        _$SetResumeState$_() {
            if (this._$MaybeGetInstance$_(), !this._$IsInstanceValid$_() && this._$IsInstanceTrack$_()) return;
            const t = this._$_timeline$_._$IsForwardPlayBack$_(), s = this._$_timeline$_._$GetTime$_() - this._$GetStartOffset$_();
            this._$_lastKeyframeDataItem$_ = t ? this._$_GetLastKeyFrameBeforeTime$_(s) : this._$_GetFirstKeyFrameAfterTime$_(s);
            for (const t of this._$_propertyTracks$_) t._$SetResumeState$_(s);
        }
        _$SetEndState$_() {
            if (!this._$GetTimeline$_()._$IsComplete$_() && (this._$MaybeGetInstance$_(), (this._$IsInstanceValid$_() || !this._$IsInstanceTrack$_()) && !this._$_isNested$_)) {
                const t = this._$_timeline$_._$GetTime$_();
                t >= this._$GetStartOffset$_() + this._$GetLocalTotalTime$_() ? this._$Interpolate$_(this._$GetLocalTotalTime$_(), !0, !1, !0, !1, !1, !0) : t <= 0 && this._$Interpolate$_(0, !0, !1, !0, !1, !1, !0);
            }
        }
        _$_SetUpdateState$_() {
            for (let t = 0, s = this._$_propertyTracks$_.length; t < s; t++) {
                const s = this._$_propertyTracks$_[t];
                s._$_SetUpdateState$_(), 0 === this._$_worldInfoChange$_ && 1 === s._$GetWorldInfoChange$_() && (this._$_worldInfoChange$_ = 1), 
                0 === this._$_renderChange$_ && 1 === s._$GetRenderChange$_() && (this._$_renderChange$_ = 1);
            }
        }
        _$BeforeInterpolate$_() {
            const t = this._$_propertyTracks$_.length;
            for (let s = 0; s < t; s++) this._$_propertyTracks$_[s]._$BeforeInterpolate$_();
        }
        _$Interpolate$_(t, s = !1, i = !1, e = !1, n = !1, h = !1, r = !1) {
            this._$_instance$_ || this._$GetInstance$_();
            const o = this._$_instance$_ && !this._$_instance$_._$IsDestroyed$_(), a = 0 === this._$_trackDataItem$_._$_type$_;
            if ((o || !a) && !(h && a && this._$GetObjectClass$_()._$IsGlobal$_() || (t -= this._$GetStartOffset$_()) < 0)) {
                this._$MaybeSetInitialStateOfNestedTrack$_(t, s), this._$MaybeTriggerKeyframeReachedConditions$_(t, s, n), 
                !this._$GetTimeline$_().IsPlaying() && this._$GetTimeline$_()._$GetStoppedOnKeyframe$_() && (t = this._$GetTimeline$_()._$GetStoppedOnKeyframe$_()._$GetTime$_());
                for (let s = 0, n = this._$_propertyTracks$_.length; s < n; s++) this._$_propertyTracks$_[s]._$Interpolate$_(t, i, e, r);
                this._$MaybeSetEndStateOfNestedTrack$_(t, s), 0 !== this._$_worldInfoChange$_ && (this._$_worldInfo$_ || (this._$_worldInfo$_ = this._$_instance$_._$GetWorldInfo$_()), 
                this._$_worldInfo$_ && this._$_worldInfo$_._$SetBboxChanged$_());
            }
        }
        _$AfterInterpolate$_() {
            const t = this._$_propertyTracks$_.length;
            for (let s = 0; s < t; s++) this._$_propertyTracks$_[s]._$AfterInterpolate$_();
        }
        _$MaybeSetInitialStateOfNestedTrack$_(t, s) {
            if (s && this._$_isNested$_ && !this._$_initialStateOfNestedSet$_) {
                if (this._$GetTimeline$_()._$IsForwardPlayBack$_()) {
                    if (t < 0) return;
                } else if (t > this._$GetLocalTotalTime$_()) return;
                for (const t of this._$_propertyTracks$_) t._$SetInitialState$_();
                this._$_initialStateOfNestedSet$_ = !0;
            }
        }
        _$MaybeSetEndStateOfNestedTrack$_(t, s) {
            if (s && this._$_isNested$_ && !this._$_endStateOfNestedSet$_) if (this._$GetTimeline$_()._$IsForwardPlayBack$_()) {
                if (t >= this._$GetLocalTotalTime$_()) {
                    for (const t of this._$_propertyTracks$_) t._$Interpolate$_(this._$GetLocalTotalTime$_(), !1, !0);
                    this._$_endStateOfNestedSet$_ = !0;
                }
            } else if (t <= 0) {
                for (const t of this._$_propertyTracks$_) t._$Interpolate$_(0, !1, !0);
                this._$_endStateOfNestedSet$_ = !0;
            }
        }
        _$MaybeTriggerKeyframeReachedConditions$_(t, s, i) {
            if (i) return;
            if (!s) return;
            if (!cm._$Plugins$_._$Timeline$_) return;
            const e = this._$GetTimeline$_();
            if (e._$IsForwardPlayBack$_()) {
                const s = this._$_lastKeyframeDataItem$_._$GetNext$_(), i = this._$_lastKeyframeDataItem$_._$GetTime$_(), n = s ? s._$GetTime$_() : e._$GetTotalTime$_();
                (t <= i || t >= n) && (this._$_lastKeyframeDataItem$_ = this._$_trackData$_._$GetFirstKeyFrameDataItemLowerOrEqualThan$_(t, this._$_trackDataItem$_), 
                s && this._$OnKeyframeReached$_(this._$_lastKeyframeDataItem$_));
            } else {
                if (!this._$_trackData$_._$GetFirstKeyFrameDataItemHigherOrEqualThan$_(t, this._$_trackDataItem$_)) return;
                this._$_lastKeyframeDataItem$_ || (this._$_lastKeyframeDataItem$_ = this._$_trackData$_._$GetFirstKeyFrameDataItemHigherOrEqualThan$_(t, this._$_trackDataItem$_));
                const s = this._$_lastKeyframeDataItem$_._$GetLast$_(), i = this._$_lastKeyframeDataItem$_._$GetTime$_(), e = s ? s._$GetTime$_() : 0;
                (t >= i || t <= e) && (this._$_lastKeyframeDataItem$_ = this._$_trackData$_._$GetFirstKeyFrameDataItemHigherOrEqualThan$_(t, this._$_trackDataItem$_), 
                this._$_lastKeyframeDataItem$_ && this._$OnKeyframeReached$_(this._$_lastKeyframeDataItem$_));
            }
        }
        _$_GetLastKeyFrameBeforeTime$_(t) {
            return this._$_trackData$_._$GetKeyFrameDataItemAtTime$_(t, this._$_trackDataItem$_) || this._$_trackData$_._$GetFirstKeyFrameDataItemLowerOrEqualThan$_(t, this._$_trackDataItem$_);
        }
        _$_GetFirstKeyFrameAfterTime$_(t) {
            return this._$_trackData$_._$GetKeyFrameDataItemAtTime$_(t, this._$_trackDataItem$_) || this._$_trackData$_._$GetFirstKeyFrameDataItemHigherOrEqualThan$_(t, this._$_trackDataItem$_);
        }
        _$OnKeyframeReached$_(t) {
            if (!cm._$Plugins$_._$Timeline$_) return;
            const s = this._$GetTimeline$_(), i = s._$GetTimelineManager$_();
            cm._$Plugins$_._$Timeline$_._$Cnds$_._$PushTriggerTimeline$_(s), cm._$Plugins$_._$Timeline$_._$Cnds$_._$PushTriggerKeyframe$_(t), 
            i._$Trigger$_(cm._$Plugins$_._$Timeline$_._$Cnds$_._$OnAnyKeyframeReached$_), i._$Trigger$_(cm._$Plugins$_._$Timeline$_._$Cnds$_._$OnKeyframeReached$_), 
            s.IsPlaying() || s._$SetStoppedOnKeyframe$_(t), cm._$Plugins$_._$Timeline$_._$Cnds$_._$PopTriggerTimeline$_(s), 
            cm._$Plugins$_._$Timeline$_._$Cnds$_._$PopTriggerKeyframe$_(t);
        }
        _$AddKeyframe$_() {
            return this._$_trackDataItem$_._$GetKeyframeData$_()._$AddEmptyKeyframeDataItem$_();
        }
        _$AddPropertyTrack$_() {
            const t = this._$_trackDataItem$_._$GetPropertyTrackData$_()._$AddEmptyPropertyTrackDataItem$_(), s = cm._$PropertyTrackState$_._$Create$_(this, t);
            return this._$_propertyTracks$_.push(s), s;
        }
        _$DeleteKeyframes$_(t) {
            this._$_trackDataItem$_._$GetKeyframeData$_()._$DeleteKeyframeDataItems$_(t);
        }
        _$DeletePropertyKeyframes$_(t) {
            for (const s of this._$_propertyTracks$_) s._$DeletePropertyKeyframes$_(t);
        }
        _$SaveState$_() {
            for (const t of this._$_propertyTracks$_) t._$SaveState$_();
        }
        _$CompareInitialStateWithCurrent$_() {
            if (this._$MaybeGetInstance$_(), this._$IsInstanceValid$_() || !this._$IsInstanceTrack$_()) for (const t of this._$_propertyTracks$_) t._$CompareInitialStateWithCurrent$_();
        }
        _$CompareSaveStateWithCurrent$_() {
            if (this._$MaybeGetInstance$_(), !this._$IsInstanceValid$_() && this._$IsInstanceTrack$_()) return;
            let t = !1;
            for (const s of this._$_propertyTracks$_) {
                const i = s._$CompareSaveStateWithCurrent$_();
                !t && i && (t = !0);
            }
            if (t) {
                const t = this._$AddKeyframe$_();
                t._$SetTime$_(this._$GetTimeline$_()._$GetTime$_()), t._$SetEase$_("noease"), t._$SetEnable$_(!0), 
                t._$SetTags$_("");
            }
        }
        _$_OnAfterLoad$_() {
            isNaN(this._$_instanceUidToLoad$_) || this._$_LoadInstanceFromJson$_(this._$_instanceUidToLoad$_), 
            this._$_instanceUidToLoad$_ = NaN;
        }
        _$_SaveToJson$_() {
            const t = this._$GetInstance$_(), s = t ? t._$GetUID$_() : this._$GetInstanceUID$_();
            return {
                propertyTracksJson: this._$_SavePropertyTracksToJson$_(),
                lastKeyframeDataItemJson: this._$_SaveLastKeyframeDataItemToJson$_(),
                initialStateOfNestedSet: this._$_initialStateOfNestedSet$_,
                endStateOfNestedSet: this._$_endStateOfNestedSet$_,
                instanceUid: s,
                cleared: this._$_cleared$_
            };
        }
        _$_LoadFromJson$_(t) {
            if (t) {
                this._$_LoadPropertyTracksFromJson$_(t.propertyTracksJson), this._$_LoadLastKeyframeDataItemFromJson$_(t.lastKeyframeDataItemJson), 
                this._$_instanceUidToLoad$_ = t.instanceUid, this._$_initialStateOfNestedSet$_ = !1, 
                t.hasOwnProperty.initialStateOfNestedSet && (this._$_initialStateOfNestedSet$_ = t.initialStateOfNestedSet), 
                this._$_endStateOfNestedSet$_ = !1, t.hasOwnProperty.endStateOfNestedSet && (this._$_endStateOfNestedSet$_ = t.endStateOfNestedSet), 
                this._$_cleared$_ = !!t.hasOwnProperty("cleared") && t.cleared;
                for (const t of this._$_propertyTracks$_) 0 === this._$_worldInfoChange$_ && 1 === t._$GetWorldInfoChange$_() && (this._$_worldInfoChange$_ = 1), 
                0 === this._$_renderChange$_ && 1 === t._$GetRenderChange$_() && (this._$_renderChange$_ = 1);
                this._$_needsBeforeAndAfter$_ = 0, this._$_propertyTracks$_.some((t => t._$GetNeedsBeforeAndAfter$_())) && (this._$_needsBeforeAndAfter$_ = 1);
            }
        }
        _$_SaveLastKeyframeDataItemToJson$_() {
            return this._$_trackDataItem$_._$GetKeyframeData$_()._$GetKeyframeDataItemIndex$_(this._$_lastKeyframeDataItem$_);
        }
        _$_SavePropertyTracksToJson$_() {
            return this._$_propertyTracks$_.map((t => t._$_SaveToJson$_()));
        }
        _$_LoadPropertyTracksFromJson$_(t) {
            t.forEach(((t, s) => {
                this._$_propertyTracks$_[s]._$_LoadFromJson$_(t);
            }));
        }
        _$_LoadInstanceFromJson$_(t) {
            if (!cm._$IsFiniteNumber$_(t)) return;
            const s = this._$GetRuntime$_()._$GetInstanceByUID$_(t);
            s && this._$GetTimeline$_()._$SetTrackInstance$_(this._$_trackDataItem$_._$GetId$_(), s, this._$GetTrackIndexInTimeline$_());
        }
        _$_LoadLastKeyframeDataItemFromJson$_(t) {
            const s = this._$_trackDataItem$_._$GetKeyframeData$_();
            this._$_lastKeyframeDataItem$_ = s._$GetKeyframeDataItemFromIndex$_(t);
        }
    };
}

{
    const fm = self._$C3$_;
    fm._$PropertyTrackState$_ = class extends fm._$DefendedBase$_ {
        constructor(t, s) {
            super(), this._$_track$_ = t, this._$_propertyTrackDataItem$_ = s, this._$_propertyTrackData$_ = s._$GetPropertyTrackData$_(), 
            this._$_worldInfoChange$_ = 0, this._$_renderChange$_ = 0, this._$_needsBeforeAndAfter$_ = 0, 
            this._$_sourceAdapter$_ = this._$GetSourceAdapter$_(), this._$_propertyKeyframeDataItems$_ = this._$_propertyTrackDataItem$_._$GetPropertyKeyframeData$_()._$GetPropertyKeyframeDataItemArray$_(), 
            this._$_lastPropertyKeyframeDataItem$_ = null, this._$_absoluteValueObject$_ = null;
        }
        static _$Create$_(t, s) {
            return fm._$New$_(fm._$PropertyTrackState$_, t, s);
        }
        _$Release$_() {
            this._$_track$_ = null, this._$_sourceAdapter$_ && (this._$_sourceAdapter$_._$Release$_(), 
            this._$_sourceAdapter$_ = null), this._$_propertyKeyframeDataItems$_ = null, this._$_propertyTrackDataItem$_ = null, 
            this._$_propertyTrackData$_ = null;
        }
        _$GetWorldInfoChange$_() {
            return this._$_worldInfoChange$_;
        }
        _$GetRenderChange$_() {
            return this._$_renderChange$_;
        }
        _$GetNeedsBeforeAndAfter$_() {
            return this._$_needsBeforeAndAfter$_;
        }
        _$HasAbsoluteValueObject$_() {
            return !!this._$_absoluteValueObject$_;
        }
        _$SetAbsoluteValueObject$_(t) {
            this._$_absoluteValueObject$_ = t;
        }
        _$GetAbsoluteValueObject$_() {
            return this._$_absoluteValueObject$_;
        }
        _$GetTrack$_() {
            return this._$_track$_;
        }
        _$GetPropertyTrackDataItem$_() {
            return this._$_propertyTrackDataItem$_;
        }
        _$GetPropertyTrackData$_() {
            return this._$_propertyTrackData$_;
        }
        _$GetTimeline$_() {
            return this._$_track$_._$GetTimeline$_();
        }
        _$GetRuntime$_() {
            return this._$_track$_._$GetRuntime$_();
        }
        _$GetInstance$_() {
            return this._$_track$_._$GetInstance$_();
        }
        _$GetSourceAdapter$_() {
            if (this._$_sourceAdapter$_) return this._$_sourceAdapter$_;
            let t;
            switch (this._$_propertyTrackDataItem$_._$GetSourceAdapterId$_()) {
              case "behavior":
                t = new fm._$PropertyTrackState$_._$BehaviorSourceAdapter$_(this);
                break;

              case "effect":
                t = new fm._$PropertyTrackState$_._$EffectSourceAdapter$_(this), this._$_renderChange$_ = 1;
                break;

              case "instance-variable":
                t = new fm._$PropertyTrackState$_._$InstanceVariableSourceAdapter$_(this);
                break;

              case "plugin":
                t = new fm._$PropertyTrackState$_._$PluginSourceAdapter$_(this), this._$_renderChange$_ = 1;
                break;

              case "world-instance":
                t = new fm._$PropertyTrackState$_._$PropertySourceAdapter$_(this), this._$_renderChange$_ = 1, 
                this._$_worldInfoChange$_ = 1;
                break;

              case "value":
                t = new fm._$PropertyTrackState$_._$ValueSourceAdapter$_(this);
                break;

              case "audio":
                t = new fm._$PropertyTrackState$_._$AudioSourceAdapter$_(this);
            }
            return this._$_sourceAdapter$_ = t, this._$_sourceAdapter$_;
        }
        _$GetSourceAdapterId$_() {
            return this._$_propertyTrackDataItem$_._$GetSourceAdapterId$_();
        }
        _$SetSourceAdapterId$_(t) {
            this._$_propertyTrackDataItem$_._$SetSourceAdapterId$_(t);
        }
        _$GetSourceAdapterArgs$_() {
            return this._$_propertyTrackDataItem$_._$GetSourceAdapterArguments$_();
        }
        _$SetSourceAdapterArgs$_(t) {
            this._$_propertyTrackDataItem$_._$SetSourceAdapterArguments$_(t);
        }
        _$GetSourceAdapterValue$_() {
            return this._$GetSourceAdapter$_()._$GetValue$_();
        }
        _$GetPropertyName$_() {
            return this._$_propertyTrackDataItem$_._$GetProperty$_();
        }
        _$SetPropertyName$_(t) {
            this._$_propertyTrackDataItem$_._$SetProperty$_(t);
        }
        _$GetPropertyType$_() {
            return this._$_propertyTrackDataItem$_._$GetType$_();
        }
        _$SetPropertyType$_(t) {
            this._$_propertyTrackDataItem$_._$SetType$_(t);
        }
        _$GetPropertyKeyframeType$_() {
            return this._$GetPropertyTrackData$_()._$GetFirstPropertyKeyframeDataItem$_(this._$_propertyTrackDataItem$_)._$GetType$_();
        }
        _$GetMin$_() {
            return this._$_propertyTrackDataItem$_._$GetMin$_();
        }
        _$SetMin$_(t) {
            this._$_propertyTrackDataItem$_._$SetMin$_(t);
        }
        _$GetMax$_() {
            return this._$_propertyTrackDataItem$_._$GetMax$_();
        }
        _$SetMax$_(t) {
            this._$_propertyTrackDataItem$_._$SetMax$_(t);
        }
        _$GetEnable$_() {
            return this._$_propertyTrackDataItem$_._$GetEnable$_();
        }
        _$SetEnable$_(t) {
            this._$_propertyTrackDataItem$_._$SetEnable$_(t);
        }
        _$GetInterpolationMode$_() {
            return this._$_propertyTrackDataItem$_._$GetInterpolationMode$_();
        }
        _$SetInterpolationMode$_(t) {
            this._$_propertyTrackDataItem$_._$SetInterpolationMode$_(t);
        }
        _$GetResultMode$_() {
            return this._$_propertyTrackDataItem$_._$GetResultMode$_();
        }
        _$SetResultMode$_(t) {
            this._$_propertyTrackDataItem$_._$SetResultMode$_(t);
        }
        _$SetEase$_(t) {
            for (const s of this._$GetPropertyKeyframeDataItems$_()) s._$SetEase$_(t);
        }
        _$CanHavePropertyKeyframes$_() {
            return this._$_propertyTrackDataItem$_._$CanHavePropertyKeyframes$_();
        }
        _$GetPropertyKeyframeDataItems$_() {
            return this._$_propertyKeyframeDataItems$_ || (this._$_propertyKeyframeDataItems$_ = this._$_propertyTrackDataItem$_._$GetPropertyKeyframeData$_()._$GetPropertyKeyframeDataItemArray$_()), 
            this._$_propertyKeyframeDataItems$_;
        }
        _$GetPropertyKeyframeDataItemArrayIncludingDisabled$_() {
            return this._$_propertyTrackDataItem$_._$GetPropertyKeyframeData$_()._$GetPropertyKeyframeDataItemArrayIncludingDisabled$_();
        }
        _$GetPropertyKeyFrameDataItemAtTime$_(t) {
            return this._$_propertyTrackData$_._$GetPropertyKeyFrameDataItemAtTime$_(t, this._$_propertyTrackDataItem$_);
        }
        _$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t) {
            return this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, this._$_propertyTrackDataItem$_);
        }
        _$GetPropertyKeyframeDataItemPairForTime$_(t) {
            let s, i = this._$_propertyTrackData$_._$GetPropertyKeyFrameDataItemAtTime$_(t, this._$_propertyTrackDataItem$_);
            return i ? s = this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemHigherThan$_(t, this._$_propertyTrackDataItem$_) : (i = this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, this._$_propertyTrackDataItem$_), 
            s = this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemHigherOrEqualThan$_(t, this._$_propertyTrackDataItem$_)), 
            {
                start: i,
                end: s
            };
        }
        * _$GetPropertyKeyframeValues$_() {
            for (const t of this._$GetPropertyKeyframeDataItems$_()) yield t._$GetValueWithResultMode$_();
        }
        * _$GetPropertyKeyframeTimes$_() {
            for (const t of this._$GetPropertyKeyframeDataItems$_()) yield t._$GetTime$_();
        }
        _$TimelineRemoved$_() {
            this._$GetSourceAdapter$_()._$TimelineRemoved$_();
        }
        _$CleanCaches$_() {
            this._$GetSourceAdapter$_()._$CleanCaches$_();
        }
        _$GetCurrentState$_() {
            return this._$GetSourceAdapter$_()._$GetCurrentState$_();
        }
        _$SetResetState$_() {
            this._$GetSourceAdapter$_()._$SetResetState$_();
        }
        _$SetInitialState$_(t) {
            this._$GetSourceAdapter$_()._$SetInitialState$_(), this._$_lastPropertyKeyframeDataItem$_ = this._$_GetLastPropertyKeyFrameBeforeTime$_(t), 
            this._$_SetUpdateState$_();
        }
        _$SetResumeState$_(t) {
            this._$GetSourceAdapter$_()._$SetResumeState$_(), this._$_lastPropertyKeyframeDataItem$_ = this._$_GetLastPropertyKeyFrameBeforeTime$_(t);
        }
        _$_SetUpdateState$_() {
            const t = this._$GetTrack$_();
            if (this._$_needsBeforeAndAfter$_ = 0, t._$IsInstanceTrack$_()) {
                const s = this._$GetTimeline$_(), i = t._$GetInstance$_(), e = this._$GetSourceAdapter$_(), n = this._$GetPropertyName$_();
                if (e._$MayNeedBeforeAndAfterInterpolate$_()) {
                    const t = s._$GetSimilarPropertyTracks$_(i, e, n, this);
                    t && t.length && (this._$_needsBeforeAndAfter$_ = 1);
                } else this._$_needsBeforeAndAfter$_ = 0;
            }
        }
        _$_GetLastPropertyKeyFrameBeforeTime$_(t) {
            const s = this._$GetTimeline$_();
            return this._$_propertyTrackData$_._$GetPropertyKeyFrameDataItemAtTime$_(t, this._$_propertyTrackDataItem$_) || (s._$IsForwardPlayBack$_() ? this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, this._$_propertyTrackDataItem$_) : this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemHigherOrEqualThan$_(t, this._$_propertyTrackDataItem$_));
        }
        _$BeforeInterpolate$_() {
            this._$_sourceAdapter$_._$BeforeInterpolate$_();
        }
        _$Interpolate$_(t, s = !1, i = !1, e = !1) {
            let n, h, r = !1;
            if (s) n = this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, this._$_propertyTrackDataItem$_); else {
                if (this._$_lastPropertyKeyframeDataItem$_) {
                    const s = this._$GetTimeline$_(), i = this._$_lastPropertyKeyframeDataItem$_._$GetNext$_(), e = this._$_lastPropertyKeyframeDataItem$_._$GetTime$_(), n = i ? i._$GetTime$_() : s._$GetTotalTime$_();
                    (t <= e || t >= n) && (this._$_lastPropertyKeyframeDataItem$_ = this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, this._$_propertyTrackDataItem$_), 
                    r = !0);
                } else this._$_lastPropertyKeyframeDataItem$_ = this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, this._$_propertyTrackDataItem$_), 
                r = !0;
                n = this._$_lastPropertyKeyframeDataItem$_;
            }
            n && (h = n._$GetNext$_()), this._$_sourceAdapter$_._$Interpolate$_(t, n, h, s, i, e, r);
        }
        _$GetInterpolatedValue$_(t) {
            if (this._$_lastPropertyKeyframeDataItem$_) {
                const s = this._$GetTimeline$_(), i = this._$_lastPropertyKeyframeDataItem$_._$GetNext$_(), e = this._$_lastPropertyKeyframeDataItem$_._$GetTime$_(), n = i ? i._$GetTime$_() : s._$GetTotalTime$_();
                (t <= e || t >= n) && (this._$_lastPropertyKeyframeDataItem$_ = this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, this._$_propertyTrackDataItem$_));
            } else this._$_lastPropertyKeyframeDataItem$_ = this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, this._$_propertyTrackDataItem$_);
            const s = this._$_lastPropertyKeyframeDataItem$_, i = s._$GetNext$_();
            return this._$_sourceAdapter$_._$GetInterpolatedValue$_(t, s, i);
        }
        _$GetInterpolatedValueFast$_(t, s, i) {
            return this._$_sourceAdapter$_._$GetInterpolatedValue$_(t, s, i);
        }
        _$AfterInterpolate$_() {
            this._$_sourceAdapter$_._$AfterInterpolate$_();
        }
        static _$GetStartPropertyKeyframeForTime$_(t, s) {
            const i = s._$GetPropertyTrackDataItem$_();
            return s._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, i);
        }
        static _$GetEndPropertyKeyframeForTime$_(t, s) {
            const i = s._$GetPropertyTrackDataItem$_();
            return s._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemHigherOrEqualThan$_(t, i);
        }
        _$AddPropertyKeyframe$_() {
            const t = this._$_propertyTrackDataItem$_._$GetPropertyKeyframeData$_()._$AddEmptyPropertyKeyframeDataItem$_();
            return this._$_lastPropertyKeyframeDataItem$_ = null, t;
        }
        _$DeletePropertyKeyframes$_(t) {
            this._$_lastPropertyKeyframeDataItem$_ = null, this._$_propertyTrackDataItem$_._$GetPropertyKeyframeData$_()._$DeletePropertyKeyframeDataItems$_(t);
        }
        _$SaveState$_() {
            this._$GetSourceAdapter$_()._$SaveState$_();
        }
        _$CompareInitialStateWithCurrent$_() {
            if (this._$GetSourceAdapter$_()._$CompareInitialStateWithCurrent$_()) {
                const t = this._$_propertyTrackData$_._$GetFirstPropertyKeyframeDataItem$_(this._$_propertyTrackDataItem$_), s = this._$GetSourceAdapter$_()._$GetCurrentState$_();
                t._$SetAbsoluteValue$_(s);
            }
        }
        _$CompareSaveStateWithCurrent$_() {
            const t = this._$GetSourceAdapter$_()._$CompareSaveStateWithCurrent$_();
            return t && this._$AddPropertyKeyframeAtCurrentTime$_(), this._$GetSourceAdapter$_()._$ClearSaveState$_(), 
            t;
        }
        _$AddPropertyKeyframeAtCurrentTime$_() {
            const t = this._$GetTimeline$_()._$GetTime$_(), s = this._$GetSourceAdapter$_(), i = fm._$PropertyTrackState$_._$GetStartPropertyKeyframeForTime$_(t, this), e = this._$AddPropertyKeyframe$_();
            e._$SetType$_(i._$GetType$_()), e._$SetTime$_(t), e._$SetEase$_(i._$GetEase$_()), 
            e._$SetEnable$_(!0), e._$SetValue$_(s._$GetValueAtTime$_()), e._$SetAbsoluteValue$_(s._$GetCurrentState$_());
        }
        _$_SaveToJson$_() {
            return {
                sourceAdapterJson: this._$GetSourceAdapter$_()._$_SaveToJson$_()
            };
        }
        _$_LoadFromJson$_(t) {
            t && this._$GetSourceAdapter$_()._$_LoadFromJson$_(t.sourceAdapterJson);
        }
    };
}

{
    const dm = self._$C3$_._$PropertyTrackState$_;
    dm._$PropertySourceAdapter$_ = class {
        constructor(t) {
            this._$_propertyTrack$_ = t, this._$_propertyAdapter$_ = null, this._$GetPropertyAdapter$_();
        }
        _$Release$_() {
            this._$_propertyAdapter$_ && (this._$_propertyAdapter$_._$Release$_(), this._$_propertyAdapter$_ = null), 
            this._$_propertyTrack$_ = null;
        }
        _$MayNeedBeforeAndAfterInterpolate$_() {
            return this._$_propertyAdapter$_._$MayNeedBeforeAndAfterInterpolate$_();
        }
        _$GetPropertyTrack$_() {
            return this._$_propertyTrack$_;
        }
        _$TimelineRemoved$_() {
            this._$_propertyAdapter$_ && this._$_propertyAdapter$_._$TimelineRemoved$_();
        }
        _$CleanCaches$_() {
            this._$_propertyAdapter$_ && this._$_propertyAdapter$_._$CleanCaches$_();
        }
        _$GetPropertyAdapter$_() {
            return this._$_propertyAdapter$_ || (this._$_propertyAdapter$_ = this._$_CreatePropertyAdapter$_()), 
            this._$_propertyAdapter$_;
        }
        _$GetEditorIndex$_() {}
        _$GetIndex$_() {
            return this._$GetEditorIndex$_();
        }
        _$GetTarget$_() {}
        _$SetResetState$_() {
            this._$GetPropertyAdapter$_()._$SetResetState$_();
        }
        _$SetInitialState$_() {
            this._$GetPropertyAdapter$_()._$SetInitialState$_();
        }
        _$SetResumeState$_() {
            this._$GetPropertyAdapter$_()._$SetResumeState$_();
        }
        _$BeforeInterpolate$_() {
            this._$_propertyAdapter$_._$BeforeChangeProperty$_();
        }
        _$Interpolate$_(t, s, i, e, n, h, r) {
            let o;
            switch (this._$_propertyTrack$_._$GetPropertyKeyframeType$_()) {
              case "numeric":
                o = dm._$NumericTypeAdapter$_._$Interpolate$_(t, s, i, this._$_propertyTrack$_);
                break;

              case "angle":
                o = dm._$AngleTypeAdapter$_._$Interpolate$_(t, s, i, this._$_propertyTrack$_);
                break;

              case "boolean":
                o = dm._$BooleanTypeAdapter$_._$Interpolate$_(t, s, i, this._$_propertyTrack$_);
                break;

              case "color":
                o = dm._$ColorTypeAdapter$_._$Interpolate$_(t, s, i, this._$_propertyTrack$_);
                break;

              case "text":
                o = dm._$TextTypeAdapter$_._$Interpolate$_(t, s, i, this._$_propertyTrack$_);
            }
            this._$_propertyAdapter$_._$ChangeProperty$_(t, o, s, i, e, n, h, r);
        }
        _$GetInterpolatedValue$_(t, s, i) {
            switch (this._$_propertyTrack$_._$GetPropertyKeyframeType$_()) {
              case "numeric":
                return dm._$NumericTypeAdapter$_._$Interpolate$_(t, s, i, this._$_propertyTrack$_);

              case "angle":
                return dm._$AngleTypeAdapter$_._$Interpolate$_(t, s, i, this._$_propertyTrack$_);

              case "boolean":
                return dm._$BooleanTypeAdapter$_._$Interpolate$_(t, s, i, this._$_propertyTrack$_);

              case "color":
                return dm._$ColorTypeAdapter$_._$Interpolate$_(t, s, i, this._$_propertyTrack$_);

              case "text":
                return dm._$TextTypeAdapter$_._$Interpolate$_(t, s, i, this._$_propertyTrack$_);
            }
        }
        _$AfterInterpolate$_() {
            this._$_propertyAdapter$_._$AfterChangeProperty$_();
        }
        _$SaveState$_() {
            this._$GetPropertyAdapter$_()._$SetSaveState$_();
        }
        _$ClearSaveState$_() {
            this._$GetPropertyAdapter$_()._$ClearSaveState$_();
        }
        _$GetCurrentState$_() {
            return this._$GetPropertyAdapter$_()._$GetCurrentState$_();
        }
        _$CompareInitialStateWithCurrent$_() {
            return this._$GetPropertyAdapter$_()._$CompareInitialStateWithCurrent$_();
        }
        _$CompareSaveStateWithCurrent$_() {
            return this._$GetPropertyAdapter$_()._$CompareSaveStateWithCurrent$_();
        }
        _$GetValueAtTime$_() {
            const t = this._$_propertyTrack$_, s = t._$GetTrack$_()._$GetTimeline$_()._$GetTime$_(), i = dm._$GetStartPropertyKeyframeForTime$_(s, t), e = i._$GetNext$_();
            switch (t._$GetPropertyKeyframeType$_()) {
              case "numeric":
                return dm._$NumericTypeAdapter$_._$Interpolate$_(s, i, e, t);

              case "angle":
                return dm._$AngleTypeAdapter$_._$Interpolate$_(s, i, e, t);

              case "boolean":
                return dm._$BooleanTypeAdapter$_._$Interpolate$_(s, i, e, t);

              case "color":
                return dm._$ColorTypeAdapter$_._$Interpolate$_(s, i, e, t);

              case "text":
                return dm._$TextTypeAdapter$_._$Interpolate$_(s, i, e, t);
            }
        }
        _$_CreatePropertyAdapter$_() {
            const t = this._$_propertyTrack$_;
            switch (t._$CanHavePropertyKeyframes$_() ? t._$GetPropertyKeyframeType$_() : "") {
              case "combo":
              case "boolean":
              case "text":
              case "string":
                return new dm._$PropertyInterpolationAdapter$_._$NoInterpolationAdapter$_(this);

              case "numeric":
              case "number":
              case "angle":
                return "combo" === this._$_propertyTrack$_._$GetPropertyType$_() ? new dm._$PropertyInterpolationAdapter$_._$NoInterpolationAdapter$_(this) : new dm._$PropertyInterpolationAdapter$_._$NumericInterpolationAdapter$_(this);

              case "color":
              case "offsetColor":
                return new dm._$PropertyInterpolationAdapter$_._$ColorInterpolationAdapter$_(this);

              default:
                return new dm._$PropertyInterpolationAdapter$_._$NumericInterpolationAdapter$_(this);
            }
        }
        _$_SaveToJson$_() {
            return {
                propertyAdapterJson: this._$GetPropertyAdapter$_()._$_SaveToJson$_()
            };
        }
        _$_LoadFromJson$_(t) {
            t && this._$GetPropertyAdapter$_()._$_LoadFromJson$_(t.propertyAdapterJson);
        }
    };
}

{
    const pm = self._$C3$_;
    class mm extends pm._$PropertyTrackState$_._$PropertySourceAdapter$_ {
        constructor(t) {
            super(t), this._$_updatedIndex$_ = NaN;
        }
        _$GetEditorIndex$_() {
            return this._$_propertyTrack$_._$GetPropertyTrackDataItem$_()._$GetSourceAdapterArguments$_()[0];
        }
        _$GetIndex$_() {
            return this._$_updatedIndex$_ ? this._$_updatedIndex$_ : super._$GetIndex$_();
        }
        _$GetTarget$_() {
            return this._$_propertyTrack$_._$GetTrack$_()._$GetInstance$_();
        }
        _$UpdateInstanceVariableIndex$_(t) {
            this._$_propertyTrack$_._$GetPropertyTrackDataItem$_()._$GetSourceAdapterArguments$_()[0] !== t && (this._$_updatedIndex$_ = t);
        }
        _$Interpolate$_(t, s, i, e, n, h, r) {
            this._$GetPropertyAdapter$_()._$CanChange$_(s._$GetValue$_()) && super._$Interpolate$_(t, s, i, e, n, h, r);
        }
        _$GetInterpolatedValue$_(t, s, i) {
            if (this._$GetPropertyAdapter$_()._$CanChange$_(s._$GetValue$_())) return super._$GetInterpolatedValue$_(t, s, i);
        }
        _$_SaveToJson$_() {
            return Object.assign(super._$_SaveToJson$_(), {
                index: this._$_updatedIndex$_
            });
        }
        _$_LoadFromJson$_(t) {
            t && (super._$_LoadFromJson$_(t), this._$_updatedIndex$_ = t.index);
        }
    }
    pm._$PropertyTrackState$_._$InstanceVariableSourceAdapter$_ = mm;
}

{
    const gm = self._$C3$_;
    class ym extends gm._$PropertyTrackState$_._$PropertySourceAdapter$_ {
        constructor(t) {
            super(t), this._$_sid$_ = NaN;
        }
        _$GetEditorIndex$_() {
            return this._$_propertyTrack$_._$GetPropertyTrackDataItem$_()._$GetSourceAdapterArguments$_()[1];
        }
        _$GetTarget$_() {
            const t = this._$_propertyTrack$_._$GetPropertyTrackDataItem$_(), s = this._$_propertyTrack$_._$GetTrack$_(), i = this._$_sid$_ ? this._$_sid$_ : t._$GetSourceAdapterArguments$_()[0], e = s._$GetInstance$_(), n = e._$GetBehaviorIndexBySID$_(i);
            return e._$GetBehaviorInstances$_()[n]._$GetSdkInstance$_();
        }
        _$GetBehaviorType$_(t) {
            const s = this._$_propertyTrack$_._$GetPropertyTrackDataItem$_()._$GetSourceAdapterArguments$_()[2];
            return t._$GetBehaviorTypeByName$_(s);
        }
        _$UpdateBehaviorTypeSid$_(t) {
            this._$_propertyTrack$_._$GetPropertyTrackDataItem$_()._$GetSourceAdapterArguments$_()[0] !== t && (this._$_sid$_ = t);
        }
        _$Interpolate$_(t, s, i, e, n, h, r) {
            const o = this._$_propertyTrack$_._$GetTrack$_()._$GetInstance$_();
            this._$GetBehaviorType$_(o._$GetObjectClass$_()) && super._$Interpolate$_(t, s, i, e, n, h, r);
        }
        _$GetInterpolatedValue$_(t, s, i) {
            const e = this._$_propertyTrack$_._$GetTrack$_()._$GetInstance$_();
            if (this._$GetBehaviorType$_(e._$GetObjectClass$_())) return super._$GetInterpolatedValue$_(t, s, i);
        }
        _$_SaveToJson$_() {
            return Object.assign(super._$_SaveToJson$_(), {
                sid: this._$_sid$_
            });
        }
        _$_LoadFromJson$_(t) {
            t && (super._$_LoadFromJson$_(t), this._$_sid$_ = t.sid);
        }
    }
    gm._$PropertyTrackState$_._$BehaviorSourceAdapter$_ = ym;
}

{
    const Mm = self._$C3$_;
    class wm extends Mm._$PropertyTrackState$_._$PropertySourceAdapter$_ {
        constructor(t) {
            super(t);
        }
        _$GetEditorIndex$_() {
            return this._$_propertyTrack$_._$GetPropertyTrackDataItem$_()._$GetSourceAdapterArguments$_()[1];
        }
        _$GetTarget$_() {
            const t = this._$_propertyTrack$_._$GetTrack$_()._$GetWorldInfo$_()._$GetInstanceEffectList$_(), s = t._$GetEffectList$_(), i = this._$GetEffectType$_(s)._$GetIndex$_();
            return t._$IsEffectIndexActive$_(i) ? t._$GetEffectParametersForIndex$_(i) : null;
        }
        _$GetEffectType$_(t) {
            const s = this._$_propertyTrack$_._$GetPropertyTrackDataItem$_()._$GetSourceAdapterArguments$_()[0];
            return t._$GetEffectTypeByName$_(s);
        }
        _$Interpolate$_(t, s, i, e, n, h, r) {
            this._$_IsEffectActive$_() && super._$Interpolate$_(t, s, i, e, n, h, r);
        }
        _$GetInterpolatedValue$_(t, s, i) {
            if (this._$_IsEffectActive$_()) return super._$GetInterpolatedValue$_(t, s, i);
        }
        _$_IsEffectActive$_() {
            const t = this._$_propertyTrack$_._$GetTrack$_()._$GetWorldInfo$_()._$GetInstanceEffectList$_(), s = t._$GetEffectList$_(), i = this._$GetEffectType$_(s);
            if (!i) return;
            const e = i._$GetIndex$_();
            return t._$IsEffectIndexActive$_(e);
        }
    }
    Mm._$PropertyTrackState$_._$EffectSourceAdapter$_ = wm;
}

{
    const Sm = self._$C3$_;
    class bm extends Sm._$PropertyTrackState$_._$PropertySourceAdapter$_ {
        constructor(t) {
            super(t);
        }
        _$GetEditorIndex$_() {
            return this._$_propertyTrack$_._$GetPropertyTrackDataItem$_()._$GetSourceAdapterArguments$_()[0];
        }
        _$GetTarget$_() {
            return this._$_propertyTrack$_._$GetTrack$_()._$GetInstance$_()._$GetSdkInstance$_();
        }
        _$Interpolate$_(t, s, i, e, n, h, r) {
            const o = this._$_propertyTrack$_._$GetTrack$_();
            o._$GetObjectClass$_()._$GetPlugin$_() === o._$GetInstance$_()._$GetObjectClass$_()._$GetPlugin$_() && super._$Interpolate$_(t, s, i, e, n, h, r);
        }
        _$GetInterpolatedValue$_(t, s, i) {
            const e = this._$_propertyTrack$_._$GetTrack$_();
            if (e._$GetObjectClass$_()._$GetPlugin$_() === e._$GetInstance$_()._$GetObjectClass$_()._$GetPlugin$_()) return super._$GetInterpolatedValue$_(t, s, i);
        }
        _$GetOptionalCallbacks$_() {
            const t = this._$_propertyTrack$_._$GetTrack$_()._$GetObjectClass$_()._$GetPlugin$_();
            if (Sm._$Plugins$_._$Sprite$_ && t instanceof Sm._$Plugins$_._$Sprite$_ && ("initial-frame" === this._$_propertyTrack$_._$GetPropertyName$_() || "initial-animation" === this._$_propertyTrack$_._$GetPropertyName$_())) switch (this._$_propertyTrack$_._$GetResultMode$_()) {
              case "relative":
              case "absolute":
                return null;
            }
        }
    }
    Sm._$PropertyTrackState$_._$PluginSourceAdapter$_ = bm;
}

{
    const Tm = self._$C3$_;
    class vm extends Tm._$PropertyTrackState$_._$PropertySourceAdapter$_ {
        constructor(t) {
            super(t), this._$_value$_ = 0, this._$_init$_ = !1;
        }
        _$MayNeedBeforeAndAfterInterpolate$_() {
            return !1;
        }
        _$SetInitialState$_() {
            const t = this._$_propertyTrack$_._$GetPropertyTrackData$_();
            let s = this._$_propertyTrack$_._$GetPropertyTrackDataItem$_();
            s = t._$GetFirstPropertyKeyframeDataItem$_(s), this._$_value$_ = s._$GetValueWithResultMode$_();
        }
        _$SetResumeState$_() {}
        _$GetValue$_() {
            return this._$_init$_ || this._$_propertyTrack$_._$Interpolate$_(0), this._$_value$_;
        }
        _$Interpolate$_(t, s, i, e, n, h, r) {
            this._$_value$_ = Tm._$PropertyTrackState$_._$NumericTypeAdapter$_._$Interpolate$_(t, s, i, this._$_propertyTrack$_), 
            this._$_init$_ = !0;
        }
        _$SaveState$_() {}
        _$ClearSaveState$_() {}
        _$GetCurrentState$_() {
            return this._$_value$_;
        }
        _$CompareInitialStateWithCurrent$_() {
            return !1;
        }
        _$CompareSaveStateWithCurrent$_() {
            return !1;
        }
        _$_SaveToJson$_() {
            return {
                value: this._$_value$_,
                init: this._$_init$_
            };
        }
        _$_LoadFromJson$_(t) {
            t && (this._$_value$_ = t.value, this._$_init$_ = !t.hasOwnProperty("init") || t.init);
        }
    }
    Tm._$PropertyTrackState$_._$ValueSourceAdapter$_ = vm;
}

{
    const xm = self._$C3$_;
    class Im extends xm._$PropertyTrackState$_._$PropertySourceAdapter$_ {
        constructor(t) {
            super(t), this._$_audioPlaybackStarted$_ = !1, this._$_sdkInstance$_ = null, this._$_actions$_ = null, 
            this._$_expressions$_ = null, this._$_timeline$_ = this._$_propertyTrack$_._$GetTimeline$_(), 
            this._$_track$_ = this._$_propertyTrack$_._$GetTrack$_(), this._$_sourceAdapterArgs$_ = this._$_propertyTrack$_._$GetSourceAdapterArgs$_(), 
            this._$_fileArgs$_ = this._$_sourceAdapterArgs$_[0], this._$_startOffsetTime$_ = this._$_sourceAdapterArgs$_[1], 
            this._$_sourceAdapterArgs$_[3] ? this._$_audioTag$_ = this._$_sourceAdapterArgs$_[3] : this._$_audioTag$_ = Math.random().toString(36).slice(2), 
            this._$_pauseTime$_ = NaN, this._$_pauseVolume$_ = NaN, this._$_volume$_ = NaN, 
            this._$_audioSource$_ = null, this._$_Initialize$_();
        }
        _$Release$_() {
            super._$Release$_(), this._$_sdkInstance$_ = null, this._$_actions$_ = null, this._$_expressions$_ = null, 
            this._$_timeline$_ = null, this._$_track$_ = null, this._$_sourceAdapterArgs$_ = null, 
            this._$_fileArgs$_ = null, this._$_audioSource$_ = null;
        }
        _$_Initialize$_() {
            if (!self._$C3$_._$Plugins$_.Audio) return;
            const t = this._$_propertyTrack$_._$GetRuntime$_()._$GetSingleGlobalObjectClassByCtor$_(self._$C3$_._$Plugins$_.Audio);
            t && (this._$_sdkInstance$_ = t._$GetSingleGlobalInstance$_()._$GetSdkInstance$_()), 
            this._$_actions$_ = self._$C3$_._$Plugins$_.Audio._$Acts$_, this._$_expressions$_ = self._$C3$_._$Plugins$_.Audio._$Exps$_;
        }
        _$_MaybeSetAudioSource$_() {
            if (this._$_audioSource$_) return;
            const t = this._$_propertyTrack$_._$GetTrack$_()._$GetPropertyTrack$_("audioSource");
            t && (this._$_audioSource$_ = t._$GetSourceAdapter$_());
        }
        _$_GetPauseVolume$_() {
            const t = this._$_propertyTrack$_._$GetTrack$_()._$GetPropertyTrack$_("volume");
            return t ? t._$GetSourceAdapter$_()._$_pauseVolume$_ : this._$_pauseVolume$_;
        }
        _$TimelineRemoved$_() {
            super._$TimelineRemoved$_(), this._$_audioPlaybackStarted$_ = !1, this._$_sdkInstance$_ && (this._$_expressions$_ && (this._$_pauseTime$_ = this._$_expressions$_._$PlaybackTime$_.call(this._$_sdkInstance$_, this._$_audioTag$_), 
            this._$_pauseVolume$_ = this._$_expressions$_._$Volume$_.call(this._$_sdkInstance$_, this._$_audioTag$_)), 
            this._$_actions$_ && this._$_actions$_._$Stop$_.call(this._$_sdkInstance$_, this._$_audioTag$_));
        }
        _$GetAudioTag$_() {
            return this._$_audioTag$_;
        }
        _$GetVolume$_() {
            return this._$_volume$_;
        }
        _$SetVolume$_(t) {
            this._$_volume$_ = t;
        }
        _$SetInitialState$_() {
            super._$SetInitialState$_(), this._$_pauseTime$_ = NaN, this._$_audioPlaybackStarted$_ = !1;
        }
        _$SetResumeState$_() {
            super._$SetResumeState$_();
            const t = this._$_propertyTrack$_._$GetTimeline$_()._$GetTime$_();
            switch (this._$_pauseTime$_ = t - this._$_startOffsetTime$_, this._$_propertyTrack$_._$GetPropertyName$_()) {
              case "audioSource":
                break;

              case "volume":
                this._$_pauseVolume$_ = this._$_propertyTrack$_._$GetInterpolatedValue$_(t);
            }
            this._$_audioPlaybackStarted$_ = !1;
        }
        _$Interpolate$_(t, s, i, e, n, h, r) {
            if (this._$_sdkInstance$_) switch (this._$_propertyTrack$_._$GetPropertyName$_()) {
              case "audioSource":
                {
                    if (!this._$_timeline$_._$IsForwardPlayBack$_()) return;
                    if (e) return void (this._$_actions$_ && this._$_actions$_._$Stop$_.call(this._$_sdkInstance$_, this._$_audioTag$_));
                    if (t < this._$_startOffsetTime$_) return void (this._$_audioPlaybackStarted$_ = !1);
                    const s = this._$_expressions$_._$PlaybackRate$_.call(this._$_sdkInstance$_, this._$_audioTag$_), i = this._$_timeline$_._$GetPlaybackRate$_();
                    if (i !== s && this._$_actions$_._$SetPlaybackRate$_.call(this._$_sdkInstance$_, this._$_audioTag$_, i), 
                    this._$_audioPlaybackStarted$_) return;
                    if (!this._$_propertyTrack$_._$GetTimeline$_().IsPlaying()) return;
                    if (this._$_audioPlaybackStarted$_ = !0, isNaN(this._$_pauseTime$_)) {
                        const s = self.performance.now(), i = t - this._$_startOffsetTime$_;
                        if ("suspended" === this._$_sdkInstance$_._$GetAudioContextState$_()) return void (this._$_audioPlaybackStarted$_ = !1);
                        const e = i + (self.performance.now() - s) / 1e3;
                        if (this._$_actions$_) {
                            let t = this._$GetVolume$_();
                            isNaN(t) ? (this._$SetVolume$_(0), t = 0) : this._$SetVolume$_(t), this._$_actions$_._$PlayFromTimeline$_.call(this._$_sdkInstance$_, this._$_fileArgs$_, t, this._$_audioTag$_, e);
                        }
                    } else {
                        const t = this._$_pauseTime$_;
                        this._$_pauseTime$_ = NaN;
                        const s = this._$_GetPauseVolume$_();
                        if (this._$_pauseVolume$_ = NaN, "suspended" === this._$_sdkInstance$_._$GetAudioContextState$_()) return void (this._$_audioPlaybackStarted$_ = !1);
                        this._$_actions$_ && (this._$SetVolume$_(s), this._$_actions$_._$PlayFromTimeline$_.call(this._$_sdkInstance$_, this._$_fileArgs$_, s, this._$_audioTag$_, t));
                    }
                    break;
                }

              case "volume":
                this._$_MaybeSetAudioSource$_(), super._$Interpolate$_(t, s, i, e, n, h, r);
            }
        }
        _$GetInterpolatedValue$_(t, s, i) {
            if (this._$_sdkInstance$_) switch (this._$_propertyTrack$_._$GetPropertyName$_()) {
              case "audioSource":
                return;

              case "volume":
                return this._$_MaybeSetAudioSource$_(), super._$GetInterpolatedValue$_(t, s, i);
            }
        }
        _$Getter$_(t, s) {
            return this._$_audioSource$_ ? this._$_audioSource$_._$GetVolume$_() : 0;
        }
        _$Setter$_(t, s, i, e) {
            this._$_audioSource$_ && this._$_audioSource$_._$SetVolume$_(this._$Getter$_() + s), 
            this._$_actions$_ && this._$_audioSource$_ && this._$_actions$_._$SetVolume$_.call(this._$_sdkInstance$_, this._$_audioSource$_._$GetAudioTag$_(), this._$_audioSource$_._$GetVolume$_());
        }
        _$AbsoluteSetter$_(t, s, i) {
            this._$_audioSource$_ && this._$_audioSource$_._$SetVolume$_(s), this._$_actions$_ && this._$_audioSource$_ && this._$_actions$_._$SetVolume$_.call(this._$_sdkInstance$_, this._$_audioSource$_._$GetAudioTag$_(), this._$_audioSource$_._$GetVolume$_());
        }
        _$DoesRounding$_() {
            return !0;
        }
        _$_SaveToJson$_() {
            return {
                audioPlaybackStarted: this._$_audioPlaybackStarted$_,
                audioTag: this._$_audioTag$_,
                pauseTime: this._$_pauseTime$_,
                pauseVolume: this._$_pauseVolume$_,
                volume: this._$_volume$_
            };
        }
        _$_LoadFromJson$_(t) {
            t && (this._$_audioPlaybackStarted$_ = t.audioPlaybackStarted, this._$_audioTag$_ = t.audioTag, 
            this._$_pauseTime$_ = t.pauseTime, this._$_pauseVolume$_ = t.pauseVolume, this._$_volume$_ = t.volume, 
            this._$_Initialize$_());
        }
    }
    xm._$PropertyTrackState$_._$AudioSourceAdapter$_ = Im;
}

self._$C3$_._$PropertyTrackState$_._$PropertyInterpolationAdapter$_ = class {
    constructor(t) {
        this._$_sourceAdapter$_ = t, this._$_propertyTrack$_ = t._$GetPropertyTrack$_(), 
        this._$_worldInfo$_ = this._$_propertyTrack$_._$GetTrack$_()._$GetWorldInfo$_(), 
        this._$_property$_ = this._$_propertyTrack$_._$GetPropertyName$_(), this._$_firstAbsoluteUpdate$_ = !1, 
        this._$_saveState$_ = null, this._$_target$_ = null;
    }
    _$Release$_() {
        this._$_sourceAdapter$_ = null, this._$_propertyTrack$_ = null, this._$_worldInfo$_ = null, 
        this._$_saveState$_ = null, this._$_target$_ = null;
    }
    _$MayNeedBeforeAndAfterInterpolate$_() {
        return !1;
    }
    _$TimelineRemoved$_() {}
    _$CleanCaches$_() {
        this._$_worldInfo$_ = null, this._$_saveState$_ = null, this._$_target$_ = null;
    }
    _$GetSourceAdapter$_() {
        return this._$_sourceAdapter$_;
    }
    _$GetPropertyTrack$_() {
        return this._$_propertyTrack$_;
    }
    _$GetWorldInfo$_() {
        return this._$_worldInfo$_ || (this._$_worldInfo$_ = this._$_propertyTrack$_._$GetTrack$_()._$GetWorldInfo$_()), 
        this._$_worldInfo$_;
    }
    _$SetFirstAbsoluteUpdate$_(t) {
        this._$_firstAbsoluteUpdate$_ = !!t;
    }
    _$GetFirstAbsoluteUpdate$_() {
        return this._$_firstAbsoluteUpdate$_;
    }
    _$SetResetState$_() {}
    _$SetInitialState$_() {}
    _$SetResumeState$_() {}
    _$SetSaveState$_() {
        this._$_saveState$_ = this._$GetCurrentState$_();
    }
    _$ClearSaveState$_() {
        this._$_saveState$_ = null;
    }
    _$GetCurrentState$_() {}
    _$CompareInitialStateWithCurrent$_() {}
    _$CompareSaveStateWithCurrent$_() {}
    _$CanChange$_(t) {
        return typeof this._$_Getter$_() == typeof t;
    }
    _$BeforeChangeProperty$_() {}
    _$ChangeProperty$_(t, s, i, e, n, h, r, o) {}
    _$AfterChangeProperty$_() {}
    _$_FirstKeyframeGetter$_() {
        return this._$_PickTimelinePlaybackMode$_((() => {
            const t = this._$_propertyTrack$_._$GetPropertyTrackDataItem$_();
            return this._$_propertyTrack$_._$GetPropertyTrackData$_()._$GetFirstPropertyKeyframeDataItem$_(t);
        }), (() => {
            const t = this._$_propertyTrack$_._$GetPropertyTrackDataItem$_();
            return this._$_propertyTrack$_._$GetPropertyTrackData$_()._$GetLastPropertyKeyframeDataItem$_(t);
        }))._$GetAbsoluteValue$_();
    }
    _$_CurrentKeyframeGetter$_() {
        const t = this._$_propertyTrack$_._$GetTimeline$_()._$GetTime$_() - this._$_propertyTrack$_._$GetTrack$_()._$GetStartOffset$_();
        return this._$_PickTimelinePlaybackMode$_((() => {
            const s = this._$_propertyTrack$_._$GetPropertyTrackDataItem$_();
            return this._$_propertyTrack$_._$GetPropertyTrackData$_()._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, s);
        }), (() => {
            const s = this._$_propertyTrack$_._$GetPropertyTrackDataItem$_(), i = this._$_propertyTrack$_._$GetPropertyTrackData$_();
            return i._$GetFirstPropertyKeyFrameDataItemHigherOrEqualThan$_(t, s) || i._$GetLastPropertyKeyframeDataItem$_(s);
        }))._$GetAbsoluteValue$_();
    }
    _$_PickTimelinePlaybackMode$_(t, s) {
        return this._$_propertyTrack$_._$GetTimeline$_()._$IsForwardPlayBack$_() ? t() : s();
    }
    _$_PickResultMode$_(t, s) {
        return "relative" === this._$_propertyTrack$_._$GetResultMode$_() ? t() : s();
    }
    _$_PickFirstAbsoluteUpdate$_(t, s) {
        return this._$GetFirstAbsoluteUpdate$_() ? (this._$SetFirstAbsoluteUpdate$_(!1), 
        t()) : s();
    }
    _$_GetAbsoluteInitialValue$_(t) {}
    _$_GetIndex$_() {
        return this._$_sourceAdapter$_._$GetIndex$_();
    }
    _$_GetTarget$_() {
        return this._$_target$_ || (this._$_target$_ = this._$_sourceAdapter$_._$GetTarget$_()), 
        this._$_target$_;
    }
    _$_PickSource$_(t, s, i, e, n, h) {
        switch (this._$_propertyTrack$_._$GetSourceAdapterId$_()) {
          case "behavior":
            return t();

          case "effect":
            return s();

          case "instance-variable":
            return i();

          case "plugin":
            return e();

          case "world-instance":
            return n();

          case "audio":
            return h();
        }
    }
    _$_SaveToJson$_() {
        return {
            firstAbsoluteUpdate: this._$_firstAbsoluteUpdate$_,
            saveState: this._$_saveState$_
        };
    }
    _$_LoadFromJson$_(t) {
        t && (this._$_firstAbsoluteUpdate$_ = t.firstAbsoluteUpdate, this._$_saveState$_ = t.saveState);
    }
    _$_GetPropertyKeyframeStubs$_(t, s = !1) {
        const i = [];
        for (const e of t) {
            const t = e._$GetTrack$_()._$GetStartOffset$_();
            for (const n of e._$GetPropertyKeyframeDataItems$_()) s && 0 === n._$GetTime$_() ? i.push({
                time: t + n._$GetTime$_(),
                value: n._$GetAbsoluteValue$_()
            }) : s || i.push({
                time: t + n._$GetTime$_(),
                value: n._$GetAbsoluteValue$_()
            });
        }
        return i.sort(((t, s) => t.time - s.time));
    }
    _$_GetLastPropertyKeyframeStub$_(t, s, i) {
        return this._$_GetPropertyKeyframeStubLowerThanPlayhead$_(s, i);
    }
    _$_GetPropertyKeyframeStubLowerThanPlayhead$_(t, s) {
        for (let i = s.length - 1; i >= 0; i--) if (s[i].time <= t) return s[i];
        return null;
    }
};

{
    const Gm = self._$C3$_, Cm = new Map, _m = [ 0, 0, 0 ];
    class Em extends Gm._$PropertyTrackState$_._$PropertyInterpolationAdapter$_ {
        constructor(t) {
            super(t);
        }
        _$SetResetState$_() {}
        _$SetInitialState$_() {}
        _$SetResumeState$_() {}
        _$GetCurrentState$_() {
            const t = this._$_propertyTrack$_._$GetSourceAdapterId$_(), s = this._$_GetTarget$_(), i = this._$_GetIndex$_();
            switch (t) {
              case "behavior":
              case "plugin":
                return this._$_ToColorArray$_(s._$GetPropertyValueByIndex$_(i));

              case "effect":
                return this._$_ToColorArray$_(s[i]);

              case "world-instance":
                return this._$_ToColorArray$_(this._$_Getter$_());
            }
        }
        _$CompareInitialStateWithCurrent$_() {
            const t = this._$_FirstKeyframeGetter$_();
            return !this._$_CompareColors$_(t, this._$_Getter$_());
        }
        _$CompareSaveStateWithCurrent$_() {
            return !Gm._$IsNullOrUndefined$_(this._$_saveState$_) && !this._$_CompareColors$_(this._$_saveState$_, this._$_Getter$_());
        }
        _$_CompareColors$_(t, s) {
            return t = this._$_GetColorFromArray$_(t), s = this._$_GetColorFromArray$_(s), t._$equalsIgnoringAlpha$_(s);
        }
        _$_FirstKeyframeGetter$_() {
            const t = super._$_FirstKeyframeGetter$_();
            return this._$_GetColorFromArray$_(t);
        }
        _$_CurrentKeyframeGetter$_() {
            const t = super._$_CurrentKeyframeGetter$_();
            return this._$_GetColorFromArray$_(t);
        }
        _$_GetAbsoluteInitialValue$_(t) {}
        _$_ToColorArray$_(t) {
            return Gm._$IsInstanceOf$_(t, Gm._$Color$_) ? t.toArray().slice(0, 3) : t.slice(0, 3);
        }
        _$_GetColorFromArray$_(t) {
            return Gm._$IsInstanceOf$_(t, Gm._$Color$_) ? t : new Gm._$Color$_(t[0], t[1], t[2], 1);
        }
        _$CanChange$_(t) {
            return !0;
        }
        _$MayNeedBeforeAndAfterInterpolate$_() {
            return !0;
        }
        _$BeforeChangeProperty$_() {
            const t = this._$_propertyTrack$_._$GetTimeline$_(), s = this._$_propertyTrack$_._$GetInstance$_(), i = this._$_propertyTrack$_._$GetSourceAdapter$_(), e = t._$GetSimilarPropertyTracks$_(s, i, this._$_property$_, this._$_propertyTrack$_);
            if (e && e.length > 1) {
                Cm.has(s) || Cm.set(s, new Map);
                const t = Cm.get(s), i = this._$_propertyTrack$_._$GetSourceAdapterId$_();
                t.has(i) || t.set(i, new Map);
                const e = t.get(i);
                e.has(this._$_property$_) || e.set(this._$_property$_, {
                    _$used$_: !1,
                    color: new Gm._$Color$_(0, 0, 0, 1)
                });
            }
        }
        _$_GetTmpColor$_(t, s, i) {
            const e = Cm.get(t).get(s).get(i);
            return e._$used$_ = !0, e.color;
        }
        _$ChangeProperty$_(t, s, i, e, n, h, r, o) {
            const a = this._$_propertyTrack$_._$GetTimeline$_(), u = this._$_propertyTrack$_._$GetTrack$_(), l = this._$_propertyTrack$_._$GetInstance$_(), c = this._$_propertyTrack$_._$GetSourceAdapter$_(), f = this._$_propertyTrack$_._$GetSourceAdapterId$_(), d = this._$_property$_, p = a._$GetSimilarPropertyTracks$_(l, c, d, this._$_propertyTrack$_);
            if (p && p.length > 1) {
                const t = this._$_GetPropertyKeyframeStubs$_(p, !0), i = this._$_GetLastPropertyKeyframeStub$_(a, a._$GetTime$_(), t);
                if (i) {
                    const t = u._$GetStartOffset$_(), e = i.time - t;
                    if (0 === e) this._$_GetTmpColor$_(l, f, this._$_property$_)._$addRgb$_(s[0], s[1], s[2]); else {
                        if (e < 0) return;
                        const t = s[0], i = s[1], n = s[2], h = this._$_propertyTrack$_._$Interpolate$_(e, !1, !0), r = Gm._$Color$_._$DiffChannel$_(t, h[0]), o = Gm._$Color$_._$DiffChannel$_(i, h[1]), a = Gm._$Color$_._$DiffChannel$_(n, h[2]);
                        this._$_GetTmpColor$_(l, f, this._$_property$_)._$addRgb$_(r, o, a);
                    }
                }
            } else this._$_Setter$_(s[0], s[1], s[2]);
        }
        _$AfterChangeProperty$_() {
            const t = this._$_propertyTrack$_._$GetInstance$_();
            if (!Cm.has(t)) return;
            const s = Cm.get(t), i = this._$_propertyTrack$_._$GetSourceAdapterId$_();
            if (!s.has(i)) return;
            const e = s.get(i);
            if (!e.has(this._$_property$_)) return;
            const n = e.get(this._$_property$_), h = n._$used$_, r = n.color;
            h && this._$_Setter$_(r._$getR$_(), r._$getG$_(), r._$getB$_()), 0 === e.size && s.delete(i), 
            0 === s.size && Cm.delete(t);
        }
        _$_Getter$_() {
            const t = this._$_propertyTrack$_._$GetSourceAdapterId$_(), s = this._$_GetTarget$_(), i = this._$_GetIndex$_();
            switch (t) {
              case "behavior":
              case "plugin":
                return this._$_GetColorFromArray$_(s._$GetPropertyValueByIndex$_(i));

              case "effect":
                return s[i].clone();

              case "world-instance":
                return this._$GetWorldInfo$_()._$GetUnpremultipliedColor$_().clone();
            }
        }
        _$_Setter$_(t, s, i) {
            const e = this._$_propertyTrack$_._$GetSourceAdapterId$_(), n = this._$_GetTarget$_(), h = this._$_GetIndex$_();
            switch (e) {
              case "behavior":
              case "plugin":
                _m[0] = t, _m[1] = s, _m[2] = i, n._$SetPropertyValueByIndex$_(h, _m);
                break;

              case "effect":
                n[h]._$setRgb$_(t, s, i);
                break;

              case "world-instance":
                this._$GetWorldInfo$_()._$SetUnpremultipliedColorRGB$_(t, s, i);
            }
        }
        _$_SaveToJson$_() {}
        _$_LoadFromJson$_(t) {}
    }
    Gm._$PropertyTrackState$_._$PropertyInterpolationAdapter$_._$ColorInterpolationAdapter$_ = Em;
}

{
    const Dm = self._$C3$_, Am = Dm._$PropertyTrackState$_;
    class Nm extends Dm._$PropertyTrackState$_._$PropertyInterpolationAdapter$_ {
        constructor(t) {
            super(t);
        }
        _$SetResetState$_() {}
        _$SetInitialState$_() {}
        _$SetResumeState$_() {}
        _$GetCurrentState$_() {
            return this._$_Getter$_();
        }
        _$CompareInitialStateWithCurrent$_() {
            return this._$_FirstKeyframeGetter$_() !== this._$GetCurrentState$_();
        }
        _$CompareSaveStateWithCurrent$_() {
            return !Dm._$IsNullOrUndefined$_(this._$_saveState$_) && this._$_saveState$_ !== this._$GetCurrentState$_();
        }
        _$MayNeedBeforeAndAfterInterpolate$_() {
            return !1;
        }
        _$ChangeProperty$_(t, s, i, e, n, h, r, o) {
            const a = this._$_propertyTrack$_, u = a._$GetTrack$_(), l = a._$GetSourceAdapterId$_(), c = a._$GetTimeline$_(), f = u._$GetInstance$_(), d = a._$GetSourceAdapter$_(), p = this._$_property$_, m = c._$GetSimilarPropertyTracks$_(f, d, p, a);
            if (m && m.length > 1) {
                const i = this._$_GetPropertyKeyframeStubs$_(m), e = t + u._$GetStartOffset$_(), n = this._$_GetLastPropertyKeyframeStub$_(c, e, i);
                n && (s = n.value);
            }
            switch (a._$GetPropertyKeyframeType$_()) {
              case "numeric":
                if (!Am._$NumericTypeAdapter$_._$WillChange$_(this._$_GetIndex$_(), this._$_GetTarget$_(), s, l)) return;
                break;

              case "angle":
                if (!Am._$AngleTypeAdapter$_._$WillChange$_(this._$_GetIndex$_(), this._$_GetTarget$_(), s, l)) return;
                break;

              case "boolean":
                if (!Am._$BooleanTypeAdapter$_._$WillChange$_(this._$_GetIndex$_(), this._$_GetTarget$_(), s, l)) return;
                break;

              case "color":
                if (!Am._$ColorTypeAdapter$_._$WillChange$_(this._$_GetIndex$_(), this._$_GetTarget$_(), s, l)) return;
                break;

              case "text":
                if (!Am._$TextTypeAdapter$_._$WillChange$_(this._$_GetIndex$_(), this._$_GetTarget$_(), s, l)) return;
            }
            this._$_Setter$_(s);
        }
        _$_Getter$_() {
            const t = this._$_propertyTrack$_._$GetSourceAdapterId$_(), s = this._$_GetTarget$_(), i = this._$_GetIndex$_();
            switch (t) {
              case "behavior":
              case "plugin":
                return s._$GetPropertyValueByIndex$_(i);

              case "effect":
                return s[i];

              case "instance-variable":
                return s._$GetInstanceVariableValue$_(i);
            }
        }
        _$_Setter$_(t) {
            const s = this._$_propertyTrack$_._$GetSourceAdapterId$_(), i = this._$_GetTarget$_(), e = this._$_GetIndex$_();
            switch (s) {
              case "behavior":
              case "plugin":
                i._$SetPropertyValueByIndex$_(e, t);
                break;

              case "effect":
                i[e] = t;
                break;

              case "instance-variable":
                i._$SetInstanceVariableValue$_(e, t);
            }
        }
    }
    Dm._$PropertyTrackState$_._$PropertyInterpolationAdapter$_._$NoInterpolationAdapter$_ = Nm;
}

{
    const Lm = self._$C3$_, Om = (Lm._$PropertyTrackState$_._$PropertyInterpolationAdapter$_, 
    new Map), Rm = (t, s, i, e, n, h = !1, r = null, o = null) => {
        Om.set(t, {
            _$setter$_: s,
            _$absolute_setter$_: i,
            _$getter$_: e,
            round: n,
            _$fRound$_: h,
            init: r,
            reset: o
        });
    };
    Rm("offsetX", ((t, s, i, e) => {
        "relative" === e._$_propertyTrack$_._$GetResultMode$_() ? t._$OffsetX$_(s, i._$GetTimeline$_()._$GetTransformWithSceneGraph$_()) : t._$OffsetX$_(s);
    }), ((t, s) => t._$SetX$_(s)), (t => t._$GetX$_()), !0), Rm("offsetY", ((t, s, i, e) => {
        "relative" === e._$_propertyTrack$_._$GetResultMode$_() ? t._$OffsetY$_(s, i._$GetTimeline$_()._$GetTransformWithSceneGraph$_()) : t._$OffsetY$_(s);
    }), ((t, s) => t._$SetY$_(s)), (t => t._$GetY$_()), !0), Rm("offsetWidth", ((t, s, i, e, n) => {
        if (0 === s) return;
        const h = "relative" === e._$_propertyTrack$_._$GetResultMode$_(), r = 1 === e._$_typeAdapter$_._$GetType$_();
        if ((h || r) && t._$HasParent$_() && t._$GetTransformWithParentWidth$_()) {
            if (isNaN(e._$_absoluteToFactor$_)) {
                const s = [];
                let n = t._$GetParent$_();
                for (;n; ) s.push(n), n = n._$GetParent$_();
                s.reverse();
                const h = (t, s) => s._$GetTimeline$_()._$GetTrackFromInstance$_(t._$GetInstance$_()), o = (t, s) => {
                    const i = h(t, s);
                    if (i) return i._$GetOriginalWidth$_();
                    const e = t._$GetInstance$_()._$GetSdkInstance$_();
                    return e._$IsOriginalSizeKnown$_() ? e._$GetOriginalWidth$_() : t._$_GetSceneGraphInfo$_()._$_GetStartWidth$_();
                }, a = (t, s, i, e = 0) => {
                    const n = h(t, s);
                    if (!n) return e;
                    const r = n._$GetPropertyTrack$_(i);
                    if (!r) return e;
                    const o = r._$GetPropertyTrackDataItem$_()._$GetPropertyKeyframeData$_();
                    if (!o) return e;
                    const a = o._$GetLastPropertyKeyframeDataItem$_();
                    return a ? a._$GetValue$_() : e;
                };
                let u;
                if (r) u = s[s.length - 1]._$GetWidth$_(); else {
                    let t = s[0];
                    u = t._$_GetSceneGraphInfo$_()._$_GetStartWidth$_() * t._$_GetSceneGraphInfo$_()._$GetStartScaleX$_(), 
                    u += a(t, i, "offsetWidth"), u += o(t, i) * a(t, i, "offsetScaleX");
                    for (let e = 1; e < s.length; e++) t = s[e], u *= t._$_GetSceneGraphInfo$_()._$GetStartScaleX$_(), 
                    u += a(t, i, "offsetWidth"), u += o(t, i) * a(t, i, "offsetScaleX");
                }
                e._$_absoluteToFactor$_ = 0 === u ? Number.EPSILON : u;
            }
            if (n) return;
            t._$OffsetWidth$_(s / e._$_absoluteToFactor$_, !0);
        } else t._$OffsetWidth$_(s);
    }), ((t, s) => t._$SetWidth$_(s)), (t => t._$GetWidth$_()), !0), Rm("offsetHeight", ((t, s, i, e, n) => {
        if (0 === s) return;
        const h = "relative" === e._$_propertyTrack$_._$GetResultMode$_(), r = 1 === e._$_typeAdapter$_._$GetType$_();
        if ((h || r) && t._$HasParent$_() && t._$GetTransformWithParentHeight$_()) {
            if (isNaN(e._$_absoluteToFactor$_)) {
                const s = [];
                let n = t._$GetParent$_();
                for (;n; ) s.push(n), n = n._$GetParent$_();
                s.reverse();
                const h = (t, s) => s._$GetTimeline$_()._$GetTrackFromInstance$_(t._$GetInstance$_()), o = (t, s) => {
                    const i = h(t, s);
                    if (i) return i._$GetOriginalHeight$_();
                    const e = t._$GetInstance$_()._$GetSdkInstance$_();
                    return e._$IsOriginalSizeKnown$_() ? e._$GetOriginalHeight$_() : t._$_GetSceneGraphInfo$_()._$_GetStartHeight$_();
                }, a = (t, s, i, e = 0) => {
                    const n = s._$GetTimeline$_()._$GetTrackFromInstance$_(t._$GetInstance$_());
                    if (!n) return e;
                    const h = n._$GetPropertyTrack$_(i);
                    if (!h) return e;
                    const r = h._$GetPropertyTrackDataItem$_()._$GetPropertyKeyframeData$_();
                    if (!r) return e;
                    const o = r._$GetLastPropertyKeyframeDataItem$_();
                    return o ? o._$GetValue$_() : e;
                };
                let u;
                if (r) u = s[s.length - 1]._$GetHeight$_(); else {
                    let t = s[0];
                    u = t._$_GetSceneGraphInfo$_()._$_GetStartHeight$_() * t._$_GetSceneGraphInfo$_()._$GetStartScaleY$_(), 
                    u += a(t, i, "offsetHeight"), u += o(t, i) * a(t, i, "offsetScaleY");
                    for (let e = 1; e < s.length; e++) t = s[e], u *= t._$_GetSceneGraphInfo$_()._$GetStartScaleY$_(), 
                    u += a(t, i), u += o(t, i) * a(t, i, "offsetScaleY");
                }
                e._$_absoluteToFactor$_ = 0 === u ? Number.EPSILON : u;
            }
            if (n) return;
            t._$OffsetHeight$_(s / e._$_absoluteToFactor$_, !0);
        } else t._$OffsetHeight$_(s);
    }), ((t, s) => t._$SetHeight$_(s)), (t => t._$GetHeight$_()), !0), Rm("offsetAngle", ((t, s, i, e, n) => {
        t._$OffsetAngle$_(s);
    }), ((t, s) => t._$SetAngle$_(s)), (t => t._$GetAngle$_()), !1, !0), Rm("offsetOpacity", ((t, s, i, e, n) => {
        s /= e._$_opacityFactor$_ ? e._$_opacityFactor$_ : 1;
        const h = t._$GetOpacity$_() + s;
        if (0 === e._$_clampAccumulator$_) h > 1 ? e._$_clampAccumulator$_ += h - 1 : h < 0 && (e._$_clampAccumulator$_ += h), 
        t._$OffsetOpacity$_(s); else {
            const i = t._$GetOpacity$_() + s;
            s > 0 && e._$_clampAccumulator$_ > 0 ? i > 1 && (e._$_clampAccumulator$_ += i - 1) : s > 0 && e._$_clampAccumulator$_ < 0 ? (e._$_clampAccumulator$_ += s, 
            e._$_clampAccumulator$_ > 0 && (t._$OffsetOpacity$_(e._$_clampAccumulator$_), e._$_clampAccumulator$_ = 0)) : s < 0 && e._$_clampAccumulator$_ > 0 ? (e._$_clampAccumulator$_ += s, 
            e._$_clampAccumulator$_ < 0 && (t._$OffsetOpacity$_(e._$_clampAccumulator$_), e._$_clampAccumulator$_ = 0)) : s < 0 && e._$_clampAccumulator$_ < 0 && i < 0 && (e._$_clampAccumulator$_ += i);
        }
    }), ((t, s) => {
        t._$SetOpacity$_(s);
    }), (t => t._$GetOpacity$_()), !1, !0, ((t, s, i) => {
        switch (t._$_clampAccumulator$_ = 0, t._$_propertyTrack$_._$GetResultMode$_()) {
          case "relative":
            {
                t._$_propertyTrack$_._$GetPropertyTrackData$_();
                const s = t._$_propertyTrack$_._$GetPropertyTrackDataItem$_()._$GetPropertyKeyframeData$_()._$GetPropertyKeyframeDataItemArray$_();
                let i = t._$GetWorldInfo$_()._$GetOpacity$_(), e = i;
                for (const n of s) {
                    const s = n._$GetTime$_();
                    e = i + t._$_propertyTrack$_._$GetInterpolatedValue$_(s), e = Lm._$clamp$_(e, 0, 1);
                }
                t._$_totalForewardOpacityDelta$_ = i - e, t._$_totalForewardOpacityDelta$_ = Math.round(100 * (t._$_totalForewardOpacityDelta$_ + Number.EPSILON)) / 100, 
                e = i;
                for (let i = s.length - 1; i >= 0; i--) {
                    const n = s[i]._$GetTime$_();
                    e -= t._$_propertyTrack$_._$GetInterpolatedValue$_(n), e = Lm._$clamp$_(e, 0, 1);
                }
                t._$_totalBackwardOpacityDelta$_ = e, t._$_totalBackwardOpacityDelta$_ = Math.round(100 * (t._$_totalBackwardOpacityDelta$_ + Number.EPSILON)) / 100;
                break;
            }
        }
        const e = "relative" === t._$_propertyTrack$_._$GetResultMode$_(), n = 1 === t._$_typeAdapter$_._$GetType$_();
        if ((e || n) && s._$HasParent$_() && s._$GetTransformWithParentOpacity$_()) {
            const e = [];
            let n = s._$GetParent$_();
            for (;n; ) e.push(n), n = n._$GetParent$_();
            e.reverse();
            const h = (t, s, i) => {
                const e = s._$GetTimeline$_()._$GetTrackFromInstance$_(t._$GetInstance$_());
                if (!e) return 0;
                const n = e._$GetPropertyTrack$_(i);
                if (!n) return 0;
                const h = n._$GetPropertyTrackDataItem$_()._$GetPropertyKeyframeData$_();
                if (!h) return 0;
                const r = h._$GetLastPropertyKeyframeDataItem$_();
                return r ? r._$GetValue$_() : 0;
            };
            let r = e[0]._$_GetSceneGraphInfo$_()._$GetStartOpacity$_();
            r += h(e[0], i, "offsetOpacity");
            for (let t = 1; t < e.length; t++) r += h(e[t], i, "offsetOpacity");
            t._$_opacityFactor$_ = 0 === r ? 1 : r;
        }
    }), (t => {
        switch (t._$_propertyTrack$_._$GetResultMode$_()) {
          case "relative":
            {
                t._$_clampAccumulator$_ = 0;
                const s = t._$GetWorldInfo$_();
                let i = s._$GetOpacity$_();
                i = Math.round(100 * (i + Number.EPSILON)) / 100, t._$_propertyTrack$_._$GetTimeline$_()._$IsForwardPlayBack$_() ? (s._$SetOpacity$_(i + t._$_totalForewardOpacityDelta$_), 
                t._$_lastValue$_ = 0) : (s._$SetOpacity$_(i - t._$_totalBackwardOpacityDelta$_), 
                t._$_lastValue$_ = t._$GetSourceAdapter$_()._$GetValueAtTime$_());
                break;
            }
        }
    })), Rm("offsetOriginX", ((t, s) => t._$OffsetOriginX$_(s)), ((t, s) => t._$SetOriginX$_(s)), (t => t._$GetOriginX$_()), !1), 
    Rm("offsetOriginY", ((t, s) => t._$OffsetOriginY$_(s)), ((t, s) => t._$SetOriginY$_(s)), (t => t._$GetOriginY$_()), !1), 
    Rm("offsetZElevation", ((t, s) => t._$OffsetZElevation$_(s)), ((t, s) => t._$SetZElevation$_(s)), (t => t._$GetZElevation$_()), !0), 
    Rm("offsetScaleX", ((t, s, i, e) => {
        if (0 === s) return;
        const n = t._$GetWidth$_() < 0 ? -1 : 1;
        if ("relative" === e._$_propertyTrack$_._$GetResultMode$_() && t._$HasParent$_() && t._$GetTransformWithParentWidth$_()) {
            const h = i._$GetOriginalWidth$_() * n * s;
            isNaN(e._$_absoluteToFactor$_) && Om.get("offsetWidth")._$setter$_(t, 1, i, e, !0), 
            t._$OffsetWidth$_(h / e._$_absoluteToFactor$_, !0);
        } else t._$OffsetWidth$_(i._$GetOriginalWidth$_() * n * s);
    }), ((t, s, i) => {
        t._$SetWidth$_(i._$GetOriginalWidth$_() * s);
    }), ((t, s) => {
        const i = t._$GetWidth$_() < 0 ? -1 : 1;
        if (t._$GetTransformWithParentWidth$_()) {
            const e = t._$GetParent$_(), n = s._$GetTimeline$_()._$GetTrackFromInstance$_(e._$GetInstance$_());
            let h = NaN;
            if (n) h = e._$GetWidth$_() / n._$GetOriginalWidth$_(); else {
                const t = e._$GetInstance$_()._$GetSdkInstance$_();
                h = t._$IsOriginalSizeKnown$_() ? e._$GetWidth$_() / t._$GetOriginalWidth$_() : 1;
            }
            return t._$GetWidth$_() * i / (s._$GetOriginalWidth$_() * h);
        }
        return t._$GetWidth$_() * i / s._$GetOriginalWidth$_();
    }), !1), Rm("offsetScaleY", ((t, s, i, e) => {
        if (0 === s) return;
        const n = t._$GetHeight$_() < 0 ? -1 : 1;
        if ("relative" === e._$_propertyTrack$_._$GetResultMode$_() && t._$HasParent$_() && t._$GetTransformWithParentHeight$_()) {
            const h = i._$GetOriginalHeight$_() * n * s;
            isNaN(e._$_absoluteToFactor$_) && Om.get("offsetHeight")._$setter$_(t, 1, i, e, !0), 
            t._$OffsetHeight$_(h / e._$_absoluteToFactor$_, !0);
        } else t._$OffsetHeight$_(i._$GetOriginalHeight$_() * n * s);
    }), ((t, s, i) => {
        t._$SetHeight$_(i._$GetOriginalHeight$_() * s);
    }), ((t, s) => {
        const i = t._$GetHeight$_() < 0 ? -1 : 1;
        if (t._$GetTransformWithParentHeight$_()) {
            const e = t._$GetParent$_(), n = s._$GetTimeline$_()._$GetTrackFromInstance$_(e._$GetInstance$_());
            let h = NaN;
            if (n) h = e._$GetHeight$_() / n._$GetOriginalHeight$_(); else {
                const t = e._$GetInstance$_()._$GetSdkInstance$_();
                h = t._$IsOriginalSizeKnown$_() ? e._$GetHeight$_() / t._$GetOriginalHeight$_() : 1;
            }
            return t._$GetHeight$_() * i / (s._$GetOriginalHeight$_() * h);
        }
        return t._$GetHeight$_() * i / s._$GetOriginalHeight$_();
    }), !1);
    class Pm extends Lm._$PropertyTrackState$_._$PropertyInterpolationAdapter$_ {
        constructor(t) {
            super(t), this._$_lastValue$_ = 0, this._$_clampAccumulator$_ = 0, this._$_totalForewardOpacityDelta$_ = 0, 
            this._$_totalBackwardOpacityDelta$_ = 0, this._$_opacityFactor$_ = NaN, this._$_absoluteToFactor$_ = NaN, 
            this._$_angleReflectMirrorOrFlip$_ = void 0, this._$_angleReflectMirrorAndFlip$_ = void 0, 
            this._$_instance_getter$_ = null, this._$_instance_setter$_ = null, this._$_instance_absolute_setter$_ = null, 
            this._$_reset_action$_ = null, this._$_init_action$_ = null, this._$_source_adapter_getter$_ = null, 
            this._$_source_adapter_setter$_ = null, this._$_source_adapter_absolute_setter$_ = null, 
            this._$_round$_ = !1, this._$_fRound$_ = !1, Lm._$IsInstanceOf$_(this._$_propertyTrack$_._$GetTimeline$_(), Lm._$TweenState$_) ? this._$_typeAdapter$_ = new Lm._$PropertyTrackState$_._$PropertyInterpolationAdapter$_._$NumericInterpolationAdapterForTween$_(this) : this._$_typeAdapter$_ = new Lm._$PropertyTrackState$_._$PropertyInterpolationAdapter$_._$NumericInterpolationAdapterForTimeline$_(this);
            const s = this._$_propertyTrack$_._$GetPropertyName$_();
            switch (this._$_propertyTrack$_._$GetSourceAdapterId$_()) {
              case "world-instance":
                {
                    const t = Om.get(s);
                    this._$_instance_getter$_ = t._$getter$_, this._$_instance_setter$_ = t._$setter$_, 
                    this._$_instance_absolute_setter$_ = t._$absolute_setter$_, this._$_round$_ = t.round, 
                    this._$_fRound$_ = t._$fRound$_, this._$_init_action$_ = t.init, this._$_reset_action$_ = t.reset;
                    break;
                }

              case "audio":
                this._$_source_adapter_getter$_ = t._$Getter$_, this._$_source_adapter_setter$_ = t._$Setter$_, 
                this._$_source_adapter_absolute_setter$_ = t._$AbsoluteSetter$_, this._$_round$_ = !!t._$DoesRounding$_(), 
                this._$_fRound$_ = !1;
            }
        }
        _$Release$_() {
            this._$_typeAdapter$_ = null, this._$_instance_getter$_ = null, this._$_instance_setter$_ = null, 
            this._$_instance_absolute_setter$_ = null, this._$_reset_action$_ = null, this._$_init_action$_ = null, 
            this._$_source_adapter_getter$_ = null, this._$_source_adapter_setter$_ = null, 
            this._$_source_adapter_absolute_setter$_ = null, super._$Release$_();
        }
        _$MayNeedBeforeAndAfterInterpolate$_() {
            return this._$_typeAdapter$_._$MayNeedBeforeAndAfterInterpolate$_();
        }
        _$GetLastValue$_() {
            return this._$_lastValue$_;
        }
        _$SetLastValue$_(t) {
            this._$_lastValue$_ = t;
        }
        _$SetResetState$_() {
            this._$_reset_action$_ && this._$_reset_action$_(this);
        }
        _$SetInitialState$_() {
            const t = this._$_typeAdapter$_._$SetInitialState$_();
            if ("number" == typeof t && (this._$_lastValue$_ = t), this._$_init_action$_) {
                const t = this._$GetWorldInfo$_(), s = this._$_propertyTrack$_._$GetTrack$_();
                this._$_init_action$_(this, t, s);
            }
        }
        _$SetResumeState$_() {
            const t = this._$_typeAdapter$_._$SetResumeState$_();
            "number" == typeof t && (this._$_lastValue$_ = t);
        }
        _$GetCurrentState$_() {
            return this._$_Getter$_();
        }
        _$CompareInitialStateWithCurrent$_() {
            return this._$_FirstKeyframeGetter$_() !== this._$GetCurrentState$_();
        }
        _$CompareSaveStateWithCurrent$_() {
            return !Lm._$IsNullOrUndefined$_(this._$_saveState$_) && this._$_saveState$_ !== this._$GetCurrentState$_();
        }
        _$BeforeChangeProperty$_() {
            this._$_typeAdapter$_._$BeforeChangeProperty$_();
        }
        _$ChangeProperty$_(t, s, i, e, n, h, r, o) {
            return this._$_typeAdapter$_._$ChangeProperty$_(t, s, i, e, n, h, r, o);
        }
        _$AfterChangeProperty$_() {
            this._$_typeAdapter$_._$AfterChangeProperty$_();
        }
        _$_Getter$_() {
            const t = this._$_GetTarget$_(), s = this._$_GetIndex$_(), i = this._$GetWorldInfo$_(), e = this._$_propertyTrack$_._$GetTrack$_();
            switch (this._$_propertyTrack$_._$GetSourceAdapterId$_()) {
              case "behavior":
              case "plugin":
                return t._$GetPropertyValueByIndex$_(s);

              case "effect":
                return t[s];

              case "instance-variable":
                return t._$GetInstanceVariableValue$_(s);

              case "world-instance":
                return this._$_instance_getter$_(i, e);

              case "audio":
                return this._$_source_adapter_getter$_.call(this._$GetSourceAdapter$_(), i, e);
            }
        }
        _$_Setter$_(t, s, i) {
            const e = this._$_GetTarget$_(), n = this._$_GetIndex$_(), h = this._$GetWorldInfo$_(), r = this._$_propertyTrack$_._$GetTrack$_();
            switch (this._$_propertyTrack$_._$GetSourceAdapterId$_()) {
              case "behavior":
                e._$OffsetPropertyValueByIndex$_(n, t);
                break;

              case "effect":
                e[n] += t;
                break;

              case "instance-variable":
                e._$SetInstanceVariableOffset$_(n, t);
                break;

              case "plugin":
                e._$OffsetPropertyValueByIndex$_(n, t, this._$GetSourceAdapter$_()._$GetOptionalCallbacks$_());
                break;

              case "world-instance":
                this._$_instance_setter$_(h, t, r, this);
                break;

              case "audio":
                this._$_source_adapter_setter$_.call(this._$GetSourceAdapter$_(), h, t, r, this);
            }
        }
        _$_SetterAbsolute$_(t, s, i) {
            let e = this._$_propertyTrack$_._$GetInterpolationMode$_();
            if (e = "default" === e ? "continuous" : e, "discrete" === e && !s) return;
            if ("discrete" === e && i) {
                const t = this._$_propertyTrack$_._$GetTimeline$_()._$GetTime$_();
                if (!this._$_propertyTrack$_._$GetPropertyKeyFrameDataItemAtTime$_(t)) return;
            }
            const n = this._$_GetTarget$_(), h = this._$_GetIndex$_(), r = this._$GetWorldInfo$_(), o = this._$_propertyTrack$_._$GetTrack$_();
            switch (this._$_propertyTrack$_._$GetSourceAdapterId$_()) {
              case "behavior":
                n._$SetPropertyValueByIndex$_(h, t);
                break;

              case "effect":
                n[h] = t;
                break;

              case "instance-variable":
                n._$SetInstanceVariableValue$_(h, t);
                break;

              case "plugin":
                n._$SetPropertyValueByIndex$_(h, t, this._$GetSourceAdapter$_()._$GetOptionalCallbacks$_());
                break;

              case "world-instance":
                this._$_instance_absolute_setter$_(r, t, o);
                break;

              case "audio":
                this._$_source_adapter_absolute_setter$_.call(this._$GetSourceAdapter$_(), r, t, o);
            }
        }
        _$_MaybeEnsureValue$_(t, s, i, e, n, h, r, o) {
            this._$_typeAdapter$_._$_MaybeEnsureValue$_(t, s, i, e, n, h, r, o);
        }
        _$_AddDelta$_(t, s, i, e, n) {
            "angle" === this._$_propertyTrack$_._$GetPropertyType$_() && (t = Lm._$toDegrees$_(t));
            const h = (t.toString().split(".")[1] || "").length, r = this._$_Getter$_();
            let o;
            switch (o = 0 === h ? this._$_round$_ ? Math.round(r) : this._$_fRound$_ ? "angle" === this._$_propertyTrack$_._$GetPropertyType$_() ? Lm._$toRadians$_(Math.round(Lm._$toDegrees$_(r))) : Number(Lm.toFixed(r, 2)) : r : this._$_round$_ ? Number(Lm.toFixed(r, h)) : (this._$_fRound$_, 
            r), this._$_Setter$_(o - r, s, i), this._$_propertyTrack$_._$GetPropertyName$_()) {
              case "offsetWidth":
              case "offsetScaleX":
                {
                    const t = this._$GetWorldInfo$_(), s = t._$GetWidth$_(), i = Number(Lm.toFixed(s, 2));
                    t._$OffsetWidth$_(i - s);
                    break;
                }

              case "offsetHeight":
              case "offsetScaleY":
                {
                    const t = this._$GetWorldInfo$_(), s = t._$GetHeight$_(), i = Number(Lm.toFixed(s, 2));
                    t._$OffsetHeight$_(i - s);
                    break;
                }
            }
        }
        _$_SaveToJson$_() {
            return Object.assign(super._$_SaveToJson$_(), {
                v: this._$_lastValue$_,
                a: this._$_clampAccumulator$_,
                fod: this._$_totalForewardOpacityDelta$_,
                bod: this._$_totalBackwardOpacityDelta$_,
                of: this._$_opacityFactor$_,
                sf: this._$_absoluteToFactor$_,
                armorf: this._$_angleReflectMirrorOrFlip$_,
                armandf: this._$_angleReflectMirrorAndFlip$_
            });
        }
        _$_LoadFromJson$_(t) {
            t && (super._$_LoadFromJson$_(t), this._$_lastValue$_ = t.v, this._$_clampAccumulator$_ = t.a, 
            this._$_totalForewardOpacityDelta$_ = Lm._$IsFiniteNumber$_(t.fod) ? t.fod : 0, 
            this._$_totalBackwardOpacityDelta$_ = Lm._$IsFiniteNumber$_(t.bod) ? t.bod : 0, 
            this._$_opacityFactor$_ = Lm._$IsFiniteNumber$_(t.of) ? t.of : NaN, this._$_absoluteToFactor$_ = Lm._$IsFiniteNumber$_(t.sf) ? t.sf : NaN, 
            this._$_angleReflectMirrorOrFlip$_ = Lm._$IsFiniteNumber$_(t.armorf) ? t.armorf : void 0, 
            this._$_angleReflectMirrorAndFlip$_ = Lm._$IsFiniteNumber$_(t.armandf) ? t.armandf : void 0);
        }
    }
    Lm._$PropertyTrackState$_._$PropertyInterpolationAdapter$_._$NumericInterpolationAdapter$_ = Pm;
}

{
    const km = self._$C3$_;
    class Fm {
        constructor(t) {
            this._$_used$_ = !1, this._$_value$_ = 0, this._$_propertyKeyframeReached$_ = !1, 
            this._$_endState$_ = !1, this._$_propertyTracks$_ = t;
            for (let t = 0, s = this._$_propertyTracks$_.length; t < s; t++) this._$_propertyTracks$_[t]._$SetAbsoluteValueObject$_(this);
        }
        _$GetPropertyTracks$_() {
            return this._$_propertyTracks$_;
        }
        _$SetUsed$_() {
            this._$_used$_ = !0;
        }
        _$GetUsed$_() {
            return this._$_used$_;
        }
        _$SetValue$_(t) {
            this._$_value$_ = t;
        }
        _$GetValue$_() {
            return this._$_value$_;
        }
        _$SetPropertyKeyframeReached$_(t) {
            this._$_propertyKeyframeReached$_ = t;
        }
        _$GetPropertyKeyframeReached$_() {
            return this._$_propertyKeyframeReached$_;
        }
        _$SetEndState$_(t) {
            this._$_endState$_ = t;
        }
        _$GetEndState$_() {
            return this._$_endState$_;
        }
        _$Reset$_() {
            this._$_used$_ = !1, this._$_value$_ = 0, this._$_propertyKeyframeReached$_ = !1, 
            this._$_endState$_ = !1;
        }
    }
    class jm {
        constructor(t) {
            this._$_numericInterpolationAdapter$_ = t;
        }
        _$Release$_() {
            this._$_numericInterpolationAdapter$_ = null;
        }
        _$GetType$_() {
            return 0;
        }
        _$SetInitialState$_() {
            const t = this._$_numericInterpolationAdapter$_;
            return this._$_numericInterpolationAdapter$_._$GetPropertyTrack$_(), t._$_PickResultMode$_((() => t._$_PickTimelinePlaybackMode$_((() => 0), (() => t._$GetSourceAdapter$_()._$GetValueAtTime$_()))), (() => {}));
        }
        _$SetResumeState$_() {}
        _$MayNeedBeforeAndAfterInterpolate$_() {
            switch (this._$_numericInterpolationAdapter$_, this._$_numericInterpolationAdapter$_._$GetPropertyTrack$_()._$GetResultMode$_()) {
              case "relative":
                return !1;

              case "absolute":
                return !0;
            }
        }
        _$BeforeChangeProperty$_() {
            this._$_numericInterpolationAdapter$_;
            const t = this._$_numericInterpolationAdapter$_._$GetPropertyTrack$_(), s = t._$GetPropertyName$_();
            switch (t._$GetResultMode$_()) {
              case "relative":
                break;

              case "absolute":
                if (t._$HasAbsoluteValueObject$_()) t._$GetAbsoluteValueObject$_()._$Reset$_(); else {
                    const i = t._$GetTimeline$_(), e = t._$GetInstance$_(), n = t._$GetSourceAdapter$_(), h = i._$GetSimilarPropertyTracks$_(e, n, s, t);
                    h && h.length > 1 && new Fm(h);
                }
            }
        }
        _$ChangeProperty$_(t, s, i, e, n, h, r, o) {
            const a = this._$_numericInterpolationAdapter$_, u = this._$_numericInterpolationAdapter$_._$GetPropertyTrack$_();
            switch (u._$GetResultMode$_()) {
              case "relative":
                {
                    const r = a._$GetLastValue$_();
                    a._$_Setter$_(s - r, i, e), h && this._$_MaybeEnsureValue$_(t, i, e, n, r, s), a._$SetLastValue$_(s);
                    break;
                }

              case "absolute":
                {
                    const t = u._$GetTimeline$_(), i = u._$GetTrack$_();
                    if (u._$GetInstance$_(), u._$GetSourceAdapter$_(), u._$HasAbsoluteValueObject$_()) {
                        const e = u._$GetAbsoluteValueObject$_(), n = e._$GetPropertyTracks$_(), h = a._$_GetPropertyKeyframeStubs$_(n, !0), l = a._$_GetLastPropertyKeyframeStub$_(t, t._$GetTime$_(), h);
                        if (l) {
                            const t = i._$GetStartOffset$_(), n = l.time - t;
                            if (0 === n) e._$SetEndState$_(r), e._$SetPropertyKeyframeReached$_(o), e._$SetUsed$_(), 
                            e._$SetValue$_(e._$GetValue$_() + s); else {
                                if (n < 0) return;
                                const t = u._$GetInterpolatedValue$_(n);
                                e._$SetEndState$_(r), e._$SetPropertyKeyframeReached$_(o), e._$SetUsed$_(), e._$SetValue$_(e._$GetValue$_() + (s - t));
                            }
                        }
                    } else a._$_SetterAbsolute$_(s, o, r);
                    break;
                }
            }
        }
        _$AfterChangeProperty$_() {
            const t = this._$_numericInterpolationAdapter$_, s = this._$_numericInterpolationAdapter$_._$GetPropertyTrack$_();
            switch (s._$GetResultMode$_()) {
              case "relative":
                break;

              case "absolute":
                if (s._$HasAbsoluteValueObject$_()) {
                    const i = s._$GetAbsoluteValueObject$_();
                    i._$GetUsed$_() && t._$_SetterAbsolute$_(i._$GetValue$_(), i._$GetPropertyKeyframeReached$_(), i._$GetEndState$_());
                }
            }
        }
        _$_MaybeEnsureValue$_(t, s, i, e, n, h) {
            const r = this._$_numericInterpolationAdapter$_;
            e || (s && t === s._$GetTime$_() ? r._$_AddDelta$_(s._$GetValueWithResultMode$_(), s, i) : i && t === i._$GetTime$_() ? r._$_AddDelta$_(i._$GetValueWithResultMode$_(), s, i) : h - n == 0 && r._$_AddDelta$_(s._$GetValueWithResultMode$_(), s, i));
        }
    }
    km._$PropertyTrackState$_._$PropertyInterpolationAdapter$_._$NumericInterpolationAdapterForTimeline$_ = jm;
}

{
    const Bm = self._$C3$_;
    class zm {
        constructor(t) {
            this._$_numericInterpolationAdapter$_ = t;
        }
        _$Release$_() {
            this._$_numericInterpolationAdapter$_ = null;
        }
        _$GetType$_() {
            return 1;
        }
        _$SetInitialState$_() {
            const t = this._$_numericInterpolationAdapter$_;
            return t._$SetFirstAbsoluteUpdate$_(!0), this._$_GetAbsoluteInitialValue$_(t._$_FirstKeyframeGetter$_());
        }
        _$SetResumeState$_() {
            const t = this._$_numericInterpolationAdapter$_;
            if (t._$_FirstKeyframeGetter$_() !== t._$_CurrentKeyframeGetter$_()) return t._$SetFirstAbsoluteUpdate$_(!0), 
            this._$_GetAbsoluteInitialValue$_(t._$_CurrentKeyframeGetter$_());
        }
        _$MayNeedBeforeAndAfterInterpolate$_() {
            return !1;
        }
        _$BeforeChangeProperty$_() {}
        _$ChangeProperty$_(t, s, i, e, n, h, r, o) {
            const a = this._$_numericInterpolationAdapter$_, u = a._$GetLastValue$_();
            switch (a._$GetPropertyTrack$_()._$GetResultMode$_()) {
              case "relative":
                a._$_Setter$_(s - u, i, e), h && this._$_MaybeEnsureValue$_(t, i, e, n, u, s, !1, r);
                break;

              case "absolute":
                a._$GetFirstAbsoluteUpdate$_() ? (a._$SetFirstAbsoluteUpdate$_(!1), a._$_Setter$_(u, i, e)) : 0 === t && 0 === a._$GetPropertyTrack$_()._$GetTimeline$_()._$GetTotalTime$_() ? a._$_SetterAbsolute$_(s, !0, !1) : (a._$_Setter$_(s - u, i, e), 
                h && this._$_MaybeEnsureValue$_(t, i, e, n, u, s, this._$_ForceEndValue$_(), r));
            }
            a._$SetLastValue$_(s);
        }
        _$AfterChangeProperty$_() {}
        _$_GetAbsoluteInitialValue$_(t) {
            return t - this._$_numericInterpolationAdapter$_._$GetCurrentState$_();
        }
        _$_ForceEndValue$_() {
            const t = this._$_numericInterpolationAdapter$_, s = t._$GetWorldInfo$_()._$GetInstance$_(), i = t._$GetPropertyTrack$_()._$GetRuntime$_()._$GetTimelineManager$_();
            let e = 0;
            for (const t of i._$GetPlayingTimelines$_()) 0 === t._$GetType$_() ? t._$HasTrackInstance$_(s) && e++ : 1 === t._$GetType$_() && t._$GetInstance$_() === s && e++;
            return e <= 1;
        }
        _$_MaybeEnsureValue$_(t, s, i, e, n, h, r, o) {
            const a = this._$_numericInterpolationAdapter$_;
            e ? s && t === s._$GetTime$_() ? a._$_AddDelta$_(s._$GetValueWithResultMode$_(), s, i, r, o) : i && t === i._$GetTime$_() ? a._$_AddDelta$_(i._$GetValueWithResultMode$_(), s, i, r, o) : i || a._$_AddDelta$_(s._$GetValueWithResultMode$_(), s, i, r, o) : s && t === s._$GetTime$_() ? a._$_AddDelta$_(s._$GetValueWithResultMode$_(), s, i, r, o) : i && t === i._$GetTime$_() ? a._$_AddDelta$_(i._$GetValueWithResultMode$_(), s, i, r, o) : h - n == 0 && a._$_AddDelta$_(s._$GetValueWithResultMode$_(), s, i, r, o);
        }
    }
    Bm._$PropertyTrackState$_._$PropertyInterpolationAdapter$_._$NumericInterpolationAdapterForTween$_ = zm;
}

{
    const Um = self._$C3$_, Wm = self._$Ease$_;
    Um._$PropertyTrackState$_._$NumericTypeAdapter$_ = class {
        constructor() {}
        static _$WillChange$_(t, s, i, e) {
            let n;
            switch (e) {
              case "behavior":
              case "plugin":
                n = s._$GetPropertyValueByIndex$_(t);
                break;

              case "effect":
                n = s[t];
                break;

              case "instance-variable":
                n = s._$GetInstanceVariableValue$_(t);
            }
            return n !== i;
        }
        static _$Interpolate$_(t, s, i, e) {
            if (!i) {
                let t = e._$GetPropertyTrackDataItem$_();
                return t = e._$GetPropertyTrackData$_()._$GetLastPropertyKeyframeDataItem$_(t), 
                t._$GetValueWithResultMode$_();
            }
            let n = e._$GetInterpolationMode$_();
            if ("default" === n && (n = "continuous"), "combo" === e._$GetPropertyType$_() && (n = "discrete"), 
            "discrete" === n) return s._$GetValueWithResultMode$_();
            if ("continuous" === n || "step" === n) {
                const h = e._$GetTimeline$_()._$GetStep$_();
                if ("step" === n && 0 !== h) {
                    const s = 1 / h;
                    t = Math.floor(t * s) / s;
                }
                const r = s._$GetValueWithResultMode$_(), o = i._$GetValueWithResultMode$_(), a = s._$GetAddOn$_("cubic-bezier"), u = i._$GetAddOn$_("cubic-bezier"), l = a && a._$GetStartEnable$_() && u && u._$GetEndEnable$_();
                if (!l && r === o) return r;
                const c = s._$GetTime$_(), f = i._$GetTime$_();
                "step" === n && 0 !== h && (t = Um._$clamp$_(t, c, f));
                const d = Um.normalize(t, c, f), p = s._$GetEase$_();
                let m;
                if (l) {
                    const t = f - c;
                    m = Wm._$GetRuntimeEase$_(p)(t * d, 0, 1, t), m = Wm._$GetRuntimeEase$_("cubicbezier")(m, r, r + a._$GetStartAnchor$_(), o + u._$GetEndAnchor$_(), o);
                } else m = Wm._$GetRuntimeEase$_(p)((f - c) * d, r, o - r, f - c);
                return "integer" === e._$GetPropertyType$_() ? Math.floor(m) : m;
            }
        }
    };
}

{
    const Jm = self._$C3$_;
    Jm._$PropertyTrackState$_._$AngleTypeAdapter$_ = class {
        constructor() {}
        static _$WillChange$_(t, s, i, e) {
            let n;
            switch (e) {
              case "behavior":
              case "plugin":
                n = s._$GetPropertyValueByIndex$_(t);
                break;

              case "effect":
                n = s[t];
                break;

              case "instance-variable":
                n = s._$GetInstanceVariableValue$_(t);
            }
            return n !== i;
        }
        static _$Interpolate$_(t, s, i, e) {
            if (!i) {
                let t = e._$GetPropertyTrackDataItem$_();
                return t = e._$GetPropertyTrackData$_()._$GetLastPropertyKeyframeDataItem$_(t), 
                t._$GetValueWithResultMode$_();
            }
            let n = e._$GetInterpolationMode$_();
            if ("default" === n && (n = "continuous"), "combo" === e._$GetPropertyType$_() && (n = "discrete"), 
            "discrete" === n) return s._$GetValueWithResultMode$_();
            if ("continuous" === n || "step" === n) {
                const h = e._$GetTimeline$_()._$GetStep$_();
                if ("step" === n && 0 !== h) {
                    const s = 1 / h;
                    t = Math.floor(t * s) / s;
                }
                const r = s._$GetTime$_(), o = i._$GetTime$_(), a = s._$GetValueWithResultMode$_(), u = i._$GetValueWithResultMode$_();
                "step" === n && 0 !== h && (t = Jm._$clamp$_(t, r, o));
                const l = s._$GetAddOn$_("angle");
                if (!l) {
                    if (a === u) return a;
                    const i = Jm.normalize(t, r, o), e = self._$Ease$_._$GetRuntimeEase$_(s._$GetEase$_());
                    return Jm._$angleLerp$_(a, u, e(i, 0, 1, 1));
                }
                {
                    const i = l._$GetRevolutions$_();
                    if (a === u && 0 === i) return a;
                    const e = Jm.normalize(t, r, o), n = self._$Ease$_._$GetRuntimeEase$_(s._$GetEase$_())(e, 0, 1, 1);
                    switch (l._$GetDirection$_()) {
                      case "closest":
                        return Jm._$angleLerp$_(a, u, n, i);

                      case "clockwise":
                        return Jm._$angleLerpClockwise$_(a, u, n, i);

                      case "anti-clockwise":
                        return Jm._$angleLerpAntiClockwise$_(a, u, n, i);
                    }
                }
            }
        }
    };
}

self._$C3$_._$PropertyTrackState$_._$BooleanTypeAdapter$_ = class {
    constructor() {}
    static _$WillChange$_(t, s, i, e) {
        let n;
        switch (e) {
          case "behavior":
          case "plugin":
            n = s._$GetPropertyValueByIndex$_(t);
            break;

          case "effect":
            n = s[t];
            break;

          case "instance-variable":
            n = s._$GetInstanceVariableValue$_(t);
        }
        return !!n != !!i;
    }
    static _$Interpolate$_(t, s, i, e) {
        if (!i) {
            let t = e._$GetPropertyTrackDataItem$_();
            return t = e._$GetPropertyTrackData$_()._$GetLastPropertyKeyframeDataItem$_(t), 
            t._$GetValueWithResultMode$_() ? 1 : 0;
        }
        return s._$GetValueWithResultMode$_() ? 1 : 0;
    }
};

{
    const Qm = self._$C3$_, Ym = [ 0, 0, 0 ], Vm = [ 0, 0, 0 ], Hm = [ 0, 0, 0 ];
    Qm._$PropertyTrackState$_._$ColorTypeAdapter$_ = class {
        constructor() {}
        static _$WillChange$_(t, s, i, e) {
            let n;
            switch (e) {
              case "behavior":
              case "plugin":
                n = s._$GetPropertyValueByIndex$_(t);
                break;

              case "effect":
                n = s[t];
                break;

              case "instance-variable":
                n = s._$GetInstanceVariableValue$_(t);
            }
            return Array.isArray(i) ? (Ym[0] = i[0], Ym[1] = i[1], Ym[2] = i[2]) : (Hm._$parseCommaSeparatedRgb$_(i), 
            Ym[0] = Math.floor(255 * Hm._$getR$_()), Ym[1] = Math.floor(255 * Hm._$getG$_()), 
            Ym[2] = Math.floor(255 * Hm._$getB$_())), Array.isArray(n) ? (Vm[0] = n[0], Vm[1] = n[1], 
            Vm[2] = n[2]) : (Hm._$parseCommaSeparatedRgb$_(n), Vm[0] = Math.floor(255 * Hm._$getR$_()), 
            Vm[1] = Math.floor(255 * Hm._$getG$_()), Vm[2] = Math.floor(255 * Hm._$getB$_())), 
            Ym[0] !== Vm[0] || Ym[1] !== Vm[1] || Ym[2] !== Vm[2];
        }
        static _$Interpolate$_(t, s, i, e) {
            if (!i) {
                let t = e._$GetPropertyTrackDataItem$_();
                t = e._$GetPropertyTrackData$_()._$GetLastPropertyKeyframeDataItem$_(t);
                const s = t._$GetValueWithResultMode$_();
                return Ym[0] = s[0], Ym[1] = s[1], Ym[2] = s[2], Ym;
            }
            let n = e._$GetInterpolationMode$_();
            if ("default" === n && (n = "continuous"), "discrete" === n) {
                const t = s._$GetValueWithResultMode$_();
                return Ym[0] = t[0], Ym[1] = t[1], Ym[2] = t[2], Ym;
            }
            if ("continuous" === n || "step" === n) {
                const h = e._$GetTimeline$_()._$GetStep$_();
                if ("step" === n && 0 !== h) {
                    const s = 1 / h;
                    t = Math.floor(t * s) / s;
                }
                const r = s._$GetTime$_(), o = i._$GetTime$_(), a = s._$GetValueWithResultMode$_(), u = i._$GetValueWithResultMode$_();
                "step" === n && 0 !== h && (t = Qm._$clamp$_(t, r, o));
                const l = Qm.normalize(t, r, o), c = s._$GetEase$_(), f = a[0], d = a[1], p = a[2], m = u[0], g = u[1], y = u[2], M = self._$Ease$_._$GetRuntimeEase$_(c), w = o - r, S = w * l;
                return Ym[0] = f === m ? f : M(S, f, m - f, w), Ym[1] = d === g ? d : M(S, d, g - d, w), 
                Ym[2] = p === y ? p : M(S, p, y - p, w), Ym;
            }
        }
    };
}

self._$C3$_._$PropertyTrackState$_._$TextTypeAdapter$_ = class {
    constructor() {}
    static _$WillChange$_(t, s, i, e) {
        let n;
        switch (e) {
          case "behavior":
          case "plugin":
            n = s._$GetPropertyValueByIndex$_(t);
            break;

          case "effect":
            n = s[t];
            break;

          case "instance-variable":
            n = s._$GetInstanceVariableValue$_(t);
        }
        return n !== i;
    }
    static _$Interpolate$_(t, s, i, e) {
        if (!i) {
            let t = e._$GetPropertyTrackDataItem$_();
            return t = e._$GetPropertyTrackData$_()._$GetLastPropertyKeyframeDataItem$_(t), 
            t._$GetValueWithResultMode$_();
        }
        return s._$GetValueWithResultMode$_();
    }
};

{
    const qm = self._$C3$_;
    qm._$TimelineDataManager$_ = class {
        constructor() {
            this._$_timelineDataItems$_ = new Map;
        }
        _$Release$_() {
            for (const t of this._$_timelineDataItems$_.values()) t._$Release$_();
            this._$_timelineDataItems$_.clear(), this._$_timelineDataItems$_ = null;
        }
        _$Add$_(t) {
            const s = new qm._$TimelineDataItem$_(t), i = s._$GetName$_();
            this._$_timelineDataItems$_.set(i, s);
        }
        _$Get$_(t) {
            return this._$_timelineDataItems$_.get(t);
        }
        _$GetNameId$_() {
            return 0;
        }
        static _$_CreateDataItems$_(t, s, i, e) {
            if (s) for (const n of s) qm._$TimelineDataManager$_._$_CreateDataItem$_("create", n, t, i, e);
        }
        static _$_CreateDataItemsIncludingDisabled$_(t, s, i, e) {
            if (s) for (const n of s) qm._$TimelineDataManager$_._$_CreateDataItem$_("create-including-disabled", n, t, i, e);
        }
        static _$_LoadDataItemsFromJson$_(t, s, i, e) {
            t.length ? s.forEach(((s, i) => {
                t[i]._$_LoadFromJson$_(s);
            })) : s.forEach((s => {
                qm._$TimelineDataManager$_._$_CreateDataItem$_("load", s, t, i, e);
            }));
        }
        static _$_CreateDataItem$_(t, s, i, e, n) {
            let h;
            if ("function" == typeof e) switch (t) {
              case "load":
                h = new e(null, n);
                break;

              case "create":
              case "create-including-disabled":
                h = new e(s, n);
            } else if ("object" == typeof e) {
                const i = s[e._$prop$_], r = e.map.get(i);
                switch (t) {
                  case "load":
                    h = new r(null, n);
                    break;

                  case "create":
                  case "create-including-disabled":
                    h = new r(s, n);
                }
            }
            switch (t) {
              case "load":
                h._$_LoadFromJson$_(s), i.push(h);
                break;

              case "create":
                if ("function" == typeof h._$GetEnable$_ && !h._$GetEnable$_()) return h._$Release$_();
                i.push(h);
                break;

              case "create-including-disabled":
                i.push(h);
            }
        }
    };
}

{
    const Xm = self._$C3$_;
    Xm._$TimelineDataItem$_ = class {
        constructor(t) {
            this._$_name$_ = "", this._$_totalTime$_ = NaN, this._$_step$_ = 0, this._$_interpolationMode$_ = "default", 
            this._$_resultMode$_ = "default", this._$_loop$_ = !1, this._$_pingPong$_ = !1, 
            this._$_repeatCount$_ = 1, this._$_trackData$_ = null, this._$_startOnLayout$_ = "", 
            this._$_transformWithSceneGraph$_ = !1, this._$_useSystemTimescale$_ = !0, t && (this._$_name$_ = t[0], 
            this._$_totalTime$_ = t[1], this._$_step$_ = t[2], this._$_interpolationMode$_ = t[3], 
            this._$_resultMode$_ = t[4], this._$_loop$_ = !!t[6], this._$_pingPong$_ = !!t[7], 
            this._$_repeatCount$_ = t[8], this._$_startOnLayout$_ = t[9], this._$_transformWithSceneGraph$_ = !!t[10], 
            this._$_useSystemTimescale$_ = !!t[11], this._$_trackData$_ = new Xm._$TrackData$_(t[5], this));
        }
        _$Release$_() {
            this._$_trackData$_._$Release$_(), this._$_trackData$_ = null;
        }
        _$GetTrackData$_() {
            return this._$_trackData$_ || (this._$_trackData$_ = new Xm._$TrackData$_(null, this)), 
            this._$_trackData$_;
        }
        _$GetName$_() {
            return this._$_name$_;
        }
        _$SetName$_(t) {
            this._$_name$_ = t;
        }
        _$GetTotalTime$_() {
            return this._$_totalTime$_;
        }
        _$SetTotalTime$_(t) {
            this._$_totalTime$_ = t;
        }
        _$GetStep$_() {
            return this._$_step$_;
        }
        _$SetStep$_(t) {
            this._$_step$_ = t;
        }
        _$GetInterpolationMode$_() {
            return this._$_interpolationMode$_;
        }
        _$SetInterpolationMode$_(t) {
            this._$_interpolationMode$_ = t;
        }
        _$GetResultMode$_() {
            return this._$_resultMode$_;
        }
        _$SetResultMode$_(t) {
            this._$_resultMode$_ = t;
        }
        _$GetLoop$_() {
            return this._$_loop$_;
        }
        _$SetLoop$_(t) {
            this._$_loop$_ = t;
        }
        _$GetPingPong$_() {
            return this._$_pingPong$_;
        }
        _$SetPingPong$_(t) {
            this._$_pingPong$_ = t;
        }
        _$GetRepeatCount$_() {
            return this._$_repeatCount$_;
        }
        _$SetRepeatCount$_(t) {
            this._$_repeatCount$_ = t;
        }
        _$GetStartOnLayout$_() {
            return this._$_startOnLayout$_;
        }
        _$GetTransformWithSceneGraph$_() {
            return this._$_transformWithSceneGraph$_;
        }
        _$GetUseSystemTimescale$_() {
            return this._$_useSystemTimescale$_;
        }
        _$_SaveToJson$_() {
            return {
                trackDataJson: this._$_trackData$_._$_SaveToJson$_(),
                name: this._$_name$_,
                totalTime: this._$_totalTime$_,
                step: this._$_step$_,
                interpolationMode: this._$_interpolationMode$_,
                resultMode: this._$_resultMode$_,
                loop: this._$_loop$_,
                pingPong: this._$_pingPong$_,
                repeatCount: this._$_repeatCount$_,
                startOnLayout: this._$_startOnLayout$_,
                transformWithSceneGraph: !!this._$_transformWithSceneGraph$_,
                useSystemTimescale: this._$_useSystemTimescale$_
            };
        }
        _$_LoadFromJson$_(t) {
            t && (this._$GetTrackData$_()._$_LoadFromJson$_(t.trackDataJson), this._$_name$_ = t.name, 
            this._$_totalTime$_ = t.totalTime, this._$_step$_ = t.step, this._$_interpolationMode$_ = t.interpolationMode, 
            this._$_resultMode$_ = t.resultMode, this._$_loop$_ = t.loop, this._$_pingPong$_ = t.pingPong, 
            this._$_repeatCount$_ = t.repeatCount, this._$_startOnLayout$_ = t.startOnLayout, 
            this._$_transformWithSceneGraph$_ = !!t.transformWithSceneGraph, this._$_useSystemTimescale$_ = !!t.useSystemTimescale);
        }
    };
}

{
    const Zm = self._$C3$_;
    class Km {
        constructor(t, s) {
            this._$_trackData$_ = s, this._$_instanceData$_ = null, this._$_additionalInstanceData$_ = null, 
            this._$_instanceUid$_ = NaN, this._$_objectClassIndex$_ = NaN, this._$_interpolationMode$_ = "default", 
            this._$_resultMode$_ = "default", this._$_enabled$_ = !1, this._$_keyframeData$_ = null, 
            this._$_propertyTrackData$_ = null, this._$_id$_ = "", this._$_nestedData$_ = null, 
            this._$_startOffset$_ = 0, this._$_localTotalTime$_ = this._$_trackData$_._$GetTimelineDataItem$_()._$GetTotalTime$_(), 
            this._$_type$_ = 0, this._$_name$_ = "", t && (t[0] && (this._$_instanceData$_ = t[0], 
            this._$_instanceUid$_ = t[0][2], this._$_objectClassIndex$_ = t[0][1]), this._$_interpolationMode$_ = t[1], 
            this._$_resultMode$_ = t[2], this._$_enabled$_ = !!t[3], t[6] && (this._$_id$_ = t[6]), 
            t[7] && (this._$_nestedData$_ = t[7], this._$_startOffset$_ = t[7][0], this._$_localTotalTime$_ = t[7][1]), 
            t[8] && (this._$_additionalInstanceData$_ = t[8]), t[8] && (this._$_additionalInstanceData$_ = t[8]), 
            t[9] && (this._$_type$_ = t[9]), t[10] && (this._$_name$_ = t[10]), this._$_keyframeData$_ = new Zm._$KeyframeData$_(t[4], this), 
            this._$_propertyTrackData$_ = new Zm._$PropertyTrackData$_(t[5], this));
        }
        _$Release$_() {
            this._$_instanceData$_ = null, this._$_trackData$_ = null, this._$_keyframeData$_ && (this._$_keyframeData$_._$Release$_(), 
            this._$_keyframeData$_ = null), this._$_propertyTrackData$_ && (this._$_propertyTrackData$_._$Release$_(), 
            this._$_propertyTrackData$_ = null), this._$_nestedData$_ = null;
        }
        _$GetTrackData$_() {
            return this._$_trackData$_;
        }
        _$GetKeyframeData$_() {
            return this._$_keyframeData$_ || (this._$_keyframeData$_ = new Zm._$KeyframeData$_(null, this)), 
            this._$_keyframeData$_;
        }
        _$GetPropertyTrackData$_() {
            return this._$_propertyTrackData$_ || (this._$_propertyTrackData$_ = new Zm._$PropertyTrackData$_(null, this)), 
            this._$_propertyTrackData$_;
        }
        _$GetInstanceData$_() {
            return this._$_instanceData$_;
        }
        _$GetObjectClassIndex$_() {
            return this._$_objectClassIndex$_;
        }
        _$SetObjectClassIndex$_(t) {
            this._$_objectClassIndex$_ = t;
        }
        _$GetInstanceUID$_() {
            return this._$_instanceUid$_;
        }
        _$SetInstanceUID$_(t) {
            this._$_instanceUid$_ = t;
        }
        _$GetInterpolationMode$_() {
            return this._$_interpolationMode$_;
        }
        _$SetInterpolationMode$_(t) {
            this._$_interpolationMode$_ = t;
        }
        _$GetResultMode$_() {
            return this._$_resultMode$_;
        }
        _$SetResultMode$_(t) {
            this._$_resultMode$_ = t;
        }
        _$GetEnable$_() {
            return this._$_enabled$_;
        }
        _$SetEnable$_(t) {
            this._$_enabled$_ = !!t;
        }
        _$GetId$_() {
            return this._$_id$_;
        }
        _$GetStartOffset$_() {
            return this._$_startOffset$_;
        }
        _$GetLocalTotalTime$_() {
            return this._$_localTotalTime$_;
        }
        _$SetLocalTotalTime$_(t) {
            this._$_localTotalTime$_ = t;
        }
        _$GetOriginalWidth$_() {
            return this._$_additionalInstanceData$_[0];
        }
        _$SetOriginalWidth$_(t) {
            this._$_additionalInstanceData$_ || (this._$_additionalInstanceData$_ = []), this._$_additionalInstanceData$_[0] = t;
        }
        _$GetOriginalHeight$_() {
            return this._$_additionalInstanceData$_ || (this._$_additionalInstanceData$_ = []), 
            this._$_additionalInstanceData$_[1];
        }
        _$SetOriginalHeight$_(t) {
            this._$_additionalInstanceData$_ || (this._$_additionalInstanceData$_ = []), this._$_additionalInstanceData$_[1] = t;
        }
        _$GetType$_() {
            return this._$_type$_;
        }
        _$GetName$_() {
            return this._$_name$_;
        }
        _$_SaveToJson$_() {
            return {
                keyframeDataJson: this._$_keyframeData$_._$_SaveToJson$_(),
                propertyTrackDataJson: this._$_propertyTrackData$_._$_SaveToJson$_(),
                instanceData: this._$_instanceData$_,
                additionalInstanceData: this._$_additionalInstanceData$_,
                instanceUid: this._$_instanceUid$_,
                objectClassIndex: this._$_objectClassIndex$_,
                interpolationMode: this._$_interpolationMode$_,
                resultMode: this._$_resultMode$_,
                enabled: this._$_enabled$_,
                id: this._$_id$_,
                nestedData: this._$_nestedData$_,
                type: this._$_type$_,
                name: this._$_name$_
            };
        }
        _$_LoadFromJson$_(t) {
            t && (this._$_instanceData$_ = t.instanceData, this._$_instanceUid$_ = t.instanceUid, 
            this._$_objectClassIndex$_ = t.objectClassIndex, this._$_interpolationMode$_ = t.interpolationMode, 
            this._$_resultMode$_ = t.resultMode, this._$_enabled$_ = t.enabled, this._$_id$_ = t.id, 
            this._$_type$_ = t.type ? t.type : 0, this._$_name$_ = t.name ? t.name : "", this._$_localTotalTime$_ = this._$_trackData$_._$GetTimelineDataItem$_()._$GetTotalTime$_(), 
            t.nestedData && (this._$_nestedData$_ = t.nestedData, this._$_startOffset$_ = this._$_nestedData$_[0], 
            this._$_localTotalTime$_ = this._$_nestedData$_[1]), t.additionalInstanceData && (this._$_additionalInstanceData$_ = t.additionalInstanceData), 
            this._$GetKeyframeData$_()._$_LoadFromJson$_(t.keyframeDataJson), this._$GetPropertyTrackData$_()._$_LoadFromJson$_(t.propertyTrackDataJson));
        }
    }
    Zm._$TrackData$_ = class {
        constructor(t, s) {
            this._$_timelineDataItem$_ = s, this._$_trackDataItems$_ = [], Zm._$TimelineDataManager$_._$_CreateDataItems$_(this._$_trackDataItems$_, t, Km, this);
        }
        _$Release$_() {
            this._$_timelineDataItem$_ = null;
            for (const t of this._$_trackDataItems$_) t._$Release$_();
            Zm._$clearArray$_(this._$_trackDataItems$_), this._$_trackDataItems$_ = null;
        }
        _$GetTimelineDataItem$_() {
            return this._$_timelineDataItem$_;
        }
        _$AddEmptyTrackDataItem$_() {
            const t = new Km(null, this);
            return this._$_trackDataItems$_.push(t), t;
        }
        _$GetFirstKeyframeDataItem$_(t) {
            return t._$GetKeyframeData$_()._$GetKeyframeDataItemArray$_()[0];
        }
        _$GetLastKeyframeDataItem$_(t) {
            return t._$GetKeyframeData$_()._$GetKeyframeDataItemArray$_().at(-1);
        }
        _$GetKeyFrameDataItemAtTime$_(t, s) {
            const i = s._$GetKeyframeData$_()._$GetKeyframeDataItemArray$_(), e = i.length;
            for (let s = 0; s < e; s++) {
                const e = i[s];
                if (e._$GetTime$_() === t) return e;
            }
        }
        _$GetFirstKeyFrameDataItemHigherThan$_(t, s) {
            const i = s._$GetKeyframeData$_()._$GetKeyframeDataItemArray$_(), e = i.length;
            for (let s = 0; s < e; s++) {
                const e = i[s];
                if (e._$GetTime$_() > t) return e;
            }
        }
        _$GetFirstKeyFrameDataItemHigherOrEqualThan$_(t, s) {
            const i = s._$GetKeyframeData$_()._$GetKeyframeDataItemArray$_(), e = i.length;
            for (let s = 0; s < e; s++) {
                const e = i[s];
                if (e._$GetTime$_() >= t) return e;
            }
        }
        _$GetFirstKeyFrameDataItemLowerOrEqualThan$_(t, s) {
            const i = s._$GetKeyframeData$_()._$GetKeyframeDataItemArray$_();
            for (let s = i.length - 1; s >= 0; s--) {
                const e = i[s];
                if (e._$GetTime$_() <= t) return e;
            }
        }
        * _$trackDataItems$_() {
            for (const t of this._$_trackDataItems$_) yield t;
        }
        _$_SaveToJson$_() {
            return {
                trackDataItemsJson: this._$_trackDataItems$_.map((t => t._$_SaveToJson$_()))
            };
        }
        _$_LoadFromJson$_(t) {
            t && Zm._$TimelineDataManager$_._$_LoadDataItemsFromJson$_(this._$_trackDataItems$_, t.trackDataItemsJson, Km, this);
        }
    };
}

{
    const $m = self._$C3$_;
    class tg {
        constructor(t, s) {
            this._$_propertyTrackData$_ = s, this._$_sourceAdapterId$_ = "", this._$_sourceAdapterArguments$_ = null, 
            this._$_property$_ = null, this._$_type$_ = null, this._$_min$_ = NaN, this._$_max$_ = NaN, 
            this._$_interpolationMode$_ = "default", this._$_resultMode$_ = "default", this._$_enabled$_ = !1, 
            this._$_propertyKeyframeData$_ = null, this._$_canHavePropertyKeyframes$_ = !0, 
            t && (this._$_sourceAdapterId$_ = t[0][0], this._$_sourceAdapterArguments$_ = t[0].slice(1), 
            this._$_property$_ = t[1], this._$_type$_ = t[2], this._$_min$_ = t[3], this._$_max$_ = t[4], 
            this._$_interpolationMode$_ = t[5], this._$_resultMode$_ = t[6], this._$_enabled$_ = !!t[7], 
            this._$_propertyKeyframeData$_ = new $m._$PropertyKeyframeData$_(t[8], this), this._$_canHavePropertyKeyframes$_ = t[9]);
        }
        _$Release$_() {
            this._$_propertyKeyframeData$_._$Release$_(), this._$_propertyKeyframeData$_ = null, 
            this._$_propertyTrackData$_ = null, this._$_sourceAdapterArguments$_ = null;
        }
        _$GetPropertyTrackData$_() {
            return this._$_propertyTrackData$_;
        }
        _$GetPropertyKeyframeData$_() {
            return this._$_propertyKeyframeData$_ || (this._$_propertyKeyframeData$_ = new $m._$PropertyKeyframeData$_(null, this)), 
            this._$_propertyKeyframeData$_;
        }
        _$GetSourceAdapterId$_() {
            return this._$_sourceAdapterId$_;
        }
        _$SetSourceAdapterId$_(t) {
            this._$_sourceAdapterId$_ = t;
        }
        _$GetSourceAdapterArguments$_() {
            return this._$_sourceAdapterArguments$_;
        }
        _$SetSourceAdapterArguments$_(t) {
            this._$_sourceAdapterArguments$_ = t;
        }
        _$GetProperty$_() {
            return this._$_property$_;
        }
        _$SetProperty$_(t) {
            this._$_property$_ = t;
        }
        _$GetType$_() {
            return this._$_type$_;
        }
        _$SetType$_(t) {
            this._$_type$_ = t;
        }
        _$GetMin$_() {
            return this._$_min$_;
        }
        _$SetMin$_(t) {
            this._$_min$_ = t;
        }
        _$GetMax$_() {
            return this._$_max$_;
        }
        _$SetMax$_(t) {
            this._$_max$_ = t;
        }
        _$GetInterpolationMode$_() {
            return this._$_interpolationMode$_;
        }
        _$SetInterpolationMode$_(t) {
            this._$_interpolationMode$_ = t;
        }
        _$GetResultMode$_() {
            return this._$_resultMode$_;
        }
        _$SetResultMode$_(t) {
            this._$_resultMode$_ = t;
        }
        _$GetEnable$_() {
            return this._$_enabled$_;
        }
        _$SetEnable$_(t) {
            this._$_enabled$_ = !!t;
        }
        _$CanHavePropertyKeyframes$_() {
            return !!this._$_canHavePropertyKeyframes$_;
        }
        _$_SaveToJson$_() {
            return {
                propertyKeyframeDataJson: this._$_propertyKeyframeData$_._$_SaveToJson$_(),
                sourceAdapterId: this._$_sourceAdapterId$_,
                sourceAdapterArguments: this._$_sourceAdapterArguments$_,
                property: this._$_property$_,
                type: this._$_type$_,
                min: this._$_min$_,
                max: this._$_max$_,
                interpolationMode: this._$_interpolationMode$_,
                resultMode: this._$_resultMode$_,
                enabled: this._$_enabled$_,
                canHavePropertyKeyframes: this._$_canHavePropertyKeyframes$_
            };
        }
        _$_LoadFromJson$_(t) {
            t && (this._$_sourceAdapterId$_ = t.sourceAdapterId, this._$_sourceAdapterArguments$_ = t.sourceAdapterArguments, 
            this._$_property$_ = t.property, this._$_type$_ = t.type, this._$_min$_ = t.min, 
            this._$_max$_ = t.max, this._$_interpolationMode$_ = t.interpolationMode, this._$_resultMode$_ = t.resultMode, 
            this._$_enabled$_ = t.enabled, this._$_canHavePropertyKeyframes$_ = t.canHavePropertyKeyframes, 
            this._$GetPropertyKeyframeData$_()._$_LoadFromJson$_(t.propertyKeyframeDataJson));
        }
    }
    $m._$PropertyTrackData$_ = class {
        constructor(t, s) {
            this._$_trackDataItem$_ = s, this._$_propertyTrackDataItems$_ = [], $m._$TimelineDataManager$_._$_CreateDataItems$_(this._$_propertyTrackDataItems$_, t, tg, this);
        }
        _$Release$_() {
            this._$_trackDataItem$_ = null;
            for (const t of this._$_propertyTrackDataItems$_) t._$Release$_();
            $m._$clearArray$_(this._$_propertyTrackDataItems$_), this._$_propertyTrackDataItems$_ = null;
        }
        _$GetTrackDataItem$_() {
            return this._$_trackDataItem$_;
        }
        _$AddEmptyPropertyTrackDataItem$_() {
            const t = new tg(null, this);
            return this._$_propertyTrackDataItems$_.push(t), t;
        }
        _$GetFirstPropertyKeyframeDataItem$_(t) {
            return t._$GetPropertyKeyframeData$_()._$GetPropertyKeyframeDataItemArray$_()[0];
        }
        _$GetLastPropertyKeyframeDataItem$_(t) {
            return t._$GetPropertyKeyframeData$_()._$GetPropertyKeyframeDataItemArray$_().at(-1);
        }
        _$GetPropertyKeyFrameDataItemAtTime$_(t, s) {
            const i = s._$GetPropertyKeyframeData$_()._$GetPropertyKeyframeDataItemArray$_(), e = i.length;
            for (let s = 0; s < e; s++) {
                const e = i[s];
                if (e._$GetTime$_() === t) return e;
            }
        }
        _$GetFirstPropertyKeyFrameDataItemHigherThan$_(t, s) {
            const i = s._$GetPropertyKeyframeData$_()._$GetPropertyKeyframeDataItemArray$_(), e = i.length;
            for (let s = 0; s < e; s++) {
                const e = i[s];
                if (e._$GetTime$_() > t) return e;
            }
        }
        _$GetFirstPropertyKeyFrameDataItemHigherOrEqualThan$_(t, s) {
            const i = s._$GetPropertyKeyframeData$_()._$GetPropertyKeyframeDataItemArray$_(), e = i.length;
            for (let s = 0; s < e; s++) {
                const e = i[s];
                if (e._$GetTime$_() >= t) return e;
            }
        }
        _$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, s) {
            const i = s._$GetPropertyKeyframeData$_()._$GetPropertyKeyframeDataItemArray$_();
            for (let s = i.length - 1; s >= 0; s--) {
                const e = i[s];
                if (e._$GetTime$_() <= t) return e;
            }
        }
        * _$propertyTrackDataItems$_() {
            for (const t of this._$_propertyTrackDataItems$_) yield t;
        }
        _$_SaveToJson$_() {
            return {
                propertyTrackDataItemsJson: this._$_propertyTrackDataItems$_.map((t => t._$_SaveToJson$_()))
            };
        }
        _$_LoadFromJson$_(t) {
            t && $m._$TimelineDataManager$_._$_LoadDataItemsFromJson$_(this._$_propertyTrackDataItems$_, t.propertyTrackDataItemsJson, tg, this);
        }
    };
}

{
    const sg = self._$C3$_;
    class ig {
        constructor(t, s) {
            if (this._$_keyframeData$_ = s, this._$_time$_ = -1, this._$_ease$_ = "noease", 
            this._$_enable$_ = !1, this._$_tags$_ = null, this._$_lowerTags$_ = null, !t) return;
            this._$_time$_ = t[0], this._$_ease$_ = t[1], this._$_enable$_ = !!t[2];
            const i = t[3];
            this._$_tags$_ = i ? i.split(" ") : [], this._$_lowerTags$_ = new Set(this._$_tags$_.map((t => t.toLowerCase()))), 
            this._$_next$_ = null, this._$_last$_ = null;
        }
        _$Release$_() {
            this._$_keyframeData$_ = null, sg._$clearArray$_(this._$_tags$_), this._$_tags$_ = null, 
            this._$_lowerTags$_.clear(), this._$_lowerTags$_ = null, this._$_next$_ = null;
        }
        _$GetKeyframeData$_() {
            return this._$_keyframeData$_;
        }
        _$GetNext$_() {
            return this._$_next$_;
        }
        _$SetNext$_(t) {
            this._$_next$_ = t;
        }
        _$GetLast$_() {
            return this._$_last$_;
        }
        _$SetLast$_(t) {
            this._$_last$_ = t;
        }
        _$GetTime$_() {
            return this._$_time$_;
        }
        _$SetTime$_(t) {
            this._$_time$_ = t, this._$_keyframeData$_._$_LinkKeyframeDataItems$_();
        }
        _$GetEase$_() {
            return this._$_ease$_;
        }
        _$SetEase$_(t) {
            this._$_ease$_ = t;
        }
        _$GetEnable$_() {
            return this._$_enable$_;
        }
        _$SetEnable$_(t) {
            this._$_enable$_ = !!t;
        }
        _$GetTags$_() {
            return this._$_tags$_;
        }
        _$SetTags$_(t) {
            this._$_tags$_ = t ? t.split(" ") : [], this._$_lowerTags$_ = new Set(this._$_tags$_.map((t => t.toLowerCase())));
        }
        _$GetLowerTags$_() {
            return this._$_lowerTags$_;
        }
        _$HasTag$_(t) {
            return this._$_lowerTags$_.has(t.toLowerCase());
        }
        _$_SaveToJson$_() {
            return {
                time: this._$_time$_,
                ease: this._$_ease$_,
                enable: this._$_enable$_,
                tags: this._$_tags$_
            };
        }
        _$_LoadFromJson$_(t) {
            t && (this._$_time$_ = t.time, this._$_ease$_ = t.ease, this._$_enable$_ = t.enable, 
            this._$_tags$_ = t.tags, this._$_lowerTags$_ = new Set(this._$_tags$_.map((t => t.toLowerCase()))));
        }
    }
    sg._$KeyframeData$_ = class {
        constructor(t, s) {
            this._$_trackDataItem$_ = s, this._$_keyframeDataItems$_ = [], sg._$TimelineDataManager$_._$_CreateDataItems$_(this._$_keyframeDataItems$_, t, ig, this), 
            this._$_LinkKeyframeDataItems$_();
        }
        _$Release$_() {
            this._$_trackDataItem$_ = null;
            for (const t of this._$_keyframeDataItems$_) t._$Release$_();
            sg._$clearArray$_(this._$_keyframeDataItems$_), this._$_keyframeDataItems$_ = null;
        }
        _$_LinkKeyframeDataItems$_() {
            this._$_keyframeDataItems$_.sort(((t, s) => t._$GetTime$_() - s._$GetTime$_()));
            for (let t = 0; t < this._$_keyframeDataItems$_.length; t++) {
                const s = this._$_keyframeDataItems$_[t];
                s._$SetNext$_(this._$_keyframeDataItems$_[t + 1]), s._$SetLast$_(this._$_keyframeDataItems$_[t - 1]);
            }
        }
        _$GetTrackDataItem$_() {
            return this._$_trackDataItem$_;
        }
        _$GetKeyframeDataItemCount$_() {
            return this._$_keyframeDataItems$_.length;
        }
        _$GetKeyframeDataItemArray$_() {
            return this._$_keyframeDataItems$_;
        }
        _$AddEmptyKeyframeDataItem$_() {
            const t = new ig(null, this);
            return this._$_keyframeDataItems$_.push(t), this._$_LinkKeyframeDataItems$_(), t;
        }
        _$DeleteKeyframeDataItems$_(t) {
            for (const s of this._$_keyframeDataItems$_) {
                if (!t(s)) continue;
                const i = this._$_keyframeDataItems$_.indexOf(s);
                -1 !== i && (s._$Release$_(), this._$_keyframeDataItems$_.splice(i, 1));
            }
            this._$SortKeyframeDataItems$_(), this._$_LinkKeyframeDataItems$_();
        }
        _$SortKeyframeDataItems$_() {
            this._$_keyframeDataItems$_.sort(((t, s) => t._$GetTime$_() - s._$GetTime$_()));
        }
        _$GetKeyframeDataItemIndex$_(t) {
            return this._$_keyframeDataItems$_.indexOf(t);
        }
        _$GetKeyframeDataItemFromIndex$_(t) {
            return this._$_keyframeDataItems$_[t];
        }
        * _$keyframeDataItems$_() {
            for (const t of this._$_keyframeDataItems$_) yield t;
        }
        * _$keyframeDataItemsReverse$_() {
            for (let t = this._$_keyframeDataItems$_.length - 1; t >= 0; t--) yield this._$_keyframeDataItems$_[t];
        }
        _$_SaveToJson$_() {
            return {
                keyframeDataItemsJson: this._$_keyframeDataItems$_.map((t => t._$_SaveToJson$_()))
            };
        }
        _$_LoadFromJson$_(t) {
            t && (sg._$TimelineDataManager$_._$_LoadDataItemsFromJson$_(this._$_keyframeDataItems$_, t.keyframeDataItemsJson, ig, this), 
            this._$_LinkKeyframeDataItems$_());
        }
    };
}

{
    const eg = self._$C3$_;
    class ng {
        constructor(t, s) {
            this._$_propertyKeyframeData$_ = s, this._$_value$_ = null, this._$_aValue$_ = null, 
            this._$_type$_ = "", this._$_time$_ = NaN, this._$_ease$_ = "noease", this._$_enable$_ = !1, 
            this._$_addonData$_ = null, this._$_addonInstance$_ = void 0, this._$_pathMode$_ = "line", 
            t && (this._$_value$_ = t[0][0], this._$_aValue$_ = t[0][1], this._$_type$_ = t[0][2], 
            this._$_time$_ = t[1], this._$_ease$_ = t[2], this._$_enable$_ = !!t[3], this._$_pathMode$_ = t[5], 
            this._$_addonData$_ = null, t[4] && (this._$_addonData$_ = new eg._$AddonData$_(t[4], this)), 
            this._$_next$_ = null, this._$_prev$_ = null);
        }
        _$Release$_() {
            this._$_propertyKeyframeData$_ = null, this._$_addonData$_ && (this._$_addonData$_._$Release$_(), 
            this._$_addonData$_ = null), this._$_next$_ = null, this._$_prev$_ = null;
        }
        _$GetAddonData$_() {
            return this._$_addonData$_;
        }
        _$SetNext$_(t) {
            this._$_next$_ = t;
        }
        _$GetNext$_() {
            return this._$_next$_;
        }
        _$SetPrevious$_(t) {
            this._$_prev$_ = t;
        }
        _$GetPrevious$_() {
            return this._$_prev$_;
        }
        _$GetValue$_() {
            return this._$_value$_;
        }
        _$SetValue$_(t) {
            "color" === this._$_type$_ && eg._$IsFiniteNumber$_(t) ? (this._$_value$_[0] = eg._$GetRValue$_(t), 
            this._$_value$_[1] = eg._$GetGValue$_(t), this._$_value$_[2] = eg._$GetBValue$_(t)) : this._$_value$_ = t;
        }
        _$GetAbsoluteValue$_() {
            return this._$_aValue$_;
        }
        _$SetAbsoluteValue$_(t) {
            "color" === this._$_type$_ && eg._$IsFiniteNumber$_(t) ? (this._$_aValue$_[0] = eg._$GetRValue$_(t), 
            this._$_aValue$_[1] = eg._$GetGValue$_(t), this._$_aValue$_[2] = eg._$GetBValue$_(t)) : this._$_aValue$_ = t;
        }
        _$GetValueWithResultMode$_() {
            const t = this._$_propertyKeyframeData$_._$GetPropertyTrackDataItem$_()._$GetResultMode$_();
            return "relative" === t ? this._$GetValue$_() : "absolute" === t ? this._$GetAbsoluteValue$_() : void 0;
        }
        _$GetType$_() {
            return this._$_type$_;
        }
        _$SetType$_(t) {
            this._$_type$_ = t;
        }
        _$GetTime$_() {
            return this._$_time$_;
        }
        _$SetTime$_(t) {
            this._$_time$_ = t, this._$_propertyKeyframeData$_._$_LinkPropertyKeyframeDataItems$_();
        }
        _$GetEase$_() {
            return this._$_ease$_;
        }
        _$SetEase$_(t) {
            this._$_ease$_ = t;
        }
        _$GetEnable$_() {
            return this._$_enable$_;
        }
        _$SetEnable$_(t) {
            this._$_enable$_ = !!t;
        }
        _$GetPathMode$_() {
            return this._$_pathMode$_;
        }
        _$GetAddOn$_(t) {
            if (!this._$_addonData$_) return;
            if (this._$_addonInstance$_ || null === this._$_addonInstance$_) return this._$_addonInstance$_;
            const s = this._$_addonData$_._$GetAddDataItemArray$_();
            if (!s) return this._$_addonInstance$_ = null, this._$_addonInstance$_;
            const i = s.length;
            for (let e = 0; e < i; e++) {
                const i = s[e];
                if (i._$GetId$_() === t) return this._$_addonInstance$_ = i, this._$_addonInstance$_;
            }
            return this._$_addonInstance$_ = null, this._$_addonInstance$_;
        }
        _$_SaveToJson$_() {
            const t = this._$_addonData$_;
            return {
                addonDataJson: t ? t._$_SaveToJson$_() : t,
                value: this._$_value$_,
                aValue: this._$_aValue$_,
                type: this._$_type$_,
                time: this._$_time$_,
                ease: this._$_ease$_,
                enable: this._$_enable$_
            };
        }
        _$_LoadFromJson$_(t) {
            t && (t.addonDataJson && this._$_addonData$_._$_SetFromJson$_(t.addonDataJson), 
            this._$_value$_ = t.value, this._$_aValue$_ = t.aValue, this._$_type$_ = t.type, 
            this._$_time$_ = t.time, this._$_ease$_ = t.ease, this._$_enable$_ = t.enable);
        }
    }
    eg._$PropertyKeyframeData$_ = class {
        constructor(t, s) {
            this._$_propertyTrackDataItem$_ = s, this._$_propertyKeyframeDataItems$_ = [], this._$_propertyKeyframeDataItemsIncludingDisabled$_ = [], 
            eg._$TimelineDataManager$_._$_CreateDataItems$_(this._$_propertyKeyframeDataItems$_, t, ng, this), 
            eg._$TimelineDataManager$_._$_CreateDataItemsIncludingDisabled$_(this._$_propertyKeyframeDataItemsIncludingDisabled$_, t, ng, this), 
            this._$_LinkPropertyKeyframeDataItems$_();
        }
        _$Release$_() {
            this._$_propertyTrackDataItem$_ = null;
            for (const t of this._$_propertyKeyframeDataItems$_) t._$Release$_();
            eg._$clearArray$_(this._$_propertyKeyframeDataItems$_), this._$_propertyKeyframeDataItems$_ = null;
            for (const t of this._$_propertyKeyframeDataItemsIncludingDisabled$_) t._$Release$_();
            eg._$clearArray$_(this._$_propertyKeyframeDataItemsIncludingDisabled$_), this._$_propertyKeyframeDataItemsIncludingDisabled$_ = null;
        }
        _$_LinkPropertyKeyframeDataItems$_() {
            let t = this._$_propertyKeyframeDataItems$_;
            t.sort(((t, s) => t._$GetTime$_() - s._$GetTime$_()));
            for (let s = 0; s < t.length; s++) {
                const i = t[s];
                s + 1 < t.length && i._$SetNext$_(t[s + 1]), s - 1 >= 0 && i._$SetPrevious$_(t[s - 1]);
            }
            t = this._$_propertyKeyframeDataItemsIncludingDisabled$_, t.sort(((t, s) => t._$GetTime$_() - s._$GetTime$_()));
            for (let s = 0; s < t.length; s++) {
                const i = t[s];
                s + 1 < t.length && i._$SetNext$_(t[s + 1]), s - 1 >= 0 && i._$SetPrevious$_(t[s - 1]);
            }
        }
        _$AddEmptyPropertyKeyframeDataItem$_() {
            const t = new ng(null, this);
            return this._$_propertyKeyframeDataItems$_.push(t), this._$_LinkPropertyKeyframeDataItems$_(), 
            t;
        }
        _$DeletePropertyKeyframeDataItems$_(t) {
            for (const s of this._$_propertyKeyframeDataItems$_) {
                if (!t(s)) continue;
                const i = this._$_propertyKeyframeDataItems$_.indexOf(s);
                -1 !== i && (s._$Release$_(), this._$_propertyKeyframeDataItems$_.splice(i, 1));
            }
            this._$SortPropertyKeyFrameDataItems$_(), this._$_LinkPropertyKeyframeDataItems$_();
        }
        _$SortPropertyKeyFrameDataItems$_() {
            this._$_propertyKeyframeDataItems$_.sort(((t, s) => t._$GetTime$_() - s._$GetTime$_()));
        }
        _$GetPropertyTrackDataItem$_() {
            return this._$_propertyTrackDataItem$_;
        }
        _$GetPropertyKeyframeDataItemCount$_() {
            return this._$_propertyKeyframeDataItems$_.length;
        }
        _$GetLastPropertyKeyframeDataItem$_() {
            return this._$_propertyKeyframeDataItems$_[this._$_propertyKeyframeDataItems$_.length - 1];
        }
        _$GetPropertyKeyframeDataItemArray$_() {
            return this._$_propertyKeyframeDataItems$_;
        }
        _$GetPropertyKeyframeDataItemArrayIncludingDisabled$_() {
            return this._$_propertyKeyframeDataItemsIncludingDisabled$_;
        }
        * _$propertyKeyframeDataItems$_() {
            for (const t of this._$_propertyKeyframeDataItems$_) yield t;
        }
        * _$propertyKeyframeDataItemsReverse$_() {
            for (let t = this._$_propertyKeyframeDataItems$_.length - 1; t >= 0; t--) yield this._$_propertyKeyframeDataItems$_[t];
        }
        _$_SaveToJson$_() {
            const t = this._$_propertyKeyframeDataItems$_, s = this._$_propertyKeyframeDataItemsIncludingDisabled$_;
            return {
                propertyKeyframeDataItemsJson: t.map((t => t._$_SaveToJson$_())),
                propertyKeyframeDataItemsIncludingDisabledJson: s.map((t => t._$_SaveToJson$_()))
            };
        }
        _$_LoadFromJson$_(t) {
            t && (eg._$TimelineDataManager$_._$_LoadDataItemsFromJson$_(this._$_propertyKeyframeDataItems$_, t.propertyKeyframeDataItemsJson, ng, this), 
            eg._$TimelineDataManager$_._$_LoadDataItemsFromJson$_(this._$_propertyKeyframeDataItemsIncludingDisabled$_, t.propertyKeyframeDataItemsIncludingDisabledJson, ng, this), 
            this._$_LinkPropertyKeyframeDataItems$_());
        }
    };
}

{
    const hg = self._$C3$_;
    class rg {
        constructor(t, s) {
            this._$_addonData$_ = s, this._$_id$_ = t[0], this._$_data$_ = t[1];
        }
        _$Release$_() {
            this._$_addonData$_ = null, this._$_data$_ = null;
        }
        _$GetAddonData$_() {
            return this._$_addonData$_;
        }
        _$GetId$_() {
            return this._$_id$_;
        }
        _$_SaveToJson$_() {
            return {
                id: this._$_id$_,
                data: this._$_data$_
            };
        }
        _$_LoadFromJson$_(t) {
            t && (this._$_id$_ = t.id, this._$_data$_ = t.data);
        }
    }
    class og extends rg {
        constructor(t, s) {
            super(t, s), this._$_startAnchor$_ = this._$_data$_[0], this._$_startEnable$_ = !!this._$_data$_[1], 
            this._$_endAnchor$_ = this._$_data$_[2], this._$_endEnable$_ = !!this._$_data$_[3];
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$GetStartAnchor$_() {
            return this._$_startAnchor$_;
        }
        _$GetStartEnable$_() {
            return this._$_startEnable$_;
        }
        _$GetEndAnchor$_() {
            return this._$_endAnchor$_;
        }
        _$GetEndEnable$_() {
            return this._$_endEnable$_;
        }
        _$_SaveToJson$_() {
            return Object.assign(super._$_SaveToJson$_(), {
                startAnchor: this._$_startAnchor$_,
                startEnable: !!this._$_startEnable$_,
                endAnchor: this._$_endAnchor$_,
                endEnable: !!this._$_endEnable$_
            });
        }
        _$_LoadFromJson$_(t) {
            t && (super._$_LoadFromJson$_(t), this._$_startAnchor$_ = t.startAnchor, this._$_startEnable$_ = !!t.startEnable, 
            this._$_endAnchor$_ = t.endAnchor, this._$_endEnable$_ = !!t.endEnable);
        }
    }
    class ag extends rg {
        constructor(t, s) {
            super(t, s), this._$_direction$_ = this._$_data$_[0], this._$_revolutions$_ = this._$_data$_[1];
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$GetDirection$_() {
            return this._$_direction$_;
        }
        _$GetRevolutions$_() {
            return this._$_revolutions$_;
        }
        _$_SaveToJson$_() {
            return Object.assign(super._$_SaveToJson$_(), {
                direction: this._$_direction$_,
                revolutions: this._$_revolutions$_
            });
        }
        _$_LoadFromJson$_(t) {
            t && (super._$_LoadFromJson$_(t), this._$_direction$_ = t.direction, this._$_revolutions$_ = t.revolutions);
        }
    }
    hg._$AddonData$_ = class {
        constructor(t, s) {
            this._$_propertyKeyframeDataItem$_ = s, this._$_addonDataItems$_ = [], hg._$TimelineDataManager$_._$_CreateDataItems$_(this._$_addonDataItems$_, t, {
                _$prop$_: 0,
                map: new Map([ [ "cubic-bezier", og ], [ "angle", ag ] ])
            }, this);
        }
        _$Release$_() {
            this._$_propertyKeyframeDataItem$_ = null;
            for (const t of this._$_addonDataItems$_) t._$Release$_();
            hg._$clearArray$_(this._$_addonDataItems$_), this._$_addonDataItems$_ = null;
        }
        _$GetPropertyKeyframeDataItem$_() {
            return this._$_propertyKeyframeDataItem$_;
        }
        _$GetAddDataItemArray$_() {
            return this._$_addonDataItems$_;
        }
        * _$addonDataItems$_() {
            for (const t of this._$_addonDataItems$_) yield t;
        }
        _$_SaveToJson$_() {
            return {
                addonDataItemsJson: this._$_addonDataItems$_.map((t => t._$_SaveToJson$_()))
            };
        }
        _$_LoadFromJson$_(t) {
            t && hg._$TimelineDataManager$_._$_LoadDataItemsFromJson$_(this._$_addonDataItems$_, t.addonDataItemsJson, {
                _$prop$_: "id",
                map: new Map([ [ "cubic-bezier", og ], [ "angle", ag ] ])
            }, this);
        }
    };
}

{
    const ug = self._$C3$_;
    let lg = 0;
    ug._$TweenState$_ = class extends ug._$TimelineState$_ {
        constructor(t, s) {
            super("tween-" + lg++, t, s), this._$_id$_ = "", this._$_destroyInstanceOnComplete$_ = !1, 
            this._$_initialValueMode$_ = "start-value", this._$_instance$_ = null, this._$_on_completed_callbacks$_ = null, 
            this._$_on_started_callbacks$_ = null, this._$_track$_ = null, this._$_iTweenState$_ = null;
        }
        _$FireReleaseEvent$_(t) {
            const s = ug._$New$_(ug.Event, "tweenstatereleased");
            s._$tweenState$_ = this, t.dispatchEvent(s);
        }
        _$GetType$_() {
            return 1;
        }
        _$CreateTrackStates$_() {
            for (const t of this._$_timelineDataItem$_._$GetTrackData$_()._$trackDataItems$_()) this._$_tracks$_.push(ug._$TweenTrackState$_._$Create$_(this, t));
            this._$_track$_ = this._$_tracks$_[0];
        }
        _$AddTrack$_() {
            const t = this._$_timelineDataItem$_._$GetTrackData$_()._$AddEmptyTrackDataItem$_(), s = ug._$TweenTrackState$_._$Create$_(this, t);
            return this._$_tracks$_.push(s), this._$_CacheTrack$_(), s;
        }
        _$_CacheTrack$_() {
            this._$_track$_ = this._$_tracks$_[0];
        }
        _$GetPropertyTrack$_(t) {
            return this._$_track$_._$GetPropertyTracks$_()[0];
        }
        _$SetPropertyType$_(t) {
            this._$_propertyType$_ = t;
        }
        _$GetInstance$_() {
            const t = this._$GetTracks$_();
            if (!t || !t.length) return;
            const s = t[0];
            if (this._$_track$_ = s, !s) return;
            const i = s._$GetInstance$_();
            return s._$IsInstanceValid$_() ? i : void 0;
        }
        _$AddStartedCallback$_(t) {
            this._$_on_started_callbacks$_ || (this._$_on_started_callbacks$_ = []), this._$_on_started_callbacks$_.push(t);
        }
        _$AddCompletedCallback$_(t) {
            this._$_on_completed_callbacks$_ || (this._$_on_completed_callbacks$_ = []), this._$_on_completed_callbacks$_.push(t);
        }
        _$RemoveStartedCallback$_(t) {
            if (!this._$_on_started_callbacks$_) return;
            const s = this._$_on_started_callbacks$_.indexOf(t);
            -1 !== s && this._$_on_started_callbacks$_.splice(s, 1);
        }
        _$RemoveCompletedCallback$_(t) {
            if (!this._$_on_completed_callbacks$_) return;
            const s = this._$_on_completed_callbacks$_.indexOf(t);
            -1 !== s && this._$_on_completed_callbacks$_.splice(s, 1);
        }
        _$SetStartValue$_(t, s) {
            for (const i of this._$_tracks$_) for (const e of i._$_propertyTracks$_) {
                if (e._$GetPropertyName$_() !== s) continue;
                const i = e._$GetPropertyTrackData$_(), n = e._$GetPropertyTrackDataItem$_(), h = i._$GetFirstPropertyKeyframeDataItem$_(n);
                h._$SetValue$_(t), h._$SetAbsoluteValue$_(t);
            }
        }
        _$_GetPropertyTrackState$_(t) {
            for (const s of this._$_tracks$_) for (const i of s._$_propertyTracks$_) if (i._$GetPropertyName$_() === t) return i;
        }
        _$BeforeSetEndValues$_(t) {
            for (const s of t) {
                const t = this._$_GetPropertyTrackState$_(s);
                this._$SetStartValue$_(t._$GetCurrentState$_(), s);
            }
            if (this._$IsForwardPlayBack$_()) {
                const t = this._$GetTotalTime$_() - this._$GetTime$_();
                this._$SetTotalTime$_(t);
                for (const s of this._$_tracks$_) s._$SetLocalTotalTime$_(t);
                this._$_SetTime$_(0);
            } else {
                const t = this._$GetTime$_();
                this._$SetTotalTime$_(t);
                for (const s of this._$_tracks$_) s._$SetLocalTotalTime$_(t);
                this._$_SetTime$_(t);
            }
            this._$SetInitialStateFromSetTime$_();
        }
        _$SetEndValue$_(t, s) {
            const i = this._$_GetPropertyTrackState$_(s), e = i._$GetPropertyTrackData$_(), n = i._$GetPropertyTrackDataItem$_(), h = e._$GetLastPropertyKeyframeDataItem$_(n);
            h._$SetTime$_(this._$GetTotalTime$_()), h._$SetValue$_(t), h._$SetAbsoluteValue$_(t);
        }
        _$SetId$_(t) {
            this._$_id$_ = t;
        }
        _$GetId$_() {
            return this._$_id$_;
        }
        _$SetInitialValueMode$_(t) {
            this._$_initialValueMode$_ = t;
        }
        _$GetInitialValueMode$_() {
            return this._$_initialValueMode$_;
        }
        _$SetDestroyInstanceOnComplete$_(t) {
            this._$_destroyInstanceOnComplete$_ = t;
        }
        _$GetDestroyInstanceOnComplete$_() {
            return this._$_destroyInstanceOnComplete$_;
        }
        _$OnStarted$_() {
            if (this._$_on_started_callbacks$_) for (const t of this._$_on_started_callbacks$_) t(this);
            if (!this._$IsComplete$_()) for (const t of this._$_tracks$_) t._$CompareSaveStateWithCurrent$_();
        }
        _$OnCompleted$_() {
            this._$_completedTick$_ = this._$_runtime$_._$GetTickCount$_();
        }
        _$FinishTriggers$_() {
            if (!this._$_finishedTriggers$_ && (this._$_finishedTriggers$_ = !0, this._$_on_completed_callbacks$_)) for (const t of this._$_on_completed_callbacks$_) t(this);
        }
        _$SetTime$_(t) {
            this._$_DeleteIntermediateKeyframes$_(), super._$SetTime$_(t);
        }
        _$_SetTimeAndReset$_(t) {
            ug._$IsFiniteNumber$_(t) || (t = this._$GetTotalTime$_()), t < 0 ? this._$_playheadTime$_ = 0 : t >= this._$GetTotalTime$_() ? this._$_playheadTime$_ = this._$GetTotalTime$_() : this._$_playheadTime$_ = t, 
            this._$_track$_._$SetResetState$_();
        }
        _$SetInitialState$_(t) {
            if (!this._$InitialStateSet$_() && "current-state" === this._$GetInitialValueMode$_()) for (const t of this._$_tracks$_) t._$CompareInitialStateWithCurrent$_();
            super._$SetInitialState$_(t);
        }
        _$Stop$_(t = !1) {
            if (super._$Stop$_(t), !this._$IsComplete$_()) for (const t of this._$_tracks$_) t._$SaveState$_();
        }
        _$Reset$_(t = !0, s = !1) {
            this._$_DeleteIntermediateKeyframes$_(), super._$Reset$_(t, s);
        }
        _$_DeleteIntermediateKeyframes$_() {
            for (const t of this._$_tracks$_) {
                const s = t => {
                    const s = t._$GetTime$_(), i = this._$GetTotalTime$_();
                    return 0 !== s && s !== i;
                };
                t._$DeleteKeyframes$_(s), t._$DeletePropertyKeyframes$_(s);
            }
        }
        _$_OnBeforeChangeLayout$_() {
            if (this._$IsReleased$_()) return !0;
            const t = this._$GetInstance$_();
            return !(t && t._$GetObjectClass$_()._$IsGlobal$_() || (this._$_timelineManager$_._$CompleteTimelineBeforeChangeOfLayout$_(this), 
            this._$ResetBeforeChangeLayout$_(), 0));
        }
        _$Tick$_(t, s, i) {
            if (this._$_instance$_ || (this._$_instance$_ = this._$GetInstance$_()), !this._$_instance$_ || this._$_instance$_._$IsDestroyed$_()) return this._$Stop$_(!0), 
            void this._$OnCompleted$_();
            const e = this._$_instance$_._$GetTimeScale$_();
            if (-1 !== e && (t = i * e), 0 === t && 0 === this._$_lastDelta$_) return;
            this._$_lastDelta$_ = t;
            const n = this._$_playheadTime$_ + this._$_overshoot$_ + t * this._$_playbackRate$_, h = this._$_timelineDataItem$_._$_totalTime$_;
            n < 0 ? (this._$_playheadTime$_ = 0, this._$_overshoot$_ = -n) : n >= h ? (this._$_playheadTime$_ = h, 
            this._$_overshoot$_ = this._$_playheadTime$_ - n) : (this._$_playheadTime$_ = n, 
            this._$_overshoot$_ = 0);
            let r = !1, o = !1;
            const a = this._$GetLoop$_(), u = this._$GetPingPong$_();
            if (a || u ? a && !u ? this._$_playbackRate$_ > 0 ? this._$_playheadTime$_ >= h && (this._$_SetTimeAndReset$_(0), 
            this._$_TweenTrigger$_(ug._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenLoop$_), 
            this._$_TweenTrigger$_(ug._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensLoop$_), o = !0) : this._$_playheadTime$_ <= 0 && (this._$_SetTimeAndReset$_(h), 
            this._$_TweenTrigger$_(ug._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenLoop$_), 
            this._$_TweenTrigger$_(ug._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensLoop$_), o = !0) : !a && u ? this._$_playbackRate$_ > 0 ? this._$_playheadTime$_ >= h && (this._$_SetTime$_(h), 
            this._$SetPlaybackRate$_(-1 * this._$GetPlaybackRate$_()), o = !0, 1 === this._$_pingPongState$_ ? this._$_currentRepeatCount$_ < this._$GetRepeatCount$_() ? (this._$_currentRepeatCount$_++, 
            this._$_TweenTrigger$_(ug._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenLoop$_), 
            this._$_TweenTrigger$_(ug._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensLoop$_), this._$_TweenTrigger$_(ug._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenPingPong$_), 
            this._$_TweenTrigger$_(ug._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensPingPong$_), 
            this.IsPlaying() ? this._$_pingPongState$_ = 0 : this._$_resumePingPongState$_ = 0) : (this._$_TweenTrigger$_(ug._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenPingPong$_), 
            this._$_TweenTrigger$_(ug._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensPingPong$_), 
            r = !0) : 0 === this._$_pingPongState$_ && (this._$_TweenTrigger$_(ug._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenPingPong$_), 
            this._$_TweenTrigger$_(ug._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensPingPong$_), 
            this.IsPlaying() ? this._$_pingPongState$_ = 1 : this._$_resumePingPongState$_ = 1)) : this._$_playheadTime$_ <= 0 && (this._$_SetTime$_(0), 
            this._$SetPlaybackRate$_(-1 * this._$GetPlaybackRate$_()), o = !0, 1 === this._$_pingPongState$_ ? this._$_currentRepeatCount$_ < this._$GetRepeatCount$_() ? (this._$_currentRepeatCount$_++, 
            this._$_TweenTrigger$_(ug._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenLoop$_), 
            this._$_TweenTrigger$_(ug._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensLoop$_), this._$_TweenTrigger$_(ug._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenPingPong$_), 
            this._$_TweenTrigger$_(ug._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensPingPong$_), 
            this.IsPlaying() ? this._$_pingPongState$_ = 0 : this._$_resumePingPongState$_ = 0) : (r = !0, 
            this._$_TweenTrigger$_(ug._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenPingPong$_), 
            this._$_TweenTrigger$_(ug._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensPingPong$_)) : 0 === this._$_pingPongState$_ && (this._$_TweenTrigger$_(ug._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenPingPong$_), 
            this._$_TweenTrigger$_(ug._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensPingPong$_), 
            this.IsPlaying() ? this._$_pingPongState$_ = 1 : this._$_resumePingPongState$_ = 1)) : a && u && (this._$_playbackRate$_ > 0 ? this._$_playheadTime$_ >= h && (this._$_SetTime$_(h), 
            this._$SetPlaybackRate$_(-1 * this._$GetPlaybackRate$_()), o = !0, 0 === this._$_pingPongState$_ && (this._$_TweenTrigger$_(ug._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenPingPong$_), 
            this._$_TweenTrigger$_(ug._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensPingPong$_)), 
            1 === this._$_pingPongState$_ && (this._$_TweenTrigger$_(ug._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenLoop$_), 
            this._$_TweenTrigger$_(ug._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensLoop$_), this._$_TweenTrigger$_(ug._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenPingPong$_), 
            this._$_TweenTrigger$_(ug._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensPingPong$_)), 
            this.IsPlaying() ? (this._$_pingPongState$_++, this._$_pingPongState$_ = ug.wrap(this._$_pingPongState$_, 0, 2)) : (this._$_resumePingPongState$_ = this._$_pingPongState$_ + 1, 
            this._$_resumePingPongState$_ = ug.wrap(this._$_resumePingPongState$_, 0, 2))) : this._$_playheadTime$_ <= 0 && (this._$_SetTime$_(0), 
            this._$SetPlaybackRate$_(-1 * this._$GetPlaybackRate$_()), o = !0, 0 === this._$_pingPongState$_ && (this._$_TweenTrigger$_(ug._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenPingPong$_), 
            this._$_TweenTrigger$_(ug._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensPingPong$_)), 
            1 === this._$_pingPongState$_ && (this._$_TweenTrigger$_(ug._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenLoop$_), 
            this._$_TweenTrigger$_(ug._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensLoop$_), this._$_TweenTrigger$_(ug._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenPingPong$_), 
            this._$_TweenTrigger$_(ug._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensPingPong$_)), 
            this.IsPlaying() ? (this._$_pingPongState$_++, this._$_pingPongState$_ = ug.wrap(this._$_pingPongState$_, 0, 2)) : (this._$_resumePingPongState$_ = this._$_pingPongState$_ + 1, 
            this._$_resumePingPongState$_ = ug.wrap(this._$_resumePingPongState$_, 0, 2)))) : this._$_playbackRate$_ > 0 ? this._$_playheadTime$_ >= h && (this._$_currentRepeatCount$_ < this._$GetRepeatCount$_() ? (this._$_currentRepeatCount$_++, 
            this._$_SetTimeAndReset$_(0), this._$_TweenTrigger$_(ug._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenLoop$_), 
            this._$_TweenTrigger$_(ug._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensLoop$_), o = !0) : (this._$_SetTime$_(h), 
            r = !0)) : this._$_playheadTime$_ <= 0 && (this._$_currentRepeatCount$_ < this._$GetRepeatCount$_() ? (this._$_currentRepeatCount$_++, 
            this._$_SetTimeAndReset$_(h), this._$_TweenTrigger$_(ug._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenLoop$_), 
            this._$_TweenTrigger$_(ug._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensLoop$_), o = !0) : (this._$_SetTime$_(0), 
            r = !0)), this.IsPlaying()) {
                if (r) return this._$_track$_._$SetEndState$_(), this._$Stop$_(!0), void this._$OnCompleted$_();
                this._$_track$_._$Interpolate$_(this._$_playheadTime$_, !0, !1, o, this._$_firstTick$_, !1), 
                this._$_firstTick$_ && (this._$_firstTick$_ = !1);
            }
        }
        _$_TweenTrigger$_(t) {
            const s = this._$GetInstance$_(), i = s._$GetBehaviorSdkInstanceFromCtor$_(ug._$Behaviors$_._$Tween$_);
            i._$PushTriggerTween$_(this), this._$_runtime$_._$Trigger$_(t, s, i._$GetBehaviorType$_()), 
            i._$PopTriggerTween$_();
        }
        _$_SaveToJson$_() {
            const t = super._$_SaveToJson$_(), s = this._$GetTimelineDataItem$_();
            return Object.assign(t, {
                tweenDataItemJson: s._$_SaveToJson$_(),
                id: this._$_id$_,
                destroyInstanceOnComplete: this._$_destroyInstanceOnComplete$_,
                initialValueMode: this._$_initialValueMode$_
            });
        }
        _$_LoadFromJson$_(t) {
            t && (this._$GetTimelineDataItem$_()._$_LoadFromJson$_(t.tweenDataItemJson), super._$_LoadFromJson$_(t), 
            this._$_id$_ = t.id, this._$_destroyInstanceOnComplete$_ = t.destroyInstanceOnComplete, 
            this._$_initialValueMode$_ = t.initialValueMode, this._$_CacheTrack$_());
        }
        static IsPlaying(t) {
            return t.IsPlaying();
        }
        static _$IsPaused$_(t) {
            return t._$IsPaused$_();
        }
        static _$IsPing$_(t) {
            return !!t._$GetPingPong$_() && 0 === t._$GetPingPongState$_();
        }
        static _$IsPong$_(t) {
            return !!t._$GetPingPong$_() && 1 === t._$GetPingPongState$_();
        }
        static _$Build$_(t) {
            const s = t.runtime._$GetTimelineManager$_(), i = new ug._$TimelineDataItem$_;
            if (t.json) {
                i._$_LoadFromJson$_(t.json.tweenDataItemJson);
                const e = new ug._$TweenState$_(i, s);
                return e._$_LoadFromJson$_(t.json), e;
            }
            {
                const e = new ug._$TweenState$_(i, s);
                ug._$IsArray$_(t._$propertyTracksConfig$_) || (t._$propertyTracksConfig$_ = [ t._$propertyTracksConfig$_ ]), 
                e._$SetId$_(t.id), e._$SetTags$_(t.tags), e._$SetInitialValueMode$_(t._$initialValueMode$_), 
                e._$SetDestroyInstanceOnComplete$_(t._$releaseOnComplete$_), e._$SetLoop$_(t.loop), 
                e._$SetPingPong$_(t._$pingPong$_), e._$SetTotalTime$_(t.time), e._$SetStep$_(0), 
                e._$SetInterpolationMode$_("default"), e._$SetResultMode$_(t._$propertyTracksConfig$_[0]._$resultMode$_), 
                e._$SetRepeatCount$_(t._$repeatCount$_);
                const n = e._$AddTrack$_();
                n._$SetInstanceUID$_(t._$instance$_._$GetUID$_()), n._$SetInterpolationMode$_("default"), 
                n._$SetResultMode$_(t._$propertyTracksConfig$_[0]._$resultMode$_), n._$SetEnable$_(!0), 
                n._$SetObjectClassIndex$_(t._$instance$_._$GetObjectClass$_()._$GetIndex$_());
                const h = t._$instance$_._$GetSdkInstance$_(), r = h._$IsOriginalSizeKnown$_() ? h._$GetOriginalWidth$_() : t._$instance$_._$GetWorldInfo$_()._$GetWidth$_(), o = h._$IsOriginalSizeKnown$_() ? h._$GetOriginalHeight$_() : t._$instance$_._$GetWorldInfo$_()._$GetHeight$_();
                n._$SetOriginalWidth$_(r), n._$SetOriginalHeight$_(o);
                const a = n._$AddKeyframe$_();
                a._$SetTime$_(0), a._$SetEase$_("noease"), a._$SetEnable$_(!0), a._$SetTags$_("");
                const u = n._$AddKeyframe$_();
                u._$SetTime$_(t.time), u._$SetEase$_("noease"), u._$SetEnable$_(!0), u._$SetTags$_("");
                for (const s of t._$propertyTracksConfig$_) {
                    const i = n._$AddPropertyTrack$_();
                    i._$SetSourceAdapterId$_(s._$sourceId$_), i._$SetSourceAdapterArgs$_(s._$sourceArgs$_), 
                    i._$SetPropertyName$_(s._$property$_), i._$SetPropertyType$_(s.type), i._$SetMin$_(NaN), 
                    i._$SetMax$_(NaN), i._$SetInterpolationMode$_("default"), i._$SetResultMode$_(s._$resultMode$_), 
                    i._$SetEnable$_(!0);
                    const e = i._$AddPropertyKeyframe$_();
                    e._$SetType$_(s.valueType), e._$SetTime$_(0), e._$SetEase$_(s._$ease$_), e._$SetEnable$_(!0), 
                    e._$SetValue$_(s._$startValue$_), e._$SetAbsoluteValue$_(s._$startValue$_);
                    const h = i._$AddPropertyKeyframe$_();
                    h._$SetType$_(s.valueType), h._$SetTime$_(t.time), h._$SetEase$_(s._$ease$_), h._$SetEnable$_(!0), 
                    h._$SetValue$_(s._$endValue$_), h._$SetAbsoluteValue$_(s._$endValue$_), i._$GetSourceAdapter$_();
                }
                return e;
            }
        }
        static _$SetInstanceUID$_(t, s) {
            if (!isNaN(s)) for (const i of t._$GetTracks$_()) i._$SetInstanceUID$_(s);
        }
        _$GetITweenState$_(t, s) {
            return this._$_iTweenState$_ || (this._$_iTweenState$_ = ug._$New$_(self._$ITweenState$_, this, t, s)), 
            this._$_iTweenState$_;
        }
    };
}

{
    const cg = self._$C3$_;
    cg._$TweenTrackState$_ = class extends cg._$TrackState$_ {
        constructor(t, s) {
            super(t, s), this._$_firstPropertyTrack$_ = null, this._$_secondPropertyTrack$_ = null;
        }
        static _$Create$_(t, s) {
            return cg._$New$_(cg._$TweenTrackState$_, t, s);
        }
        _$_CachePropertyTracks$_() {
            1 === this._$_propertyTracks$_.length ? this._$_firstPropertyTrack$_ = this._$_propertyTracks$_[0] : (this._$_firstPropertyTrack$_ = this._$_propertyTracks$_[0], 
            this._$_secondPropertyTrack$_ = this._$_propertyTracks$_[1]);
        }
        _$CreatePropertyTrackStates$_() {
            for (const t of this._$_trackDataItem$_._$GetPropertyTrackData$_()._$propertyTrackDataItems$_()) this._$_propertyTracks$_.push(cg._$TweenPropertyTrackState$_._$Create$_(this, t));
            this._$_CachePropertyTracks$_();
        }
        _$AddPropertyTrack$_() {
            const t = this._$_trackDataItem$_._$GetPropertyTrackData$_()._$AddEmptyPropertyTrackDataItem$_(), s = cg._$TweenPropertyTrackState$_._$Create$_(this, t);
            return this._$_propertyTracks$_.push(s), this._$_CachePropertyTracks$_(), s;
        }
        _$SetInitialState$_() {
            if (this._$MaybeGetInstance$_(), !this._$IsInstanceValid$_() && this._$IsInstanceTrack$_()) return;
            const t = this._$GetTimeline$_()._$IsForwardPlayBack$_() ? 0 : this._$GetLocalTotalTime$_();
            for (const s of this._$_propertyTracks$_) s._$SetInitialState$_(t), 0 === this._$_worldInfoChange$_ && 1 === s._$GetWorldInfoChange$_() && (this._$_worldInfoChange$_ = 1), 
            0 === this._$_renderChange$_ && 1 === s._$GetRenderChange$_() && (this._$_renderChange$_ = 1);
            this._$_needsBeforeAndAfter$_ = 0, this._$_propertyTracks$_.some((t => t._$GetNeedsBeforeAndAfter$_())) && (this._$_needsBeforeAndAfter$_ = 1), 
            this._$_lastKeyframeDataItem$_ = this._$_GetLastKeyFrameBeforeTime$_(t), this._$_initialStateOfNestedSet$_ = !1, 
            this._$_endStateOfNestedSet$_ = !1, this._$Interpolate$_(t);
        }
        _$BeforeInterpolate$_() {}
        _$Interpolate$_(t, s = !1, i = !1, e = !1, n = !1, h = !1, r = !1) {
            if (this._$_instance$_ || this._$GetInstance$_(), this._$_instance$_) return !this._$_instance$_._$IsDestroyed$_() && (!h || !this._$GetObjectClass$_()._$IsGlobal$_()) && (this._$_secondPropertyTrack$_ ? (this._$_firstPropertyTrack$_._$Interpolate$_(t, i, e, r), 
            this._$_secondPropertyTrack$_._$Interpolate$_(t, i, e, r)) : this._$_firstPropertyTrack$_._$Interpolate$_(t, i, e, r), 
            void (0 !== this._$_firstPropertyTrack$_._$GetWorldInfoChange$_() && (this._$_worldInfo$_ || (this._$_worldInfo$_ = this._$_instance$_._$GetWorldInfo$_()), 
            this._$_worldInfo$_ && this._$_worldInfo$_._$SetBboxChanged$_())));
        }
        _$AfterInterpolate$_() {}
        _$_LoadFromJson$_(t) {
            super._$_LoadFromJson$_(t), this._$_CachePropertyTracks$_();
        }
    };
}

{
    const fg = self._$C3$_;
    fg._$TweenPropertyTrackState$_ = class extends fg._$PropertyTrackState$_ {
        constructor(t, s) {
            super(t, s), this._$_basic$_ = !1;
        }
        static _$Create$_(t, s) {
            return fg._$New$_(fg._$TweenPropertyTrackState$_, t, s);
        }
        _$Interpolate$_(t, s = !1, i = !1, e = !1) {
            let n, h;
            if (this._$_basic$_) n = this._$_propertyKeyframeDataItems$_[0], h = this._$_propertyKeyframeDataItems$_[1]; else if (s) n = this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, this._$_propertyTrackDataItem$_), 
            h = n._$GetNext$_(); else {
                if (this._$_lastPropertyKeyframeDataItem$_) {
                    const s = this._$GetTimeline$_(), i = this._$_lastPropertyKeyframeDataItem$_._$GetNext$_(), e = this._$_lastPropertyKeyframeDataItem$_._$GetTime$_(), n = i ? i._$GetTime$_() : s._$GetTotalTime$_();
                    (t <= e || t >= n) && (this._$_lastPropertyKeyframeDataItem$_ = this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, this._$_propertyTrackDataItem$_));
                } else this._$_lastPropertyKeyframeDataItem$_ = this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, this._$_propertyTrackDataItem$_);
                n = this._$_lastPropertyKeyframeDataItem$_, h = n._$GetNext$_();
            }
            this._$_sourceAdapter$_._$Interpolate$_(t, n, h, s, i, e);
        }
        _$AddPropertyKeyframe$_() {
            const t = this._$_propertyTrackDataItem$_._$GetPropertyKeyframeData$_()._$AddEmptyPropertyKeyframeDataItem$_();
            return this._$_lastPropertyKeyframeDataItem$_ = null, this._$_basic$_ = this._$GetPropertyKeyframeDataItems$_().length <= 2, 
            t;
        }
        _$DeletePropertyKeyframes$_(t) {
            this._$_lastPropertyKeyframeDataItem$_ = null, this._$_propertyTrackDataItem$_._$GetPropertyKeyframeData$_()._$DeletePropertyKeyframeDataItems$_(t), 
            this._$_basic$_ = this._$GetPropertyKeyframeDataItems$_().length <= 2;
        }
        _$_SaveToJson$_() {
            return {
                sourceAdapterJson: this._$GetSourceAdapter$_()._$_SaveToJson$_(),
                basic: this._$_basic$_
            };
        }
        _$_LoadFromJson$_(t) {
            t && (this._$GetSourceAdapter$_()._$_LoadFromJson$_(t.sourceAdapterJson), this._$_basic$_ = t.basic);
        }
    };
}

{
    const dg = self._$C3$_, pg = self._$Ease$_;
    dg._$Transition$_ = class extends dg._$DefendedBase$_ {
        constructor(t, s = !0) {
            super(), this._$_name$_ = t[0], this._$_linear$_ = t[2], this._$_transitionKeyframes$_ = [];
            for (const s of t[1]) {
                const t = dg._$TransitionKeyframe$_._$Create$_(this, s);
                this._$_transitionKeyframes$_.push(t);
            }
            for (let t = 0; t < this._$_transitionKeyframes$_.length; t++) {
                const s = this._$_transitionKeyframes$_[t], i = this._$_transitionKeyframes$_[t + 1], e = this._$_transitionKeyframes$_[t - 1];
                s._$SetNext$_(i), s._$SetPrevious$_(e);
            }
            this._$_precalculatedSamples$_ = new Map, this._$_transitionKeyframeCache$_ = new Map, 
            this._$_PreCalcSamples$_(), s && pg._$AddCustomEase$_(this._$_name$_, ((t, s, i, e) => this._$Interpolate$_(t, s, i, e)), null, {
                transition: this
            });
        }
        static _$Create$_(t) {
            return dg._$New$_(dg._$Transition$_, t);
        }
        _$Release$_() {
            for (const t of this._$_transitionKeyframes$_) t._$Release$_();
            dg._$clearArray$_(this._$_transitionKeyframes$_), this._$_transitionKeyframes$_ = null, 
            this._$_precalculatedSamples$_.clear(), this._$_precalculatedSamples$_ = null, this._$_transitionKeyframeCache$_.clear(), 
            this._$_transitionKeyframeCache$_ = null;
        }
        _$MakeLinear$_(t) {
            this._$_linear$_ = !!t;
        }
        _$GetTransitionKeyFrameAt$_(t) {
            const s = this._$_transitionKeyframeCache$_.get(t);
            if (s) return s;
            for (const s of this._$_transitionKeyframes$_) if (s._$GetValueX$_() === t) return this._$_transitionKeyframeCache$_.set(t, s), 
            s;
        }
        _$GetFirstTransitionKeyFrameLowerOrEqualThan$_(t) {
            for (let s = this._$_transitionKeyframes$_.length - 1; s >= 0; s--) {
                const i = this._$_transitionKeyframes$_[s], e = i._$GetValueX$_();
                if (e <= t) {
                    let s = i;
                    if (e < t) return s;
                    if (e === t) {
                        for (;s; ) {
                            const t = s._$GetPrevious$_();
                            if (!t) break;
                            if (t._$GetValueX$_() !== s._$GetValueX$_()) break;
                            s = t;
                        }
                        return s;
                    }
                }
            }
        }
        _$Interpolate$_(t, s, i, e) {
            let n = t / e;
            if (this._$_linear$_) {
                const n = this._$GetTransitionKeyFrameAt$_(0), h = this._$GetTransitionKeyFrameAt$_(1), r = s + (s + i) * n._$GetValueY$_(), o = (s + i) * h._$GetValueY$_() - r;
                return 0 === e ? r + o : pg._$NoEase$_(t, r, o, e);
            }
            0 === e && (n = 1);
            let h = this._$GetFirstTransitionKeyFrameLowerOrEqualThan$_(n), r = h._$GetNext$_();
            if (!r) {
                const t = h._$GetPrevious$_(), s = h;
                h = t, r = s;
            }
            const o = r._$GetValueX$_() - h._$GetValueX$_(), a = dg._$mapToRange$_(n, h._$GetValueX$_(), r._$GetValueX$_(), 0, o);
            if (h._$IsSegmentLinear$_() || 0 === o) {
                const t = s + (s + i) * h._$GetValueY$_(), e = (s + i) * r._$GetValueY$_() - t;
                return 0 === o ? 1 === a ? t + e : t : pg._$NoEase$_(a, t, e, o);
            }
            const u = h._$GetValueX$_(), l = h._$GetValueY$_(), c = h._$GetValueX$_() + h._$GetStartAnchorX$_(), f = h._$GetValueY$_() + h._$GetStartAnchorY$_(), d = r._$GetValueX$_() + r._$GetEndAnchorX$_(), p = r._$GetValueY$_() + r._$GetEndAnchorY$_(), m = r._$GetValueX$_(), g = r._$GetValueY$_();
            let y = pg._$GetRuntimeEase$_("spline")(a, u, l, c, f, d, p, m, g, this._$_precalculatedSamples$_.get(h));
            return y += h._$GetValueY$_(), (1 - y) * s + y * (s + i);
        }
        _$_PreCalcSamples$_() {
            this._$_precalculatedSamples$_.clear();
            for (let t = 0; t < this._$_transitionKeyframes$_.length - 1; t++) {
                const s = this._$_transitionKeyframes$_[t];
                if (!s._$GetStartEnable$_()) continue;
                const i = s, e = this._$_transitionKeyframes$_[t + 1];
                if (!e._$GetEndEnable$_()) continue;
                const n = i._$GetValueX$_(), h = i._$GetValueX$_() + i._$GetStartAnchorX$_(), r = e._$GetValueX$_() + e._$GetEndAnchorX$_(), o = e._$GetValueX$_();
                this._$_precalculatedSamples$_.set(i, pg._$GetBezierSamples$_(n, h, r, o));
            }
        }
    };
}

{
    const mg = self._$C3$_;
    mg._$TransitionKeyframe$_ = class extends mg._$DefendedBase$_ {
        constructor(t, s) {
            super(), this._$_transition$_ = t, this._$_valueX$_ = s[0], this._$_valueY$_ = s[1], 
            this._$_startAnchorX$_ = s[2], this._$_startAnchorY$_ = s[3], this._$_endAnchorX$_ = s[4], 
            this._$_endAnchorY$_ = s[5], this._$_startEnable$_ = s[6], this._$_endEnable$_ = s[7], 
            this._$_segmentMode$_ = s[8], this._$_next$_ = null, this._$_prev$_ = null;
        }
        _$Release$_() {
            this._$_transition$_ = null;
        }
        static _$Create$_(t, s) {
            return mg._$New$_(mg._$TransitionKeyframe$_, t, s);
        }
        _$SetNext$_(t) {
            this._$_next$_ = t;
        }
        _$GetNext$_() {
            return this._$_next$_;
        }
        _$SetPrevious$_(t) {
            this._$_prev$_ = t;
        }
        _$GetPrevious$_() {
            return this._$_prev$_;
        }
        _$GetValueX$_() {
            return this._$_valueX$_;
        }
        _$GetValueY$_() {
            return this._$_valueY$_;
        }
        _$GetStartAnchorX$_() {
            return this._$_startAnchorX$_;
        }
        _$GetStartAnchorY$_() {
            return this._$_startAnchorY$_;
        }
        _$GetEndAnchorX$_() {
            return this._$_endAnchorX$_;
        }
        _$GetEndAnchorY$_() {
            return this._$_endAnchorY$_;
        }
        _$GetStartEnable$_() {
            return this._$_startEnable$_;
        }
        _$GetEndEnable$_() {
            return this._$_endEnable$_;
        }
        _$IsSegmentLinear$_() {
            return "linear" === this._$_segmentMode$_;
        }
        _$IsSegmentCubic$_() {
            return "cubic" === this._$_segmentMode$_;
        }
    };
}

{
    const gg = self._$C3$_;
    gg._$TransitionManager$_ = class extends gg._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_runtime$_ = t, this._$_transitions$_ = [];
        }
        _$Release$_() {
            for (const t of this._$_transitions$_) t._$Release$_();
            gg._$clearArray$_(this._$_transitions$_), this._$_transitions$_ = null;
        }
        _$Create$_(t) {
            this._$_transitions$_.push(gg._$Transition$_._$Create$_(t));
        }
    };
}

{
    const yg = self._$C3$_;
    yg._$TemplateManager$_ = class extends yg._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_runtime$_ = t, this._$_templateDataMap$_ = null, this._$_instanceToTemplateNameMap$_ = null, 
            this._$_instanceDestroy$_ = t => this._$_OnInstanceDestroy$_(t._$instance$_);
        }
        _$Release$_() {
            if (this._$RemoveRuntimeListeners$_(), this._$_templateDataMap$_) {
                for (const t of this._$_templateDataMap$_.values()) t.clear();
                this._$_templateDataMap$_.clear();
            }
            this._$_templateDataMap$_ = null, this._$_runtime$_ = null;
        }
        _$Create$_(t) {
            if (this._$_templateDataMap$_ || (this._$_templateDataMap$_ = new Map), !t) return;
            const s = t[0][16][0], i = t[1];
            this._$_templateDataMap$_.has(i) || this._$_templateDataMap$_.set(i, new Map), this._$_templateDataMap$_.get(i).set(s, t);
        }
        _$AddRuntimeListeners$_() {
            const t = this._$_runtime$_._$Dispatcher$_();
            t && t.addEventListener("instancedestroy", this._$_instanceDestroy$_);
        }
        _$RemoveRuntimeListeners$_() {
            const t = this._$_runtime$_._$Dispatcher$_();
            t && t.removeEventListener("instancedestroy", this._$_instanceDestroy$_);
        }
        _$HasTemplates$_() {
            return !!this._$_templateDataMap$_ && 0 !== this._$_templateDataMap$_.size;
        }
        _$GetTemplateData$_(t, s) {
            let i = 0;
            if (i = t instanceof yg._$ObjectClass$_ ? t._$GetIndex$_() : t, !this._$_templateDataMap$_.has(i)) return;
            const e = this._$_templateDataMap$_.get(i).get(s);
            return e ? JSON.parse(JSON.stringify(e)) : void 0;
        }
        _$MapInstanceToTemplateName$_(t, s) {
            this._$_instanceToTemplateNameMap$_ || (this._$_instanceToTemplateNameMap$_ = new WeakMap), 
            this._$_instanceToTemplateNameMap$_.has(t) || this._$_instanceToTemplateNameMap$_.set(t, s);
        }
        _$GetInstanceTemplateName$_(t) {
            if (!this._$_instanceToTemplateNameMap$_) return "";
            return this._$_instanceToTemplateNameMap$_.get(t) || "";
        }
        _$_OnInstanceDestroy$_(t) {
            this._$_instanceToTemplateNameMap$_ && this._$_instanceToTemplateNameMap$_.has(t) && this._$_instanceToTemplateNameMap$_.delete(t);
        }
    };
}

{
    const Mg = self._$C3$_;
    Mg._$FlowchartManager$_ = class {
        constructor(t) {
            this._$_runtime$_ = t, this._$_flowchartDataManager$_ = new Mg._$FlowchartDataManager$_;
        }
        _$Release$_() {
            this._$_flowchartDataManager$_._$Release$_(), this._$_flowchartDataManager$_ = null, 
            this._$_runtime$_ = null;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$Create$_(t) {
            this._$_flowchartDataManager$_._$Add$_(t);
        }
        _$GetFlowchartDataItemByName$_(t) {
            return this._$_flowchartDataManager$_._$Get$_(t);
        }
        _$HasFlowcharts$_() {
            return this._$_flowchartDataManager$_._$HasFlowcharts$_();
        }
    };
}

{
    const wg = self._$C3$_;
    wg._$FlowchartState$_ = class {
        constructor(t, s, i, e, n, h, r) {
            this._$_runtime$_ = n._$GetRuntime$_(), this._$_flowchartManager$_ = n, this._$_flowchartName$_ = t, 
            this._$_startNodeTag$_ = i, this._$_flowchartDataItem$_ = e, this._$_tag$_ = s, 
            this._$_pluginInstance$_ = h, this._$_pluginUID$_ = r ?? h._$GetInstance$_()._$GetUID$_(), 
            this._$_SetStartFlowchartNode$_(), this._$_currentFlowchartNodeId$_ = this._$_startFlowchartNode$_?._$GetFlowchartId$_() ?? -1, 
            this._$_previousFlowchartNodeIds$_ = [], this._$_previousFlowchartState$_ = null, 
            this._$_previousFlowchartStateStartNodeId$_ = NaN, this._$_referenceFlowchartStates$_ = null, 
            this._$_currentReferenceFlowchartState$_ = null, this._$_rootFlowchartState$_ = null, 
            this._$_previousFlowchartStateTag$_ = "", this._$_referenceFlowchartStatesJson$_ = null, 
            this._$_currentReferenceFlowchartStateTag$_ = "", this._$_rootFlowchartStateTag$_ = "", 
            this._$_triggerCount$_ = 0, this._$_markForRelease$_ = !1, this._$_released$_ = !1;
        }
        _$Release$_() {
            this._$_released$_ || (wg._$clearArray$_(this._$_previousFlowchartNodeIds$_), this._$_previousFlowchartNodeIds$_ = null, 
            this._$_runtime$_ = null, this._$_flowchartManager$_ = null, this._$_flowchartDataItem$_ = null, 
            this._$_pluginInstance$_ = null, this._$_previousFlowchartState$_ = null, this._$_previousFlowchartStateStartNodeId$_ = NaN, 
            this._$_referenceFlowchartStates$_ && this._$_referenceFlowchartStates$_.clear(), 
            this._$_referenceFlowchartStates$_ = null, this._$_currentReferenceFlowchartState$_ = null, 
            this._$_rootFlowchartState$_ = null, this._$_previousFlowchartStateTag$_ = "", this._$_referenceFlowchartStatesJson$_ = null, 
            this._$_currentReferenceFlowchartStateTag$_ = "", this._$_rootFlowchartStateTag$_ = "", 
            this._$_released$_ = !0);
        }
        _$WasReleased$_() {
            return this._$_released$_;
        }
        _$GetFlowchartManager$_() {
            return this._$_flowchartManager$_;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetName$_() {
            return this._$_flowchartName$_;
        }
        _$GetFlowchartDataItem$_() {
            return this._$_flowchartDataItem$_;
        }
        _$GetTag$_() {
            return this._$_tag$_;
        }
        _$GetPluginInstance$_() {
            return this._$_pluginInstance$_ || (this._$_pluginInstance$_ = this._$_runtime$_._$GetInstanceByUID$_(this._$_pluginUID$_)._$GetSdkInstance$_()), 
            this._$_pluginInstance$_;
        }
        _$GetCurrentNode$_() {
            return this._$GetFlowchartElementById$_(this._$_currentFlowchartNodeId$_);
        }
        _$GetCurrentNodeTag$_() {
            const t = this._$GetCurrentNode$_();
            return t ? t._$GetTag$_() : "";
        }
        _$GetCurrentNodeTags$_() {
            const t = this._$GetCurrentNode$_();
            return t ? t._$GetTags$_() : [];
        }
        _$CurrentNodeHasTags$_(t) {
            const s = this._$GetCurrentNodeTags$_();
            if (!s) return !1;
            if (!s.length) return !1;
            const i = wg._$FlowchartState$_._$_GetTagArray$_(t);
            return !(!i || !i.length) && i.every(wg._$FlowchartState$_._$_HasTag$_, s);
        }
        _$CurrentNodeCompareTags$_(t, s) {
            const i = this._$GetCurrentNodeTags$_();
            if (!i) return !1;
            if (!i.length) return !1;
            const e = wg._$FlowchartState$_._$_GetTagArray$_(t);
            return !(!e || !e.length) && e.every((t => wg._$FlowchartState$_._$_CompareTag$_.call(i, t, s)));
        }
        static _$_HasTag$_(t) {
            const s = this;
            return "" === t ? 1 === s.length && "" === s[0] : s.map((t => t.trim().toLowerCase())).includes(t.trim().toLowerCase());
        }
        static _$_GetTagArray$_(t) {
            return t.trim().split(" ");
        }
        static _$_CompareTag$_(t, s) {
            const i = this;
            return "" === t ? 1 === i.length && "" === i[0] : i.some((i => wg.compare(i.trim(), s, t.trim())));
        }
        _$GetCurrentNodeParent$_(t) {
            const s = this._$GetCurrentNode$_();
            if (s) {
                if (wg._$IsFiniteNumber$_(t)) {
                    const i = s._$GetParentFlowchartIds$_(), e = i ? i[t] : void 0;
                    if (wg._$IsFiniteNumber$_(e)) return this._$GetFlowchartElementById$_(e);
                }
                if ("string" == typeof t) for (const i of s._$GetParentFlowchartIds$_()) {
                    const s = this._$GetFlowchartElementById$_(i);
                    if (s._$HasTags$_(t)) return this._$GetFlowchartElementById$_(s._$GetFlowchartId$_());
                }
            }
        }
        _$GetCurrentNodeParentTag$_(t) {
            const s = this._$GetCurrentNodeParent$_(t);
            return s ? s._$GetTag$_() : "";
        }
        _$GetCurrentNodeParentTags$_(t) {
            const s = this._$GetCurrentNodeParent$_(t);
            return s ? s._$GetTags$_() : "";
        }
        _$GetCurrentNodeParentIndex$_(t) {
            const s = this._$GetCurrentNode$_();
            if (!s) return -1;
            const i = s._$GetParentFlowchartIds$_();
            if (!i) return -1;
            const e = this._$GetCurrentNodeParent$_(t);
            return e ? i.indexOf(e._$GetFlowchartId$_()) : -1;
        }
        _$GetCurrentNodeParentCount$_() {
            const t = this._$GetCurrentNode$_();
            if (!t) return 0;
            const s = t._$GetParentFlowchartIds$_();
            return s ? s.length : 0;
        }
        _$GetFlowchartElementById$_(t) {
            return this._$_flowchartDataItem$_._$GetFlowchartElementById$_(t);
        }
        _$Reset$_() {
            this._$_GetRootFlowchartState$_()._$_Reset$_(!0);
        }
        _$_Reset$_(t) {
            if (this._$_GetReferenceFlowchartStates$_()) {
                for (const [t, s] of this._$_GetReferenceFlowchartStates$_().entries()) s._$_Reset$_(!1);
                this._$_GetReferenceFlowchartStates$_().clear();
            }
            if (this._$_referenceFlowchartStates$_ = null, this._$_previousFlowchartState$_ = null, 
            this._$_previousFlowchartStateStartNode$_ = null, this._$_currentReferenceFlowchartState$_ = null, 
            this._$_previousFlowchartStateTag$_ = "", this._$_referenceFlowchartStatesJson$_ = null, 
            this._$_currentReferenceFlowchartStateTag$_ = "", this._$_rootFlowchartStateTag$_ = "", 
            this._$_previousFlowchartNodeIds$_ = [], t) {
                this._$_flowchartManager$_._$SetCurrentFlowchartState$_(this);
                const t = this._$_startFlowchartNode$_._$GetFlowchartId$_();
                t !== this._$_currentFlowchartNodeId$_ && this._$_GotoFlowchartNode$_(t);
            } else this._$_currentFlowchartNodeId$_ = this._$_startFlowchartNode$_._$GetFlowchartId$_();
        }
        _$GetCurrentNodeOutputCount$_() {
            const t = this._$_flowchartDataItem$_._$GetFlowchartElementById$_(this._$_currentFlowchartNodeId$_);
            return t ? t._$GetFlowchartNodeOutputData$_()._$GetFlowchartNodeOutputDataItemCount$_() : 0;
        }
        _$IsIndexOfDefaultOutput$_(t) {
            return !(t < 0) && t === this._$GetDefaultOutputIndex$_();
        }
        _$GetDefaultOutputIndex$_() {
            const t = this._$_flowchartDataItem$_._$GetFlowchartElementById$_(this._$_currentFlowchartNodeId$_);
            if (!t) return -1;
            let s = t._$GetFlowchartNodeOutputData$_()._$GetFlowchartNodeOutputDefault$_();
            return s ? t._$GetFlowchartNodeOutputData$_()._$GetFlowchartNodeOutputDataItems$_().indexOf(s) : -1;
        }
        _$GetCurrentNodeOutputNameAt$_(t) {
            const s = this._$_GetFlowchartNodeOutputAt$_(t);
            return s ? s._$GetName$_() : "";
        }
        _$GetCurrentNodeOutputValueAt$_(t) {
            let s;
            return wg._$IsFiniteNumber$_(t) && (s = this._$_GetFlowchartNodeOutputAt$_(t)), 
            "string" == typeof t && (s = this._$_GetFlowchartNodeOutputByName$_(t)), "number" != typeof t && "string" != typeof t && console.warn("[Flowcharts] unexpected argument type in GetCurrentNodeOutputValueAt expression"), 
            s ? s._$GetValue$_() : "";
        }
        _$_MaybeByPassNodes$_(t, s) {
            if (t._$GetEnable$_()) return t._$GetFlowchartId$_();
            {
                const i = t._$GetFlowchartNodeOutputData$_()._$GetFlowchartNodeOutputDefault$_();
                if (!i) return s._$GetFlowchartId$_();
                const e = i._$GetConnectedFlowchartNodeFlowchartId$_();
                if (!wg._$IsFiniteNumber$_(e)) return s._$GetFlowchartId$_();
                const n = this._$GetFlowchartElementById$_(e);
                return n ? this._$_MaybeByPassNodes$_(n, s) : s._$GetFlowchartId$_();
            }
        }
        _$_MaybeByPassNodesInReferenceFlowchart$_(t, s) {
            if (t._$GetEnable$_()) {
                if ("reference" === t._$GetType$_()) {
                    const s = t._$GetReferenceFlowchartName$_(), i = t._$GetReferenceFlowchartStartNodeTag$_(), e = this._$_flowchartManager$_._$GetFlowchartDataItemByName$_(s);
                    if (!e) return [ -1, null ];
                    const n = e._$GetFlowchartNodeByTags$_(i);
                    return n ? this._$_MaybeByPassNodesInReferenceFlowchart$_(n, e) : this._$_MaybeByPassNodesInReferenceFlowchart$_(e._$GetFlowchartStartNode$_(), e);
                }
                return [ t._$GetFlowchartId$_(), s ];
            }
            {
                const i = t._$GetFlowchartNodeOutputData$_()._$GetFlowchartNodeOutputDefault$_();
                if (!i) return [ -1, null ];
                const e = i._$GetConnectedFlowchartNodeFlowchartId$_();
                if (!wg._$IsFiniteNumber$_(e)) return [ -1, null ];
                const n = s._$GetFlowchartElementById$_(e);
                return n ? this._$_MaybeByPassNodesInReferenceFlowchart$_(n, s) : [ -1, null ];
            }
        }
        _$_ProcessAllByPasses$_(t, s) {
            let i = this._$GetFlowchartElementById$_(t);
            if (i) {
                if (!i._$GetEnable$_()) {
                    const s = this._$GetFlowchartElementById$_(this._$_currentFlowchartNodeId$_);
                    t = this._$_MaybeByPassNodes$_(i, s);
                }
                if (wg._$IsFiniteNumber$_(t) && t !== this._$_currentFlowchartNodeId$_) if (i = this._$GetFlowchartElementById$_(t), 
                "reference" === i._$GetType$_()) {
                    const e = i._$GetReferenceFlowchartName$_(), n = i._$GetReferenceFlowchartStartNodeTag$_(), h = this._$_flowchartManager$_._$GetFlowchartDataItemByName$_(e);
                    let r = h._$GetFlowchartNodeByTags$_(n);
                    if (r) {
                        const i = this._$_MaybeByPassNodesInReferenceFlowchart$_(r, h);
                        if (-1 === i[0]) return;
                        s(this._$_currentFlowchartNodeId$_, t, i[1], i[0]);
                    } else s(this._$_currentFlowchartNodeId$_, t);
                } else s(this._$_currentFlowchartNodeId$_, t);
            }
        }
        _$GotoNextFlowchartNode$_(t) {
            let s;
            if (wg._$IsFiniteNumber$_(t) && (s = this._$_GetFlowchartNodeOutputAt$_(t)), "string" == typeof t && (s = this._$_GetFlowchartNodeOutputByName$_(t)), 
            !s) return;
            let i = s._$GetConnectedFlowchartNodeFlowchartId$_();
            wg._$IsFiniteNumber$_(i) && this._$_ProcessAllByPasses$_(i, ((t, s, i, e) => {
                this._$_previousFlowchartNodeIds$_.push(t), this._$_GotoFlowchartNode$_(s, i, e);
            }));
        }
        _$GotoNextFlowchartNodeDefault$_() {
            const t = this._$_GetFlowchartNodeOutputDefault$_();
            if (!t) return;
            const s = t._$GetConnectedFlowchartNodeFlowchartId$_();
            wg._$IsFiniteNumber$_(s) && this._$_ProcessAllByPasses$_(s, ((t, s, i, e) => {
                this._$_previousFlowchartNodeIds$_.push(t), this._$_GotoFlowchartNode$_(s, i, e);
            }));
        }
        _$GotoAnyFlowchartNode$_(t) {
            const s = this._$_flowchartDataItem$_._$GetFlowchartNodeByTags$_(t);
            if (!s) return;
            const i = s._$GetFlowchartId$_();
            wg._$IsFiniteNumber$_(i) && this._$_ProcessAllByPasses$_(i, ((t, s, i, e) => {
                this._$_previousFlowchartNodeIds$_.push(t), this._$_GotoFlowchartNode$_(s, i, e);
            }));
        }
        _$GotoPreviousFlowchartNode$_() {
            const t = this._$_previousFlowchartNodeIds$_.pop();
            wg._$IsFiniteNumber$_(t) ? this._$_GotoFlowchartNode$_(t) : this._$_GetPreviousFlowchartState$_() && (this._$_flowchartManager$_._$SetCurrentFlowchartState$_(this._$_GetPreviousFlowchartState$_(), !0, !1, !1), 
            this._$_GetPreviousFlowchartState$_()._$_GotoFlowchartNode$_(this._$_GetPreviousFlowchartStateStartNodeId$_()), 
            this._$_GetRootFlowchartState$_()._$_SetCurrentReferenceFlowchart$_(this._$_GetPreviousFlowchartState$_()));
        }
        _$GotoParentFlowchartNode$_(t) {
            if (!this._$GetCurrentNode$_()) return;
            const s = this._$GetCurrentNodeParent$_(t);
            if (s) {
                if (!s._$GetEnable$_()) return;
                const t = s._$GetFlowchartId$_();
                if (!wg._$IsFiniteNumber$_(t)) return;
                this._$_previousFlowchartNodeIds$_.push(this._$_currentFlowchartNodeId$_), this._$_GotoFlowchartNode$_(s._$GetFlowchartId$_());
            }
        }
        _$HasOutput$_(t) {
            if (wg._$IsFiniteNumber$_(t)) return !!this._$_flowchartDataItem$_._$GetFlowchartElementById$_(this._$_currentFlowchartNodeId$_)._$GetFlowchartNodeOutputData$_()._$GetFlowchartNodeOutputDataItems$_()[t];
            if ("string" == typeof t) {
                const s = this._$_flowchartDataItem$_._$GetFlowchartElementById$_(this._$_currentFlowchartNodeId$_)._$GetFlowchartNodeOutputData$_()._$GetFlowchartNodeOutputDataItems$_();
                for (let i = 0; i < s.length; i++) if (s[i]._$GetName$_() === t) return !0;
                return !1;
            }
            return !1;
        }
        _$MarkForRelease$_() {
            this._$_markForRelease$_ = !0;
        }
        _$IsInTriggerState$_() {
            return this._$_triggerCount$_ > 0;
        }
        _$PushIsTriggerState$_() {
            this._$_triggerCount$_++;
        }
        _$PopIsTriggerState$_() {
            this._$_triggerCount$_--, 0 === this._$_triggerCount$_ && this._$_markForRelease$_ && this._$_flowchartManager$_._$RemoveFlowchartState$_(this);
        }
        _$_GotoFlowchartNode$_(t, s, i) {
            const e = this._$_currentFlowchartNodeId$_, n = this._$GetPluginInstance$_()._$GetInstance$_();
            this._$PushIsTriggerState$_(), this._$_flowchartManager$_._$PushFlowchartState$_(this), 
            this._$_runtime$_._$Trigger$_(wg._$Plugins$_._$Flowchart$_._$Cnds$_._$OnBeforeAnyNodeChange$_, n), 
            this._$_runtime$_._$Trigger$_(wg._$Plugins$_._$Flowchart$_._$Cnds$_._$OnBeforeTaggedNodeChange$_, n), 
            this._$_runtime$_._$Trigger$_(wg._$Plugins$_._$Flowchart$_._$Cnds$_._$OnBeforeAnyNodeChangeInFlowchart$_, n), 
            this._$_runtime$_._$Trigger$_(wg._$Plugins$_._$Flowchart$_._$Cnds$_._$OnBeforeTaggedNodeChangeInFlowchart$_, n), 
            this._$_currentFlowchartNodeId$_ = t;
            let h = this._$GetFlowchartElementById$_(this._$_currentFlowchartNodeId$_);
            if ("dictionary" === h._$GetType$_() && (this._$_runtime$_._$Trigger$_(wg._$Plugins$_._$Flowchart$_._$Cnds$_._$OnAnyNodeChange$_, n), 
            this._$_runtime$_._$Trigger$_(wg._$Plugins$_._$Flowchart$_._$Cnds$_._$OnTaggedNodeChange$_, n), 
            this._$_runtime$_._$Trigger$_(wg._$Plugins$_._$Flowchart$_._$Cnds$_._$OnAnyNodeChangeInFlowchart$_, n), 
            this._$_runtime$_._$Trigger$_(wg._$Plugins$_._$Flowchart$_._$Cnds$_._$OnTaggedNodeChangeInFlowchart$_, n)), 
            this._$_flowchartManager$_._$PopFlowchartState$_(), this._$PopIsTriggerState$_(), 
            !this._$WasReleased$_() && (h = this._$GetFlowchartElementById$_(this._$_currentFlowchartNodeId$_), 
            "reference" === h._$GetType$_())) {
                const t = s ? s._$GetName$_() : h._$GetReferenceFlowchartName$_();
                if (this._$_HasReferenceFlowchartState$_(h)) {
                    this._$_previousFlowchartNodeIds$_.pop();
                    const t = this._$_GetReferenceFlowchartState$_(h);
                    this._$_flowchartManager$_._$SetCurrentFlowchartState$_(t, !0, !0, !1), t._$_SetPreviousFlowchart$_(this, e), 
                    this._$_GetRootFlowchartState$_()._$_SetCurrentReferenceFlowchart$_(t);
                } else {
                    const s = "number" == typeof i ? i : h._$GetReferenceFlowchartStartNodeTag$_();
                    if (t) {
                        this._$_previousFlowchartNodeIds$_.pop();
                        let i = h._$GetReferenceFlowchartTag$_();
                        if (i) {
                            let t = this._$_flowchartManager$_._$GetFlowchartState$_(i);
                            for (;t; ) i = wg._$IncrementNumberAtEndOf$_(i), t = this._$_flowchartManager$_._$GetFlowchartState$_(i);
                        } else {
                            i = `${t}-ref`;
                            let s = this._$_flowchartManager$_._$GetFlowchartState$_(i);
                            for (;s; ) i = wg._$IncrementNumberAtEndOf$_(i), s = this._$_flowchartManager$_._$GetFlowchartState$_(i);
                        }
                        const n = this._$_flowchartManager$_._$AddFlowchartState$_(t, s, i, this._$_pluginInstance$_, !0);
                        n._$_SetPreviousFlowchart$_(this, e), this._$_SetReferenceFlowchartState$_(h, n);
                        const r = this._$_GetRootFlowchartState$_();
                        n._$_SetRootFlowchartState$_(r), r._$_SetCurrentReferenceFlowchart$_(n);
                    }
                }
            }
        }
        _$_GetFlowchartNodeOutputDefault$_() {
            const t = this._$_flowchartDataItem$_._$GetFlowchartElementById$_(this._$_currentFlowchartNodeId$_);
            return t ? t._$GetFlowchartNodeOutputData$_()._$GetFlowchartNodeOutputDefault$_() : null;
        }
        _$_GetFlowchartNodeOutputAt$_(t) {
            const s = this._$_flowchartDataItem$_._$GetFlowchartElementById$_(this._$_currentFlowchartNodeId$_);
            if (!s) return null;
            const i = s._$GetFlowchartNodeOutputData$_()._$GetFlowchartNodeOutputDataItems$_();
            if (!i) return null;
            return i[t] || null;
        }
        _$_GetFlowchartNodeOutputByName$_(t) {
            const s = this._$_flowchartDataItem$_._$GetFlowchartElementById$_(this._$_currentFlowchartNodeId$_);
            if (!s) return null;
            return s._$GetFlowchartNodeOutputData$_()._$GetFlowchartNodeOutputDataItemByName$_(t) || null;
        }
        _$_SetStartFlowchartNode$_(t) {
            if ("number" == typeof t) {
                let s = this._$GetFlowchartElementById$_(t);
                s || (s = this._$_flowchartDataItem$_._$GetFlowchartStartNode$_()), this._$_startFlowchartNode$_ = s;
            } else if ("number" == typeof this._$_startNodeTag$_) {
                let t = this._$GetFlowchartElementById$_(this._$_startNodeTag$_);
                t || (t = this._$_flowchartDataItem$_._$GetFlowchartStartNode$_()), this._$_startFlowchartNode$_ = t;
            } else {
                let t = this._$_flowchartDataItem$_._$GetFlowchartNodeByTags$_(this._$_startNodeTag$_);
                t || (t = this._$_flowchartDataItem$_._$GetFlowchartStartNode$_()), this._$_startFlowchartNode$_ = t;
            }
        }
        _$_SaveToJson$_() {
            return this._$_markForRelease$_ ? null : {
                flowchartName: this._$_flowchartName$_,
                flowchartTag: this._$_tag$_,
                startNodeTag: this._$_startNodeTag$_,
                currentNodeId: this._$_currentFlowchartNodeId$_,
                previousNodeIds: this._$_previousFlowchartNodeIds$_,
                pluginUID: this._$_pluginInstance$_._$GetInstance$_()._$GetUID$_(),
                reference: {
                    previousFlowchartTag: this._$_GetPreviousFlowchartState$_() ? this._$_GetPreviousFlowchartState$_()._$GetTag$_() : "",
                    previousStartNodeId: wg._$IsFiniteNumber$_(this._$_GetPreviousFlowchartStateStartNodeId$_()) ? this._$_GetPreviousFlowchartStateStartNodeId$_() : NaN,
                    referencesJson: this._$_GetFlowchartReferencesJson$_(),
                    currentReferenceFlowchartTag: this._$GetCurrentReferenceFlowchart$_() ? this._$GetCurrentReferenceFlowchart$_()._$GetTag$_() : "",
                    rootFlowchartTag: this._$_GetRootFlowchartState$_() ? this._$_GetRootFlowchartState$_()._$GetTag$_() : ""
                }
            };
        }
        _$_GetFlowchartReferencesJson$_() {
            if (!this._$_HasReferenceFlowchartStates$_()) return null;
            const t = [];
            for (const [s, i] of this._$_GetReferenceFlowchartStates$_().entries()) t.push({
                flowchartElementId: s._$GetFlowchartId$_(),
                flowchartStateTag: i._$GetTag$_()
            });
            return t.length ? t : null;
        }
        _$_LoadFromJson$_(t) {
            if (t) {
                if (this._$_flowchartName$_ = t.flowchartName, this._$_tag$_ = t.flowchartTag, this._$_startNodeTag$_ = t.startNodeTag, 
                this._$_currentFlowchartNodeId$_ = t.currentNodeId, this._$_previousFlowchartNodeIds$_ = t.previousNodeIds, 
                this._$_pluginUID$_ = t.pluginUID, t.hasOwnProperty("reference")) {
                    const s = t.reference;
                    this._$_previousFlowchartStateTag$_ = s.previousFlowchartTag, this._$_previousFlowchartStateStartNodeId$_ = s.previousStartNodeId, 
                    this._$_referenceFlowchartStatesJson$_ = s.referencesJson, this._$_currentReferenceFlowchartStateTag$_ = s.currentReferenceFlowchartTag, 
                    this._$_rootFlowchartStateTag$_ = s.rootFlowchartTag;
                }
                this._$_SetStartFlowchartNode$_();
            }
        }
        _$_GetPreviousFlowchartState$_() {
            return "string" == typeof this._$_previousFlowchartStateTag$_ && this._$_previousFlowchartStateTag$_ && (this._$_previousFlowchartState$_ = this._$_flowchartManager$_._$GetFlowchartState$_(this._$_previousFlowchartStateTag$_), 
            this._$_previousFlowchartStateTag$_ = ""), this._$_previousFlowchartState$_;
        }
        _$_GetPreviousFlowchartStateStartNodeId$_() {
            return this._$_previousFlowchartStateStartNodeId$_;
        }
        _$_SetPreviousFlowchart$_(t, s) {
            this._$_previousFlowchartState$_ = t, this._$_previousFlowchartStateStartNodeId$_ = s;
        }
        _$GetCurrentReferenceFlowchart$_() {
            return "string" == typeof this._$_currentReferenceFlowchartStateTag$_ && this._$_currentReferenceFlowchartStateTag$_ && (this._$_currentReferenceFlowchartState$_ = this._$_flowchartManager$_._$GetFlowchartState$_(this._$_currentReferenceFlowchartStateTag$_), 
            this._$_currentReferenceFlowchartStateTag$_ = ""), this._$_currentReferenceFlowchartState$_;
        }
        _$_SetCurrentReferenceFlowchart$_(t) {
            this._$_currentReferenceFlowchartState$_ = t, this._$_currentReferenceFlowchartState$_ === this && (this._$_currentReferenceFlowchartState$_ = null);
        }
        _$_GetRootFlowchartState$_() {
            return "string" == typeof this._$_rootFlowchartStateTag$_ && this._$_rootFlowchartStateTag$_ && (this._$_rootFlowchartState$_ = this._$_flowchartManager$_._$GetFlowchartState$_(this._$_rootFlowchartStateTag$_), 
            this._$_rootFlowchartStateTag$_ = ""), this._$_rootFlowchartState$_ ? this._$_rootFlowchartState$_ : this;
        }
        _$_SetRootFlowchartState$_(t) {
            this._$_rootFlowchartState$_ = t;
        }
        _$_HasReferenceFlowchartStates$_() {
            return this._$_RebuildReferenceFlowchartStates$_(), !!this._$_referenceFlowchartStates$_;
        }
        _$_HasReferenceFlowchartState$_(t) {
            return this._$_RebuildReferenceFlowchartStates$_(), this._$_referenceFlowchartStates$_ && this._$_referenceFlowchartStates$_.has(t);
        }
        _$_RebuildReferenceFlowchartStates$_() {
            if (this._$_referenceFlowchartStatesJson$_) {
                this._$_referenceFlowchartStates$_ && this._$_referenceFlowchartStates$_.clear(), 
                this._$_referenceFlowchartStates$_ || (this._$_referenceFlowchartStates$_ = new Map);
                for (const t of this._$_referenceFlowchartStatesJson$_) {
                    const s = this._$_flowchartManager$_._$GetFlowchartState$_(t.flowchartStateTag), i = s._$GetFlowchartElementById$_(t.flowchartElementId);
                    this._$_referenceFlowchartStates$_.set(i, s);
                }
                this._$_referenceFlowchartStatesJson$_ = null;
            }
        }
        _$_GetReferenceFlowchartStates$_() {
            return this._$_RebuildReferenceFlowchartStates$_(), this._$_referenceFlowchartStates$_;
        }
        _$_GetReferenceFlowchartState$_(t) {
            return this._$_RebuildReferenceFlowchartStates$_(), this._$_referenceFlowchartStates$_.get(t);
        }
        _$_SetReferenceFlowchartState$_(t, s) {
            this._$_referenceFlowchartStates$_ || (this._$_referenceFlowchartStates$_ = new Map), 
            this._$_referenceFlowchartStates$_.set(t, s);
        }
    };
}

{
    const Sg = self._$C3$_;
    Sg._$FlowchartStateManager$_ = class {
        constructor(t) {
            this._$_runtime$_ = t, this._$_flowchartStates$_ = new Map, this._$_currentFlowchartState$_ = null, 
            this._$_flowchartStateStack$_ = [], this._$_on_after_load$_ = () => this._$_OnAfterLoad$_(), 
            this._$_loadJson$_ = null;
        }
        _$Release$_() {
            Sg._$clearArray$_(this._$_flowchartStateStack$_), this._$_flowchartStateStack$_ = null, 
            this._$_flowchartStates$_.clear(), this._$_flowchartStates$_ = null, this._$_currentFlowchartState$_ = null, 
            this._$_runtime$_ = null, this._$_loadJson$_ = null;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetFlowchartDataItemByName$_(t) {
            return this._$_runtime$_._$GetFlowchartManager$_()._$GetFlowchartDataItemByName$_(t);
        }
        _$AddFlowchartState$_(t, s, i, e, n, h) {
            const r = this._$_runtime$_._$GetFlowchartManager$_()._$GetFlowchartDataItemByName$_(t);
            if (!r) return void console.warn(`[Flowcharts] no flowchart found with name '${t}'`);
            if (this._$_flowchartStates$_.has(i)) {
                const t = this._$_flowchartStates$_.get(i);
                return void (t && this._$RemoveFlowchartState$_(t));
            }
            const o = new Sg._$FlowchartState$_(t, i, s, r, this, e, h);
            return this._$_flowchartStates$_.set(i, o), n && this._$SetCurrentFlowchartState$_(o, !0), 
            o;
        }
        _$RemoveFlowchartState$_(t) {
            if (t._$MarkForRelease$_(), t._$IsInTriggerState$_()) return;
            const s = t._$GetTag$_();
            this._$_flowchartStates$_.delete(s), t._$Release$_(), this._$_currentFlowchartState$_ === t && (this._$_currentFlowchartState$_ = null);
        }
        _$ResetFlowchartState$_(t) {
            t._$Reset$_();
        }
        _$GetFlowchartState$_(t) {
            return this._$_flowchartStates$_.get(t);
        }
        _$PushFlowchartState$_(t) {
            this._$_flowchartStateStack$_.push(t);
        }
        _$PopFlowchartState$_() {
            this._$_flowchartStateStack$_.pop();
        }
        _$SetCurrentFlowchartState$_(t, s = !1, i = !1, e = !0) {
            if (e) {
                const s = t._$GetCurrentReferenceFlowchart$_();
                t = s || t;
            }
            t !== this._$_currentFlowchartState$_ && (this._$_TriggerBeforeFlowchartChange$_(), 
            this._$_TriggerAfterFlowchartChange$_(t, s, i));
        }
        _$GetCurrentFlowchartState$_(t) {
            return "string" == typeof t ? this._$GetFlowchartState$_(t) : this._$_flowchartStateStack$_.length ? this._$_flowchartStateStack$_[this._$_flowchartStateStack$_.length - 1] : this._$_currentFlowchartState$_;
        }
        _$_TriggerBeforeFlowchartChange$_() {
            if (!this._$_currentFlowchartState$_) return;
            if (this._$_currentFlowchartState$_._$WasReleased$_()) return;
            const t = this._$_currentFlowchartState$_._$GetPluginInstance$_()._$GetInstance$_();
            this._$_currentFlowchartState$_._$PushIsTriggerState$_(), this._$PushFlowchartState$_(this._$_currentFlowchartState$_), 
            this._$_runtime$_._$Trigger$_(Sg._$Plugins$_._$Flowchart$_._$Cnds$_._$OnBeforeFlowchartChange$_, t), 
            this._$PopFlowchartState$_(), this._$_currentFlowchartState$_._$PopIsTriggerState$_();
        }
        _$_TriggerAfterFlowchartChange$_(t, s = !1, i = !1) {
            if (this._$_currentFlowchartState$_ = t, !this._$_currentFlowchartState$_) return;
            if (this._$_currentFlowchartState$_._$WasReleased$_()) return;
            const e = this._$_currentFlowchartState$_._$GetPluginInstance$_()._$GetInstance$_();
            this._$_currentFlowchartState$_._$PushIsTriggerState$_(), this._$PushFlowchartState$_(this._$_currentFlowchartState$_), 
            this._$_runtime$_._$Trigger$_(Sg._$Plugins$_._$Flowchart$_._$Cnds$_._$OnFlowchartChange$_, e), 
            !0 !== i && "number" != typeof i || this._$_currentFlowchartState$_._$_SetStartFlowchartNode$_(i), 
            s && (this._$_runtime$_._$Trigger$_(Sg._$Plugins$_._$Flowchart$_._$Cnds$_._$OnAnyNodeChange$_, e), 
            this._$_runtime$_._$Trigger$_(Sg._$Plugins$_._$Flowchart$_._$Cnds$_._$OnTaggedNodeChange$_, e), 
            this._$_runtime$_._$Trigger$_(Sg._$Plugins$_._$Flowchart$_._$Cnds$_._$OnAnyNodeChangeInFlowchart$_, e), 
            this._$_runtime$_._$Trigger$_(Sg._$Plugins$_._$Flowchart$_._$Cnds$_._$OnTaggedNodeChangeInFlowchart$_, e)), 
            this._$PopFlowchartState$_(), this._$_currentFlowchartState$_._$PopIsTriggerState$_();
        }
        _$_SaveToJson$_() {
            return {
                flowchartJsonObjects: [ ...this._$_flowchartStates$_.values() ].map((t => t._$_SaveToJson$_())),
                currentFlowchartTag: this._$_currentFlowchartState$_ ? this._$_currentFlowchartState$_._$GetTag$_() : null
            };
        }
        _$_LoadFromJson$_(t) {
            if (!t) return;
            this._$_loadJson$_ = t;
            const s = new Map;
            for (const t of this._$_loadJson$_.flowchartJsonObjects) {
                const i = t.flowchartTag;
                if (this._$_flowchartStates$_.has(i)) {
                    const e = this._$_flowchartStates$_.get(i);
                    e._$_LoadFromJson$_(t), s.set(i, e);
                } else {
                    const i = this._$AddFlowchartState$_(t.flowchartName, t.startNodeTag, t.flowchartTag, null, !1, t.pluginUID);
                    i._$_LoadFromJson$_(t), s.set(t.flowchartTag, i);
                }
            }
            for (const [t, i] of this._$_flowchartStates$_.entries()) s.has(t) || i._$Release$_();
            this._$_flowchartStates$_.clear(), this._$_flowchartStates$_ = s, this._$_runtime$_._$IsLoadingState$_() ? this._$_runtime$_._$Dispatcher$_().addEventListener("afterload", this._$_on_after_load$_) : this._$_OnAfterLoad$_();
        }
        _$_OnAfterLoad$_() {
            this._$_runtime$_._$Dispatcher$_().removeEventListener("afterload", this._$_on_after_load$_);
            const t = this._$_flowchartStates$_.get(this._$_loadJson$_.currentFlowchartTag);
            t && this._$SetCurrentFlowchartState$_(t, !0), this._$_loadJson$_ = null;
        }
    };
}

{
    const bg = self._$C3$_;
    bg._$FlowchartDataManager$_ = class {
        constructor() {
            this._$_flowchartDataItems$_ = new Map;
        }
        _$Release$_() {
            for (const t of this._$_flowchartDataItems$_.values()) t._$Release$_();
            this._$_flowchartDataItems$_.clear(), this._$_flowchartDataItems$_ = null;
        }
        _$Add$_(t) {
            const s = new bg._$FlowchartDataItem$_(t), i = s._$GetName$_();
            this._$_flowchartDataItems$_.set(i, s);
        }
        _$Get$_(t) {
            return this._$_flowchartDataItems$_.get(t);
        }
        _$HasFlowcharts$_() {
            return !!this._$_flowchartDataItems$_.size;
        }
        static _$CreateDataItems$_(t, s, i, e) {
            if (s) for (const n of s) {
                const s = new i(n, e);
                t.push(s);
            }
        }
    };
}

{
    const Tg = self._$C3$_;
    Tg._$FlowchartDataItem$_ = class {
        constructor(t) {
            this._$_name$_ = t[0], this._$_flowchartNodeData$_ = new Tg._$FlowchartNodeData$_(t[1], this);
        }
        _$Release$_() {
            this._$_flowchartNodeData$_._$Release$_(), this._$_flowchartNodeData$_ = null;
        }
        _$GetFlowchartNodeData$_() {
            return this._$_flowchartNodeData$_;
        }
        _$GetFlowchartElementById$_(t) {
            return this._$_flowchartNodeData$_._$GetFlowchartElementById$_(t);
        }
        _$GetFlowchartNodeByTags$_(t) {
            return this._$_flowchartNodeData$_._$GetFlowchartNodeByTags$_(t);
        }
        _$GetFlowchartStartNode$_() {
            return this._$_flowchartNodeData$_._$GetFlowchartStartNode$_();
        }
        _$GetName$_() {
            return this._$_name$_;
        }
    };
}

{
    const vg = self._$C3$_;
    class xg {
        constructor(t, s) {
            this._$_flowchartNodeData$_ = s, this._$_type$_ = t[7], this._$_flowchartId$_ = t[0], 
            this._$_tag$_ = t[1], this._$_tag$_ ? this._$_tags$_ = this._$_tag$_.trim().split(" ").map((t => t.trim())) : this._$_tags$_ = [], 
            this._$_parentFlowchartIds$_ = t[2], this._$_parentOutputFlowchartIds$_ = null, 
            this._$_childrenFlowchartIds$_ = null, this._$_enable$_ = !1, "dictionary" === this._$_type$_ && (this._$_parentOutputFlowchartIds$_ = t[3], 
            this._$_childrenFlowchartIds$_ = t[4], this._$_enable$_ = t[8]), this._$_isStart$_ = t[6], 
            this._$_referenceFlowchartName$_ = null, this._$_referenceFlowchartStartNodeTag$_ = null, 
            this._$_referenceFlowchartTag$_ = null, "reference" === this._$_type$_ && (this._$_referenceFlowchartName$_ = t[8], 
            this._$_referenceFlowchartStartNodeTag$_ = t[9], this._$_referenceFlowchartTag$_ = t[10], 
            this._$_enable$_ = t[11]), this._$_flowchartNodeOutputData$_ = new vg._$FlowchartNodeOutputData$_(t[5], this);
        }
        _$Release$_() {
            this._$_flowchartNodeData$_ = null;
        }
        _$GetFlowchartNodeData$_() {
            return this._$_flowchartNodeData$_;
        }
        _$GetFlowchartNodeOutputData$_() {
            return this._$_flowchartNodeOutputData$_;
        }
        _$GetFlowchartId$_() {
            return this._$_flowchartId$_;
        }
        _$GetTag$_() {
            return this._$_tag$_;
        }
        _$GetTags$_() {
            return this._$_tags$_;
        }
        _$HasTags$_(t) {
            if (!this._$_tags$_) return !1;
            if (!this._$_tags$_.length) return !1;
            const s = vg._$FlowchartState$_._$_GetTagArray$_(t);
            return !(!s || !s.length) && s.every(vg._$FlowchartState$_._$_HasTag$_, this._$_tags$_);
        }
        _$GetIsStart$_() {
            return this._$_isStart$_;
        }
        _$SetIsStart$_(t) {
            this._$_isStart$_ = !!t;
        }
        _$CanBeStartNode$_() {
            if ("dictionary" === this._$_type$_) return !0;
            if ("reference" === this._$_type$_) return !1;
            throw new Error(`unexpected flowchart node type: ${this._$_type$_}`);
        }
        _$GetParentFlowchartIds$_() {
            return this._$_parentFlowchartIds$_;
        }
        _$GetParentOutputFlowchartIds$_() {
            return this._$_parentOutputFlowchartIds$_;
        }
        _$GetChildrenFlowchartIds$_() {
            return this._$_childrenFlowchartIds$_;
        }
        _$GetType$_() {
            return this._$_type$_;
        }
        _$GetEnable$_() {
            return this._$_enable$_;
        }
        _$GetReferenceFlowchartName$_() {
            return this._$_referenceFlowchartName$_;
        }
        _$GetReferenceFlowchartStartNodeTag$_() {
            return this._$_referenceFlowchartStartNodeTag$_;
        }
        _$GetReferenceFlowchartTag$_() {
            return this._$_referenceFlowchartTag$_;
        }
    }
    vg._$FlowchartNodeData$_ = class {
        constructor(t, s) {
            this._$_flowchartDataItem$_ = s, this._$_flowchartNodeItems$_ = [], this._$_flowchartNodeItemsIdMap$_ = new Map, 
            this._$_flowchartNodeItemsTagMap$_ = new Map, this._$_flowchartNodeStartItem$_ = null, 
            vg._$FlowchartDataManager$_._$CreateDataItems$_(this._$_flowchartNodeItems$_, t, xg, this);
            for (const t of this._$_flowchartNodeItems$_) {
                const s = t._$GetFlowchartId$_(), i = t._$GetTag$_(), e = t._$GetTags$_(), n = t._$GetIsStart$_();
                if (this._$_flowchartNodeItemsIdMap$_.set(s, t), i) for (const s of e) this._$_flowchartNodeItemsTagMap$_.has(s) || this._$_flowchartNodeItemsTagMap$_.set(s, new Set), 
                this._$_flowchartNodeItemsTagMap$_.get(s).add(t);
                n && (this._$_flowchartNodeStartItem$_ = t);
                const h = t._$GetFlowchartNodeOutputData$_();
                for (const t of h._$flowchartNodeOutputDataItems$_()) {
                    const s = t._$GetFlowchartId$_();
                    this._$_flowchartNodeItemsIdMap$_.set(s, t);
                }
            }
            this._$_flowchartNodeStartItem$_ || this._$_SetStartNodeIfMissing$_();
        }
        _$Release$_() {
            this._$_flowchartDataItem$_ = null;
            for (const t of this._$_flowchartNodeItems$_) t._$Release$_();
            vg._$clearArray$_(this._$_flowchartNodeItems$_), this._$_flowchartNodeItems$_ = null;
        }
        _$GetFlowchartDataItem$_() {
            return this._$_flowchartDataItem$_;
        }
        _$GetFlowchartElementById$_(t) {
            return this._$_flowchartNodeItemsIdMap$_.get(t);
        }
        _$GetFlowchartNodeByTags$_(t) {
            if (!t || !t.length) return null;
            const s = [];
            for (const i of t.trim().split(" ")) {
                let t = this._$_flowchartNodeItemsTagMap$_.get(i.trim()) ?? new Set;
                if (0 === t.size) return null;
                s.push(t);
            }
            return [ ...s.reduce(((t, s) => s.size < t.size ? s : t)) ].filter((t => s.every((s => s.has(t)))))[0];
        }
        _$GetFlowchartStartNode$_() {
            return this._$_flowchartNodeStartItem$_;
        }
        * _$flowchartNodeDataItems$_() {
            for (const t of this._$_flowchartNodeItems$_) yield t;
        }
        _$_SetStartNodeIfMissing$_() {
            let t = 0;
            for (const s of this._$flowchartNodeDataItems$_()) s._$GetIsStart$_() && t++;
            if (0 === t) {
                for (const t of this._$flowchartNodeDataItems$_()) if (t._$CanBeStartNode$_() && !t._$GetIsStart$_()) return void t._$SetIsStart$_(!0);
            } else {
                if (1 === t) return;
                if (t > 1) {
                    let t = !0;
                    for (const s of this._$flowchartNodeDataItems$_()) s._$CanBeStartNode$_() && (s._$GetIsStart$_() && t ? t = !1 : s._$GetIsStart$_() && !t && s._$SetIsStart$_(!1));
                }
            }
            for (const t of this._$flowchartNodeDataItems$_()) if (t._$CanBeStartNode$_() && t._$GetIsStart$_()) return void (this._$_flowchartNodeStartItem$_ = t);
        }
    };
}

{
    const Ig = self._$C3$_;
    class Gg {
        constructor(t, s) {
            this._$_flowchartNodeOutputData$_ = s, this._$_flowchartId$_ = t[0], this._$_name$_ = t[1], 
            this._$_value$_ = t[2], this._$_connectedFlowchartNodeFlowchartId$_ = t[3], this._$_enable$_ = t[4], 
            this._$_default$_ = t[5];
        }
        _$Release$_() {
            this._$_flowchartNodeOutputData$_ = null;
        }
        _$GetFlowchartNodeOutputData$_() {
            return this._$_flowchartNodeOutputData$_;
        }
        _$GetFlowchartId$_() {
            return this._$_flowchartId$_;
        }
        _$GetName$_() {
            return this._$_name$_;
        }
        _$GetValue$_() {
            return this._$_value$_;
        }
        _$GetConnectedFlowchartNodeFlowchartId$_() {
            return this._$_connectedFlowchartNodeFlowchartId$_;
        }
        _$GetEnable$_() {
            return this._$_enable$_;
        }
        _$GetDefault$_() {
            return this._$_default$_;
        }
    }
    Ig._$FlowchartNodeOutputData$_ = class {
        constructor(t, s) {
            this._$_flowchartDataNodeItem$_ = s, this._$_flowchartNodeOutputItems$_ = [], this._$_flowchartNodeOutputItemsNameMap$_ = new Map, 
            Ig._$FlowchartDataManager$_._$CreateDataItems$_(this._$_flowchartNodeOutputItems$_, t, Gg, this), 
            this._$_enabledFlowchartNodeOutputItems$_ = this._$_flowchartNodeOutputItems$_.filter((t => t._$GetEnable$_()));
            for (const t of this._$_enabledFlowchartNodeOutputItems$_) this._$_flowchartNodeOutputItemsNameMap$_.set(t._$GetName$_(), t);
        }
        _$Release$_() {
            this._$_flowchartDataNodeItem$_ = null;
            for (const t of this._$_flowchartNodeOutputItems$_) t._$Release$_();
            Ig._$clearArray$_(this._$_flowchartNodeOutputItems$_), this._$_flowchartNodeOutputItems$_ = null, 
            Ig._$clearArray$_(this._$_enabledFlowchartNodeOutputItems$_), this._$_enabledFlowchartNodeOutputItems$_ = null;
        }
        _$GetFlowchartNodeDataItem$_() {
            return this._$_flowchartDataNodeItem$_;
        }
        _$GetFlowchartNodeOutputDataItemCount$_() {
            return this._$_enabledFlowchartNodeOutputItems$_.length;
        }
        _$GetFlowchartNodeOutputDataItems$_() {
            return this._$_enabledFlowchartNodeOutputItems$_;
        }
        _$GetFlowchartNodeOutputDataItemByName$_(t) {
            return this._$_flowchartNodeOutputItemsNameMap$_.get(t);
        }
        _$GetFlowchartNodeOutputDefault$_() {
            for (const t of this._$_enabledFlowchartNodeOutputItems$_) if (t._$GetDefault$_()) return t;
        }
        * _$flowchartNodeOutputDataItems$_() {
            for (const t of this._$_enabledFlowchartNodeOutputItems$_) yield t;
        }
    };
}

{
    const Cg = self._$C3$_;
    Cg._$SolStack$_ = class extends Cg._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_objectClass$_ = t, this._$_stack$_ = [], this._$_stack$_.push(Cg._$New$_(Cg._$Sol$_, this)), 
            this._$_index$_ = 0, this._$_current$_ = this._$_stack$_[0];
        }
        _$Release$_() {
            for (const t of this._$_stack$_) t._$Release$_();
            Cg._$clearArray$_(this._$_stack$_), this._$_current$_ = null, this._$_objectClass$_ = null;
        }
        _$GetObjectClass$_() {
            return this._$_objectClass$_;
        }
        _$GetCurrentSol$_() {
            return this._$_current$_;
        }
        _$GetOneBelowCurrentSol$_() {
            return this._$_stack$_[this._$_index$_ - 1];
        }
        _$Clear$_() {
            this._$GetCurrentSol$_()._$Clear$_();
        }
        _$PushClean$_() {
            const t = this._$_stack$_, s = ++this._$_index$_;
            if (s === t.length) {
                const s = Cg._$New$_(Cg._$Sol$_, this);
                t.push(s), this._$_current$_ = s;
            } else {
                const i = t[s];
                i._$Reset$_(), this._$_current$_ = i;
            }
        }
        _$PushCopy$_() {
            const t = this._$_stack$_, s = ++this._$_index$_;
            s === t.length && t.push(Cg._$New$_(Cg._$Sol$_, this));
            const i = t[s];
            i._$Copy$_(t[s - 1]), this._$_current$_ = i;
        }
        _$Pop$_() {
            this._$_current$_ = this._$_stack$_[--this._$_index$_];
        }
        _$RemoveInstances$_(t) {
            const s = this._$_stack$_;
            for (let i = 0, e = s.length; i < e; ++i) s[i]._$RemoveInstances$_(t);
        }
    };
}

{
    const _g = self._$C3$_;
    _g._$Sol$_ = class extends _g._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_stack$_ = t, this._$_objectClass$_ = this._$_stack$_._$GetObjectClass$_(), 
            this._$_eventStack$_ = this._$_objectClass$_._$GetRuntime$_()._$GetEventStack$_(), 
            this._$_selectAll$_ = !0, this._$_instances$_ = [], this._$_elseInstances$_ = [];
        }
        _$Release$_() {
            this._$ClearArrays$_(), this._$_stack$_ = null, this._$_objectClass$_ = null, this._$_eventStack$_ = null;
        }
        _$ClearArrays$_() {
            _g._$clearArray$_(this._$_instances$_), _g._$clearArray$_(this._$_elseInstances$_);
        }
        _$GetObjectClass$_() {
            return this._$_objectClass$_;
        }
        _$IsSelectAll$_() {
            return this._$_selectAll$_;
        }
        _$HasAnyInstances$_() {
            return this._$_selectAll$_ ? !!this._$_objectClass$_._$GetInstanceCount$_() : !!this._$_instances$_.length;
        }
        _$GetInstances$_() {
            return this._$_selectAll$_ ? this._$_objectClass$_._$GetInstances$_() : this._$_instances$_;
        }
        _$HasAnyElseInstances$_() {
            return !!this._$_elseInstances$_.length;
        }
        _$GetElseInstances$_() {
            return this._$_elseInstances$_;
        }
        _$GetExpressionInstances$_() {
            const t = this._$GetInstances$_();
            return t.length ? t : this._$_elseInstances$_;
        }
        _$Reset$_() {
            this._$_selectAll$_ = !0, _g._$clearArray$_(this._$_elseInstances$_);
        }
        _$Clear$_() {
            this._$_selectAll$_ = !0;
        }
        _$Copy$_(t) {
            t._$IsSelectAll$_() ? this._$Reset$_() : (this._$_selectAll$_ = !1, _g._$shallowAssignArray$_(this._$_instances$_, t._$_instances$_), 
            _g._$clearArray$_(this._$_elseInstances$_));
        }
        _$_PushInstance$_(t) {
            this._$_instances$_.push(t);
        }
        _$_PushElseInstance$_(t) {
            this._$_elseInstances$_.push(t);
        }
        _$_SetSelectAll$_(t) {
            this._$_selectAll$_ = !!t;
        }
        _$_GetOwnInstances$_() {
            return this._$_instances$_;
        }
        _$_GetOwnElseInstances$_() {
            return this._$_elseInstances$_;
        }
        _$SetSinglePicked$_(t) {
            this._$_selectAll$_ = !1, _g._$clearArray$_(this._$_instances$_), this._$_instances$_.push(t);
        }
        _$SetArrayPicked$_(t) {
            this._$_selectAll$_ = !1, _g._$shallowAssignArray$_(this._$_instances$_, t);
        }
        _$SetSetPicked$_(t) {
            this._$_selectAll$_ = !1, _g._$clearArray$_(this._$_instances$_);
            for (const s of t) this._$_instances$_.push(s);
        }
        _$AddElseInstances$_(t, s) {
            for (const i of s) t.has(i) || this._$_elseInstances$_.push(i);
        }
        _$TransferElseInstancesToOwn$_(t) {
            for (const s of t) this._$_instances$_.push(s);
            _g._$arrayRemoveAllInSet$_(this._$_elseInstances$_, t);
        }
        _$ClearElseInstances$_() {
            _g._$clearArray$_(this._$_elseInstances$_);
        }
        _$PickOne$_(t) {
            if (t) if (this._$_eventStack$_._$GetCurrentStackFrame$_()._$GetCurrentEvent$_()._$IsOrBlock$_()) {
                this._$IsSelectAll$_() && (_g._$clearArray$_(this._$_instances$_), _g._$shallowAssignArray$_(this._$_elseInstances$_, t._$GetObjectClass$_()._$GetInstances$_()), 
                this._$_selectAll$_ = !1);
                const s = this._$_elseInstances$_.indexOf(t);
                -1 !== s && (this._$_instances$_.push(this._$_elseInstances$_[s]), this._$_elseInstances$_.splice(s, 1));
            } else this._$SetSinglePicked$_(t);
        }
        _$RemoveInstances$_(t) {
            _g._$arrayRemoveAllInSet$_(this._$_instances$_, t), _g._$arrayRemoveAllInSet$_(this._$_elseInstances$_, t);
        }
    };
}

{
    const Eg = self._$C3$_;
    Eg._$EventStack$_ = class extends Eg._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_eventSheetManager$_ = t, this._$_runtime$_ = this._$_eventSheetManager$_._$GetRuntime$_(), 
            this._$_stack$_ = [], this._$_stack$_.push(Eg._$New$_(Eg._$EventStackFrame$_, this, null)), 
            this._$_index$_ = 0, this._$_expFuncStack$_ = [];
        }
        _$Release$_() {
            for (const t of this._$_stack$_) t._$Release$_();
            Eg._$clearArray$_(this._$_stack$_), Eg._$clearArray$_(this._$_expFuncStack$_), this._$_eventSheetManager$_ = null, 
            this._$_runtime$_ = null;
        }
        _$GetEventSheetManager$_() {
            return this._$_eventSheetManager$_;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetCurrentStackFrame$_() {
            return this._$_stack$_[this._$_index$_];
        }
        _$GetAllStackFrames$_() {
            return this._$_stack$_;
        }
        _$GetCurrentStackFrameIndex$_() {
            return this._$_index$_;
        }
        _$Push$_(t) {
            const s = this._$_stack$_, i = ++this._$_index$_;
            if (i === s.length) {
                const i = Eg._$New$_(Eg._$EventStackFrame$_, this, t);
                return s.push(i), i;
            }
            {
                const e = s[i];
                return e._$Reset$_(t), e;
            }
        }
        _$Pop$_() {
            --this._$_index$_;
        }
        _$PushExpFunc$_(t) {
            this._$_expFuncStack$_.push(t);
        }
        _$PopExpFunc$_() {
            this._$_expFuncStack$_.pop();
        }
        _$GetCurrentExpFuncStackFrame$_() {
            const t = this._$_expFuncStack$_;
            return 0 === t.length ? null : t.at(-1);
        }
    };
}

{
    const Dg = self._$C3$_;
    Dg._$EventStackFrame$_ = class extends Dg._$DefendedBase$_ {
        constructor(t, s) {
            super(), this._$_stack$_ = t, this._$_runtime$_ = this._$_stack$_._$GetRuntime$_(), 
            this._$_currentEvent$_ = s, this._$_cndIndex$_ = 0, this._$_actIndex$_ = 0, this._$_lastEventTrue$_ = !1, 
            this._$_elseBranchRan$_ = !1, this._$_expressionObjectClass$_ = null, this._$_functionReturnType$_ = 0, 
            this._$_functionReturnValue$_ = 0, this._$_dynamicSolModifiers$_ = null;
        }
        _$Release$_() {
            this._$Reset$_(null), this._$_stack$_ = null, this._$_runtime$_ = null;
        }
        _$Reset$_(t) {
            this._$_currentEvent$_ = t, this._$_cndIndex$_ = 0, this._$_actIndex$_ = 0, this._$_lastEventTrue$_ = !1, 
            this._$_elseBranchRan$_ = !1, this._$_dynamicSolModifiers$_ = null;
        }
        _$_Restore$_(t, s) {
            this._$_currentEvent$_ = t, this._$_cndIndex$_ = 0, this._$_actIndex$_ = s;
        }
        _$ResetQuick$_() {
            this._$_cndIndex$_ = 0, this._$_actIndex$_ = 0;
        }
        _$GetCurrentEvent$_() {
            return this._$_currentEvent$_;
        }
        _$SetCurrentEvent$_(t) {
            this._$_currentEvent$_ = t;
        }
        _$GetConditionIndex$_() {
            return this._$_cndIndex$_;
        }
        _$SetConditionIndex$_(t) {
            this._$_cndIndex$_ = t;
        }
        _$GetActionIndex$_() {
            return this._$_actIndex$_;
        }
        _$SetActionIndex$_(t) {
            this._$_actIndex$_ = t;
        }
        _$SetLastEventTrue$_(t) {
            this._$_lastEventTrue$_ = !!t;
        }
        _$GetLastEventTrue$_() {
            return this._$_lastEventTrue$_;
        }
        _$SetElseBranchRan$_(t) {
            this._$_elseBranchRan$_ = !!t;
        }
        _$GetElseBranchRan$_() {
            return this._$_elseBranchRan$_;
        }
        _$SetExpressionObjectClass$_(t) {
            this._$_expressionObjectClass$_ = t;
        }
        _$GetExpressionObjectClass$_() {
            return this._$_expressionObjectClass$_;
        }
        _$InitCallFunctionExpression$_(t, s) {
            this._$_functionReturnType$_ = t, this._$_functionReturnValue$_ = s;
        }
        _$GetFunctionReturnType$_() {
            return this._$_functionReturnType$_;
        }
        _$SetFunctionReturnValue$_(t) {
            this._$_functionReturnValue$_ = t;
        }
        _$GetFunctionReturnValue$_() {
            return this._$_functionReturnValue$_;
        }
        _$IsSolModifierAfterCnds$_() {
            const t = this._$_currentEvent$_;
            return !!t._$IsSolWriterAfterCnds$_() || this._$_cndIndex$_ < t._$GetConditionCount$_() - 1 && !!t._$GetSolModifiers$_().length;
        }
        _$SetDynamicSolModifiers$_(t) {
            this._$_dynamicSolModifiers$_ = t;
        }
        _$GetDynamicSolModifiers$_() {
            return this._$_dynamicSolModifiers$_;
        }
    };
}

{
    const Ag = self._$C3$_;
    Ag._$LocalVarStack$_ = class extends Ag._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_eventSheetManager$_ = t, this._$_runtime$_ = this._$_eventSheetManager$_._$GetRuntime$_(), 
            this._$_stack$_ = [], this._$_index$_ = -1, this._$_current$_ = null, this._$_initialValues$_ = [];
        }
        _$Release$_() {
            Ag._$clearArray$_(this._$_stack$_), this._$_eventSheetManager$_ = null, this._$_runtime$_ = null;
        }
        _$_SetInitialValues$_(t) {
            this._$_initialValues$_ = t;
            const s = this._$_initialValues$_.slice(0);
            this._$_stack$_.push(s), this._$_index$_ = 0, this._$_current$_ = s;
        }
        _$GetEventSheetManager$_() {
            return this._$_eventSheetManager$_;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetCurrent$_() {
            return this._$_current$_;
        }
        _$Push$_() {
            const t = ++this._$_index$_, s = this._$_stack$_;
            t === s.length ? s.push(this._$_initialValues$_.slice(0)) : Ag._$shallowAssignArray$_(s[t], this._$_initialValues$_), 
            this._$_current$_ = s[t];
        }
        _$Pop$_() {
            this._$_current$_ = this._$_stack$_[--this._$_index$_];
        }
    };
}

{
    const Ng = self._$C3$_;
    Ng._$LoopStack$_ = class extends Ng._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_eventSheetManager$_ = t, this._$_runtime$_ = this._$_eventSheetManager$_._$GetRuntime$_(), 
            this._$_stack$_ = [], this._$_index$_ = -1;
        }
        _$Release$_() {
            Ng._$clearArray$_(this._$_stack$_), this._$_eventSheetManager$_ = null, this._$_runtime$_ = null;
        }
        _$GetEventSheetManager$_() {
            return this._$_eventSheetManager$_;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$IsInLoop$_() {
            return this._$_index$_ >= 0;
        }
        _$GetCurrent$_() {
            return this._$_stack$_[this._$_index$_];
        }
        _$Push$_() {
            if (++this._$_index$_, this._$_index$_ === this._$_stack$_.length) {
                const t = Ng._$New$_(Ng._$Loop$_, this);
                return this._$_stack$_.push(t), t;
            }
            {
                const t = this._$_stack$_[this._$_index$_];
                return t._$Reset$_(), t;
            }
        }
        _$Pop$_() {
            --this._$_index$_;
        }
        _$FindByName$_(t) {
            const s = this._$_stack$_;
            for (let i = this._$_index$_; i >= 0; --i) {
                const e = s[i];
                if (e._$GetName$_() === t) return e;
            }
            return null;
        }
        _$_GetStack$_() {
            return this._$_stack$_.slice(0, this._$_index$_ + 1);
        }
    };
}

{
    const Lg = self._$C3$_;
    Lg._$Loop$_ = class extends Lg._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_loopStack$_ = t, this._$_name$_ = "", this._$_index$_ = 0, this._$_isStopped$_ = !1, 
            this._$_end$_ = NaN;
        }
        _$Reset$_() {
            this._$_name$_ = "", this._$_index$_ = 0, this._$_isStopped$_ = !1, this._$_end$_ = NaN;
        }
        _$SetName$_(t) {
            this._$_name$_ = t;
        }
        _$GetName$_() {
            return this._$_name$_;
        }
        _$SetIndex$_(t) {
            this._$_index$_ = t;
        }
        _$GetIndex$_() {
            return this._$_index$_;
        }
        _$Stop$_() {
            this._$_isStopped$_ = !0;
        }
        _$IsStopped$_() {
            return this._$_isStopped$_;
        }
        _$SetEnd$_(t) {
            this._$_end$_ = t;
        }
        _$GetEnd$_() {
            return this._$_end$_;
        }
    };
}

{
    const Og = self._$C3$_;
    Og._$ArrayStack$_ = class extends Og._$DefendedBase$_ {
        constructor() {
            super(), this._$_stack$_ = [], this._$_index$_ = -1;
        }
        _$Release$_() {
            Og._$clearArray$_(this._$_stack$_);
        }
        _$GetCurrent$_() {
            return this._$_stack$_[this._$_index$_];
        }
        _$Push$_() {
            if (++this._$_index$_, this._$_index$_ === this._$_stack$_.length) {
                const t = [];
                return this._$_stack$_.push(t), t;
            }
            return this._$_stack$_[this._$_index$_];
        }
        _$Pop$_() {
            --this._$_index$_;
        }
    };
}

{
    let Rg = function(t, s) {
        return t._$GetIndex$_() - s._$GetIndex$_();
    }, Pg = function(t, s) {
        for (let i = 0, e = t.length; i < e; ++i) if (t[i] !== s[i]) return !1;
        return !0;
    };
    0;
    const kg = self._$C3$_;
    self.assert;
    kg._$EventSheetManager$_ = class extends kg._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_runtime$_ = t, this._$_allSheets$_ = [], this._$_sheetsByName$_ = new Map, 
            this._$_allGroups$_ = [], this._$_groupsByName$_ = new Map, this._$_blocksBySid$_ = new Map, 
            this._$_cndsBySid$_ = new Map, this._$_actsBySid$_ = new Map, this._$_allUniqueSolModifiers$_ = new Map, 
            this._$_eventVarsBySid$_ = new Map, this._$_nextLocalVarIndex$_ = 0, this._$_allGlobalVars$_ = [], 
            this._$_allLocalVars$_ = [], this._$_localVarInitialValues$_ = [], this._$_functionBlocksByName$_ = new Map, 
            this._$_customActionBlocksMap$_ = new Map, this._$_eventStack$_ = kg._$New$_(kg._$EventStack$_, this), 
            this._$_localVarStack$_ = kg._$New$_(kg._$LocalVarStack$_, this), this._$_loopStack$_ = kg._$New$_(kg._$LoopStack$_, this), 
            this._$_triggersToPostInit$_ = [], this._$_queuedTriggers$_ = [], this._$_queuedDebugTriggers$_ = [], 
            this._$_runningEventsDepth$_ = 0, this._$_executingTriggerDepth$_ = 0, this._$_blockFlushingDepth$_ = 0, 
            this._$_scheduledWaits$_ = [], this._$_asyncActionPromises$_ = [], this._$_signalTags$_ = [], 
            this._$_signalPromises$_ = new Map, this._$_instSignals$_ = new Map, self.c3_callFunction = (t, s) => this._$_InvokeFunctionFromJS$_(t, s);
        }
        _$Release$_() {
            this._$ClearAllScheduledWaits$_(), this._$_eventStack$_._$Release$_(), this._$_eventStack$_ = null, 
            this._$_localVarStack$_._$Release$_(), this._$_localVarStack$_ = null, kg._$clearArray$_(this._$_queuedTriggers$_), 
            kg._$clearArray$_(this._$_queuedDebugTriggers$_), this._$_runtime$_ = null, kg._$clearArray$_(this._$_allSheets$_), 
            this._$_sheetsByName$_.clear();
        }
        _$Create$_(t) {
            const s = kg._$New$_(kg._$EventSheet$_, this, t);
            this._$_allSheets$_.push(s), this._$_sheetsByName$_.set(s._$GetName$_().toLowerCase(), s);
        }
        _$_AddTriggerToPostInit$_(t) {
            this._$_triggersToPostInit$_.push(t);
        }
        _$_PostInit$_() {
            for (const t of this._$_customActionBlocksMap$_.values()) t._$_CheckOverrideState$_();
            for (const t of this._$_functionBlocksByName$_.values()) t._$_PostInit$_();
            for (const t of this._$_customActionBlocksMap$_.values()) t._$_PostInit$_();
            for (const t of this._$_allSheets$_) t._$_PostInit$_();
            for (const t of this._$_allSheets$_) t._$_UpdateDeepIncludes$_();
            for (const t of this._$_triggersToPostInit$_) t._$_PostInit$_(!1);
            kg._$clearArray$_(this._$_triggersToPostInit$_), this._$_localVarStack$_._$_SetInitialValues$_(this._$_localVarInitialValues$_);
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetEventSheetByName$_(t) {
            return this._$_sheetsByName$_.get(t.toLowerCase()) || null;
        }
        _$_RegisterGroup$_(t) {
            this._$_allGroups$_.push(t), this._$_groupsByName$_.set(t._$GetGroupName$_(), t);
        }
        _$_RegisterEventBlock$_(t) {
            this._$_blocksBySid$_.set(t._$GetSID$_(), t);
        }
        _$_RegisterCondition$_(t) {
            this._$_cndsBySid$_.set(t._$GetSID$_(), t);
        }
        _$_RegisterAction$_(t) {
            this._$_actsBySid$_.set(t._$GetSID$_(), t);
        }
        _$_RegisterFunctionBlock$_(t) {
            switch (t._$GetFunctionType$_()) {
              case 0:
                this._$_functionBlocksByName$_.set(t._$GetFunctionName$_().toLowerCase(), t);
                break;

              case 1:
                this._$_customActionBlocksMap$_.set(t._$GetFunctionName$_().toLowerCase(), t);
            }
        }
        _$_RegisterEventVariable$_(t) {
            this._$_eventVarsBySid$_.set(t._$GetSID$_(), t), t._$IsGlobal$_() ? this._$_allGlobalVars$_.push(t) : this._$_allLocalVars$_.push(t);
        }
        _$_DeduplicateSolModifierList$_(t) {
            t.length >= 2 && t.sort(Rg);
            let s = this._$_allUniqueSolModifiers$_.get(t.length);
            s || (s = [], this._$_allUniqueSolModifiers$_.set(t.length, s));
            for (let i = 0, e = s.length; i < e; ++i) {
                const e = s[i];
                if (Pg(t, e)) return e;
            }
            return s.push(t), t;
        }
        _$_GetNextLocalVarIndex$_(t) {
            return this._$_localVarInitialValues$_.push(t._$GetInitialValue$_()), this._$_nextLocalVarIndex$_++;
        }
        _$GetEventStack$_() {
            return this._$_eventStack$_;
        }
        _$GetCurrentEventStackFrame$_() {
            return this._$GetEventStack$_()._$GetCurrentStackFrame$_();
        }
        _$GetCurrentEvent$_() {
            return this._$GetCurrentEventStackFrame$_()._$GetCurrentEvent$_();
        }
        _$GetCurrentCondition$_() {
            const t = this._$GetCurrentEventStackFrame$_();
            return t._$GetCurrentEvent$_()._$GetConditionAt$_(t._$GetConditionIndex$_());
        }
        _$GetCurrentAction$_() {
            const t = this._$GetCurrentEventStackFrame$_();
            return t._$GetCurrentEvent$_()._$GetActionAt$_(t._$GetActionIndex$_());
        }
        _$GetLocalVarStack$_() {
            return this._$_localVarStack$_;
        }
        _$GetLoopStack$_() {
            return this._$_loopStack$_;
        }
        _$GetAllLocalVariablesInScope$_(t) {
            const s = [];
            for (t = t._$GetScopeParent$_(); t; ) kg._$appendArray$_(s, t._$_GetAllLocalVariablesInScope$_()), 
            t = t._$GetScopeParent$_();
            return s;
        }
        _$_GetLocalVariablesScriptInterface$_(t) {
            const s = {};
            for (const i of this._$GetAllLocalVariablesInScope$_(t)) s[i._$GetJsPropName$_()] = i._$_GetScriptInterfaceDescriptor$_();
            return Object.create(Object.prototype, s);
        }
        _$GetEventVariableBySID$_(t) {
            return this._$_eventVarsBySid$_.get(t) || null;
        }
        _$GetEventBlockBySID$_(t) {
            return this._$_blocksBySid$_.get(t) || null;
        }
        _$GetConditionBySID$_(t) {
            return this._$_cndsBySid$_.get(t) || null;
        }
        _$GetActionBySID$_(t) {
            return this._$_actsBySid$_.get(t) || null;
        }
        _$GetFunctionBlockByName$_(t) {
            return this._$_functionBlocksByName$_.get(t.toLowerCase()) || null;
        }
        _$GetCustomActionBlockByName$_(t, s) {
            let i = this._$_customActionBlocksMap$_.get((t._$GetName$_() + "." + s).toLowerCase());
            if (i) return i;
            if (!t._$IsFamily$_()) for (const e of t._$GetFamilies$_()) if (i = this._$_customActionBlocksMap$_.get((e._$GetName$_() + "." + s).toLowerCase()), 
            i) return i;
            return null;
        }
        _$GetAllGlobalVariables$_() {
            return this._$_allGlobalVars$_;
        }
        _$GetAllLocalVariables$_() {
            return this._$_allLocalVars$_;
        }
        _$ResetAllGlobalsToInitialValue$_(t) {
            for (const t of this._$_allGlobalVars$_) t._$ResetToInitialValue$_();
            if (t) for (const t of this._$_allLocalVars$_) t._$IsStatic$_() && t._$ResetToInitialValue$_();
        }
        _$GetEventGroupByName$_(t) {
            return this._$_groupsByName$_.get(t.toLowerCase()) || null;
        }
        _$GetEventGroupBySID$_(t) {
            const s = this._$_blocksBySid$_.get(t);
            return s && s._$IsGroup$_() ? s : null;
        }
        _$GetAllGroups$_() {
            return this._$_allGroups$_;
        }
        _$ResetAllGroupsInitialActivation$_() {
            for (const t of this._$_allGroups$_) t._$ResetInitialActivation$_();
        }
        _$_ResetAllHasRunFlags$_() {
            for (const t of this._$_allSheets$_) t._$_ResetHasRunFlag$_();
        }
        _$RunEvents$_(t) {
            this._$_ResetAllHasRunFlags$_(), this._$_runningEventsDepth$_++;
            for (const s of t._$runningLayouts$_()) {
                const t = s._$GetEventSheet$_();
                t && (this._$_runtime$_._$PushCurrentLayout$_(s), t._$Run$_(), this._$_runtime$_._$PopCurrentLayout$_());
            }
            this._$_runningEventsDepth$_--;
        }
        async _$DebugRunEvents$_(t) {
            this._$_ResetAllHasRunFlags$_(), this._$_runningEventsDepth$_++;
            for (const s of this._$_DebugRunEventsGen$_(t)) await this._$_runtime$_._$DebugBreak$_(s);
            this._$_runningEventsDepth$_--;
        }
        * _$_DebugRunEventsGen$_(t) {
            for (const s of t._$runningLayouts$_()) {
                const t = s._$GetEventSheet$_();
                t && (this._$_runtime$_._$PushCurrentLayout$_(s), yield* t._$DebugRun$_(), this._$_runtime$_._$PopCurrentLayout$_());
            }
        }
        _$_Trigger$_(t, s, i, e) {
            let n = !1;
            if (!t._$GetMainRunningLayout$_()) return this._$QueueTrigger$_(s, i, e);
            this._$_executingTriggerDepth$_++;
            for (const h of t._$runningLayouts$_()) {
                const t = h._$GetEventSheet$_();
                if (!t) continue;
                this._$_runtime$_._$PushCurrentLayout$_(h);
                for (const h of t._$deepIncludes$_()) {
                    const t = h._$_Trigger$_(s, i, e);
                    n = n || t;
                }
                const r = t._$_Trigger$_(s, i, e);
                n = n || r, this._$_runtime$_._$PopCurrentLayout$_();
            }
            return this._$_executingTriggerDepth$_--, n;
        }
        * _$_DebugTrigger$_(t, s, i, e) {
            let n = !1;
            if (!t._$GetMainRunningLayout$_()) return this._$QueueTrigger$_(s, i, e);
            this._$_executingTriggerDepth$_++;
            for (const h of t._$runningLayouts$_()) {
                const t = h._$GetEventSheet$_();
                if (!t) continue;
                this._$_runtime$_._$PushCurrentLayout$_(h);
                for (const h of t._$deepIncludes$_()) {
                    const t = yield* h._$_DebugTrigger$_(s, i, e);
                    n = n || t;
                }
                const r = yield* t._$_DebugTrigger$_(s, i, e);
                n = n || r, this._$_runtime$_._$PopCurrentLayout$_();
            }
            return this._$_executingTriggerDepth$_--, n;
        }
        _$QueueTrigger$_(t, s, i) {
            return this._$_queuedTriggers$_.push([ t, s, i ]), !1;
        }
        _$QueueDebugTrigger$_(t, s, i) {
            let e = null;
            const n = new Promise((t => e = t));
            return this._$_queuedDebugTriggers$_.push([ t, s, i, e ]), n;
        }
        * _$_RunQueuedDebugTriggersGen$_() {
            if (this._$_runtime$_._$HitBreakpoint$_()) throw new Error("should not be in breakpoint");
            const t = this._$_runtime$_._$GetLayoutManager$_();
            for (;this._$_queuedDebugTriggers$_.length; ) {
                const [s, i, e, n] = this._$_queuedDebugTriggers$_.shift();
                n(yield* this._$_DebugTrigger$_(t, s, i, e));
            }
        }
        async _$RunQueuedDebugTriggersAsync$_() {
            for (const t of this._$_RunQueuedDebugTriggersGen$_()) await this._$_runtime$_._$DebugBreak$_(t);
        }
        _$_FastTrigger$_(t, s, i, e) {
            let n = !1;
            const h = t._$GetMainRunningLayout$_(), r = h._$GetEventSheet$_();
            if (!r) return;
            this._$_executingTriggerDepth$_++, this._$_runtime$_._$PushCurrentLayout$_(h);
            const o = r._$deepIncludes$_();
            for (let t = 0, h = o.length; t < h; ++t) {
                const h = o[t]._$_FastTrigger$_(s, i, e);
                n = n || h;
            }
            const a = r._$_FastTrigger$_(s, i, e);
            return n = n || a, this._$_runtime$_._$PopCurrentLayout$_(), this._$_executingTriggerDepth$_--, 
            n;
        }
        * _$_DebugFastTrigger$_(t, s, i, e) {
            let n = !1;
            const h = t._$GetMainRunningLayout$_(), r = h._$GetEventSheet$_();
            if (!r) return;
            this._$_executingTriggerDepth$_++, this._$_runtime$_._$PushCurrentLayout$_(h);
            const o = r._$deepIncludes$_();
            for (let t = 0, h = o.length; t < h; ++t) {
                const h = yield* o[t]._$_DebugFastTrigger$_(s, i, e);
                n = n || h;
            }
            const a = yield* r._$_DebugFastTrigger$_(s, i, e);
            return n = n || a, this._$_runtime$_._$PopCurrentLayout$_(), this._$_executingTriggerDepth$_--, 
            n;
        }
        _$GetTriggerDepth$_() {
            return this._$_executingTriggerDepth$_;
        }
        _$IsInTrigger$_() {
            return this._$GetTriggerDepth$_() > 0;
        }
        _$_IncTriggerDepth$_() {
            return ++this._$_executingTriggerDepth$_;
        }
        _$_DecTriggerDepth$_() {
            --this._$_executingTriggerDepth$_;
        }
        _$IsRunningEvents$_() {
            return this._$_runningEventsDepth$_ > 0;
        }
        _$IsInEventEngine$_() {
            return this._$IsRunningEvents$_() || this._$IsInTrigger$_();
        }
        _$_RunQueuedTriggers$_(t) {
            for (const [s, i, e] of this._$_queuedTriggers$_) this._$_Trigger$_(t, s, i, e);
            kg._$clearArray$_(this._$_queuedTriggers$_);
        }
        _$BlockFlushingInstances$_(t) {
            t ? this._$_blockFlushingDepth$_++ : this._$_blockFlushingDepth$_--;
        }
        _$IsFlushingBlocked$_() {
            return this._$_blockFlushingDepth$_ > 0;
        }
        _$ClearSol$_(t) {
            for (let s = 0, i = t.length; s < i; ++s) t[s]._$GetSolStack$_()._$Clear$_();
        }
        _$PushCleanSol$_(t) {
            for (let s = 0, i = t.length; s < i; ++s) t[s]._$GetSolStack$_()._$PushClean$_();
        }
        _$PushCopySol$_(t) {
            for (let s = 0, i = t.length; s < i; ++s) t[s]._$GetSolStack$_()._$PushCopy$_();
        }
        _$PopSol$_(t) {
            for (let s = 0, i = t.length; s < i; ++s) t[s]._$GetSolStack$_()._$Pop$_();
        }
        _$GetDynamicSolModifiersSet$_(t) {
            const s = new Set, i = this._$_eventStack$_._$GetAllStackFrames$_(), e = this._$_eventStack$_._$GetCurrentStackFrameIndex$_();
            for (let n = 0; n <= e; ++n) {
                const e = i[n]._$GetDynamicSolModifiers$_();
                if (e) for (const i of e) t && t.has(i) || s.add(i);
            }
            return s;
        }
        _$PushCleanSolDynamic$_(t) {
            const s = new Set([ ...t ]), i = this._$GetDynamicSolModifiersSet$_(s);
            if (i.size > 0) {
                for (const t of i) t._$GetSolStack$_()._$PushClean$_();
                return [ ...i ];
            }
            return null;
        }
        _$AddScheduledWait$_() {
            const t = kg._$New$_(kg._$ScheduledWait$_, this);
            return this._$_scheduledWaits$_.push(t), t;
        }
        _$scheduledWaits$_() {
            return this._$_scheduledWaits$_;
        }
        _$RunScheduledWaits$_() {
            if (!this._$_scheduledWaits$_.length) return;
            const t = this._$GetCurrentEventStackFrame$_();
            let s = !1;
            this._$_runningEventsDepth$_++;
            for (let i = 0, e = this._$_scheduledWaits$_.length; i < e; ++i) {
                const e = this._$_scheduledWaits$_[i];
                e._$_ShouldRun$_() && e._$_Run$_(t), e._$ShouldRelease$_() && (s = !0);
            }
            s && (this._$_FilterScheduledWaitsToRelease$_(), t._$Reset$_(null)), this._$_runningEventsDepth$_--;
        }
        async _$DebugRunScheduledWaits$_() {
            if (!this._$_scheduledWaits$_.length) return;
            const t = this._$GetCurrentEventStackFrame$_();
            let s = !1;
            this._$_runningEventsDepth$_++;
            for (let i = 0, e = this._$_scheduledWaits$_.length; i < e; ++i) {
                const e = this._$_scheduledWaits$_[i];
                e._$_ShouldRun$_() && await e._$_DebugRun$_(t), e._$ShouldRelease$_() && (s = !0);
            }
            s && (this._$_FilterScheduledWaitsToRelease$_(), t._$Reset$_(null)), this._$_runningEventsDepth$_--;
        }
        _$_FilterScheduledWaitsToRelease$_() {
            const t = kg._$arrayFilterOut$_(this._$_scheduledWaits$_, (t => t._$ShouldRelease$_()));
            for (const s of t) s._$Release$_();
        }
        _$ClearAllScheduledWaits$_() {
            for (const t of this._$_scheduledWaits$_) t._$Release$_();
            kg._$clearArray$_(this._$_scheduledWaits$_);
        }
        _$_OnInstancesReleased$_(t) {
            for (const s of this._$_scheduledWaits$_) s._$RemoveInstances$_(t);
            for (const s of t) {
                const t = this._$_instSignals$_.get(s);
                if (this._$_instSignals$_.delete(s), t) for (const {resolve: s} of t._$signalPromises$_.values()) s(!0);
            }
        }
        _$AddAsyncActionPromise$_(t) {
            this._$_asyncActionPromises$_.push({
                promise: t,
                _$triggerDepth$_: this._$GetTriggerDepth$_()
            });
        }
        _$ClearAsyncActionPromises$_() {
            kg._$clearArray$_(this._$_asyncActionPromises$_);
        }
        _$ClearNestedAsyncActionPromises$_() {
            const t = this._$GetTriggerDepth$_();
            this._$_asyncActionPromises$_ = this._$_asyncActionPromises$_.filter((s => s._$triggerDepth$_ <= t));
        }
        _$GetPromiseForAllAsyncActions$_() {
            const t = Promise.all(this._$_asyncActionPromises$_.map((t => t.promise)));
            return this._$_asyncActionPromises$_ = [], t;
        }
        _$Signal$_(t) {
            const s = t.toLowerCase();
            this._$_signalTags$_.push(s), this._$_runtime$_._$Trigger$_(kg._$Plugins$_._$System$_._$Cnds$_._$OnSignal$_, null), 
            this._$_signalTags$_.pop();
            for (const t of this._$_runtime$_._$GetEventSheetManager$_()._$scheduledWaits$_()) t._$IsSignal$_() && t._$GetSignalTag$_() === s && t._$SetSignalled$_();
            const i = this._$_signalPromises$_.get(s);
            i && (i.resolve(), this._$_signalPromises$_.delete(s));
        }
        _$WaitForSignal$_(t) {
            const s = t.toLowerCase(), i = this._$_signalPromises$_.get(s);
            if (i) return i.promise;
            {
                let t = null;
                const i = new Promise((s => t = s));
                return this._$_signalPromises$_.set(s, {
                    promise: i,
                    resolve: t
                }), i;
            }
        }
        _$GetCurrentSignalTag$_() {
            if (0 === this._$_signalTags$_.length) throw new Error("not in a signal");
            return this._$_signalTags$_.at(-1);
        }
        _$_GetInstanceSignalState$_(t) {
            let s = this._$_instSignals$_.get(t);
            return s || (s = {
                _$signalTags$_: [],
                _$signalPromises$_: new Map
            }, this._$_instSignals$_.set(t, s)), s;
        }
        _$InstanceSignal$_(t, s) {
            const i = this._$_GetInstanceSignalState$_(t), e = s.toLowerCase();
            i._$signalTags$_.push(e), this._$_runtime$_._$Trigger$_(t._$GetPlugin$_()._$GetConstructor$_()._$Cnds$_._$OnInstanceSignal$_, t), 
            i._$signalTags$_.pop();
            for (const s of this._$_runtime$_._$GetEventSheetManager$_()._$scheduledWaits$_()) s._$IsInstanceSignals$_() && s._$GetSignalTag$_() === e && s._$SetInstanceSignalled$_(t);
            const n = i._$signalPromises$_.get(e);
            n && (n.resolve(!1), i._$signalPromises$_.delete(e)), 0 === i._$signalTags$_.length && 0 === i._$signalPromises$_.size && this._$_instSignals$_.delete(t);
        }
        _$WaitForInstanceSignal$_(t, s) {
            const i = this._$_GetInstanceSignalState$_(t), e = s.toLowerCase(), n = i._$signalPromises$_.get(e);
            if (n) return n.promise;
            {
                let t = null;
                const s = new Promise((s => t = s));
                return i._$signalPromises$_.set(e, {
                    promise: s,
                    resolve: t
                }), s;
            }
        }
        _$GetCurrentInstanceSignalTag$_(t) {
            const s = this._$_GetInstanceSignalState$_(t);
            if (!s || 0 === s._$signalTags$_.length) throw new Error("not in a signal");
            return s._$signalTags$_.at(-1);
        }
        _$_SaveToJson$_() {
            return {
                groups: this._$_SaveGroupsToJson$_(),
                cnds: this._$_SaveCndsToJson$_(),
                acts: this._$_SaveActsToJson$_(),
                vars: this._$_SaveVarsToJson$_(),
                waits: this._$_SaveScheduledWaitsToJson$_()
            };
        }
        _$_LoadFromJson$_(t) {
            this._$_LoadGroupsFromJson$_(t.groups), this._$_LoadCndsFromJson$_(t.cnds), this._$_LoadActsFromJson$_(t.acts), 
            this._$_LoadVarsFromJson$_(t.vars), this._$_LoadScheduledWaitsFromJson$_(t.waits);
        }
        _$_SaveGroupsToJson$_() {
            const t = {};
            for (const s of this._$GetAllGroups$_()) t[s._$GetSID$_().toString()] = s._$IsGroupActive$_();
            return t;
        }
        _$_LoadGroupsFromJson$_(t) {
            for (const [s, i] of Object.entries(t)) {
                const t = parseInt(s, 10), e = this._$GetEventGroupBySID$_(t);
                e && e._$SetGroupActive$_(i);
            }
        }
        _$_SaveCndsToJson$_() {
            const t = {};
            for (const [s, i] of this._$_cndsBySid$_) {
                const e = i._$_SaveToJson$_();
                e && (t[s.toString()] = e);
            }
            return t;
        }
        _$_LoadCndsFromJson$_(t) {
            const s = new Map;
            for (const [i, e] of Object.entries(t)) s.set(parseInt(i, 10), e);
            for (const [t, i] of this._$_cndsBySid$_) i._$_LoadFromJson$_(s.get(t) || null);
        }
        _$_SaveActsToJson$_() {
            const t = {};
            for (const [s, i] of this._$_actsBySid$_) {
                const e = i._$_SaveToJson$_();
                e && (t[s.toString()] = e);
            }
            return t;
        }
        _$_LoadActsFromJson$_(t) {
            const s = new Map;
            for (const [i, e] of Object.entries(t)) s.set(parseInt(i, 10), e);
            for (const [t, i] of this._$_actsBySid$_) i._$_LoadFromJson$_(s.get(t) || null);
        }
        _$_SaveVarsToJson$_() {
            const t = {};
            for (const [s, i] of this._$_eventVarsBySid$_) i._$IsConstant$_() || !i._$IsGlobal$_() && !i._$IsStatic$_() || (t[s.toString()] = i._$GetValue$_());
            return t;
        }
        _$_LoadVarsFromJson$_(t) {
            for (const [s, i] of Object.entries(t)) {
                const t = parseInt(s, 10), e = this._$GetEventVariableBySID$_(t);
                e && e._$SetValue$_(i);
            }
        }
        _$_SaveScheduledWaitsToJson$_() {
            return this._$_scheduledWaits$_.filter((t => !t._$IsPromise$_())).map((t => t._$_SaveToJson$_()));
        }
        _$_LoadScheduledWaitsFromJson$_(t) {
            this._$ClearAllScheduledWaits$_();
            for (const s of t) {
                const t = kg._$ScheduledWait$_._$_CreateFromJson$_(this, s);
                t && this._$_scheduledWaits$_.push(t);
            }
        }
        _$_GetPerfRecords$_() {
            return [ ...this._$_runtime$_._$GetLayoutManager$_()._$runningLayouts$_() ].map((t => t._$GetEventSheet$_())).filter((t => t)).map((t => t._$_GetPerfRecord$_()));
        }
        _$FindFirstFunctionBlockParent$_(t) {
            for (;t; ) {
                const s = t._$GetScopeParent$_();
                if (s instanceof kg._$FunctionBlock$_) return s;
                t = s;
            }
            return null;
        }
        _$_InvokeFunctionFromJS$_(t, s) {
            Array.isArray(s) || (s = []);
            const i = this._$GetFunctionBlockByName$_(t.toLowerCase());
            if (!i) return null;
            if (!i._$IsEnabled$_()) return i._$GetDefaultReturnValue$_();
            const e = i._$GetFunctionParameters$_();
            if (s.length < e.length) {
                s = s.slice(0);
                do {
                    s.push(e[s.length]._$GetInitialValue$_());
                } while (s.length < e.length);
            }
            const n = i._$GetEventBlock$_();
            return n._$RunAsExpressionFunctionCall$_(n._$GetSolModifiersIncludingParents$_(), !1, i._$GetReturnType$_(), i._$GetDefaultReturnValue$_(), ...s);
        }
    };
}

{
    const Fg = self._$C3$_;
    Fg._$EventSheet$_ = class extends Fg._$DefendedBase$_ {
        constructor(t, s) {
            super(), this._$_eventSheetManager$_ = t, this._$_runtime$_ = t._$GetRuntime$_(), 
            this._$_name$_ = s[0], this._$_events$_ = [], this._$_triggers$_ = new Map, this._$_fastTriggers$_ = new Map, 
            this._$_eventsByDisplayNumber$_ = new Map, this._$_hasRun$_ = !1, this._$_shallowIncludes$_ = [], 
            this._$_deepIncludes$_ = [], this._$_alreadyIncludedSheets$_ = new Set;
            for (const t of s[1]) this._$_CreateEvent$_(t, null, this._$_events$_);
            this._$_perfRecord$_ = this._$_runtime$_._$IsDebug$_() ? {
                type: "sheet",
                name: this._$_name$_,
                _$totalTimeCounter$_: 0,
                children: []
            } : null;
        }
        _$Release$_() {
            this._$_eventSheetManager$_ = null, this._$_runtime$_ = null;
        }
        _$_CreateEvent$_(t, s, i) {
            switch (t[0]) {
              case 0:
              case 3:
                this._$_CreateEventBlock$_(t, s, i);
                break;

              case 1:
                this._$_CreateEventVariable$_(t, s, i);
                break;

              case 2:
                this._$_CreateInclude$_(t, s, i);
                break;

              case 4:
                this._$_CreateFunctionBlock$_(t, s);
                break;

              case 5:
                this._$_CreateScriptBlock$_(t, s, i);
                break;

              case 6:
                this._$_CreateCustomACEBlock$_(t, s);
                break;

              default:
                throw new Error("invalid event type");
            }
        }
        _$_CreateEventBlock$_(t, s, i) {
            const e = Fg._$EventBlock$_._$Create$_(this, s, t);
            if (e._$IsOrBlock$_()) {
                i.push(e);
                const t = e._$GetConditions$_();
                for (let s = 0, i = t.length; s < i; ++s) t[s]._$IsTrigger$_() && this._$_InitTrigger$_(e, s);
            } else e._$IsTrigger$_() ? this._$_InitTrigger$_(e, 0) : i.push(e);
        }
        _$_CreateFunctionBlock$_(t, s) {
            const i = Fg._$FunctionBlock$_._$CreateFunctionBlock$_(this, s, t);
            this._$_eventSheetManager$_._$_RegisterFunctionBlock$_(i);
        }
        _$_CreateCustomACEBlock$_(t, s) {
            const i = Fg._$FunctionBlock$_._$CreateCustomACEBlock$_(this, s, t);
            this._$_eventSheetManager$_._$_RegisterFunctionBlock$_(i);
        }
        _$_CreateEventVariable$_(t, s, i) {
            const e = Fg._$EventVariable$_._$Create$_(this, s, t);
            i.push(e);
        }
        _$_CreateInclude$_(t, s, i) {
            const e = Fg._$EventInclude$_._$Create$_(this, s, t);
            i.push(e);
        }
        _$_CreateScriptBlock$_(t, s, i) {
            const e = Fg._$EventScript$_._$Create$_(this, s, t);
            i.push(e);
        }
        _$_InitTrigger$_(t, s) {
            t._$IsOrBlock$_() || this._$_eventSheetManager$_._$_AddTriggerToPostInit$_(t);
            const i = t._$GetConditionAt$_(s), e = i._$_GetFunc$_(), n = i._$GetObjectClass$_();
            if (i._$IsFastTrigger$_()) {
                let h = this._$_fastTriggers$_.get(n);
                h || (h = new Map, this._$_fastTriggers$_.set(n, h));
                const r = i._$GetFastTriggerValue$_().toLowerCase();
                let o = h.get(e);
                o || (o = new Map, h.set(e, o));
                let a = o.get(r);
                a || (a = [], o.set(r, a)), a.push([ t, s ]);
            } else {
                let h = this._$_triggers$_.get(n);
                h || (h = {
                    _$methodMap$_: new Map,
                    _$behaviors$_: new Map
                }, this._$_triggers$_.set(n, h));
                const r = i._$GetBehaviorType$_();
                let o;
                r ? (o = h._$behaviors$_.get(r), o || (o = new Map, h._$behaviors$_.set(r, o))) : o = h._$methodMap$_;
                let a = o.get(e);
                a || (a = [], o.set(e, a)), a.push([ t, s ]);
            }
        }
        _$_PostInit$_() {
            const t = this._$_events$_;
            for (let s = 0, i = t.length; s < i; ++s) {
                const e = s < i - 1 && t[s + 1] instanceof Fg._$EventBlock$_ && t[s + 1]._$IsElseBlock$_();
                t[s]._$_PostInit$_(e);
            }
        }
        _$_AddShallowInclude$_(t) {
            this._$_shallowIncludes$_.push(t);
        }
        _$_UpdateDeepIncludes$_() {
            Fg._$clearArray$_(this._$_deepIncludes$_), this._$_AddDeepIncludes$_(this), this._$_alreadyIncludedSheets$_.clear();
        }
        _$_AddDeepIncludes$_(t) {
            const s = t._$_deepIncludes$_, i = t._$_alreadyIncludedSheets$_;
            for (const e of this._$_shallowIncludes$_) {
                const n = e._$GetIncludeSheet$_();
                e._$IsActive$_() && t !== n && !i.has(n) && (i.add(n), n._$_AddDeepIncludes$_(t), 
                s.push(n));
            }
        }
        _$deepIncludes$_() {
            return this._$_deepIncludes$_;
        }
        _$GetEventSheetManager$_() {
            return this._$_eventSheetManager$_;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetName$_() {
            return this._$_name$_;
        }
        _$_RegisterEventByDisplayNumber$_(t, s) {
            this._$_eventsByDisplayNumber$_.set(s, t);
        }
        _$_GetEventByDisplayNumber$_(t) {
            return this._$_eventsByDisplayNumber$_.get(t) || null;
        }
        _$_ResetHasRunFlag$_() {
            this._$_hasRun$_ = !1;
        }
        _$Run$_() {
            if (this._$_hasRun$_) return;
            const t = this._$_runtime$_, s = t._$IsCPUProfiling$_(), i = s ? performance.now() : 0;
            this._$_hasRun$_ = !0;
            const e = this._$GetEventSheetManager$_(), n = e._$GetCurrentEventStackFrame$_();
            for (const s of this._$_events$_) s._$Run$_(n), e._$ClearSol$_(s._$GetSolModifiers$_()), 
            e._$ClearAsyncActionPromises$_(), t._$FlushPendingInstances$_();
            n._$Reset$_(null), s && (this._$_perfRecord$_._$totalTimeCounter$_ += performance.now() - i);
        }
        * _$DebugRun$_() {
            if (this._$_hasRun$_) return;
            this._$_hasRun$_ = !0;
            const t = this._$_runtime$_, s = this._$GetEventSheetManager$_(), i = s._$GetCurrentEventStackFrame$_();
            for (const e of this._$_events$_) yield* e._$DebugRun$_(i), s._$ClearSol$_(e._$GetSolModifiers$_()), 
            s._$ClearAsyncActionPromises$_(), t._$FlushPendingInstances$_();
            i._$Reset$_(null);
        }
        _$_Trigger$_(t, s, i) {
            if (!s) return this._$_TriggerForClass$_(t, s, null, null);
            {
                const e = s._$GetObjectClass$_();
                let n = !1, h = this._$_TriggerForClass$_(t, s, e, i);
                n = n || h;
                for (const r of e._$GetFamilies$_()) h = this._$_TriggerForClass$_(t, s, r, i), 
                n = n || h;
            }
        }
        _$_TriggerForClass$_(t, s, i, e) {
            const n = this._$_triggers$_.get(i);
            if (!n) return !1;
            const h = e ? n._$behaviors$_.get(e) : n._$methodMap$_;
            if (!h) return !1;
            const r = h.get(t);
            if (!r) return !1;
            let o = !1;
            for (const [t, i] of r) {
                const e = this._$_ExecuteTrigger$_(s, t, i);
                o = o || e;
            }
            return o;
        }
        * _$_DebugTrigger$_(t, s, i) {
            if (!s) return yield* this._$_DebugTriggerForClass$_(t, s, null, null);
            {
                const e = s._$GetObjectClass$_();
                let n = !1, h = yield* this._$_DebugTriggerForClass$_(t, s, e, i);
                n = n || h;
                for (const r of e._$GetFamilies$_()) h = yield* this._$_DebugTriggerForClass$_(t, s, r, i), 
                n = n || h;
            }
        }
        * _$_DebugTriggerForClass$_(t, s, i, e) {
            const n = this._$_triggers$_.get(i);
            if (!n) return !1;
            const h = e ? n._$behaviors$_.get(e) : n._$methodMap$_;
            if (!h) return !1;
            const r = h.get(t);
            if (!r) return !1;
            let o = !1;
            for (const [t, i] of r) {
                let e;
                e = t._$DebugCanRunFast$_() ? this._$_ExecuteTrigger$_(s, t, i) : yield* this._$_DebugExecuteTrigger$_(s, t, i), 
                o = o || e;
            }
            return o;
        }
        _$_FastTrigger$_(t, s, i) {
            const e = s._$GetObjectClass$_(), n = this._$_fastTriggers$_.get(e);
            if (!n) return !1;
            const h = n.get(t);
            if (!h) return !1;
            const r = h.get(i);
            if (!r) return !1;
            let o = !1;
            for (let t = 0, s = r.length; t < s; ++t) {
                const s = r[t], i = this._$_ExecuteTrigger$_(null, s[0], s[1]);
                o = o || i;
            }
            return o;
        }
        * _$_DebugFastTrigger$_(t, s, i) {
            const e = s._$GetObjectClass$_(), n = this._$_fastTriggers$_.get(e);
            if (!n) return !1;
            const h = n.get(t);
            if (!h) return !1;
            const r = h.get(i);
            if (!r) return !1;
            let o = !1;
            for (let t = 0, s = r.length; t < s; ++t) {
                const s = r[t], i = s[0], e = s[1];
                let n;
                n = i._$DebugCanRunFast$_() ? this._$_ExecuteTrigger$_(null, i, e) : yield* this._$_DebugExecuteTrigger$_(null, i, e), 
                o = o || n;
            }
            return o;
        }
        _$_ExecuteTrigger$_(t, s, i) {
            const e = this._$_runtime$_, n = this._$_eventSheetManager$_, h = n._$GetCurrentEvent$_(), r = n._$GetEventStack$_(), o = n._$GetTriggerDepth$_();
            let a = !1;
            h && n._$PushCleanSol$_(h._$GetSolModifiersIncludingParents$_()), n._$PushCleanSol$_(s._$GetSolModifiersIncludingParents$_());
            const u = o > 1;
            u && n._$GetLocalVarStack$_()._$Push$_();
            const l = r._$Push$_(s);
            t && (s._$GetConditions$_()[i]._$GetObjectClass$_()._$GetCurrentSol$_()._$SetSinglePicked$_(t), 
            t._$IsInContainer$_() && t._$SetSiblingsSinglePicked$_());
            let c = !0;
            if (s._$GetParent$_()) {
                const t = s._$GetTriggerParents$_();
                for (let s = 0, i = t.length; s < i; ++s) if (!t[s]._$RunPreTrigger$_(l)) {
                    c = !1;
                    break;
                }
            }
            return c && (s._$IsOrBlock$_() ? s._$RunOrBlockTrigger$_(l, i) : s._$Run$_(l), a = l._$GetLastEventTrue$_()), 
            r._$Pop$_(), u && n._$GetLocalVarStack$_()._$Pop$_(), n._$PopSol$_(s._$GetSolModifiersIncludingParents$_()), 
            h && n._$PopSol$_(h._$GetSolModifiersIncludingParents$_()), h || 1 !== o || (n._$ClearAsyncActionPromises$_(), 
            n._$IsFlushingBlocked$_() || e._$FlushPendingInstances$_()), a;
        }
        * _$_DebugExecuteTrigger$_(t, s, i) {
            const e = this._$_runtime$_, n = this._$_eventSheetManager$_, h = n._$GetCurrentEvent$_(), r = n._$GetEventStack$_(), o = n._$GetTriggerDepth$_();
            let a = !1;
            h && n._$PushCleanSol$_(h._$GetSolModifiersIncludingParents$_()), n._$PushCleanSol$_(s._$GetSolModifiersIncludingParents$_());
            const u = o > 1;
            u && n._$GetLocalVarStack$_()._$Push$_();
            const l = r._$Push$_(s);
            t && (s._$GetConditions$_()[i]._$GetObjectClass$_()._$GetCurrentSol$_()._$SetSinglePicked$_(t), 
            t._$IsInContainer$_() && t._$SetSiblingsSinglePicked$_());
            let c = !0;
            if (s._$GetParent$_()) {
                const t = s._$GetTriggerParents$_();
                for (let s = 0, i = t.length; s < i; ++s) if (!(yield* t[s]._$DebugRunPreTrigger$_(l))) {
                    c = !1;
                    break;
                }
            }
            return c && (s._$IsOrBlock$_() ? yield* s._$DebugRunOrBlockTrigger$_(l, i) : yield* s._$DebugRun$_(l), 
            a = l._$GetLastEventTrue$_()), r._$Pop$_(), u && n._$GetLocalVarStack$_()._$Pop$_(), 
            n._$PopSol$_(s._$GetSolModifiersIncludingParents$_()), h && n._$PopSol$_(h._$GetSolModifiersIncludingParents$_()), 
            h || 1 !== o || (n._$ClearAsyncActionPromises$_(), n._$IsFlushingBlocked$_() || e._$FlushPendingInstances$_()), 
            a;
        }
        _$_GetPerfRecord$_() {
            return this._$_perfRecord$_;
        }
    };
}

{
    let jg = function(t, s) {
        return !0;
    };
    0;
    const Bg = self._$C3$_, zg = [];
    function* Ug(t, s) {
        return !0;
    }
    Bg._$EventBlock$_ = class extends Bg._$DefendedBase$_ {
        constructor(t, s, i) {
            super(), this._$_eventSheet$_ = t, this._$_runtime$_ = t._$GetRuntime$_(), this._$_parent$_ = s, 
            this._$_scopeParent$_ = null, this._$_eventStack$_ = this._$_runtime$_._$GetEventSheetManager$_()._$GetEventStack$_(), 
            this._$_solModifiers$_ = [], this._$_solModifiersIncludingParents$_ = [], this._$_hasGotSolModifiersIncludingParents$_ = !1, 
            this._$_isSolWriterAfterCnds$_ = !1, this._$_isTopLevelGroup$_ = !1, this._$_hasElseBlock$_ = !1, 
            this._$_isOrBlock$_ = !!i[2], this._$_isElseBlock$_ = !1, this._$_triggerParents$_ = null, 
            this._$_conditions$_ = [], this._$_actions$_ = [], this._$_subEvents$_ = [], this._$_RunActions$_ = jg, 
            this._$_DebugRunActions$_ = Ug, this._$_isGroup$_ = !1, this._$_isInitiallyActive$_ = !1, 
            this._$_groupName$_ = "", this._$_isGroupActive$_ = !1, this._$_containedIncludes$_ = null, 
            this._$_perfRecord$_ = null, this._$_sid$_ = i[4], this._$_displayNumber$_ = i[5], 
            this._$_eventSheet$_._$_RegisterEventByDisplayNumber$_(this, this._$_displayNumber$_), 
            this._$_debugData$_ = this._$_runtime$_._$IsDebug$_() ? {
                _$isBreakpoint$_: i[3][0],
                _$isBreakable$_: i[3][1],
                _$canRunAllConditionsFast$_: !1,
                _$canRunAllActionsFast$_: !1,
                _$canRunAllSubEventsFast$_: !1,
                _$canRunSelfFast$_: !1
            } : null, this._$GetEventSheetManager$_()._$_RegisterEventBlock$_(this), 3 === i[0] && this._$_InitGroup$_(i[1]);
            let e = 0;
            for (const t of i[6]) {
                const s = Bg._$Condition$_._$Create$_(this, t, e++);
                this._$_conditions$_.push(s), this._$_AddSolModifier$_(s._$GetObjectClass$_());
            }
            e = 0;
            for (const t of i[7]) {
                const s = Bg._$Action$_._$Create$_(this, t, e++);
                this._$_actions$_.push(s);
            }
            if (9 === i.length) {
                const t = i[8];
                for (const s of t) this._$_eventSheet$_._$_CreateEvent$_(s, this, this._$_subEvents$_);
            }
            this._$_conditions$_.length && (this._$_isElseBlock$_ = null === this._$_conditions$_[0]._$GetObjectClass$_() && this._$_conditions$_[0]._$_GetFunc$_() === Bg._$Plugins$_._$System$_._$Cnds$_._$Else$_), 
            0 === this._$_conditions$_.length && (this._$_conditions$_ = zg), 0 === this._$_actions$_.length && (this._$_actions$_ = zg), 
            0 === this._$_subEvents$_.length && (this._$_subEvents$_ = zg);
        }
        static _$Create$_(t, s, i) {
            return Bg._$New$_(Bg._$EventBlock$_, t, s, i);
        }
        _$_InitGroup$_(t) {
            this._$_isGroup$_ = !0, this._$_isInitiallyActive$_ = !!t[0], this._$_isGroupActive$_ = this._$_isInitiallyActive$_, 
            this._$_groupName$_ = t[1].toLowerCase(), this._$_containedIncludes$_ = [], this._$GetEventSheetManager$_()._$_RegisterGroup$_(this), 
            this._$_runtime$_._$IsDebug$_() && (this._$_perfRecord$_ = {
                type: "group",
                name: t[1],
                _$totalTimeCounter$_: 0,
                children: []
            });
        }
        _$_AddContainedInclude$_(t) {
            this._$_containedIncludes$_.push(t);
        }
        _$_AddContainerSolModifierToList$_(t, s) {
            for (const i of t._$GetContainer$_()._$objectTypes$_()) s.includes(i) || s.push(i);
        }
        _$_AddSolModifierToList$_(t, s) {
            if (t) if (s.includes(t) || s.push(t), t._$IsFamily$_()) for (const i of t._$GetFamilyMembers$_()) i._$IsInContainer$_() && this._$_AddContainerSolModifierToList$_(i, s); else t._$IsInContainer$_() && this._$_AddContainerSolModifierToList$_(t, s);
        }
        _$_AddSolModifier$_(t) {
            this._$_AddSolModifierToList$_(t, this._$_solModifiers$_);
        }
        _$_AddParentSolModifier$_(t) {
            this._$_AddSolModifierToList$_(t, this._$_solModifiersIncludingParents$_);
        }
        _$SetAllSolModifiers$_() {
            this._$_solModifiers$_ = this._$_runtime$_._$GetAllObjectClasses$_();
        }
        _$_PostInit$_(t) {
            this._$_hasElseBlock$_ = !!t, this._$_IdentifyTopLevelGroup$_(), this._$_IdentifyTriggerParents$_();
            for (const t of this._$_conditions$_) t._$_PostInit$_();
            if (this._$_actions$_.length > 0) {
                let t = !1;
                for (const s of this._$_actions$_) s._$_PostInit$_(), s._$HasReturnType$_() && (t = !0);
                t ? (this._$_RunActions$_ = this._$_RunActions_ReturnValue$_, this._$_DebugRunActions$_ = this._$_DebugRunActions_ReturnValue$_) : (this._$_RunActions$_ = this._$_RunActions_Fast$_, 
                this._$_DebugRunActions$_ = this._$_DebugRunActions_Fast$_);
            }
            const s = this._$_subEvents$_;
            for (let t = 0, i = s.length; t < i; ++t) {
                const e = t < i - 1 && s[t + 1] instanceof Bg._$EventBlock$_ && s[t + 1]._$IsElseBlock$_();
                s[t]._$_PostInit$_(e);
            }
            this._$_debugData$_ && this._$_UpdateCanRunFast$_(), this._$_perfRecord$_ && this._$_GetPerfRecordParent$_()._$_GetPerfRecord$_().children.push(this._$_perfRecord$_);
        }
        _$_GetPerfRecord$_() {
            return this._$_perfRecord$_;
        }
        _$_GetPerfRecordParent$_() {
            let t = this._$GetParent$_();
            for (;t; ) {
                if (t._$IsGroup$_()) return t;
                t = t._$GetParent$_();
            }
            return this._$_eventSheet$_;
        }
        _$_UpdateCanRunFast$_() {
            const t = this._$_debugData$_;
            t._$canRunAllConditionsFast$_ = this._$_conditions$_.every((t => t._$DebugCanRunFast$_())), 
            t._$canRunAllActionsFast$_ = this._$_actions$_.every((t => t._$DebugCanRunFast$_())), 
            t._$canRunAllSubEventsFast$_ = this._$_subEvents$_.every((t => t._$DebugCanRunFast$_())), 
            t._$canRunSelfFast$_ = t._$canRunAllConditionsFast$_ && t._$canRunAllActionsFast$_ && t._$canRunAllSubEventsFast$_;
        }
        _$_UpdateCanRunFastRecursive$_() {
            let t = this;
            do {
                t._$_UpdateCanRunFast$_(), t = t._$GetParent$_();
            } while (t);
        }
        _$_IdentifyTopLevelGroup$_() {
            if (!this._$IsGroup$_()) return;
            let t = this._$GetParent$_();
            for (this._$_isTopLevelGroup$_ = !0; t; ) {
                if (!t._$IsGroup$_()) {
                    this._$_isTopLevelGroup$_ = !1;
                    break;
                }
                t = t._$GetParent$_();
            }
        }
        _$_IdentifySolModifiersIncludingParents$_() {
            const t = this._$_runtime$_._$GetAllObjectClasses$_();
            if (this._$_solModifiers$_ === t) this._$_solModifiersIncludingParents$_ = t; else {
                this._$_solModifiersIncludingParents$_ = Bg._$cloneArray$_(this._$_solModifiers$_);
                let t = this._$GetParent$_();
                for (;t; ) {
                    for (const s of t._$_solModifiers$_) this._$_AddParentSolModifier$_(s);
                    t = t._$GetParent$_();
                }
                const s = this._$GetEventSheetManager$_();
                this._$_solModifiers$_ = s._$_DeduplicateSolModifierList$_(this._$_solModifiers$_), 
                this._$_solModifiersIncludingParents$_ = s._$_DeduplicateSolModifierList$_(this._$_solModifiersIncludingParents$_);
            }
        }
        _$_IdentifyTriggerParents$_() {
            if (!this._$HasAnyTriggeredCondition$_()) return;
            this._$_triggerParents$_ = [];
            let t = this._$GetParent$_();
            for (;t; ) this._$_triggerParents$_.push(t), t = t._$GetParent$_();
            this._$_triggerParents$_.reverse();
        }
        _$SetSolWriterAfterCnds$_() {
            this._$_isSolWriterAfterCnds$_ = !0, this._$_parent$_ && this._$_parent$_._$SetSolWriterAfterCnds$_();
        }
        _$IsSolWriterAfterCnds$_() {
            return this._$_isSolWriterAfterCnds$_;
        }
        _$GetSolModifiers$_() {
            return this._$_solModifiers$_;
        }
        _$GetSolModifiersIncludingParents$_() {
            return this._$_hasGotSolModifiersIncludingParents$_ || (this._$_hasGotSolModifiersIncludingParents$_ = !0, 
            this._$_IdentifySolModifiersIncludingParents$_()), this._$_solModifiersIncludingParents$_;
        }
        _$HasSolModifier$_(t) {
            return this._$_solModifiers$_.includes(t);
        }
        _$GetTriggerParents$_() {
            return this._$_triggerParents$_;
        }
        _$GetEventSheet$_() {
            return this._$_eventSheet$_;
        }
        _$GetEventSheetManager$_() {
            return this._$_eventSheet$_._$GetEventSheetManager$_();
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetParent$_() {
            return this._$_parent$_;
        }
        _$_SetScopeParent$_(t) {
            this._$_scopeParent$_ = t;
        }
        _$GetScopeParent$_() {
            return this._$_scopeParent$_ || this._$_parent$_;
        }
        _$GetDisplayNumber$_() {
            return this._$_displayNumber$_;
        }
        _$IsDebugBreakable$_() {
            return this._$_debugData$_ && this._$_debugData$_._$isBreakable$_;
        }
        _$IsDebugBreakpoint$_() {
            return this._$IsDebugBreakable$_() && this._$_debugData$_._$isBreakpoint$_;
        }
        _$_SetDebugBreakpoint$_(t) {
            this._$_debugData$_._$isBreakpoint$_ = !!t, this._$_UpdateCanRunFastRecursive$_();
        }
        _$IsGroup$_() {
            return this._$_isGroup$_;
        }
        _$IsTopLevelGroup$_() {
            return this._$_isTopLevelGroup$_;
        }
        _$IsElseBlock$_() {
            return this._$_isElseBlock$_;
        }
        _$HasElseBlock$_() {
            return this._$_hasElseBlock$_;
        }
        _$GetGroupName$_() {
            return this._$_groupName$_;
        }
        _$IsGroupActive$_() {
            return this._$_isGroupActive$_;
        }
        _$ResetInitialActivation$_() {
            this._$SetGroupActive$_(this._$_isInitiallyActive$_);
        }
        _$SetGroupActive$_(t) {
            if (t = !!t, !this._$_isGroup$_) throw new Error("not a group");
            if (this._$_isGroupActive$_ !== t) {
                this._$_isGroupActive$_ = t;
                for (const t of this._$_containedIncludes$_) t._$UpdateActive$_();
                if (this._$_containedIncludes$_.length) {
                    const t = this._$_runtime$_._$GetCurrentLayout$_()._$GetEventSheet$_();
                    t && t._$_UpdateDeepIncludes$_();
                }
            }
        }
        _$GetSID$_() {
            return this._$_sid$_;
        }
        _$IsOrBlock$_() {
            return this._$_isOrBlock$_;
        }
        _$IsTrigger$_() {
            return this._$_conditions$_.length && this._$_conditions$_[0]._$IsTrigger$_();
        }
        _$IsForFunctionBlock$_() {
            return this._$_scopeParent$_ && this._$_scopeParent$_ instanceof Bg._$FunctionBlock$_;
        }
        _$HasAnyTriggeredCondition$_() {
            return this._$IsForFunctionBlock$_() || this._$_conditions$_.some((t => t._$IsTrigger$_()));
        }
        _$GetConditions$_() {
            return this._$_conditions$_;
        }
        _$GetConditionCount$_() {
            return this._$_conditions$_.length;
        }
        _$GetConditionAt$_(t) {
            if ((t = Math.floor(t)) < 0 || t >= this._$_conditions$_.length) throw new RangeError("invalid condition index");
            return this._$_conditions$_[t];
        }
        _$GetConditionByDebugIndex$_(t) {
            return this._$GetConditionAt$_(t);
        }
        _$IsFirstConditionOfType$_(t) {
            let s = t._$GetIndex$_();
            if (0 === s) return !0;
            --s;
            const i = t._$IsSystemOrSingleGlobalCondition$_() ? t._$GetFirstObjectParameterObjectClass$_() : t._$GetObjectClass$_();
            for (;s >= 0; --s) {
                const t = this._$_conditions$_[s];
                if (i === t._$GetObjectClass$_() || t._$IsSystemOrSingleGlobalCondition$_() && t._$GetFirstObjectParameterObjectClass$_() === i) return !1;
            }
            return !0;
        }
        _$GetActions$_() {
            return this._$_actions$_;
        }
        _$GetActionCount$_() {
            return this._$_actions$_.length;
        }
        _$GetActionAt$_(t) {
            if ((t = Math.floor(t)) < 0 || t >= this._$_actions$_.length) throw new RangeError("invalid action index");
            return this._$_actions$_[t];
        }
        _$GetActionByDebugIndex$_(t) {
            t = Math.floor(t);
            const s = this._$_actions$_.find((s => s._$GetDebugIndex$_() === t));
            if (!s) throw new RangeError("invalid action debug index");
            return s;
        }
        _$_HasActionIndex$_(t) {
            return (t = Math.floor(t)) >= 0 && t < this._$_actions$_.length;
        }
        _$GetSubEvents$_() {
            return this._$_subEvents$_;
        }
        _$_GetAllLocalVariablesInScope$_() {
            return this._$_subEvents$_.filter((t => t instanceof Bg._$EventVariable$_));
        }
        _$RunPreTrigger$_(t) {
            t._$SetCurrentEvent$_(this);
            const s = this._$_conditions$_;
            let i = 0 === s.length;
            for (let e = 0, n = s.length; e < n; ++e) {
                const n = s[e];
                if (t._$SetConditionIndex$_(e), n._$IsLooping$_()) throw new Error("trigger cannot be used as sub-event to a loop");
                if (n._$Run$_()) i = !0; else if (!this._$_isOrBlock$_) return !1;
            }
            return !this._$_isOrBlock$_ || i;
        }
        _$RunOrBlockTrigger$_(t, s) {
            t._$SetCurrentEvent$_(this), t._$SetConditionIndex$_(s), this._$_conditions$_[s]._$Run$_() && (this._$_RunActions$_(t, 0) && this._$_RunSubEvents$_(t), 
            t._$SetLastEventTrue$_(!0));
        }
        * _$DebugRunPreTrigger$_(t) {
            t._$SetCurrentEvent$_(this);
            const s = this._$_conditions$_;
            let i = 0 === s.length;
            for (let e = 0, n = s.length; e < n; ++e) {
                const n = s[e];
                if (t._$SetConditionIndex$_(e), n._$IsLooping$_()) throw new Error("trigger cannot be used as sub-event to a loop");
                let h;
                if (h = n._$DebugCanRunFast$_() ? n._$Run$_() : yield* n._$DebugRun$_(), h) i = !0; else if (!this._$_isOrBlock$_) return !1;
            }
            return !this._$_isOrBlock$_ || i;
        }
        * _$DebugRunOrBlockTrigger$_(t, s) {
            t._$SetCurrentEvent$_(this), t._$SetConditionIndex$_(s);
            const i = this._$_conditions$_[s];
            let e;
            if (e = i._$DebugCanRunFast$_() ? i._$Run$_() : yield* i._$DebugRun$_(), e) {
                let s;
                s = this._$DebugCanRunActionsFast$_() ? this._$_RunActions$_(t, 0) : yield* this._$_DebugRunActions$_(t, 0), 
                s && (this._$DebugCanRunSubEventsFast$_() ? this._$_RunSubEvents$_() : yield* this._$_DebugRunSubEvents$_()), 
                t._$SetLastEventTrue$_(!0);
            }
        }
        _$Run$_(t) {
            t._$SetCurrentEvent$_(this), this._$_isElseBlock$_ || t._$SetElseBranchRan$_(!1), 
            this._$_isOrBlock$_ ? this._$_RunOrBlock$_(t) : this._$_RunAndBlock$_(t);
        }
        * _$DebugRun$_(t) {
            (this._$IsDebugBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            t._$SetCurrentEvent$_(this), this._$_isElseBlock$_ || t._$SetElseBranchRan$_(!1), 
            this._$_isOrBlock$_ ? yield* this._$_DebugRunOrBlock$_(t) : yield* this._$_DebugRunAndBlock$_(t);
        }
        _$_RunOrBlock$_(t) {
            const s = this._$_conditions$_;
            let i = 0 === s.length;
            for (let e = 0, n = s.length; e < n; ++e) {
                const n = s[e];
                if (n._$IsTrigger$_()) continue;
                t._$SetConditionIndex$_(e);
                const h = n._$Run$_();
                i = i || h;
            }
            t._$SetLastEventTrue$_(i), i && (this._$_RunActions$_(t, 0) && this._$_RunSubEvents$_(t), 
            this._$_hasElseBlock$_ && t._$SetElseBranchRan$_(!0));
        }
        * _$_DebugRunOrBlock$_(t) {
            const s = this._$_conditions$_;
            let i = 0 === s.length;
            for (let e = 0, n = s.length; e < n; ++e) {
                const n = s[e];
                if (n._$IsTrigger$_()) continue;
                let h;
                t._$SetConditionIndex$_(e), h = n._$DebugCanRunFast$_() ? n._$Run$_() : yield* n._$DebugRun$_(), 
                i = i || h;
            }
            if (t._$SetLastEventTrue$_(i), i) {
                let s;
                s = this._$DebugCanRunActionsFast$_() ? this._$_RunActions$_(t, 0) : yield* this._$_DebugRunActions$_(t, 0), 
                s && (this._$DebugCanRunSubEventsFast$_() ? this._$_RunSubEvents$_() : yield* this._$_DebugRunSubEvents$_()), 
                this._$_hasElseBlock$_ && t._$SetElseBranchRan$_(!0);
            }
        }
        _$_RunAndBlock$_(t) {
            const s = this._$_conditions$_;
            for (let i = 0, e = s.length; i < e; ++i) {
                const e = s[i];
                if (t._$SetConditionIndex$_(i), !e._$Run$_()) return void t._$SetLastEventTrue$_(!1);
            }
            t._$SetLastEventTrue$_(!0), this._$_RunActions$_(t, 0) && this._$_RunSubEvents$_(t), 
            t._$GetLastEventTrue$_() && this._$_hasElseBlock$_ && t._$SetElseBranchRan$_(!0);
        }
        * _$_DebugRunAndBlock$_(t) {
            const s = this._$_conditions$_;
            for (let i = 0, e = s.length; i < e; ++i) {
                const e = s[i];
                let n;
                if (t._$SetConditionIndex$_(i), n = e._$DebugCanRunFast$_() ? e._$Run$_() : yield* e._$DebugRun$_(), 
                !n) return void t._$SetLastEventTrue$_(!1);
            }
            let i;
            t._$SetLastEventTrue$_(!0), i = this._$DebugCanRunActionsFast$_() ? this._$_RunActions$_(t, 0) : yield* this._$_DebugRunActions$_(t, 0), 
            i && (this._$DebugCanRunSubEventsFast$_() ? this._$_RunSubEvents$_() : yield* this._$_DebugRunSubEvents$_()), 
            t._$GetLastEventTrue$_() && this._$_hasElseBlock$_ && t._$SetElseBranchRan$_(!0);
        }
        _$_RunActions_Fast$_(t, s) {
            const i = this._$_actions$_;
            for (let e = s, n = i.length; e < n; ++e) {
                const s = i[e];
                t._$SetActionIndex$_(e), s._$Run$_();
            }
            return !0;
        }
        * _$_DebugRunActions_Fast$_(t, s) {
            const i = this._$_actions$_;
            for (let e = s, n = i.length; e < n; ++e) {
                const s = i[e];
                t._$SetActionIndex$_(e), s._$DebugCanRunFast$_() ? s._$Run$_() : yield* s._$DebugRun$_();
            }
            return !0;
        }
        _$_RunActions_ReturnValue$_(t, s) {
            const i = this._$GetEventSheetManager$_(), e = this._$_actions$_;
            for (let n = s, h = e.length; n < h; ++n) {
                const s = e[n];
                t._$SetActionIndex$_(n);
                const h = s._$Run$_();
                if (s._$CanBailOut$_() && !0 === h) return !1;
                s._$IsAsync$_() && h instanceof Promise && i._$AddAsyncActionPromise$_(h);
            }
            return !0;
        }
        * _$_DebugRunActions_ReturnValue$_(t, s) {
            const i = this._$GetEventSheetManager$_(), e = this._$_actions$_;
            for (let n = s, h = e.length; n < h; ++n) {
                const s = e[n];
                let h;
                if (t._$SetActionIndex$_(n), h = s._$DebugCanRunFast$_() ? s._$Run$_() : yield* s._$DebugRun$_(), 
                s._$CanBailOut$_() && !0 === h) return !1;
                s._$IsAsync$_() && h instanceof Promise && i._$AddAsyncActionPromise$_(h);
            }
            return !0;
        }
        _$_ResumeActionsAndSubEvents$_(t) {
            this._$_RunActions$_(t, t._$GetActionIndex$_()) && this._$_RunSubEvents$_();
        }
        * _$_DebugResumeActionsAndSubEvents$_(t) {
            (yield* this._$_DebugRunActions$_(t, t._$GetActionIndex$_())) && (yield* this._$_DebugRunSubEvents$_());
        }
        _$_RunSubEvents$_() {
            if (!this._$_subEvents$_.length) return;
            const t = this._$IsGroup$_() && this._$_runtime$_._$IsCPUProfiling$_(), s = t ? performance.now() : 0, i = this._$_eventStack$_, e = i._$Push$_(this);
            this._$_isSolWriterAfterCnds$_ ? this._$_RunSubEvents_SolWriterAfterCnds$_(e) : this._$_RunSubEvents_Fast$_(e), 
            i._$Pop$_(), t && (this._$_perfRecord$_._$totalTimeCounter$_ += performance.now() - s);
        }
        _$_RunSubEvents_SolWriterAfterCnds$_(t) {
            const s = this._$_isGroup$_, i = this._$_isTopLevelGroup$_, e = this._$GetEventSheetManager$_(), n = this._$_subEvents$_;
            for (let h = 0, r = n.length, o = r - 1; h < r; ++h) {
                const r = n[h], a = r._$GetSolModifiers$_(), u = !i || !s && h < o;
                u && e._$PushCopySol$_(a), r._$Run$_(t), u ? e._$PopSol$_(a) : e._$ClearSol$_(a);
            }
        }
        _$_RunSubEvents_Fast$_(t) {
            const s = this._$_subEvents$_;
            for (let i = 0, e = s.length; i < e; ++i) s[i]._$Run$_(t);
        }
        * _$_DebugRunSubEvents$_() {
            if (!this._$_subEvents$_.length) return;
            const t = this._$_eventStack$_, s = t._$Push$_(this);
            this._$_isSolWriterAfterCnds$_ ? yield* this._$_DebugRunSubEvents_SolWriterAfterCnds$_(s) : yield* this._$_DebugRunSubEvents_Fast$_(s), 
            t._$Pop$_();
        }
        * _$_DebugRunSubEvents_SolWriterAfterCnds$_(t) {
            const s = this._$_isGroup$_, i = this._$_isTopLevelGroup$_, e = this._$GetEventSheetManager$_(), n = this._$_subEvents$_;
            for (let h = 0, r = n.length, o = r - 1; h < r; ++h) {
                const r = n[h], a = r._$GetSolModifiers$_(), u = !i || !s && h < o;
                u && e._$PushCopySol$_(a), yield* r._$DebugRun$_(t), u ? e._$PopSol$_(a) : e._$ClearSol$_(a);
            }
        }
        * _$_DebugRunSubEvents_Fast$_(t) {
            const s = this._$_subEvents$_;
            for (let i = 0, e = s.length; i < e; ++i) yield* s[i]._$DebugRun$_(t);
        }
        _$Retrigger$_(t, s) {
            s._$ResetQuick$_();
            const i = this._$_conditions$_;
            if (!this._$IsOrBlock$_()) for (let e = t._$GetConditionIndex$_() + 1, n = i.length; e < n; ++e) {
                const t = i[e];
                if (s._$SetConditionIndex$_(e), !t._$Run$_()) return !1;
            }
            return this._$_RunActions$_(s, 0) && this._$_RunSubEvents$_(s), !0;
        }
        * _$DebugRetrigger$_(t, s) {
            s._$ResetQuick$_();
            const i = this._$_conditions$_;
            if (!this._$IsOrBlock$_()) for (let e = t._$GetConditionIndex$_() + 1, n = i.length; e < n; ++e) {
                const t = i[e];
                let n;
                if (s._$SetConditionIndex$_(e), n = t._$DebugCanRunFast$_() ? t._$Run$_() : yield* t._$DebugRun$_(), 
                !n) return !1;
            }
            let e;
            return e = this._$DebugCanRunActionsFast$_() ? this._$_RunActions$_(s, 0) : yield* this._$_DebugRunActions$_(s, 0), 
            e && (this._$DebugCanRunSubEventsFast$_() ? this._$_RunSubEvents$_() : yield* this._$_DebugRunSubEvents$_()), 
            !0;
        }
        _$DebugCanRunFast$_() {
            return !this._$IsDebugBreakpoint$_() && !this._$_runtime$_._$DebugBreakNext$_() && this._$_debugData$_._$canRunSelfFast$_;
        }
        _$DebugCanRunActionsFast$_() {
            return !this._$_runtime$_._$DebugBreakNext$_() && this._$_debugData$_._$canRunAllActionsFast$_;
        }
        _$DebugCanRunSubEventsFast$_() {
            return !this._$_runtime$_._$DebugBreakNext$_() && this._$_debugData$_._$canRunAllSubEventsFast$_;
        }
        _$_CheckParentsOKToRun$_(t) {
            if (this._$GetParent$_()) {
                const s = this._$GetTriggerParents$_();
                for (let i = 0, e = s.length; i < e; ++i) if (!s[i]._$RunPreTrigger$_(t)) return !1;
            }
            return !0;
        }
        * _$_DebugCheckParentsOKToRun$_(t) {
            if (this._$GetParent$_()) {
                const s = this._$GetTriggerParents$_();
                for (let i = 0, e = s.length; i < e; ++i) if (!(yield* s[i]._$DebugRunPreTrigger$_(t))) return !1;
            }
            return !0;
        }
        _$_EvaluateFunctionCallParameters$_(t, s, i) {
            if (s.length > 0) if (i) {
                const i = s.map((t => t._$Get$_(0)));
                t._$GetLocalVarStack$_()._$Push$_(), this._$_scopeParent$_._$SetFunctionParameters$_(i);
            } else this._$_scopeParent$_._$EvaluateFunctionParameters$_(s); else i && t._$GetLocalVarStack$_()._$Push$_();
        }
        _$RunAsFunctionCall$_(t, s, i, e) {
            let n, h;
            const r = t.length > 0;
            let o = null;
            const a = this._$_runtime$_, u = this._$_eventStack$_, l = a._$GetEventSheetManager$_(), c = this._$_scopeParent$_, f = c._$IsAsync$_(), d = l._$_IncTriggerDepth$_() > 1;
            if (this._$_EvaluateFunctionCallParameters$_(l, s, d), r && (i ? l._$PushCopySol$_(t) : l._$PushCleanSol$_(t)), 
            null !== e) {
                if (e._$copyFromObjectClass$_) {
                    const t = i ? e._$copyFromObjectClass$_._$GetCurrentSol$_() : e._$copyFromObjectClass$_._$GetSolStack$_()._$GetOneBelowCurrentSol$_(), s = e._$copyToObjectClass$_._$GetCurrentSol$_();
                    s._$SetArrayPicked$_(t._$GetInstances$_()), s._$ClearElseInstances$_(), i || e._$copyToObjectClass$_._$ApplySolToContainer$_();
                } else if (e._$pickObjectClass$_) {
                    const t = e._$pickObjectClass$_._$GetCurrentSol$_();
                    t._$SetArrayPicked$_(e._$pickInstances$_), t._$ClearElseInstances$_();
                }
                e._$pushCleanSolDynamic$_ && (o = l._$PushCleanSolDynamic$_(t));
            }
            const p = u._$Push$_(this);
            return i && p._$SetDynamicSolModifiers$_(t), this._$_CheckParentsOKToRun$_(p) && (p._$SetCurrentEvent$_(this), 
            f && ([h, n] = c._$StartAsyncFunctionCall$_()), this._$_RunAndBlock$_(p), f && c._$MaybeFinishAsyncFunctionCall$_(h)), 
            u._$Pop$_(), d && l._$GetLocalVarStack$_()._$Pop$_(), null !== o && l._$PopSol$_(o), 
            r && l._$PopSol$_(t), l._$_DecTriggerDepth$_(), f || l._$ClearNestedAsyncActionPromises$_(), 
            n;
        }
        * _$DebugRunAsFunctionCall$_(t, s, i, e) {
            let n, h;
            (this._$IsDebugBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this);
            const r = t.length > 0;
            let o = null;
            const a = this._$_runtime$_, u = this._$_eventStack$_, l = a._$GetEventSheetManager$_(), c = this._$_scopeParent$_, f = c._$IsAsync$_(), d = l._$_IncTriggerDepth$_() > 1;
            if (this._$_EvaluateFunctionCallParameters$_(l, s, d), r && (i ? l._$PushCopySol$_(t) : l._$PushCleanSol$_(t)), 
            null !== e) {
                if (e._$copyFromObjectClass$_) {
                    const t = i ? e._$copyFromObjectClass$_._$GetCurrentSol$_() : e._$copyFromObjectClass$_._$GetSolStack$_()._$GetOneBelowCurrentSol$_(), s = e._$copyToObjectClass$_._$GetCurrentSol$_();
                    s._$SetArrayPicked$_(t._$GetInstances$_()), s._$ClearElseInstances$_(), i || e._$copyToObjectClass$_._$ApplySolToContainer$_();
                } else if (e._$pickObjectClass$_) {
                    const t = e._$pickObjectClass$_._$GetCurrentSol$_();
                    t._$SetArrayPicked$_(e._$pickInstances$_), t._$ClearElseInstances$_();
                }
                e._$pushCleanSolDynamic$_ && (o = l._$PushCleanSolDynamic$_(t));
            }
            const p = u._$Push$_(this);
            return i && p._$SetDynamicSolModifiers$_(t), (yield* this._$_DebugCheckParentsOKToRun$_(p)) && (p._$SetCurrentEvent$_(this), 
            f && ([h, n] = c._$StartAsyncFunctionCall$_()), yield* this._$_DebugRunAndBlock$_(p), 
            f && c._$MaybeFinishAsyncFunctionCall$_(h)), u._$Pop$_(), d && l._$GetLocalVarStack$_()._$Pop$_(), 
            null !== o && l._$PopSol$_(o), r && l._$PopSol$_(t), l._$_DecTriggerDepth$_(), f || l._$ClearNestedAsyncActionPromises$_(), 
            n;
        }
        _$RunAsMappedFunctionCall$_(t, s) {
            const i = this._$GetSolModifiersIncludingParents$_(), e = i.length > 0, n = this._$_runtime$_, h = this._$_eventStack$_, r = n._$GetEventSheetManager$_(), o = r._$_IncTriggerDepth$_() > 1;
            o && r._$GetLocalVarStack$_()._$Push$_(), this._$_scopeParent$_._$SetFunctionParameters$_(t), 
            e && (s ? r._$PushCopySol$_(i) : r._$PushCleanSol$_(i));
            const a = h._$Push$_(this);
            this._$_CheckParentsOKToRun$_(a) && (a._$SetCurrentEvent$_(this), this._$_RunAndBlock$_(a)), 
            h._$Pop$_(), o && r._$GetLocalVarStack$_()._$Pop$_(), e && r._$PopSol$_(i), r._$_DecTriggerDepth$_(), 
            r._$ClearNestedAsyncActionPromises$_();
        }
        * _$DebugRunAsMappedFunctionCall$_(t, s) {
            (this._$IsDebugBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this);
            const i = this._$GetSolModifiersIncludingParents$_(), e = i.length > 0, n = this._$_runtime$_, h = this._$_eventStack$_, r = n._$GetEventSheetManager$_(), o = r._$_IncTriggerDepth$_() > 1;
            o && r._$GetLocalVarStack$_()._$Push$_(), this._$_scopeParent$_._$SetFunctionParameters$_(t), 
            e && (s ? r._$PushCopySol$_(i) : r._$PushCleanSol$_(i));
            const a = h._$Push$_(this);
            (yield* this._$_DebugCheckParentsOKToRun$_(a)) && (a._$SetCurrentEvent$_(this), 
            yield* this._$_DebugRunAndBlock$_(a)), h._$Pop$_(), o && r._$GetLocalVarStack$_()._$Pop$_(), 
            e && r._$PopSol$_(i), r._$_DecTriggerDepth$_(), r._$ClearNestedAsyncActionPromises$_();
        }
        _$RunAsExpressionFunctionCall$_(t, s, i, e, ...n) {
            let h, r;
            const o = t.length > 0, a = this._$_runtime$_, u = this._$_eventStack$_, l = a._$GetEventSheetManager$_(), c = this._$_scopeParent$_, f = c._$IsAsync$_(), d = l._$_IncTriggerDepth$_() > 1;
            d && l._$GetLocalVarStack$_()._$Push$_(), n.length > 0 && this._$_scopeParent$_._$SetFunctionParameters$_(n), 
            o && (s ? l._$PushCopySol$_(t) : l._$PushCleanSol$_(t));
            const p = u._$Push$_(this);
            return p._$InitCallFunctionExpression$_(i, e), u._$PushExpFunc$_(p), a._$SetDebuggingEnabled$_(!1), 
            this._$_CheckParentsOKToRun$_(p) && (p._$SetCurrentEvent$_(this), f && ([r, h] = c._$StartAsyncFunctionCall$_()), 
            this._$_RunAndBlock$_(p), f && c._$MaybeFinishAsyncFunctionCall$_(r)), a._$SetDebuggingEnabled$_(!0), 
            u._$Pop$_(), u._$PopExpFunc$_(), d && l._$GetLocalVarStack$_()._$Pop$_(), o && l._$PopSol$_(t), 
            l._$_DecTriggerDepth$_(), f || l._$ClearNestedAsyncActionPromises$_(), h || p._$GetFunctionReturnValue$_();
        }
    };
}

{
    const Wg = self._$C3$_, Jg = [];
    let Qg = !1;
    Wg._$EventScript$_ = class extends Wg._$DefendedBase$_ {
        constructor(t, s, i) {
            super();
            const e = t._$GetRuntime$_(), n = t._$GetEventSheetManager$_();
            this._$_eventSheet$_ = t, this._$_eventSheetManager$_ = n, this._$_runtime$_ = t._$GetRuntime$_(), 
            this._$_parent$_ = s;
            const h = e._$GetObjectReference$_(i[1]);
            this._$_func$_ = h, this._$_displayNumber$_ = i[2], this._$_eventSheet$_._$_RegisterEventByDisplayNumber$_(this, this._$_displayNumber$_), 
            this._$_debugData$_ = e._$IsDebug$_() ? {
                _$isBreakpoint$_: i[3][0],
                _$isBreakable$_: i[3][1]
            } : null;
        }
        static _$Create$_(t, s, i) {
            return Wg._$New$_(Wg._$EventScript$_, t, s, i);
        }
        _$_PostInit$_() {
            const t = this._$_func$_, s = this._$_runtime$_._$GetEventSheetManager$_()._$_GetLocalVariablesScriptInterface$_(this);
            this._$_func$_ = t.bind(null, this._$_runtime$_._$GetIRuntime$_(), s);
        }
        _$GetParent$_() {
            return this._$_parent$_;
        }
        _$GetScopeParent$_() {
            return this._$_parent$_;
        }
        _$GetEventSheet$_() {
            return this._$_eventSheet$_;
        }
        _$GetDisplayNumber$_() {
            return this._$_displayNumber$_;
        }
        _$IsDebugBreakable$_() {
            return this._$_debugData$_ && this._$_debugData$_._$isBreakable$_;
        }
        _$IsDebugBreakpoint$_() {
            return this._$IsDebugBreakable$_() && this._$_debugData$_._$isBreakpoint$_;
        }
        _$_SetDebugBreakpoint$_(t) {
            this._$_debugData$_._$isBreakpoint$_ = !!t;
        }
        _$IsElseBlock$_() {
            return !1;
        }
        _$GetSolModifiers$_() {
            return Jg;
        }
        _$GetSolModifiersIncludingParents$_() {
            return this._$_parent$_ ? this._$_parent$_._$GetSolModifiersIncludingParents$_() : Jg;
        }
        _$Run$_(t) {
            t._$SetCurrentEvent$_(this), this._$_eventSheetManager$_._$AddAsyncActionPromise$_(this._$_RunUserScript$_());
        }
        async _$_RunUserScript$_() {
            try {
                await this._$_func$_();
            } catch (t) {
                console.error(`Unhandled exception running script %c${this._$GetEventSheet$_()._$GetName$_()}, event ${this._$GetDisplayNumber$_()}:`, "font-size: 1.2em; font-weight: bold;", t), 
                self._$C3Debugger$_ && self._$C3Debugger$_._$_SetLastErrorScript$_(this), Qg || (console.info("%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()", "font-weight: bold; text-decoration: underline", "", "font-weight: bold"), 
                Qg = !0);
            }
        }
        * _$DebugRun$_(t) {
            t._$SetCurrentEvent$_(this), (this._$IsDebugBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            this._$Run$_(t);
        }
        _$DebugCanRunFast$_() {
            return !this._$IsDebugBreakpoint$_() && !this._$_runtime$_._$DebugBreakNext$_();
        }
        static _$HadUserScriptException$_() {
            return Qg;
        }
        static _$SetHadUserScriptException$_() {
            Qg = !0;
        }
    };
}

{
    const Yg = self._$C3$_;
    self.assert;
    Yg._$FunctionBlock$_ = class extends Yg._$DefendedBase$_ {
        constructor(t, s, i) {
            super(), this._$_eventSheet$_ = t, this._$_runtime$_ = t._$GetRuntime$_(), this._$_parent$_ = s, 
            this._$_functionType$_ = 0, this._$_functionName$_ = "", this._$_returnType$_ = 0, 
            this._$_functionParameters$_ = [], this._$_isEnabled$_ = !0, this._$_aceName$_ = "", 
            this._$_objectClass$_ = null, this._$_hasOverrides$_ = !1, this._$_innerLocalVariables$_ = [], 
            this._$_isCopyPicked$_ = !1, this._$_isAsync$_ = !1, this._$_nextAsyncId$_ = 0, 
            this._$_currentAsyncId$_ = -1, this._$_asyncMap$_ = new Map, this._$_eventBlock$_ = Yg._$EventBlock$_._$Create$_(t, s, i), 
            this._$_eventBlock$_._$_SetScopeParent$_(this);
        }
        _$InitFunctionBlock$_(t) {
            this._$_functionType$_ = 0, this._$_functionName$_ = t[0], this._$_returnType$_ = t[1], 
            this._$_functionParameters$_ = t[2].map((t => Yg._$EventVariable$_._$Create$_(this._$_eventSheet$_, this, t))), 
            this._$_isEnabled$_ = t[3], this._$_isAsync$_ = t[4], this._$_isCopyPicked$_ = t[5];
        }
        _$InitCustomACEBlock$_(t) {
            this._$_functionType$_ = 1, this._$_aceName$_ = t[1], this._$_objectClass$_ = this._$_runtime$_._$GetObjectClassByIndex$_(t[2]), 
            this._$_eventBlock$_._$_AddSolModifier$_(this._$_objectClass$_), this._$_functionName$_ = this._$_objectClass$_._$GetName$_() + "." + this._$_aceName$_, 
            this._$_returnType$_ = t[3], this._$_functionParameters$_ = t[4].map((t => Yg._$EventVariable$_._$Create$_(this._$_eventSheet$_, this, t))), 
            this._$_isEnabled$_ = t[5], this._$_isAsync$_ = t[6], this._$_isCopyPicked$_ = t[7], 
            this._$_objectClass$_._$AddCustomAction$_(this);
        }
        static _$CreateFunctionBlock$_(t, s, i) {
            const e = Yg._$New$_(Yg._$FunctionBlock$_, t, s, i), n = i[1];
            return e._$InitFunctionBlock$_(n), e;
        }
        static _$CreateCustomACEBlock$_(t, s, i) {
            const e = Yg._$New$_(Yg._$FunctionBlock$_, t, s, i), n = i[1];
            return e._$InitCustomACEBlock$_(n), e;
        }
        _$_CheckOverrideState$_() {
            if (this._$_objectClass$_ && this._$_objectClass$_._$IsFamily$_()) for (const t of this._$_objectClass$_._$GetFamilyMembers$_()) if (t._$HasOwnCustomActionByName$_(this._$_aceName$_)) {
                this._$_hasOverrides$_ = !0;
                break;
            }
        }
        _$_PostInit$_() {
            for (const t of this._$_functionParameters$_) t._$_PostInit$_();
            this._$_eventBlock$_._$_PostInit$_(!1);
        }
        _$GetFunctionType$_() {
            return this._$_functionType$_;
        }
        _$_GetAllLocalVariablesInScope$_() {
            return this._$_functionParameters$_;
        }
        _$GetFunctionParameters$_() {
            return this._$_functionParameters$_;
        }
        _$GetFunctionParameterCount$_() {
            return this._$_functionParameters$_.length;
        }
        _$_RegisterLocalVariable$_(t) {
            this._$_innerLocalVariables$_.push(t);
        }
        _$_GetAllInnerLocalVariables$_() {
            return this._$_innerLocalVariables$_;
        }
        _$EvaluateFunctionParameters$_(t) {
            const s = this._$_functionParameters$_;
            for (let i = 0, e = s.length; i < e; ++i) s[i]._$SetValue$_(t[i]._$Get$_(0));
        }
        _$SetFunctionParameters$_(t) {
            const s = this._$_functionParameters$_;
            for (let i = 0, e = s.length; i < e; ++i) s[i]._$SetValue$_(t[i]);
        }
        _$CaptureFunctionParameters$_() {
            return this._$_functionParameters$_.map((t => t._$GetValue$_()));
        }
        _$GetParent$_() {
            return this._$_parent$_;
        }
        _$GetScopeParent$_() {
            return this._$_parent$_;
        }
        _$GetFunctionName$_() {
            return this._$_functionName$_;
        }
        _$GetACEName$_() {
            return this._$_aceName$_;
        }
        _$HasCustomACEOverrides$_() {
            return this._$_hasOverrides$_;
        }
        _$GetReturnType$_() {
            return this._$_returnType$_;
        }
        _$GetObjectClass$_() {
            return this._$_objectClass$_;
        }
        _$IsEnabled$_() {
            return this._$_isEnabled$_;
        }
        _$GetDefaultReturnValue$_() {
            switch (this._$_returnType$_) {
              case 0:
                return null;

              case 2:
                return "";

              default:
                return 0;
            }
        }
        _$GetEventBlock$_() {
            return this._$_eventBlock$_;
        }
        _$IsCopyPicked$_() {
            return this._$_isCopyPicked$_;
        }
        _$IsAsync$_() {
            return this._$_isAsync$_;
        }
        _$StartAsyncFunctionCall$_() {
            const t = this._$_nextAsyncId$_++;
            let s;
            this._$_currentAsyncId$_ = t;
            const i = new Promise((t => s = t));
            return this._$_asyncMap$_.set(t, {
                resolve: s,
                _$pauseCount$_: 0
            }), [ t, i ];
        }
        _$MaybeFinishAsyncFunctionCall$_(t) {
            const s = this._$_asyncMap$_.get(t);
            0 === s._$pauseCount$_ && (s.resolve(), this._$_asyncMap$_.delete(t)), this._$_currentAsyncId$_ = -1;
        }
        _$PauseCurrentAsyncFunction$_() {
            return this._$_asyncMap$_.get(this._$_currentAsyncId$_)._$pauseCount$_++, this._$_currentAsyncId$_;
        }
        _$ResumeAsyncFunction$_(t) {
            this._$_currentAsyncId$_ = t, this._$_asyncMap$_.get(t)._$pauseCount$_--;
        }
        _$RunAsFamilyCustomActionWithOverrides$_(t, s) {
            const i = new Map, e = [];
            for (const t of this._$_objectClass$_._$GetCurrentSol$_()._$GetInstances$_()) {
                const s = t._$GetObjectClass$_();
                if (s._$HasOwnCustomActionByName$_(this._$_aceName$_)) {
                    const e = i.get(s);
                    Array.isArray(e) ? e.push(t) : i.set(s, [ t ]);
                } else e.push(t);
            }
            if (e.length > 0 && this._$_eventBlock$_._$RunAsFunctionCall$_(t, s, this._$_isCopyPicked$_, {
                _$pickObjectClass$_: this._$_objectClass$_,
                _$pickInstances$_: e
            }), i.size > 0) for (const [e, n] of i) {
                const i = e._$GetOwnCustomActionByName$_(this._$_aceName$_)._$GetEventBlock$_(), h = [ ...new Set([ ...t, ...i._$GetSolModifiers$_() ]) ];
                i._$RunAsFunctionCall$_(h, s, this._$_isCopyPicked$_, {
                    _$pickObjectClass$_: e,
                    _$pickInstances$_: n
                });
            }
        }
        * _$DebugRunAsFamilyCustomActionWithOverrides$_(t, s) {
            const i = new Map, e = [];
            for (const t of this._$_objectClass$_._$GetCurrentSol$_()._$GetInstances$_()) {
                const s = t._$GetObjectClass$_();
                if (s._$HasOwnCustomActionByName$_(this._$_aceName$_)) {
                    const e = i.get(s);
                    Array.isArray(e) ? e.push(t) : i.set(s, [ t ]);
                } else e.push(t);
            }
            if (e.length > 0 && (yield* this._$_eventBlock$_._$DebugRunAsFunctionCall$_(t, s, this._$_isCopyPicked$_, {
                _$pickObjectClass$_: this._$_objectClass$_,
                _$pickInstances$_: e
            })), i.size > 0) for (const [e, n] of i) {
                const i = e._$GetOwnCustomActionByName$_(this._$_aceName$_)._$GetEventBlock$_(), h = [ ...new Set([ ...t, ...i._$GetSolModifiers$_() ]) ];
                yield* i._$DebugRunAsFunctionCall$_(h, s, this._$_isCopyPicked$_, {
                    _$pickObjectClass$_: e,
                    _$pickInstances$_: n
                });
            }
        }
    };
}

{
    const Vg = self._$C3$_, Hg = [];
    Vg._$EventVariable$_ = class extends Vg._$DefendedBase$_ {
        constructor(t, s, i) {
            super();
            const e = t._$GetEventSheetManager$_();
            this._$_eventSheet$_ = t, this._$_eventSheetManager$_ = e, this._$_runtime$_ = t._$GetRuntime$_(), 
            this._$_parent$_ = s, this._$_localVarStack$_ = e._$GetLocalVarStack$_(), this._$_name$_ = i[1], 
            this._$_type$_ = i[2], this._$_initialValue$_ = i[3], this._$_isStatic$_ = !!i[4], 
            this._$_isConstant$_ = !!i[5], this._$_isFunctionParameter$_ = s instanceof Vg._$FunctionBlock$_, 
            this._$_sid$_ = i[6], this._$_jsPropName$_ = this._$_runtime$_._$GetJsPropName$_(i[8]), 
            this._$_scriptSetter$_ = t => this._$SetValue$_(t), this._$_scriptGetter$_ = () => this._$GetValue$_(), 
            this._$_hasSingleValue$_ = !this._$_parent$_ || this._$_isStatic$_ || this._$_isConstant$_, 
            this._$_value$_ = this._$_initialValue$_, this._$_localIndex$_ = -1, this._$IsBoolean$_() && (this._$_value$_ = this._$_value$_ ? 1 : 0), 
            !this._$IsLocal$_() || this._$IsStatic$_() || this._$IsConstant$_() || (this._$_localIndex$_ = e._$_GetNextLocalVarIndex$_(this)), 
            e._$_RegisterEventVariable$_(this);
        }
        static _$Create$_(t, s, i) {
            return Vg._$New$_(Vg._$EventVariable$_, t, s, i);
        }
        _$_PostInit$_() {
            if (this._$IsLocal$_() && !this._$IsStatic$_() && !this._$IsConstant$_() && !this._$IsFunctionParameter$_()) {
                const t = this._$_eventSheetManager$_._$FindFirstFunctionBlockParent$_(this);
                t && t._$_RegisterLocalVariable$_(this);
            }
        }
        _$GetName$_() {
            return this._$_name$_;
        }
        _$GetJsPropName$_() {
            return this._$_jsPropName$_;
        }
        _$GetParent$_() {
            return this._$_parent$_;
        }
        _$GetScopeParent$_() {
            return this._$GetParent$_();
        }
        _$IsGlobal$_() {
            return !this._$GetParent$_();
        }
        _$IsLocal$_() {
            return !this._$IsGlobal$_();
        }
        _$IsFunctionParameter$_() {
            return this._$_isFunctionParameter$_;
        }
        _$IsStatic$_() {
            return this._$_isStatic$_;
        }
        _$IsConstant$_() {
            return this._$_isConstant$_;
        }
        _$IsNumber$_() {
            return 0 === this._$_type$_;
        }
        _$IsString$_() {
            return 1 === this._$_type$_;
        }
        _$IsBoolean$_() {
            return 2 === this._$_type$_;
        }
        _$IsElseBlock$_() {
            return !1;
        }
        _$GetSID$_() {
            return this._$_sid$_;
        }
        _$GetInitialValue$_() {
            return this._$_initialValue$_;
        }
        _$GetSolModifiers$_() {
            return Hg;
        }
        _$Run$_(t) {
            !this._$IsLocal$_() || this._$IsStatic$_() || this._$IsConstant$_() || this._$SetValue$_(this._$GetInitialValue$_());
        }
        _$DebugCanRunFast$_() {
            return !0;
        }
        * _$DebugRun$_(t) {
            this._$Run$_(t);
        }
        _$SetValue$_(t) {
            this._$IsNumber$_() ? "number" != typeof t && (t = parseFloat(t)) : this._$IsString$_() ? "string" != typeof t && (t = t.toString()) : this._$IsBoolean$_() && (t = t ? 1 : 0), 
            this._$_hasSingleValue$_ ? this._$_value$_ = t : this._$_localVarStack$_._$GetCurrent$_()[this._$_localIndex$_] = t;
        }
        _$GetValue$_() {
            return this._$_hasSingleValue$_ ? this._$_value$_ : this._$_localVarStack$_._$GetCurrent$_()[this._$_localIndex$_];
        }
        _$GetTypedValue$_() {
            let t = this._$GetValue$_();
            return this._$IsBoolean$_() && (t = !!t), t;
        }
        _$ResetToInitialValue$_() {
            this._$_value$_ = this._$_initialValue$_;
        }
        _$_GetScriptInterfaceDescriptor$_() {
            return {
                configurable: !1,
                enumerable: !0,
                get: this._$_scriptGetter$_,
                set: this._$_scriptSetter$_
            };
        }
    };
}

{
    const qg = self._$C3$_, Xg = (self.assert, []);
    qg._$EventInclude$_ = class extends qg._$DefendedBase$_ {
        constructor(t, s, i) {
            super();
            const e = t._$GetEventSheetManager$_();
            this._$_eventSheet$_ = t, this._$_eventSheetManager$_ = e, this._$_runtime$_ = t._$GetRuntime$_(), 
            this._$_parent$_ = s, this._$_includeSheet$_ = null, this._$_includeSheetName$_ = i[1], 
            this._$_isActive$_ = !0;
        }
        static _$Create$_(t, s, i) {
            return qg._$New$_(qg._$EventInclude$_, t, s, i);
        }
        _$_PostInit$_() {
            this._$_includeSheet$_ = this._$_eventSheetManager$_._$GetEventSheetByName$_(this._$_includeSheetName$_), 
            this._$_eventSheet$_._$_AddShallowInclude$_(this);
            let t = this._$GetParent$_();
            for (;t; ) t instanceof qg._$EventBlock$_ && t._$IsGroup$_() && t._$_AddContainedInclude$_(this), 
            t = t._$GetParent$_();
            this._$UpdateActive$_(), this._$_runtime$_._$IsDebug$_() && this._$_eventSheet$_._$_GetPerfRecord$_().children.push(this._$_includeSheet$_._$_GetPerfRecord$_());
        }
        _$GetParent$_() {
            return this._$_parent$_;
        }
        _$GetSolModifiers$_() {
            return Xg;
        }
        _$GetIncludeSheet$_() {
            return this._$_includeSheet$_;
        }
        _$Run$_(t) {
            const s = !!this._$GetParent$_(), i = this._$_runtime$_._$GetAllObjectClasses$_();
            s && this._$_eventSheetManager$_._$PushCleanSol$_(i), this._$_includeSheet$_._$Run$_(), 
            s && this._$_eventSheetManager$_._$PopSol$_(i);
        }
        * _$DebugRun$_(t) {
            const s = !!this._$GetParent$_(), i = this._$_runtime$_._$GetAllObjectClasses$_();
            s && this._$_eventSheetManager$_._$PushCleanSol$_(i), yield* this._$_includeSheet$_._$DebugRun$_(), 
            s && this._$_eventSheetManager$_._$PopSol$_(i);
        }
        _$DebugCanRunFast$_() {
            return !1;
        }
        _$IsActive$_() {
            return this._$_isActive$_;
        }
        _$UpdateActive$_() {
            let t = this._$GetParent$_();
            for (;t; ) {
                if (t instanceof qg._$EventBlock$_ && t._$IsGroup$_() && !t._$IsGroupActive$_()) return void (this._$_isActive$_ = !1);
                t = t._$GetParent$_();
            }
            this._$_isActive$_ = !0;
        }
    };
}

{
    let Zg = function(t, s) {
        return t >= s ? t % s : t < 0 ? (t <= -s && (t %= s), t < 0 && (t += s), t) : t;
    };
    0;
    const Kg = self._$C3$_;
    self.assert;
    Kg._$ExpNode$_ = class extends Kg._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_owner$_ = t, this._$_runtime$_ = t._$GetRuntime$_();
        }
        _$_PostInit$_() {}
        static _$CreateNode$_(t, s) {
            const i = s[0], e = [ ey, sy, iy, ny, $g, ty ];
            return Kg._$New$_(e[i], t, s);
        }
    };
    class $g extends Kg._$ExpNode$_ {
        constructor(t, s) {
            super(t), this._$_systemPlugin$_ = this._$_runtime$_._$GetSystemPlugin$_(), this._$_func$_ = this._$_runtime$_._$GetObjectReference$_(s[1]), 
            this._$_func$_ !== Kg._$Plugins$_._$System$_._$Exps$_.random && this._$_func$_ !== Kg._$Plugins$_._$System$_._$Exps$_._$choose$_ || this._$_owner$_._$SetVariesPerInstance$_();
        }
        _$GetBoundMethod$_() {
            return this._$_systemPlugin$_._$_GetBoundACEMethod$_(this._$_func$_, this._$_systemPlugin$_);
        }
    }
    class ty extends Kg._$ExpNode$_ {
        constructor(t, s) {
            super(t), this._$_functionBlock$_ = null, this._$_functionName$_ = s[1], this._$_owner$_._$SetVariesPerInstance$_();
        }
        _$_PostInit$_() {
            const t = this._$_runtime$_._$GetEventSheetManager$_();
            this._$_functionBlock$_ = t._$GetFunctionBlockByName$_(this._$_functionName$_), 
            this._$_functionName$_ = null;
            const s = this._$_owner$_._$GetEventBlock$_(), i = this._$_functionBlock$_._$GetEventBlock$_();
            this._$_combinedSolModifiers$_ = [ ...new Set([ ...s._$GetSolModifiersIncludingParents$_(), ...i._$GetSolModifiersIncludingParents$_() ]) ], 
            this._$_combinedSolModifiers$_ = t._$_DeduplicateSolModifierList$_(this._$_combinedSolModifiers$_);
        }
        _$GetBoundMethod$_() {
            const t = this._$_functionBlock$_;
            if (t._$IsEnabled$_()) {
                const s = t._$GetEventBlock$_();
                return Kg._$EventBlock$_.prototype._$RunAsExpressionFunctionCall$_.bind(s, this._$_combinedSolModifiers$_, t._$IsCopyPicked$_(), t._$GetReturnType$_(), t._$GetDefaultReturnValue$_());
            }
            {
                const s = t._$GetDefaultReturnValue$_();
                return () => s;
            }
        }
    }
    class sy extends Kg._$ExpNode$_ {
        constructor(t, s) {
            super(t), this._$_objectClass$_ = this._$_runtime$_._$GetObjectClassByIndex$_(s[1]), 
            this._$_func$_ = this._$_runtime$_._$GetObjectReference$_(s[2]), this._$_returnsString$_ = !!s[3], 
            this._$_eventStack$_ = this._$_runtime$_._$GetEventSheetManager$_()._$GetEventStack$_(), 
            this._$_owner$_._$_MaybeVaryFor$_(this._$_objectClass$_);
        }
        _$GetBoundMethod$_() {
            return this._$_objectClass$_._$GetPlugin$_()._$_GetBoundACEMethod$_(this._$_func$_, this._$_objectClass$_._$GetSingleGlobalInstance$_()._$GetSdkInstance$_());
        }
        _$ExpObject$_(...t) {
            const s = this._$_objectClass$_, i = s._$GetCurrentSol$_()._$GetExpressionInstances$_(), e = i.length;
            if (0 === e) return this._$_returnsString$_ ? "" : 0;
            const n = Zg(this._$_owner$_._$GetSolIndex$_(), e);
            return this._$_eventStack$_._$GetCurrentStackFrame$_()._$SetExpressionObjectClass$_(s), 
            this._$_func$_.apply(i[n]._$GetSdkInstance$_(), t);
        }
        _$ExpObject_InstExpr$_(t, ...s) {
            const i = this._$_objectClass$_, e = i._$GetInstances$_(), n = e.length;
            if (0 === n || "number" != typeof t) return this._$_returnsString$_ ? "" : 0;
            const h = Zg(t, n);
            return this._$_eventStack$_._$GetCurrentStackFrame$_()._$SetExpressionObjectClass$_(i), 
            this._$_func$_.apply(e[h]._$GetSdkInstance$_(), s);
        }
    }
    class iy extends Kg._$ExpNode$_ {
        constructor(t, s) {
            super(t), this._$_objectClass$_ = this._$_runtime$_._$GetObjectClassByIndex$_(s[1]), 
            this._$_varIndex$_ = s[3], this._$_returnsString$_ = !!s[2], this._$_owner$_._$_MaybeVaryFor$_(this._$_objectClass$_);
        }
        _$ExpInstVar$_() {
            const t = this._$_objectClass$_._$GetCurrentSol$_()._$GetExpressionInstances$_(), s = t.length;
            return 0 === s ? this._$_returnsString$_ ? "" : 0 : t[Zg(this._$_owner$_._$GetSolIndex$_(), s)]._$_GetInstanceVariableValueUnchecked$_(this._$_varIndex$_);
        }
        _$ExpInstVar_Family$_() {
            const t = this._$_objectClass$_, s = t._$GetCurrentSol$_()._$GetExpressionInstances$_(), i = s.length;
            if (0 === i) return this._$_returnsString$_ ? "" : 0;
            const e = s[Zg(this._$_owner$_._$GetSolIndex$_(), i)], n = e._$GetObjectClass$_()._$GetFamilyInstanceVariableOffset$_(t._$GetFamilyIndex$_());
            return e._$_GetInstanceVariableValueUnchecked$_(this._$_varIndex$_ + n);
        }
        _$ExpInstVar_InstExpr$_(t) {
            const s = this._$_objectClass$_, i = s._$GetInstances$_(), e = i.length;
            if (0 === e || "number" != typeof t) return this._$_returnsString$_ ? "" : 0;
            const n = i[Zg(t, e)];
            let h = 0;
            return s._$IsFamily$_() && (h = n._$GetObjectClass$_()._$GetFamilyInstanceVariableOffset$_(s._$GetFamilyIndex$_())), 
            n._$_GetInstanceVariableValueUnchecked$_(this._$_varIndex$_ + h);
        }
    }
    class ey extends Kg._$ExpNode$_ {
        constructor(t, s) {
            super(t), this._$_objectClass$_ = this._$_runtime$_._$GetObjectClassByIndex$_(s[1]), 
            this._$_behaviorType$_ = this._$_objectClass$_._$GetBehaviorTypeByName$_(s[2]), 
            this._$_behaviorIndex$_ = this._$_objectClass$_._$GetBehaviorIndexByName$_(s[2]), 
            this._$_func$_ = this._$_runtime$_._$GetObjectReference$_(s[3]), this._$_returnsString$_ = !!s[4], 
            this._$_eventStack$_ = this._$_runtime$_._$GetEventSheetManager$_()._$GetEventStack$_(), 
            this._$_owner$_._$_MaybeVaryFor$_(this._$_objectClass$_);
        }
        _$ExpBehavior$_(...t) {
            const s = this._$_objectClass$_, i = s._$GetCurrentSol$_()._$GetExpressionInstances$_(), e = i.length;
            if (0 === e) return this._$_returnsString$_ ? "" : 0;
            const n = Zg(this._$_owner$_._$GetSolIndex$_(), e);
            this._$_eventStack$_._$GetCurrentStackFrame$_()._$SetExpressionObjectClass$_(s);
            const h = i[n];
            let r = 0;
            return s._$IsFamily$_() && (r = h._$GetObjectClass$_()._$GetFamilyBehaviorOffset$_(s._$GetFamilyIndex$_())), 
            this._$_func$_.apply(h._$GetBehaviorInstances$_()[this._$_behaviorIndex$_ + r]._$GetSdkInstance$_(), t);
        }
        _$ExpBehavior_InstExpr$_(t, ...s) {
            const i = this._$_objectClass$_, e = i._$GetInstances$_(), n = e.length;
            if (0 === n || "number" != typeof t) return this._$_returnsString$_ ? "" : 0;
            const h = Zg(t, n);
            this._$_eventStack$_._$GetCurrentStackFrame$_()._$SetExpressionObjectClass$_(i);
            const r = e[h];
            let o = 0;
            return i._$IsFamily$_() && (o = r._$GetObjectClass$_()._$GetFamilyBehaviorOffset$_(i._$GetFamilyIndex$_())), 
            this._$_func$_.apply(r._$GetBehaviorInstances$_()[this._$_behaviorIndex$_ + o]._$GetSdkInstance$_(), s);
        }
    }
    class ny extends Kg._$ExpNode$_ {
        constructor(t, s) {
            super(t), this._$_eventVar$_ = null, this._$_eventVarSid$_ = s[1];
        }
        _$_PostInit$_() {
            this._$_eventVar$_ = this._$_runtime$_._$GetEventSheetManager$_()._$GetEventVariableBySID$_(this._$_eventVarSid$_);
        }
        _$GetVar$_() {
            return this._$_eventVar$_;
        }
    }
}

{
    let hy = function(t) {
        const s = self._$C3_ExpressionFuncs$_[t];
        if (!s) throw new Error("invalid expression number");
        return s;
    };
    0;
    const ry = self._$C3$_;
    self.assert;
    ry._$Parameter$_ = class extends ry._$DefendedBase$_ {
        constructor(t, s, i) {
            super(), this._$_owner$_ = t, this._$_index$_ = i, this._$_type$_ = s, this._$Get$_ = null, 
            this._$_variesPerInstance$_ = !1, this._$_isConstant$_ = !1;
        }
        static _$Create$_(t, s, i) {
            const e = s[0], n = [ oy, ay, my, ly, fy, uy, dy, oy, ly, ly, gy, yy, my, wy, ay, py, cy, My, Sy, by, Ty, vy ];
            return ry._$New$_(n[e], t, e, i, s);
        }
        _$_PostInit$_() {}
        _$SetVariesPerInstance$_() {
            this._$_variesPerInstance$_ = !0;
        }
        _$_MaybeVaryFor$_(t) {
            this._$_variesPerInstance$_ || t && (t._$GetPlugin$_()._$IsSingleGlobal$_() || (this._$_variesPerInstance$_ = !0));
        }
        _$VariesPerInstance$_() {
            return this._$_variesPerInstance$_;
        }
        _$GetIndex$_() {
            return this._$_index$_;
        }
        _$GetRuntime$_() {
            return this._$_owner$_._$GetRuntime$_();
        }
        _$GetEventBlock$_() {
            return this._$_owner$_._$GetEventBlock$_();
        }
        _$IsConstant$_() {
            return this._$_isConstant$_;
        }
        _$IsObjectParameter$_() {
            return 4 === this._$_type$_;
        }
    };
    class oy extends ry._$Parameter$_ {
        constructor(t, s, i, e) {
            super(t, s, i), this._$_solIndex$_ = 0;
            const n = e[1];
            this._$_expressionNumber$_ = n[0], this._$_numberedNodes$_ = [], this._$_expressionFunc$_ = null;
            for (let t = 1, s = n.length; t < s; ++t) this._$_numberedNodes$_.push(ry._$ExpNode$_._$CreateNode$_(this, n[t]));
            this._$_numberedNodes$_.length ? this._$Get$_ = this._$GetExpression$_ : (this._$Get$_ = hy(this._$_expressionNumber$_), 
            this._$_isConstant$_ = !0);
        }
        _$_GetNode$_(t) {
            if (t < 0 || t >= this._$_numberedNodes$_.length) throw new RangeError("invalid numbered node");
            return this._$_numberedNodes$_[t];
        }
        _$_PostInit$_() {
            for (const t of this._$_numberedNodes$_) t._$_PostInit$_();
            const t = hy(this._$_expressionNumber$_);
            this._$_numberedNodes$_.length ? this._$_expressionFunc$_ = t(this) : this._$_expressionFunc$_ = t;
        }
        _$GetSolIndex$_() {
            return this._$_solIndex$_;
        }
        _$GetExpression$_(t) {
            return this._$_solIndex$_ = t, this._$_expressionFunc$_();
        }
    }
    class ay extends oy {
        constructor(t, s, i, e) {
            super(t, s, i, e), this._$Get$_ = this._$GetStringExpression$_, 14 === s && (this._$GetEventBlock$_()._$SetAllSolModifiers$_(), 
            this._$_owner$_ instanceof ry._$Action$_ && this._$GetEventBlock$_()._$SetSolWriterAfterCnds$_());
        }
        _$GetStringExpression$_(t) {
            this._$_solIndex$_ = t;
            const s = this._$_expressionFunc$_();
            return "string" == typeof s ? s : "";
        }
        _$_GetFastTriggerValue$_() {
            return hy(this._$_expressionNumber$_)();
        }
    }
    class uy extends oy {
        constructor(t, s, i, e) {
            super(t, s, i, e), t._$GetImplementationSdkVersion$_() >= 2 ? this._$Get$_ = this._$GetILayer$_ : this._$Get$_ = this._$GetLayer$_, 
            this._$_isConstant$_ = !1;
        }
        _$GetLayer$_(t) {
            this._$_solIndex$_ = t;
            const s = this._$_expressionFunc$_();
            return this._$GetRuntime$_()._$GetCurrentLayout$_()._$GetLayer$_(s);
        }
        _$GetILayer$_(t) {
            const s = this._$GetLayer$_(t);
            return s ? s._$GetILayer$_() : null;
        }
    }
    class ly extends ry._$Parameter$_ {
        constructor(t, s, i, e) {
            super(t, s, i), this._$_combo$_ = e[1], this._$Get$_ = this._$GetCombo$_, this._$_isConstant$_ = !0;
        }
        _$GetCombo$_() {
            return this._$_combo$_;
        }
    }
    class cy extends ry._$Parameter$_ {
        constructor(t, s, i, e) {
            super(t, s, i), this._$_bool$_ = e[1], this._$Get$_ = this._$GetBoolean$_, this._$_isConstant$_ = !0;
        }
        _$GetBoolean$_() {
            return this._$_bool$_;
        }
    }
    class fy extends ry._$Parameter$_ {
        constructor(t, s, i, e) {
            super(t, s, i), this._$_objectClass$_ = this._$GetRuntime$_()._$GetObjectClassByIndex$_(e[1]), 
            t._$GetImplementationSdkVersion$_() >= 2 ? this._$Get$_ = this._$GetIObjectClass$_ : this._$Get$_ = this._$GetObjectClass$_;
            const n = this._$GetEventBlock$_();
            n._$_AddSolModifier$_(this._$_objectClass$_), this._$_owner$_ instanceof ry._$Action$_ ? n._$SetSolWriterAfterCnds$_() : n._$GetParent$_() && n._$GetParent$_()._$SetSolWriterAfterCnds$_(), 
            this._$_isConstant$_ = !0;
        }
        _$GetObjectClass$_() {
            return this._$_objectClass$_;
        }
        _$GetIObjectClass$_() {
            return this._$_objectClass$_ ? this._$_objectClass$_._$GetIObjectClass$_() : null;
        }
    }
    class dy extends ry._$Parameter$_ {
        constructor(t, s, i, e) {
            super(t, s, i), this._$_layout$_ = this._$GetRuntime$_()._$GetLayoutManager$_()._$GetLayoutByName$_(e[1]), 
            t._$GetImplementationSdkVersion$_() >= 2 ? this._$Get$_ = this._$GetILayout$_ : this._$Get$_ = this._$GetLayout$_, 
            this._$_isConstant$_ = !0;
        }
        _$GetLayout$_() {
            return this._$_layout$_;
        }
        _$GetILayout$_() {
            return this._$_layout$_ ? this._$_layout$_._$GetILayout$_() : null;
        }
    }
    class py extends ry._$Parameter$_ {
        constructor(t, s, i, e) {
            super(t, s, i), this._$_timeline$_ = this._$GetRuntime$_()._$GetTimelineManager$_()._$GetTimelineByName$_(e[1]), 
            t._$GetImplementationSdkVersion$_() >= 2 ? this._$Get$_ = this._$GetITimelineState$_ : this._$Get$_ = this._$GetTimeline$_, 
            this._$_isConstant$_ = !0;
        }
        _$GetTimeline$_() {
            return this._$_timeline$_;
        }
        _$GetITimelineState$_() {
            return this._$_timeline$_ ? this._$_timeline$_._$GetITimelineState$_() : null;
        }
    }
    class my extends ry._$Parameter$_ {
        constructor(t, s, i, e) {
            super(t, s, i), this._$_fileInfo$_ = e[1], this._$Get$_ = this._$GetFile$_, this._$_isConstant$_ = !0;
        }
        _$GetFile$_() {
            return this._$_fileInfo$_;
        }
    }
    class gy extends ry._$Parameter$_ {
        constructor(t, s, i, e) {
            super(t, s, i), this._$_instVarIndex$_ = e[1];
            const n = this._$_owner$_._$GetObjectClass$_();
            this._$_owner$_ instanceof ry._$Condition$_ && this._$_owner$_._$IsStatic$_() ? (this._$Get$_ = this._$GetInstanceVariable$_, 
            this._$_isConstant$_ = !0) : n && n._$IsFamily$_() ? (this._$Get$_ = this._$GetFamilyInstanceVariable$_, 
            this._$SetVariesPerInstance$_()) : (this._$Get$_ = this._$GetInstanceVariable$_, 
            this._$_isConstant$_ = !0);
        }
        _$GetInstanceVariable$_() {
            return this._$_instVarIndex$_;
        }
        _$GetFamilyInstanceVariable$_(t) {
            t = t || 0;
            const s = this._$_owner$_._$GetObjectClass$_(), i = s._$GetCurrentSol$_(), e = i._$GetInstances$_();
            let n = null;
            if (e.length) n = e[t % e.length]._$GetObjectClass$_(); else if (i._$HasAnyElseInstances$_()) {
                const s = i._$GetElseInstances$_();
                n = s[t % s.length]._$GetObjectClass$_();
            } else {
                if (!(s._$GetInstanceCount$_() > 0)) return 0;
                {
                    const i = s._$GetInstances$_();
                    n = i[t % i.length]._$GetObjectClass$_();
                }
            }
            return this._$_instVarIndex$_ + n._$GetFamilyInstanceVariableOffset$_(s._$GetFamilyIndex$_());
        }
    }
    class yy extends ry._$Parameter$_ {
        constructor(t, s, i, e) {
            super(t, s, i), this._$_eventVarSid$_ = e[1], this._$_eventVar$_ = null, t._$GetImplementationSdkVersion$_() >= 2 ? this._$Get$_ = this._$GetIEventVariable$_ : this._$Get$_ = this._$GetEventVariable$_, 
            this._$_isConstant$_ = !0;
        }
        _$_PostInit$_() {
            this._$_eventVar$_ = this._$GetRuntime$_()._$GetEventSheetManager$_()._$GetEventVariableBySID$_(this._$_eventVarSid$_);
        }
        _$GetEventVariable$_() {
            return this._$_eventVar$_;
        }
        _$GetIEventVariable$_() {
            return null;
        }
    }
    class My extends ry._$Parameter$_ {
        constructor(t, s, i, e) {
            super(t, s, i), this._$_functionBlockName$_ = e[1], this._$_functionBlock$_ = null, 
            t._$GetImplementationSdkVersion$_() >= 2 ? this._$Get$_ = this._$GetIFunction$_ : this._$Get$_ = this._$GetFunction$_, 
            this._$_isConstant$_ = !0;
        }
        _$_PostInit$_() {
            this._$_functionBlock$_ = this._$GetRuntime$_()._$GetEventSheetManager$_()._$GetFunctionBlockByName$_(this._$_functionBlockName$_), 
            this._$_functionBlockName$_ = null;
        }
        _$GetFunction$_() {
            return this._$_functionBlock$_;
        }
        _$GetIFunction$_() {
            return null;
        }
    }
    class wy extends ry._$Parameter$_ {
        constructor(t, s, i, e) {
            super(t, s, i), this._$_subParams$_ = [], this._$_variadicRet$_ = [], this._$_isConstant$_ = !0;
            for (let t = 1, s = e.length; t < s; ++t) {
                const s = ry._$Parameter$_._$Create$_(this._$_owner$_, e[t], 0);
                this._$_subParams$_.push(s), this._$_variadicRet$_.push(0), s._$IsConstant$_() || (this._$_isConstant$_ = !1);
            }
            this._$Get$_ = this._$GetVariadic$_;
        }
        _$_PostInit$_() {
            for (const t of this._$_subParams$_) t._$_PostInit$_();
        }
        _$GetVariadic$_() {
            const t = this._$_subParams$_, s = this._$_variadicRet$_;
            for (let i = 0, e = t.length; i < e; ++i) s[i] = t[i]._$Get$_(0);
            return s;
        }
    }
    class Sy extends ry._$Parameter$_ {
        constructor(t, s, i, e) {
            super(t, s, i), this._$_easeIndex$_ = e[1], this._$Get$_ = this._$GetEase$_, this._$_isConstant$_ = !0;
        }
        _$GetEase$_() {
            return this._$_easeIndex$_;
        }
    }
    class by extends ry._$Parameter$_ {
        constructor(t, s, i, e) {
            super(t, s, i), this._$_brushIndex$_ = e[1], this._$Get$_ = this._$GetTilemapBrush$_, 
            this._$_isConstant$_ = !0;
        }
        _$GetTilemapBrush$_() {
            return this._$_brushIndex$_;
        }
    }
    class Ty extends oy {
        constructor(t, s, i, e) {
            super(t, s, i, e), this._$Get$_ = this._$GetTemplateName$_, this._$_isConstant$_ = !1;
        }
        _$GetTemplateName$_() {
            return this._$_expressionFunc$_();
        }
    }
    class vy extends ry._$Parameter$_ {
        constructor(t, s, i, e) {
            super(t, s, i), this._$_flowchartDataItem$_ = this._$GetRuntime$_()._$GetFlowchartManager$_()._$GetFlowchartDataItemByName$_(e[1]), 
            this._$Get$_ = this._$GetFlowchartName$_, this._$_isConstant$_ = !0;
        }
        _$GetFlowchartName$_() {
            return this._$_flowchartDataItem$_._$GetName$_();
        }
    }
}

{
    let xy = function(t, s) {
        for (let i = 0, e = t.length; i < e; ++i) s[i] = t[i]._$Get$_(0);
    };
    0;
    const Iy = self._$C3$_, Gy = (self.assert, []), Cy = function() {};
    Iy._$Condition$_ = class extends Iy._$DefendedBase$_ {
        constructor(t, s, i) {
            if (super(), this._$_eventBlock$_ = t, this._$_runtime$_ = t._$GetRuntime$_(), this._$_index$_ = i, 
            this._$_func$_ = this._$_runtime$_._$GetObjectReference$_(s[1]), this._$_isTrigger$_ = s[3] > 0, 
            this._$_isFastTrigger$_ = 2 === s[3], this._$_isLooping$_ = !!s[4], this._$_isInverted$_ = !!s[5], 
            this._$_isStatic$_ = !!s[6], this._$_sid$_ = s[7], this._$_isInOrBlock$_ = this._$_eventBlock$_._$IsOrBlock$_(), 
            this._$_objectClass$_ = null, this._$_behaviorType$_ = null, this._$_behaviorIndex$_ = -1, 
            this._$_systemPlugin$_ = null, this._$Run$_ = Cy, this._$DebugRun$_ = Cy, this._$_parameters$_ = [], 
            this._$_results$_ = [], this._$_anyParamVariesPerInstance$_ = !1, this._$_savedData$_ = null, 
            this._$_unsavedData$_ = null, this._$_debugData$_ = this._$_runtime$_._$IsDebug$_() ? {
                _$isBreakpoint$_: s[8][0],
                _$canDebug$_: s[8][1]
            } : null, -1 === s[0] ? this._$_systemPlugin$_ = this._$_runtime$_._$GetSystemPlugin$_() : (this._$_objectClass$_ = this._$_runtime$_._$GetObjectClassByIndex$_(s[0]), 
            s[2] && (this._$_behaviorType$_ = this._$_objectClass$_._$GetBehaviorTypeByName$_(s[2]), 
            this._$_behaviorIndex$_ = this._$_objectClass$_._$GetBehaviorIndexByName$_(s[2])), 
            this._$_eventBlock$_._$GetParent$_() && this._$_eventBlock$_._$GetParent$_()._$SetSolWriterAfterCnds$_()), 
            10 === s.length) {
                let t = s[9];
                for (let s of t) this._$_parameters$_.push(Iy._$Parameter$_._$Create$_(this, s, this._$_parameters$_.length)), 
                this._$_results$_.push(0);
            }
            0 === this._$_parameters$_.length && (this._$_parameters$_ = Gy, this._$_results$_ = Gy), 
            this._$_eventBlock$_._$GetEventSheetManager$_()._$_RegisterCondition$_(this);
        }
        static _$Create$_(t, s, i) {
            return Iy._$New$_(Iy._$Condition$_, t, s, i);
        }
        _$_PostInit$_() {
            for (const t of this._$_parameters$_) t._$_PostInit$_(), t._$VariesPerInstance$_() && (this._$_anyParamVariesPerInstance$_ = !0);
            this._$_isFastTrigger$_ ? (this._$Run$_ = this._$_RunFastTrigger$_, this._$DebugRun$_ = this._$_DebugRunFastTrigger$_) : this._$_systemPlugin$_ ? (this._$_SetSystemRunMethod$_(), 
            this._$DebugRun$_ = this._$_DebugRunSystem$_) : this._$_objectClass$_._$GetPlugin$_()._$IsSingleGlobal$_() ? (this._$_SetSingleGlobalRunMethod$_(), 
            this._$DebugRun$_ = this._$_DebugRunSingleGlobal$_) : this._$_isStatic$_ ? (this._$Run$_ = this._$_RunStatic$_, 
            this._$DebugRun$_ = this._$_DebugRunStatic$_) : (this._$Run$_ = this._$_RunObject$_, 
            this._$DebugRun$_ = this._$_DebugRunObject$_);
        }
        _$_SetSystemRunMethod$_() {
            const t = this._$_systemPlugin$_, s = this._$_systemPlugin$_;
            this._$_SetRunMethodForBoundFunc$_(t, s, this._$_RunSystem$_);
        }
        _$_SetSingleGlobalRunMethod$_() {
            const t = this._$_objectClass$_._$GetPlugin$_(), s = this._$_objectClass$_._$GetSingleGlobalInstance$_()._$GetSdkInstance$_();
            this._$_SetRunMethodForBoundFunc$_(t, s, this._$_RunSingleGlobal$_);
        }
        _$_SetRunMethodForBoundFunc$_(t, s, i) {
            const e = this._$_func$_, n = this._$_isInverted$_, h = this._$_parameters$_;
            if (0 === h.length) {
                const i = t._$_GetBoundACEMethod$_(e, s);
                this._$Run$_ = n ? function() {
                    return Iy.xor(i(), n);
                } : i;
            } else if (1 === h.length) {
                const i = h[0];
                if (!n && i._$IsConstant$_()) this._$Run$_ = t._$_GetBoundACEMethod_1param$_(e, s, i._$Get$_(0)); else {
                    const h = t._$_GetBoundACEMethod$_(e, s);
                    this._$Run$_ = function() {
                        return Iy.xor(h(i._$Get$_(0)), n);
                    };
                }
            } else if (2 === h.length) {
                const i = h[0], r = h[1];
                if (!n && i._$IsConstant$_() && r._$IsConstant$_()) this._$Run$_ = t._$_GetBoundACEMethod_2params$_(e, s, i._$Get$_(0), r._$Get$_(0)); else {
                    const h = t._$_GetBoundACEMethod$_(e, s);
                    this._$Run$_ = function() {
                        return Iy.xor(h(i._$Get$_(0), r._$Get$_(0)), n);
                    };
                }
            } else if (3 === h.length) {
                const i = h[0], r = h[1], o = h[2];
                if (!n && i._$IsConstant$_() && r._$IsConstant$_() && o._$IsConstant$_()) this._$Run$_ = t._$_GetBoundACEMethod_3params$_(e, s, i._$Get$_(0), r._$Get$_(0), o._$Get$_(0)); else {
                    const h = t._$_GetBoundACEMethod$_(e, s);
                    this._$Run$_ = function() {
                        return Iy.xor(h(i._$Get$_(0), r._$Get$_(0), o._$Get$_(0)), n);
                    };
                }
            } else this._$Run$_ = i;
        }
        _$GetSID$_() {
            return this._$_sid$_;
        }
        _$_GetFunc$_() {
            return this._$_func$_;
        }
        _$GetObjectClass$_() {
            return this._$_objectClass$_;
        }
        _$GetBehaviorType$_() {
            return this._$_behaviorType$_;
        }
        _$GetImplementationAddon$_() {
            return this._$_behaviorType$_ ? this._$_behaviorType$_._$GetBehavior$_() : this._$_objectClass$_ ? this._$_objectClass$_._$GetPlugin$_() : null;
        }
        _$GetImplementationSdkVersion$_() {
            const t = this._$GetImplementationAddon$_();
            return t ? t._$GetSdkVersion$_() : 1;
        }
        _$GetEventBlock$_() {
            return this._$_eventBlock$_;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetIndex$_() {
            return this._$_index$_;
        }
        _$GetDebugIndex$_() {
            return this._$GetIndex$_();
        }
        _$IsTrigger$_() {
            return this._$_isTrigger$_;
        }
        _$IsFastTrigger$_() {
            return this._$_isFastTrigger$_;
        }
        _$IsInverted$_() {
            return this._$_isInverted$_;
        }
        _$IsLooping$_() {
            return this._$_isLooping$_;
        }
        _$IsStatic$_() {
            return this._$_isStatic$_;
        }
        _$IsBreakpoint$_() {
            return this._$_debugData$_._$isBreakpoint$_;
        }
        _$IsSystemCondition$_() {
            return !!this._$_systemPlugin$_;
        }
        _$IsSystemOrSingleGlobalCondition$_() {
            return this._$IsSystemCondition$_() || this._$_objectClass$_._$GetPlugin$_()._$IsSingleGlobal$_();
        }
        _$GetFirstObjectParameterObjectClass$_() {
            for (const t of this._$_parameters$_) if (t._$IsObjectParameter$_()) return t._$GetObjectClass$_();
            return null;
        }
        _$_SetBreakpoint$_(t) {
            this._$_debugData$_._$isBreakpoint$_ = !!t, this._$_eventBlock$_._$_UpdateCanRunFastRecursive$_();
        }
        _$_DebugReturnsGenerator$_() {
            return this._$_debugData$_._$canDebug$_;
        }
        _$DebugCanRunFast$_() {
            return !this._$IsBreakpoint$_() && !this._$_runtime$_._$DebugBreakNext$_() && !this._$_DebugReturnsGenerator$_();
        }
        _$GetSavedDataMap$_() {
            return this._$_savedData$_ || (this._$_savedData$_ = new Map), this._$_savedData$_;
        }
        _$GetUnsavedDataMap$_() {
            return this._$_unsavedData$_ || (this._$_unsavedData$_ = new Map), this._$_unsavedData$_;
        }
        _$_RunSystem$_() {
            const t = this._$_results$_;
            return xy(this._$_parameters$_, t), Iy.xor(this._$_func$_.apply(this._$_systemPlugin$_, t), this._$_isInverted$_);
        }
        * _$_DebugRunSystem$_() {
            if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            this._$_DebugReturnsGenerator$_()) {
                const t = this._$_results$_;
                xy(this._$_parameters$_, t);
                let s = this._$_func$_.apply(this._$_systemPlugin$_, t);
                return Iy._$IsIterator$_(s) && (s = yield* s), Iy.xor(s, this._$_isInverted$_);
            }
            return this._$Run$_();
        }
        _$_RunSingleGlobal$_() {
            const t = this._$_results$_;
            xy(this._$_parameters$_, t);
            const s = this._$_objectClass$_._$GetSingleGlobalInstance$_()._$GetSdkInstance$_();
            return Iy.xor(this._$_func$_.apply(s, t), this._$_isInverted$_);
        }
        * _$_DebugRunSingleGlobal$_() {
            if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            this._$_DebugReturnsGenerator$_()) {
                const t = this._$_results$_;
                xy(this._$_parameters$_, t);
                const s = this._$_objectClass$_._$GetSingleGlobalInstance$_()._$GetSdkInstance$_();
                let i = this._$_func$_.apply(s, t);
                return Iy._$IsIterator$_(i) && (i = yield* i), Iy.xor(i, this._$_isInverted$_);
            }
            return this._$Run$_();
        }
        _$_RunFastTrigger$_() {
            return !0;
        }
        * _$_DebugRunFastTrigger$_() {
            return (this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            !0;
        }
        _$_GetStaticConditionThis$_() {
            return this._$_behaviorType$_ ? this._$_behaviorType$_._$GetBehavior$_()._$GetSdkVersion$_() >= 2 ? this._$_behaviorType$_._$GetIBehaviorType$_() : this._$_behaviorType$_ : this._$_objectClass$_._$GetPlugin$_()._$GetSdkVersion$_() >= 2 ? this._$_objectClass$_._$GetIObjectClass$_() : this._$_objectClass$_;
        }
        _$_RunStatic$_() {
            const t = this._$_results$_;
            xy(this._$_parameters$_, t);
            const s = this._$_func$_.apply(this._$_GetStaticConditionThis$_(), t);
            return this._$_objectClass$_._$ApplySolToContainer$_(), s;
        }
        * _$_DebugRunStatic$_() {
            if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            this._$_DebugReturnsGenerator$_()) {
                const t = this._$_results$_;
                xy(this._$_parameters$_, t);
                let s = this._$_func$_.apply(this._$_GetStaticConditionThis$_(), t);
                return Iy._$IsIterator$_(s) && (s = yield* s), this._$_objectClass$_._$ApplySolToContainer$_(), 
                s;
            }
            return this._$Run$_();
        }
        _$_RunObject$_() {
            const t = this._$_parameters$_, s = this._$_results$_, i = this._$_objectClass$_._$GetCurrentSol$_();
            for (let i = 0, e = t.length; i < e; ++i) {
                const e = t[i];
                e._$VariesPerInstance$_() || (s[i] = e._$Get$_(0));
            }
            return i._$IsSelectAll$_() ? this._$_RunObject_FirstFilter$_(i) : this._$_RunObject_NextFilter$_(i);
        }
        * _$_DebugRunObject$_() {
            return (this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            this._$_RunObject$_();
        }
        _$_EvaluateVaryingParameters$_(t) {
            const s = this._$_parameters$_, i = this._$_results$_;
            for (let e = 0, n = s.length; e < n; ++e) {
                const n = s[e];
                n._$VariesPerInstance$_() && (i[e] = n._$Get$_(t));
            }
        }
        _$_RunObject_FirstFilter$_(t) {
            const s = this._$_objectClass$_, i = s._$IsFamily$_(), e = s._$GetFamilyIndex$_(), n = this._$_behaviorIndex$_, h = n >= 0, r = s._$GetInstances$_(), o = this._$_anyParamVariesPerInstance$_, a = this._$_results$_, u = this._$_func$_, l = this._$_isInverted$_, c = this._$_isInOrBlock$_ && !this._$_isTrigger$_;
            t._$ClearArrays$_();
            for (let s = 0, f = r.length; s < f; ++s) {
                const f = r[s];
                let d;
                if (o && this._$_EvaluateVaryingParameters$_(s), h) {
                    const t = i ? f._$GetObjectClass$_()._$GetFamilyBehaviorOffset$_(e) : 0;
                    d = u.apply(f._$GetBehaviorInstances$_()[n + t]._$GetSdkInstance$_(), a);
                } else d = u.apply(f._$GetSdkInstance$_(), a);
                Iy.xor(d, l) ? t._$_PushInstance$_(f) : c && t._$_PushElseInstance$_(f);
            }
            return s._$FinishCondition$_(!0), t._$_SetSelectAll$_(!1), s._$ApplySolToContainer$_(), 
            t._$HasAnyInstances$_();
        }
        _$_RunObject_NextFilter$_(t) {
            const s = this._$_objectClass$_, i = s._$IsFamily$_(), e = s._$GetFamilyIndex$_(), n = s._$IsInContainer$_(), h = this._$_behaviorIndex$_, r = h >= 0, o = this._$_anyParamVariesPerInstance$_, a = this._$_results$_, u = this._$_func$_, l = this._$_isInverted$_, c = this._$_isInOrBlock$_ && !this._$_isTrigger$_, f = t._$_GetOwnInstances$_(), d = t._$_GetOwnElseInstances$_(), p = c && !this._$_eventBlock$_._$IsFirstConditionOfType$_(this), m = p ? d : f;
            let g = 0, y = !1;
            for (let t = 0, s = m.length; t < s; ++t) {
                const s = m[t];
                let M;
                if (o && this._$_EvaluateVaryingParameters$_(t), r) {
                    const t = i ? s._$GetObjectClass$_()._$GetFamilyBehaviorOffset$_(e) : 0;
                    M = u.apply(s._$GetBehaviorInstances$_()[h + t]._$GetSdkInstance$_(), a);
                } else M = u.apply(s._$GetSdkInstance$_(), a);
                Iy.xor(M, l) ? (y = !0, p ? (f.push(s), n && s._$_PushSiblingsToSolInstances$_()) : (m[g] = s, 
                n && s._$_SetSiblingsToSolInstancesIndex$_(g), ++g)) : p ? (m[g] = s, n && s._$_SetSiblingsToSolElseInstancesIndex$_(g), 
                ++g) : c && (d.push(s), n && s._$_PushSiblingsToSolElseInstances$_());
            }
            Iy._$truncateArray$_(m, g), n && s._$_TruncateContainerSols$_(p, g);
            const M = y;
            return p && !y && (y = this._$_OrBlockCheckInstances$_(f)), s._$FinishCondition$_(M || c), 
            c ? y : t._$HasAnyInstances$_();
        }
        _$_OrBlockCheckInstances$_(t) {
            const s = this._$_objectClass$_, i = s._$IsFamily$_(), e = s._$GetFamilyIndex$_(), n = this._$_anyParamVariesPerInstance$_, h = this._$_behaviorIndex$_, r = h >= 0, o = this._$_results$_, a = this._$_func$_, u = this._$_isInverted$_;
            for (let s = 0, l = t.length; s < l; ++s) {
                const l = t[s];
                let c;
                if (n && this._$_EvaluateVaryingParameters$_(s), r) {
                    const t = i ? l._$GetObjectClass$_()._$GetFamilyBehaviorOffset$_(e) : 0;
                    c = a.apply(l._$GetBehaviorInstances$_()[h + t]._$GetSdkInstance$_(), o);
                } else c = a.apply(l._$GetSdkInstance$_(), o);
                if (Iy.xor(c, u)) return !0;
            }
            return !1;
        }
        _$ReevaluateParameter$_(t, s) {
            return this._$_parameters$_[t]._$Get$_(s);
        }
        _$GetFastTriggerValue$_() {
            const t = this._$_parameters$_;
            if (!t.length) throw new Error("no parameters");
            return t[0]._$_GetFastTriggerValue$_();
        }
        _$_SaveToJson$_() {
            if (!this._$_savedData$_ || !this._$_savedData$_.size) return null;
            const t = {};
            for (const [s, i] of this._$_savedData$_.entries()) {
                let e = i;
                "collmemory" === s && (e = [ ...i.entries() ].map((t => [ t[0]._$GetUID$_(), t[1]._$GetUID$_(), t[2] ]))), 
                t[s] = e;
            }
            return {
                ex: t
            };
        }
        _$_LoadFromJson$_(t) {
            if (this._$_savedData$_ && (this._$_savedData$_.clear(), this._$_savedData$_ = null), 
            !t) return;
            const s = this._$_runtime$_, i = t.ex;
            if (i) {
                const t = this._$GetSavedDataMap$_();
                t.clear();
                for (const [e, n] of Object.entries(i)) {
                    let i = n;
                    "collmemory" === e && (i = Iy._$New$_(Iy._$PairMap$_, n.map((t => [ s._$GetInstanceByUID$_(t[0]), s._$GetInstanceByUID$_(t[1]), t[2] ])).filter((t => t[0] && t[1])))), 
                    t.set(e, i);
                }
            }
        }
    };
}

{
    let _y = function(t, s) {
        for (let i = 0, e = t.length; i < e; ++i) s[i] = t[i]._$Get$_(0);
    };
    0;
    const Ey = self._$C3$_, Dy = (self.assert, []), Ay = function() {}, Ny = function*() {};
    Ey._$Action$_ = class extends Ey._$DefendedBase$_ {
        constructor(t, s, i) {
            super(), this._$_eventBlock$_ = t;
            const e = t._$GetRuntime$_();
            this._$_runtime$_ = e, this._$_index$_ = i, this._$_sid$_ = s.length >= 4 ? s[3] : -1, 
            this._$_actionType$_ = s.length >= 5 ? 255 & s[4] : 0, this._$_flags$_ = s.length >= 5 ? s[4] >> 8 : 0, 
            this._$_func$_ = null, this._$_objectClass$_ = null, this._$_behaviorType$_ = null, 
            this._$_behaviorIndex$_ = -1, this._$_systemPlugin$_ = null, this._$_callFunctionName$_ = "", 
            this._$_callCustomAceObjectClass$_ = null, this._$_callEventBlock$_ = null, this._$Run$_ = Ay, 
            this._$DebugRun$_ = Ay, this._$_parameters$_ = [], this._$_results$_ = [], this._$_anyParamVariesPerInstance$_ = !1, 
            this._$_savedData$_ = null, this._$_unsavedData$_ = null;
            const n = -3 === s[0], h = n ? s[2] : s[5];
            if (this._$_debugData$_ = e._$IsDebug$_() || n ? {
                _$isBreakpoint$_: h[0],
                _$canDebug$_: h[1],
                index: h[2]
            } : null, -1 === s[0]) this._$_systemPlugin$_ = e._$GetSystemPlugin$_(), this._$_func$_ = e._$GetObjectReference$_(s[1]); else if (-2 === s[0]) this._$_callFunctionName$_ = s[1]; else if (n) {
                const t = e._$GetObjectReference$_(s[1]);
                this._$_func$_ = t, this._$Run$_ = this._$RunUserScript$_, this._$DebugRun$_ = this._$DebugRunUserScript$_, 
                this._$_flags$_ |= 8;
            } else this._$_objectClass$_ = e._$GetObjectClassByIndex$_(s[0]), 4 & this._$_flags$_ ? (this._$_callFunctionName$_ = s[1], 
            this._$_callCustomAceObjectClass$_ = e._$GetObjectClassByIndex$_(s[2])) : (s[2] && (this._$_behaviorType$_ = this._$_objectClass$_._$GetBehaviorTypeByName$_(s[2]), 
            this._$_behaviorIndex$_ = this._$_objectClass$_._$GetBehaviorIndexByName$_(s[2])), 
            this._$_func$_ = e._$GetObjectReference$_(s[1]));
            if (7 === s.length) {
                const t = s[6];
                for (const s of t) this._$_parameters$_.push(Ey._$Parameter$_._$Create$_(this, s, this._$_parameters$_.length)), 
                this._$_results$_.push(0);
            }
            0 === this._$_parameters$_.length && (this._$_parameters$_ = Dy, this._$_results$_ = Dy), 
            this._$CanPickAnyObjectClass$_() && (this._$_eventBlock$_._$SetAllSolModifiers$_(), 
            this._$_eventBlock$_._$SetSolWriterAfterCnds$_()), this._$_eventBlock$_._$GetEventSheetManager$_()._$_RegisterAction$_(this);
        }
        static _$Create$_(t, s, i) {
            return Ey._$New$_(Ey._$Action$_, t, s, i);
        }
        _$_PostInit$_() {
            for (const t of this._$_parameters$_) t._$_PostInit$_(), t._$VariesPerInstance$_() && (this._$_anyParamVariesPerInstance$_ = !0);
            if (this._$_systemPlugin$_) this._$_SetSystemRunMethod$_(), this._$DebugRun$_ = this._$_DebugRunSystem$_; else if (this._$_callFunctionName$_) 4 & this._$_flags$_ ? this._$_SetCallCustomActionRunMethod$_() : this._$_SetCallFunctionRunMethod$_(), 
            this._$_callFunctionName$_ = "", this._$_callCustomAceObjectClass$_ = null; else if (this._$Run$_ === this._$RunUserScript$_) {
                const t = this._$_func$_, s = this._$_runtime$_._$GetEventSheetManager$_()._$_GetLocalVariablesScriptInterface$_(this._$_eventBlock$_);
                this._$_func$_ = t.bind(null, this._$_runtime$_._$GetIRuntime$_(), s);
            } else this._$_behaviorType$_ ? this._$IsAsync$_() ? (this._$Run$_ = this._$_RunBehavior_Async$_, 
            this._$DebugRun$_ = this._$_DebugRunBehavior_Async$_) : (this._$Run$_ = this._$_RunBehavior$_, 
            this._$DebugRun$_ = this._$_DebugRunBehavior$_) : this._$_objectClass$_._$GetPlugin$_()._$IsSingleGlobal$_() ? (this._$_SetSingleGlobalRunMethod$_(), 
            this._$DebugRun$_ = this._$_DebugRunSingleGlobal$_) : this._$IsStatic$_() ? (this._$Run$_ = this._$_RunObject_Static$_, 
            this._$DebugRun$_ = this._$_DebugRunObject_Static$_) : this._$IsAsync$_() ? (this._$Run$_ = this._$_RunObject_Async$_, 
            this._$DebugRun$_ = this._$_DebugRunObject_Async$_) : this._$CallBeforeAfterHooks$_() ? (this._$Run$_ = this._$_RunObject_BeforeAfterHooks$_, 
            this._$DebugRun$_ = this._$_DebugRunObject_BeforeAfterHooks$_) : this._$_parameters$_.length ? this._$_parameters$_.every((t => t._$VariesPerInstance$_())) ? (this._$Run$_ = this._$_RunObject_AllParamsVary$_, 
            this._$DebugRun$_ = this._$_DebugRunObject_AllParamsVary$_) : this._$_anyParamVariesPerInstance$_ ? (this._$Run$_ = this._$_RunObject_SomeParamsVary$_, 
            this._$DebugRun$_ = this._$_DebugRunObject_SomeParamsVary$_) : this._$_parameters$_.every((t => t._$IsConstant$_())) ? (_y(this._$_parameters$_, this._$_results$_), 
            this._$Run$_ = this._$_RunObject_ParamsConst$_, this._$DebugRun$_ = this._$_DebugRunObject_ParamsConst$_) : (this._$Run$_ = this._$_RunObject_ParamsDontVary$_, 
            this._$DebugRun$_ = this._$_DebugRunObject_ParamsDontVary$_) : (this._$Run$_ = this._$_RunObject_ParamsConst$_, 
            this._$DebugRun$_ = this._$_DebugRunObject_ParamsConst$_);
        }
        _$_SetSystemRunMethod$_() {
            const t = this._$_systemPlugin$_, s = this._$_systemPlugin$_;
            this._$_SetRunMethodForBoundFunc$_(t, s, this._$_RunSystem$_);
        }
        _$_SetSingleGlobalRunMethod$_() {
            const t = this._$_objectClass$_._$GetPlugin$_(), s = this._$_objectClass$_._$GetSingleGlobalInstance$_()._$GetSdkInstance$_();
            this._$_SetRunMethodForBoundFunc$_(t, s, this._$_RunSingleGlobal$_);
        }
        _$_SetCallFunctionRunMethod$_() {
            const t = this._$_eventBlock$_._$GetEventSheetManager$_(), s = t._$GetFunctionBlockByName$_(this._$_callFunctionName$_);
            if (s._$IsEnabled$_()) {
                const i = !!(2 & this._$_flags$_);
                this._$_callEventBlock$_ = s._$GetEventBlock$_();
                let e = [ ...new Set([ ...this._$_eventBlock$_._$GetSolModifiersIncludingParents$_(), ...this._$_callEventBlock$_._$GetSolModifiersIncludingParents$_() ]) ];
                e = t._$_DeduplicateSolModifierList$_(e);
                const n = !s._$IsCopyPicked$_() && this._$_HasCopyPickedParent$_() ? {
                    _$pushCleanSolDynamic$_: !0
                } : null;
                if (this._$Run$_ = Ey._$EventBlock$_.prototype._$RunAsFunctionCall$_.bind(this._$_callEventBlock$_, e, this._$_parameters$_, i, n), 
                this._$_runtime$_._$IsDebug$_()) {
                    const t = this;
                    this._$DebugRun$_ = function*() {
                        return (t._$IsBreakpoint$_() || t._$_runtime$_._$DebugBreakNext$_()) && (yield t), 
                        yield* t._$_callEventBlock$_._$DebugRunAsFunctionCall$_(e, t._$_parameters$_, i, n);
                    };
                } else this._$DebugRun$_ = Ny;
            } else this._$Run$_ = Ay, this._$DebugRun$_ = Ny;
        }
        _$_SetCallCustomActionRunMethod$_() {
            const t = this._$_eventBlock$_._$GetEventSheetManager$_(), s = t._$GetCustomActionBlockByName$_(this._$_callCustomAceObjectClass$_, this._$_callFunctionName$_);
            if (s._$IsEnabled$_()) {
                const i = !!(2 & this._$_flags$_);
                this._$_callEventBlock$_ = s._$GetEventBlock$_();
                let e = [ ...new Set([ ...this._$_eventBlock$_._$GetSolModifiersIncludingParents$_(), ...this._$_callEventBlock$_._$GetSolModifiersIncludingParents$_(), this._$_objectClass$_, s._$GetObjectClass$_() ]) ];
                e = t._$_DeduplicateSolModifierList$_(e);
                const n = !this._$_objectClass$_._$IsFamily$_() && !s._$GetObjectClass$_()._$IsFamily$_(), h = !this._$_objectClass$_._$IsFamily$_() && s._$GetObjectClass$_()._$IsFamily$_(), r = this._$_objectClass$_._$IsFamily$_();
                let o = null;
                if (!s._$IsCopyPicked$_() && this._$_HasCopyPickedParent$_() && (o = o || {}, o._$pushCleanSolDynamic$_ = !0), 
                !h && i || (o = o || {}, o._$copyFromObjectClass$_ = this._$_objectClass$_, o._$copyToObjectClass$_ = s._$GetObjectClass$_()), 
                n || h || r && !s._$HasCustomACEOverrides$_() ? this._$Run$_ = Ey._$EventBlock$_.prototype._$RunAsFunctionCall$_.bind(this._$_callEventBlock$_, e, this._$_parameters$_, i, o) : r && (this._$Run$_ = Ey._$FunctionBlock$_.prototype._$RunAsFamilyCustomActionWithOverrides$_.bind(s, e, this._$_parameters$_)), 
                this._$_runtime$_._$IsDebug$_()) {
                    const t = this;
                    n || h || r && !s._$HasCustomACEOverrides$_() ? this._$DebugRun$_ = function*() {
                        return (t._$IsBreakpoint$_() || t._$_runtime$_._$DebugBreakNext$_()) && (yield t), 
                        yield* t._$_callEventBlock$_._$DebugRunAsFunctionCall$_(e, t._$_parameters$_, i, o);
                    } : r && (this._$DebugRun$_ = function*() {
                        return (t._$IsBreakpoint$_() || t._$_runtime$_._$DebugBreakNext$_()) && (yield t), 
                        yield* s._$DebugRunAsFamilyCustomActionWithOverrides$_(e, t._$_parameters$_);
                    });
                } else this._$DebugRun$_ = Ny;
            } else this._$Run$_ = Ay, this._$DebugRun$_ = Ny;
        }
        _$_SetRunMethodForBoundFunc$_(t, s, i) {
            const e = this._$_func$_, n = this._$_parameters$_;
            if (0 === n.length) this._$Run$_ = t._$_GetBoundACEMethod$_(e, s); else if (1 === n.length) {
                const i = n[0];
                if (i._$IsConstant$_()) this._$Run$_ = t._$_GetBoundACEMethod_1param$_(e, s, i._$Get$_(0)); else {
                    const n = t._$_GetBoundACEMethod$_(e, s);
                    this._$Run$_ = function() {
                        return n(i._$Get$_(0));
                    };
                }
            } else if (2 === n.length) {
                const i = n[0], h = n[1];
                if (i._$IsConstant$_() && h._$IsConstant$_()) this._$Run$_ = t._$_GetBoundACEMethod_2params$_(e, s, i._$Get$_(0), h._$Get$_(0)); else {
                    const n = t._$_GetBoundACEMethod$_(e, s);
                    this._$Run$_ = function() {
                        return n(i._$Get$_(0), h._$Get$_(0));
                    };
                }
            } else if (3 === n.length) {
                const i = n[0], h = n[1], r = n[2];
                if (i._$IsConstant$_() && h._$IsConstant$_() && r._$IsConstant$_()) this._$Run$_ = t._$_GetBoundACEMethod_3params$_(e, s, i._$Get$_(0), h._$Get$_(0), r._$Get$_(0)); else {
                    const n = t._$_GetBoundACEMethod$_(e, s);
                    this._$Run$_ = function() {
                        return n(i._$Get$_(0), h._$Get$_(0), r._$Get$_(0));
                    };
                }
            } else this._$Run$_ = i;
        }
        _$GetSID$_() {
            return this._$_sid$_;
        }
        _$IsAsync$_() {
            return !!(8 & this._$_flags$_);
        }
        _$CanBailOut$_() {
            return !!(16 & this._$_flags$_);
        }
        _$CallBeforeAfterHooks$_() {
            return 1 === this._$_actionType$_;
        }
        _$IsStatic$_() {
            return 2 === this._$_actionType$_;
        }
        _$CanPickAnyObjectClass$_() {
            return !!(1 & this._$_flags$_);
        }
        _$HasReturnType$_() {
            return this._$IsAsync$_() || this._$CanBailOut$_();
        }
        _$GetObjectClass$_() {
            return this._$_objectClass$_;
        }
        _$GetImplementationAddon$_() {
            return this._$_behaviorType$_ ? this._$_behaviorType$_._$GetBehavior$_() : this._$_objectClass$_ ? this._$_objectClass$_._$GetPlugin$_() : null;
        }
        _$GetImplementationSdkVersion$_() {
            const t = this._$GetImplementationAddon$_();
            return t ? t._$GetSdkVersion$_() : 1;
        }
        _$GetEventBlock$_() {
            return this._$_eventBlock$_;
        }
        _$_HasCopyPickedParent$_() {
            let t = this._$_eventBlock$_;
            do {
                if (t instanceof Ey._$FunctionBlock$_ && t._$IsCopyPicked$_()) return !0;
                t = t._$GetScopeParent$_();
            } while (t);
            return !1;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetIndex$_() {
            return this._$_index$_;
        }
        _$GetDebugIndex$_() {
            return this._$_debugData$_.index;
        }
        _$IsBreakpoint$_() {
            return this._$_debugData$_._$isBreakpoint$_;
        }
        _$_SetBreakpoint$_(t) {
            this._$_debugData$_._$isBreakpoint$_ = !!t, this._$_eventBlock$_._$_UpdateCanRunFastRecursive$_();
        }
        _$_DebugReturnsGenerator$_() {
            return this._$_debugData$_._$canDebug$_;
        }
        _$DebugCanRunFast$_() {
            return !this._$IsBreakpoint$_() && !this._$_runtime$_._$DebugBreakNext$_() && !this._$_DebugReturnsGenerator$_();
        }
        _$GetSavedDataMap$_() {
            return this._$_savedData$_ || (this._$_savedData$_ = new Map), this._$_savedData$_;
        }
        _$GetUnsavedDataMap$_() {
            return this._$_unsavedData$_ || (this._$_unsavedData$_ = new Map), this._$_unsavedData$_;
        }
        _$_RunSystem$_() {
            const t = this._$_results$_;
            return _y(this._$_parameters$_, t), this._$_func$_.apply(this._$_systemPlugin$_, t);
        }
        * _$_DebugRunSystem$_() {
            if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            this._$_DebugReturnsGenerator$_()) {
                const t = this._$_results$_;
                return _y(this._$_parameters$_, t), yield* this._$_func$_.apply(this._$_systemPlugin$_, t);
            }
            return this._$Run$_();
        }
        _$_RunSingleGlobal$_() {
            const t = this._$_results$_;
            return _y(this._$_parameters$_, t), this._$_func$_.apply(this._$_objectClass$_._$GetSingleGlobalInstance$_()._$GetSdkInstance$_(), t);
        }
        * _$_DebugRunSingleGlobal$_() {
            if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            this._$_DebugReturnsGenerator$_()) {
                const t = this._$_results$_;
                return _y(this._$_parameters$_, t), yield* this._$_func$_.apply(this._$_objectClass$_._$GetSingleGlobalInstance$_()._$GetSdkInstance$_(), t);
            }
            return this._$Run$_();
        }
        _$_RunObject_ParamsConst$_() {
            const t = this._$_results$_, s = this._$_objectClass$_._$GetCurrentSol$_()._$GetInstances$_();
            for (let i = 0, e = s.length; i < e; ++i) this._$_func$_.apply(s[i]._$GetSdkInstance$_(), t);
        }
        * _$_DebugRunObject_ParamsConst$_() {
            if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            this._$_DebugReturnsGenerator$_()) {
                const t = this._$_results$_, s = this._$_objectClass$_._$GetCurrentSol$_()._$GetInstances$_();
                for (let i = 0, e = s.length; i < e; ++i) yield* this._$_func$_.apply(s[i]._$GetSdkInstance$_(), t);
            } else this._$_RunObject_ParamsConst$_();
        }
        _$_RunObject_ParamsDontVary$_() {
            const t = this._$_results$_;
            _y(this._$_parameters$_, t);
            const s = this._$_objectClass$_._$GetCurrentSol$_()._$GetInstances$_();
            for (let i = 0, e = s.length; i < e; ++i) this._$_func$_.apply(s[i]._$GetSdkInstance$_(), t);
        }
        * _$_DebugRunObject_ParamsDontVary$_() {
            if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            this._$_DebugReturnsGenerator$_()) {
                const t = this._$_results$_;
                _y(this._$_parameters$_, t);
                const s = this._$_objectClass$_._$GetCurrentSol$_()._$GetInstances$_();
                for (let i = 0, e = s.length; i < e; ++i) yield* this._$_func$_.apply(s[i]._$GetSdkInstance$_(), t);
            } else this._$_RunObject_ParamsDontVary$_();
        }
        _$_RunObject_AllParamsVary$_() {
            const t = this._$_parameters$_, s = this._$_results$_, i = this._$_func$_, e = this._$_objectClass$_._$GetCurrentSol$_()._$GetInstances$_();
            for (let n = 0, h = e.length; n < h; ++n) {
                const h = e[n];
                for (let i = 0, e = t.length; i < e; ++i) s[i] = t[i]._$Get$_(n);
                i.apply(h._$GetSdkInstance$_(), s);
            }
        }
        * _$_DebugRunObject_AllParamsVary$_() {
            if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            this._$_DebugReturnsGenerator$_()) {
                const t = this._$_parameters$_, s = this._$_results$_, i = this._$_func$_, e = this._$_objectClass$_._$GetCurrentSol$_()._$GetInstances$_();
                for (let n = 0, h = e.length; n < h; ++n) {
                    const h = e[n];
                    for (let i = 0, e = t.length; i < e; ++i) s[i] = t[i]._$Get$_(n);
                    yield* i.apply(h._$GetSdkInstance$_(), s);
                }
            } else this._$_RunObject_AllParamsVary$_();
        }
        _$_RunObject_SomeParamsVary$_() {
            const t = this._$_parameters$_, s = this._$_results$_, i = this._$_func$_, e = this._$_objectClass$_._$GetCurrentSol$_()._$GetInstances$_();
            for (let i = 0, e = t.length; i < e; ++i) {
                const e = t[i];
                e._$VariesPerInstance$_() || (s[i] = e._$Get$_(0));
            }
            for (let n = 0, h = e.length; n < h; ++n) {
                const h = e[n];
                for (let i = 0, e = t.length; i < e; ++i) {
                    const e = t[i];
                    e._$VariesPerInstance$_() && (s[i] = e._$Get$_(n));
                }
                i.apply(h._$GetSdkInstance$_(), s);
            }
        }
        * _$_DebugRunObject_SomeParamsVary$_() {
            if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            this._$_DebugReturnsGenerator$_()) {
                const t = this._$_parameters$_, s = this._$_results$_, i = this._$_func$_, e = this._$_objectClass$_._$GetCurrentSol$_()._$GetInstances$_();
                for (let i = 0, e = t.length; i < e; ++i) {
                    const e = t[i];
                    e._$VariesPerInstance$_() || (s[i] = e._$Get$_(0));
                }
                for (let n = 0, h = e.length; n < h; ++n) {
                    const h = e[n];
                    for (let i = 0, e = t.length; i < e; ++i) {
                        const e = t[i];
                        e._$VariesPerInstance$_() && (s[i] = e._$Get$_(n));
                    }
                    yield* i.apply(h._$GetSdkInstance$_(), s);
                }
            } else this._$_RunObject_SomeParamsVary$_();
        }
        _$_RunObject_BeforeAfterHooks$_() {
            const t = this._$_parameters$_, s = this._$_results$_, i = this._$_func$_, e = this._$_objectClass$_, n = e._$GetSdkType$_(), h = e._$GetCurrentSol$_()._$GetInstances$_();
            n._$BeforeRunAction$_(i);
            for (let e = 0, n = h.length; e < n; ++e) {
                const n = h[e];
                for (let i = 0, n = t.length; i < n; ++i) s[i] = t[i]._$Get$_(e);
                i.apply(n._$GetSdkInstance$_(), s);
            }
            n._$AfterRunAction$_(i);
        }
        * _$_DebugRunObject_BeforeAfterHooks$_() {
            if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            this._$_DebugReturnsGenerator$_()) {
                const t = this._$_parameters$_, s = this._$_results$_, i = this._$_func$_, e = this._$_objectClass$_, n = e._$GetSdkType$_(), h = e._$GetCurrentSol$_()._$GetInstances$_();
                n._$BeforeRunAction$_(i);
                for (let e = 0, n = h.length; e < n; ++e) {
                    const n = h[e];
                    for (let i = 0, n = t.length; i < n; ++i) s[i] = t[i]._$Get$_(e);
                    yield* i.apply(n._$GetSdkInstance$_(), s);
                }
                n._$AfterRunAction$_(i);
            } else this._$_RunObject_BeforeAfterHooks$_();
        }
        _$_GetStaticActionThis$_() {
            return this._$_behaviorType$_ ? this._$_behaviorType$_._$GetBehavior$_()._$GetSdkVersion$_() >= 2 ? this._$_behaviorType$_._$GetIBehaviorType$_() : this._$_behaviorType$_ : this._$_objectClass$_._$GetPlugin$_()._$GetSdkVersion$_() >= 2 ? this._$_objectClass$_._$GetIObjectClass$_() : this._$_objectClass$_;
        }
        _$_RunObject_Static$_() {
            const t = this._$_results$_;
            return _y(this._$_parameters$_, t), this._$_func$_.apply(this._$_GetStaticActionThis$_(), t);
        }
        * _$_DebugRunObject_Static$_() {
            if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            this._$_DebugReturnsGenerator$_()) {
                const t = this._$_results$_;
                _y(this._$_parameters$_, t);
                let s = this._$_func$_.apply(this._$_GetStaticActionThis$_(), t);
                return Ey._$IsIterator$_(s) && (s = yield* s), s;
            }
            return this._$_RunObject_Static$_();
        }
        _$_RunBehavior$_() {
            const t = this._$_objectClass$_, s = t._$IsFamily$_(), i = t._$GetFamilyIndex$_(), e = this._$_parameters$_, n = this._$_anyParamVariesPerInstance$_, h = this._$_results$_, r = this._$_func$_, o = this._$_behaviorIndex$_, a = t._$GetCurrentSol$_()._$GetInstances$_();
            for (let t = 0, s = e.length; t < s; ++t) {
                const s = e[t];
                s._$VariesPerInstance$_() || (h[t] = s._$Get$_(0));
            }
            for (let t = 0, u = a.length; t < u; ++t) {
                const u = a[t];
                if (n) for (let s = 0, i = e.length; s < i; ++s) {
                    const i = e[s];
                    i._$VariesPerInstance$_() && (h[s] = i._$Get$_(t));
                }
                const l = s ? u._$GetObjectClass$_()._$GetFamilyBehaviorOffset$_(i) : 0;
                r.apply(u._$GetBehaviorInstances$_()[o + l]._$GetSdkInstance$_(), h);
            }
        }
        * _$_DebugRunBehavior$_() {
            if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            this._$_DebugReturnsGenerator$_()) {
                const t = this._$_objectClass$_, s = t._$IsFamily$_(), i = t._$GetFamilyIndex$_(), e = this._$_parameters$_, n = this._$_anyParamVariesPerInstance$_, h = this._$_results$_, r = this._$_func$_, o = this._$_behaviorIndex$_, a = t._$GetCurrentSol$_()._$GetInstances$_();
                for (let t = 0, s = e.length; t < s; ++t) {
                    const s = e[t];
                    s._$VariesPerInstance$_() || (h[t] = s._$Get$_(0));
                }
                for (let t = 0, u = a.length; t < u; ++t) {
                    const u = a[t];
                    if (n) for (let s = 0, i = e.length; s < i; ++s) {
                        const i = e[s];
                        i._$VariesPerInstance$_() && (h[s] = i._$Get$_(t));
                    }
                    const l = s ? u._$GetObjectClass$_()._$GetFamilyBehaviorOffset$_(i) : 0;
                    yield* r.apply(u._$GetBehaviorInstances$_()[o + l]._$GetSdkInstance$_(), h);
                }
            } else this._$_RunBehavior$_();
        }
        _$_RunObject_Async$_() {
            const t = this._$_parameters$_, s = this._$_results$_, i = this._$_func$_, e = this._$_objectClass$_._$GetCurrentSol$_()._$GetInstances$_(), n = [];
            for (let h = 0, r = e.length; h < r; ++h) {
                const r = e[h];
                for (let i = 0, e = t.length; i < e; ++i) s[i] = t[i]._$Get$_(h);
                n.push(i.apply(r._$GetSdkInstance$_(), s));
            }
            return Promise.all(n);
        }
        * _$_DebugRunObject_Async$_() {
            if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            this._$_DebugReturnsGenerator$_()) {
                const t = this._$_parameters$_, s = this._$_results$_, i = this._$_func$_, e = this._$_objectClass$_._$GetCurrentSol$_()._$GetInstances$_(), n = [];
                for (let h = 0, r = e.length; h < r; ++h) {
                    const r = e[h];
                    for (let i = 0, e = t.length; i < e; ++i) s[i] = t[i]._$Get$_(h);
                    n.push(yield* i.apply(r._$GetSdkInstance$_(), s));
                }
                return Promise.all(n);
            }
            return this._$_RunObject_Async$_();
        }
        _$_RunBehavior_Async$_() {
            const t = this._$_objectClass$_, s = t._$IsFamily$_(), i = t._$GetFamilyIndex$_(), e = this._$_parameters$_, n = this._$_results$_, h = this._$_func$_, r = this._$_behaviorIndex$_, o = t._$GetCurrentSol$_()._$GetInstances$_(), a = [];
            for (let t = 0, u = o.length; t < u; ++t) {
                const u = o[t];
                for (let s = 0, i = e.length; s < i; ++s) n[s] = e[s]._$Get$_(t);
                const l = s ? u._$GetObjectClass$_()._$GetFamilyBehaviorOffset$_(i) : 0;
                a.push(h.apply(u._$GetBehaviorInstances$_()[r + l]._$GetSdkInstance$_(), n));
            }
            return Promise.all(a);
        }
        * _$_DebugRunBehavior_Async$_() {
            if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            this._$_DebugReturnsGenerator$_()) {
                const t = this._$_objectClass$_, s = t._$IsFamily$_(), i = t._$GetFamilyIndex$_(), e = this._$_parameters$_, n = this._$_results$_, h = this._$_func$_, r = this._$_behaviorIndex$_, o = t._$GetCurrentSol$_()._$GetInstances$_(), a = [];
                for (let t = 0, u = o.length; t < u; ++t) {
                    const u = o[t];
                    for (let s = 0, i = e.length; s < i; ++s) n[s] = e[s]._$Get$_(t);
                    const l = s ? u._$GetObjectClass$_()._$GetFamilyBehaviorOffset$_(i) : 0;
                    a.push(yield* h.apply(u._$GetBehaviorInstances$_()[r + l]._$GetSdkInstance$_(), n));
                }
                return Promise.all(a);
            }
            return this._$_RunBehavior_Async$_();
        }
        async _$RunUserScript$_() {
            try {
                await this._$_func$_();
            } catch (t) {
                console.error(`Unhandled exception running script %c${this._$_eventBlock$_._$GetEventSheet$_()._$GetName$_()}, event ${this._$_eventBlock$_._$GetDisplayNumber$_()}, action ${this._$GetDebugIndex$_() + 1}:`, "font-size: 1.2em; font-weight: bold;", t), 
                self._$C3Debugger$_ && self._$C3Debugger$_._$_SetLastErrorScript$_(this), Ey._$EventScript$_._$HadUserScriptException$_() || (console.info("%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()", "font-weight: bold; text-decoration: underline", "", "font-weight: bold"), 
                Ey._$EventScript$_._$SetHadUserScriptException$_());
            }
        }
        * _$DebugRunUserScript$_() {
            return (this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            this._$RunUserScript$_();
        }
        _$_SaveToJson$_() {
            return this._$_savedData$_ && this._$_savedData$_.size ? {
                ex: Ey._$ToSuperJSON$_(this._$_savedData$_)
            } : null;
        }
        _$_LoadFromJson$_(t) {
            if (this._$_savedData$_ && (this._$_savedData$_.clear(), this._$_savedData$_ = null), 
            !t) return;
            const s = t.ex;
            s && (this._$_savedData$_ = Ey._$FromSuperJSON$_(s));
        }
    };
}

{
    let Ly = function(t) {
        return t instanceof tM ? $y._$_UnwrapScriptInterface$_(t) : t._$GetInstance$_();
    }, Oy = function(t) {
        return Ly(t)._$GetWorldInfo$_();
    }, Ry = function(t) {
        return $y._$_UnwrapScriptInterface$_(t);
    }, Py = function(t) {
        return Ry(t)._$GetWorldInfo$_();
    }, ky = function(t) {
        return t instanceof sM ? $y._$_UnwrapScriptInterface$_(t) : t;
    }, Fy = function(t) {
        return t instanceof iM ? $y._$_UnwrapScriptInterface$_(t) : t;
    }, jy = function(t, s, i, e) {
        s._$GetUID$_() < i._$GetUID$_() ? t.Set(s, i, e) : t.Set(i, s, e);
    }, By = function(t, s, i) {
        s._$GetUID$_() < i._$GetUID$_() ? t._$Delete$_(s, i) : t._$Delete$_(i, s);
    }, zy = function(t, s) {
        t._$DeleteEither$_(s);
    }, Uy = function(t, s, i) {
        return s._$GetUID$_() < i._$GetUID$_() ? t._$Get$_(s, i) : t._$Get$_(i, s);
    }, Wy = function(t, s, i, e) {
        if (!s) return !1;
        const n = 0 !== i || 0 !== e, h = t._$GetWorldInfo$_(), r = $y._$GetCollisionEngine$_(), o = $y._$GetCurrentCondition$_(), a = o._$GetEventBlock$_()._$IsOrBlock$_(), u = o._$GetObjectClass$_(), l = o._$IsInverted$_(), c = s._$GetCurrentSol$_(), f = u !== s;
        let d;
        oM = s, rM = f && !l, aM = !1;
        let p = 0, m = 0, g = !1;
        c._$IsSelectAll$_() ? (eM._$copy$_(h._$GetBoundingBox$_()), eM.offset(i, e), r._$GetCollisionCandidates$_(h._$GetLayer$_(), s, eM, hM), 
        d = hM) : a ? $y._$IsCurrentConditionFirst$_() && !c._$_GetOwnElseInstances$_().length && c._$_GetOwnInstances$_().length ? d = c._$_GetOwnInstances$_() : (d = c._$_GetOwnElseInstances$_(), 
        aM = !0) : d = c._$_GetOwnInstances$_(), n && (p = h._$GetX$_(), m = h._$GetY$_(), 
        h._$OffsetXY$_(i, e), h._$SetBboxChanged$_());
        for (const s of d) if (r._$TestOverlap$_(t, s)) {
            if (g = !0, l) break;
            f && uM.add(s);
        }
        return n && (h._$SetXY$_(p, m), h._$SetBboxChanged$_()), Hy._$clearArray$_(hM), 
        g;
    }, Jy = function(t) {
        const s = $y._$GetCurrentEvent$_()._$IsOrBlock$_(), i = oM._$GetCurrentSol$_(), e = i._$_GetOwnInstances$_(), n = i._$_GetOwnElseInstances$_();
        i._$IsSelectAll$_() ? (i._$SetSetPicked$_(uM), s && (Hy._$clearArray$_(n), i._$AddElseInstances$_(uM, oM._$GetInstances$_()))) : s ? aM ? i._$TransferElseInstancesToOwn$_(uM) : (i._$AddElseInstances$_(uM, e), 
        i._$SetSetPicked$_(uM)) : i._$SetSetPicked$_(uM), oM._$ApplySolToContainer$_();
    }, Qy = function(t, s) {
        rM && (s && Jy(t), uM.clear(), oM = null, rM = !1);
    }, Yy = function(t, s) {
        const i = $y._$GetInstanceByUID$_(s);
        if (!i) return !1;
        const e = t._$GetCurrentSol$_();
        if (!e._$IsSelectAll$_() && !e._$_GetOwnInstances$_().includes(i)) return !1;
        if (t._$IsFamily$_()) {
            if (i._$GetObjectClass$_()._$BelongsToFamily$_(t)) return e._$PickOne$_(i), t._$ApplySolToContainer$_(), 
            !0;
        } else if (i._$GetObjectClass$_() === t) return e._$PickOne$_(i), t._$ApplySolToContainer$_(), 
        !0;
        return !1;
    }, Vy = function(t, s) {
        const i = t._$GetCurrentSol$_();
        if (i._$IsSelectAll$_()) {
            i._$_SetSelectAll$_(!1), i._$ClearArrays$_();
            const e = t._$GetInstances$_();
            for (let t = 0, n = e.length; t < n; ++t) {
                const n = e[t];
                n._$GetUID$_() === s ? i._$_PushElseInstance$_(n) : i._$_PushInstance$_(n);
            }
            return t._$ApplySolToContainer$_(), !!i._$_GetOwnInstances$_().length;
        }
        {
            const e = i._$_GetOwnInstances$_();
            let n = 0;
            for (let t = 0, h = e.length; t < h; ++t) {
                const h = e[t];
                e[n] = h, h._$GetUID$_() === s ? i._$_PushElseInstance$_(h) : ++n;
            }
            return Hy._$truncateArray$_(e, n), t._$ApplySolToContainer$_(), !!e.length;
        }
    };
    0;
    const Hy = self._$C3$_, qy = new Hy._$Color$_, Xy = {}, Zy = {}, Ky = {};
    let $y = null;
    Hy._$CommonACES_SetRuntime$_ = function(t) {
        $y = t;
    };
    const tM = self._$IInstance$_, sM = self._$IObjectClass$_, iM = self._$ILayer$_;
    Zy._$CompareX$_ = function(t, s) {
        return Hy.compare(this._$GetWorldInfo$_()._$GetX$_(), t, s);
    }, Ky._$CompareX$_ = function(t, s) {
        return Hy.compare(this.x, t, s);
    }, Zy._$CompareY$_ = function(t, s) {
        return Hy.compare(this._$GetWorldInfo$_()._$GetY$_(), t, s);
    }, Ky._$CompareY$_ = function(t, s) {
        return Hy.compare(this.y, t, s);
    }, Zy._$IsOnScreen$_ = function() {
        return this._$GetWorldInfo$_()._$IsInViewport2$_();
    }, Ky._$IsOnScreen$_ = function() {
        return this._$isOnScreen$_();
    }, Xy._$IsOutsideLayout$_ = function() {
        const t = Oy(this), s = t._$GetLayout$_(), i = t._$GetBoundingBox$_();
        return i._$getRight$_() < 0 || i._$getBottom$_() < 0 || i._$getLeft$_() > s._$GetWidth$_() || i._$getTop$_() > s._$GetHeight$_();
    }, Xy._$PickDistance$_ = function(t, s, i) {
        const e = ky(this)._$GetCurrentSol$_(), n = e._$GetInstances$_();
        if (!n.length) return !1;
        let h = n[0], r = h._$GetWorldInfo$_(), o = h, a = Hy._$distanceSquared$_(r._$GetX$_(), r._$GetY$_(), s, i);
        for (let e = 1, u = n.length; e < u; ++e) {
            h = n[e], r = h._$GetWorldInfo$_();
            const u = Hy._$distanceSquared$_(r._$GetX$_(), r._$GetY$_(), s, i);
            (0 === t && u < a || 1 === t && u > a) && (a = u, o = h);
        }
        return e._$PickOne$_(o), !0;
    }, Zy._$SetX$_ = function(t) {
        const s = this._$GetWorldInfo$_();
        s._$GetX$_() !== t && (s._$SetX$_(t), s._$SetBboxChanged$_());
    }, Ky._$SetX$_ = function(t) {
        this.x = +t;
    }, Zy._$SetY$_ = function(t) {
        const s = this._$GetWorldInfo$_();
        s._$GetY$_() !== t && (s._$SetY$_(t), s._$SetBboxChanged$_());
    }, Ky._$SetY$_ = function(t) {
        this.y = +t;
    }, Zy._$SetPos$_ = function(t, s) {
        const i = this._$GetWorldInfo$_();
        i._$EqualsXY$_(t, s) || (i._$SetXY$_(t, s), i._$SetBboxChanged$_());
    }, Ky._$SetPos$_ = function(t, s) {
        this.setPosition(t, s);
    }, Xy._$SetPosToObject$_ = function(t, s) {
        if (!(t = ky(t))) return;
        const i = Ly(this), e = t._$GetPairedInstance$_(i);
        if (!e) return;
        const [n, h] = e._$GetImagePoint$_(s), r = i._$GetWorldInfo$_();
        r._$GetX$_() === n && r._$GetY$_() === h || (r._$SetXY$_(n, h), r._$SetBboxChanged$_());
    }, Xy._$MoveForward$_ = function(t) {
        if (0 === t) return;
        const s = Oy(this);
        s._$OffsetXY$_(s._$GetCosAngle$_() * t, s._$GetSinAngle$_() * t), s._$SetBboxChanged$_();
    }, Zy._$MoveAtAngle$_ = function(t, s) {
        if (0 === s) return;
        const i = this._$GetWorldInfo$_();
        t = Hy._$toRadians$_(t), i._$OffsetXY$_(Math.cos(t) * s, Math.sin(t) * s), i._$SetBboxChanged$_();
    }, Ky._$MoveAtAngle$_ = function(t, s) {
        0 !== s && (t = Hy._$toRadians$_(t), this.offsetPosition(Math.cos(t) * s, Math.sin(t) * s));
    }, Zy._$GetX$_ = function() {
        return this._$GetWorldInfo$_()._$GetX$_();
    }, Ky._$GetX$_ = function() {
        return this.x;
    }, Zy._$GetY$_ = function() {
        return this._$GetWorldInfo$_()._$GetY$_();
    }, Ky._$GetY$_ = function() {
        return this.y;
    }, Xy._$GetDt$_ = function() {
        return $y._$GetDt$_(Ly(this));
    }, Zy._$CompareWidth$_ = function(t, s) {
        return Hy.compare(this._$GetWorldInfo$_()._$GetWidth$_(), t, s);
    }, Ky._$CompareWidth$_ = function(t, s) {
        return Hy.compare(this.width, t, s);
    }, Zy._$CompareHeight$_ = function(t, s) {
        return Hy.compare(this._$GetWorldInfo$_()._$GetHeight$_(), t, s);
    }, Ky._$CompareHeight$_ = function(t, s) {
        return Hy.compare(this.height, t, s);
    }, Zy._$SetWidth$_ = function(t) {
        const s = this._$GetWorldInfo$_();
        s._$GetWidth$_() !== t && (s._$SetWidth$_(t), s._$SetBboxChanged$_());
    }, Ky._$SetWidth$_ = function(t) {
        this.width = t;
    }, Zy._$SetHeight$_ = function(t) {
        const s = this._$GetWorldInfo$_();
        s._$GetHeight$_() !== t && (s._$SetHeight$_(t), s._$SetBboxChanged$_());
    }, Ky._$SetHeight$_ = function(t) {
        this.height = t;
    }, Zy._$SetSize$_ = function(t, s) {
        const i = Oy(this);
        i._$GetWidth$_() === t && i._$GetHeight$_() === s || (i._$SetSize$_(t, s), i._$SetBboxChanged$_());
    }, Ky._$SetSize$_ = function(t, s) {
        this._$setSize$_(t, s);
    }, Zy._$GetWidth$_ = function() {
        return this._$GetWorldInfo$_()._$GetWidth$_();
    }, Ky._$GetWidth$_ = function() {
        return this.width;
    }, Zy._$GetHeight$_ = function() {
        return this._$GetWorldInfo$_()._$GetHeight$_();
    }, Ky._$GetHeight$_ = function() {
        return this.height;
    }, Xy._$GetBboxLeft$_ = function() {
        return Oy(this)._$GetBoundingBox$_()._$getLeft$_();
    }, Xy._$GetBboxTop$_ = function() {
        return Oy(this)._$GetBoundingBox$_()._$getTop$_();
    }, Xy._$GetBboxRight$_ = function() {
        return Oy(this)._$GetBoundingBox$_()._$getRight$_();
    }, Xy._$GetBboxBottom$_ = function() {
        return Oy(this)._$GetBoundingBox$_()._$getBottom$_();
    }, Xy._$GetBboxMidX$_ = function() {
        const t = Oy(this)._$GetBoundingBox$_();
        return (t._$getLeft$_() + t._$getRight$_()) / 2;
    }, Xy._$GetBboxMidY$_ = function() {
        const t = Oy(this)._$GetBoundingBox$_();
        return (t._$getTop$_() + t._$getBottom$_()) / 2;
    }, Xy._$IsAngleWithin$_ = function(t, s) {
        return Hy._$angleDiff$_(Oy(this)._$GetAngle$_(), Hy._$toRadians$_(s)) <= Hy._$toRadians$_(t);
    }, Xy._$IsAngleClockwiseFrom$_ = function(t) {
        return Hy._$angleClockwise$_(Oy(this)._$GetAngle$_(), Hy._$toRadians$_(t));
    }, Xy._$IsBetweenAngles$_ = function(t, s) {
        const i = Hy._$toRadians$_(t), e = Hy._$toRadians$_(s), n = Oy(this)._$GetAngle$_();
        return Hy._$angleClockwise$_(e, i) ? Hy._$angleClockwise$_(n, i) && !Hy._$angleClockwise$_(n, e) : !(!Hy._$angleClockwise$_(n, i) && Hy._$angleClockwise$_(n, e));
    }, Zy._$SetAngle$_ = function(t) {
        const s = this._$GetWorldInfo$_(), i = Hy._$clampAngle$_(Hy._$toRadians$_(t));
        isNaN(i) || s._$GetAngle$_() === i || (s._$SetAngle$_(i), s._$SetBboxChanged$_());
    }, Ky._$SetAngle$_ = function(t) {
        this._$angleDegrees$_ = t;
    }, Xy._$RotateClockwise$_ = function(t) {
        if (isNaN(t) || 0 === t) return;
        const s = Oy(this);
        s._$SetAngle$_(s._$GetAngle$_() + Hy._$toRadians$_(t)), s._$SetBboxChanged$_();
    }, Xy._$RotateCounterclockwise$_ = function(t) {
        if (isNaN(t) || 0 === t) return;
        const s = Oy(this);
        s._$SetAngle$_(s._$GetAngle$_() - Hy._$toRadians$_(t)), s._$SetBboxChanged$_();
    }, Xy._$RotateTowardAngle$_ = function(t, s) {
        const i = Oy(this), e = i._$GetAngle$_(), n = Hy._$angleRotate$_(e, Hy._$toRadians$_(s), Hy._$toRadians$_(t));
        isNaN(n) || e === n || (i._$SetAngle$_(n), i._$SetBboxChanged$_());
    }, Xy._$RotateTowardPosition$_ = function(t, s, i) {
        const e = Oy(this), n = e._$GetAngle$_(), h = s - e._$GetX$_(), r = i - e._$GetY$_(), o = Math.atan2(r, h), a = Hy._$angleRotate$_(n, o, Hy._$toRadians$_(t));
        isNaN(a) || n === a || (e._$SetAngle$_(a), e._$SetBboxChanged$_());
    }, Xy._$SetTowardPosition$_ = function(t, s) {
        const i = Oy(this), e = i._$GetAngle$_(), n = t - i._$GetX$_(), h = s - i._$GetY$_(), r = Math.atan2(h, n);
        isNaN(r) || e === r || (i._$SetAngle$_(r), i._$SetBboxChanged$_());
    }, Zy._$GetAngle$_ = function() {
        return Hy._$toDegrees$_(this._$GetWorldInfo$_()._$GetAngle$_());
    }, Ky._$GetAngle$_ = function() {
        return this._$angleDegrees$_;
    }, Xy._$CompareOpacity$_ = function(t, s) {
        return Hy.compare(Hy._$roundToDp$_(100 * Oy(this)._$GetOpacity$_(), 6), t, s);
    }, Zy._$IsVisible$_ = function() {
        return this._$GetWorldInfo$_()._$IsVisible$_();
    }, Ky._$IsVisible$_ = function() {
        return this.isVisible;
    }, Xy._$SetVisible$_ = function(t) {
        const s = Oy(this);
        t = 2 === t ? !s._$IsVisible$_() : 0 !== t, s._$IsVisible$_() !== t && (s._$SetVisible$_(t), 
        $y._$UpdateRender$_());
    }, Xy._$SetOpacity$_ = function(t) {
        const s = Hy._$clamp$_(t / 100, 0, 1), i = Oy(this);
        if (i._$GetTransformWithParentOpacity$_()) {
            if (i._$_GetSceneGraphInfo$_()._$GetOwnOpacity$_() === s) return;
        } else if (i._$GetOpacity$_() === s) return;
        i._$SetOpacity$_(s), $y._$UpdateRender$_();
    }, Xy._$SetDefaultColor$_ = function(t) {
        qy._$setFromRgbValue$_(t);
        const s = Oy(this);
        s._$GetUnpremultipliedColor$_()._$equalsIgnoringAlpha$_(qy) || (s._$SetUnpremultipliedColor$_(qy), 
        $y._$UpdateRender$_());
    }, Xy._$GetColor$_ = function() {
        const t = Oy(this)._$GetUnpremultipliedColor$_();
        return Hy._$PackRGBAEx$_(t._$getR$_(), t._$getG$_(), t._$getB$_(), t._$getA$_());
    }, Xy._$GetOpacity$_ = function() {
        return Hy._$roundToDp$_(100 * Oy(this)._$GetOpacity$_(), 6);
    }, Xy._$IsOnLayer$_ = function(t) {
        return !!(t = Fy(t)) && Oy(this)._$GetLayer$_() === t;
    }, Xy._$PickTopBottom$_ = function(t) {
        const s = ky(this)._$GetCurrentSol$_(), i = s._$GetInstances$_();
        if (!i.length) return !1;
        let e = i[0];
        for (let s = 1, n = i.length; s < n; ++s) {
            const n = i[s], h = n._$GetWorldInfo$_(), r = e._$GetWorldInfo$_(), o = h._$GetLayer$_()._$GetIndex$_(), a = r._$GetLayer$_()._$GetIndex$_();
            0 === t ? (o > a || o === a && h._$GetZIndex$_() > r._$GetZIndex$_()) && (e = n) : (o < a || o === a && h._$GetZIndex$_() < r._$GetZIndex$_()) && (e = n);
        }
        return s._$PickOne$_(e), !0;
    }, Zy._$CompareZElevation$_ = function(t, s, i) {
        const e = this._$GetWorldInfo$_(), n = 0 === t ? e._$GetZElevation$_() : e._$GetTotalZElevation$_();
        return Hy.compare(n, s, i);
    }, Ky._$CompareZElevation$_ = function(t, s, i) {
        const e = 0 === t ? this._$zElevation$_ : this._$totalZElevation$_;
        return Hy.compare(e, s, i);
    }, Zy._$MoveToTop$_ = function() {
        this._$GetWorldInfo$_()._$ZOrderMoveToTop$_();
    }, Ky._$MoveToTop$_ = function() {
        this._$moveToTop$_();
    }, Zy._$MoveToBottom$_ = function() {
        this._$GetWorldInfo$_()._$ZOrderMoveToBottom$_();
    }, Ky._$MoveToBottom$_ = function() {
        this._$moveToBottom$_();
    }, Xy._$MoveToLayer$_ = function(t) {
        (t = Fy(t)) && Oy(this)._$ZOrderMoveToLayer$_(t);
    }, Xy._$ZMoveToObject$_ = function(t, s) {
        const i = 0 === t;
        if (!(s = ky(s))) return;
        const e = Ly(this), n = s._$GetFirstPicked$_(e);
        n && e._$GetWorldInfo$_()._$ZOrderMoveAdjacentToInstance$_(n, i);
    }, Zy._$SetZElevation$_ = function(t) {
        const s = this._$GetWorldInfo$_();
        s._$GetZElevation$_() !== t && (s._$SetZElevation$_(t), $y._$UpdateRender$_());
    }, Ky._$SetZElevation$_ = function(t) {
        this._$zElevation$_ = t;
    }, Xy._$LayerNumber$_ = function() {
        return Oy(this)._$GetLayer$_()._$GetIndex$_();
    }, Xy._$LayerName$_ = function() {
        return Oy(this)._$GetLayer$_()._$GetName$_();
    }, Zy._$ZIndex$_ = function() {
        return this._$GetWorldInfo$_()._$GetZIndex$_();
    }, Ky._$ZIndex$_ = function() {
        return this.zIndex;
    }, Zy._$ZElevation$_ = function() {
        return this._$GetWorldInfo$_()._$GetZElevation$_();
    }, Ky._$ZElevation$_ = function() {
        return this._$zElevation$_;
    }, Zy._$TotalZElevation$_ = function() {
        return this._$GetWorldInfo$_()._$GetTotalZElevation$_();
    }, Ky._$TotalZElevation$_ = function() {
        return this._$totalZElevation$_;
    }, Xy._$IsEffectEnabled$_ = function(t) {
        const s = Ly(this), i = s._$GetObjectClass$_()._$GetEffectList$_()._$GetEffectTypeByName$_(t);
        if (!i) return;
        const e = i._$GetIndex$_();
        return s._$GetWorldInfo$_()._$GetInstanceEffectList$_()._$IsEffectIndexActive$_(e);
    }, Xy._$SetEffectEnabled$_ = function(t, s) {
        const i = Ly(this), e = i._$GetObjectClass$_()._$GetEffectList$_()._$GetEffectTypeByName$_(s);
        if (!e) return;
        const n = e._$GetIndex$_(), h = 1 === t, r = i._$GetWorldInfo$_()._$GetInstanceEffectList$_();
        r._$IsEffectIndexActive$_(n) !== h && (r._$SetEffectIndexActive$_(n, h), r._$UpdateActiveEffects$_(), 
        $y._$UpdateRender$_());
    }, Xy._$SetEffectParam$_ = function(t, s, i) {
        const e = Ly(this), n = e._$GetObjectClass$_()._$GetEffectList$_()._$GetEffectTypeByName$_(t);
        if (!n) return;
        s = Math.floor(s);
        const h = n._$GetShaderProgram$_()._$GetParameterType$_(s);
        if (!h) return;
        "color" === h ? (qy._$setFromRgbValue$_(i), i = qy) : "percent" === h && (i /= 100);
        const r = n._$GetIndex$_(), o = e._$GetWorldInfo$_()._$GetInstanceEffectList$_();
        o._$SetEffectParameter$_(r, s, i) && o._$IsEffectIndexActive$_(r) && $y._$UpdateRender$_();
    };
    const eM = Hy._$New$_(Hy.Rect), nM = [], hM = [];
    let rM = !1, oM = null, aM = !1;
    const uM = new Set;
    function* lM(t) {
        if (!t) return !1;
        const s = this._$GetRuntime$_(), i = s._$GetCollisionEngine$_(), e = s._$GetEventSheetManager$_(), n = e._$GetEventStack$_(), h = e._$GetCurrentCondition$_(), r = h._$GetObjectClass$_(), o = h._$GetSavedDataMap$_(), a = h._$GetUnsavedDataMap$_(), u = n._$GetCurrentStackFrame$_(), l = s._$GetTickCount$_(), c = l - 1, f = u._$GetCurrentEvent$_(), d = n._$Push$_(f);
        let p = o.get("collmemory");
        p || (p = Hy._$New$_(Hy._$PairMap$_), o.set("collmemory", p)), a.get("collisionCreatedDestroyCallback") || (a.set("collisionCreatedDestroyCallback", !0), 
        s._$Dispatcher$_().addEventListener("instancedestroy", (t => zy(p, t._$instance$_))));
        const m = r._$GetCurrentSol$_(), g = t._$GetCurrentSol$_(), y = m._$GetInstances$_();
        let M = null;
        for (let s = 0; s < y.length; ++s) {
            const n = y[s];
            g._$IsSelectAll$_() ? (i._$GetCollisionCandidates$_(n._$GetWorldInfo$_()._$GetLayer$_(), t, n._$GetWorldInfo$_()._$GetBoundingBox$_(), nM), 
            M = nM, i._$AddRegisteredCollisionCandidates$_(n, t, M)) : M = g._$GetInstances$_();
            for (let s = 0; s < M.length; ++s) {
                const h = M[s];
                if (i._$TestOverlap$_(n, h) || i._$CheckRegisteredCollision$_(n, h)) {
                    const s = Uy(p, n, h);
                    let i = !1, o = -2;
                    "number" == typeof s && (i = !0, o = s);
                    const a = !i || o < c;
                    if (jy(p, n, h, l), a) {
                        const s = f._$GetSolModifiers$_();
                        e._$PushCopySol$_(s);
                        const i = r._$GetCurrentSol$_(), o = t._$GetCurrentSol$_();
                        if (i._$_SetSelectAll$_(!1), o._$_SetSelectAll$_(!1), r === t) {
                            const t = i._$_GetOwnInstances$_();
                            Hy._$clearArray$_(t), t.push(n), t.push(h), r._$ApplySolToContainer$_();
                        } else {
                            const s = i._$_GetOwnInstances$_(), e = o._$_GetOwnInstances$_();
                            Hy._$clearArray$_(s), Hy._$clearArray$_(e), s.push(n), e.push(h), r._$ApplySolToContainer$_(), 
                            t._$ApplySolToContainer$_();
                        }
                        yield* f._$DebugRetrigger$_(u, d), e._$PopSol$_(s);
                    }
                } else By(p, n, h);
            }
            Hy._$clearArray$_(nM);
        }
        return n._$Pop$_(), !1;
    }
    Xy._$OnCollision$_ = function(t) {
        const s = ky(this);
        t = ky(t);
        const i = s._$GetRuntime$_();
        if (i._$IsDebugging$_()) return lM.call(s, t);
        if (!t) return !1;
        const e = i._$GetCollisionEngine$_(), n = i._$GetEventSheetManager$_(), h = n._$GetEventStack$_(), r = n._$GetCurrentCondition$_(), o = r._$GetObjectClass$_(), a = r._$GetSavedDataMap$_(), u = r._$GetUnsavedDataMap$_(), l = h._$GetCurrentStackFrame$_(), c = i._$GetTickCount$_(), f = c - 1, d = l._$GetCurrentEvent$_(), p = h._$Push$_(d);
        let m = a.get("collmemory");
        m || (m = Hy._$New$_(Hy._$PairMap$_), a.set("collmemory", m)), u.get("collisionCreatedDestroyCallback") || (u.set("collisionCreatedDestroyCallback", !0), 
        i._$Dispatcher$_().addEventListener("instancedestroy", (t => zy(m, t._$instance$_))));
        const g = o._$GetCurrentSol$_(), y = t._$GetCurrentSol$_(), M = g._$GetInstances$_();
        let w = null;
        for (let s = 0; s < M.length; ++s) {
            const i = M[s];
            y._$IsSelectAll$_() ? (e._$GetCollisionCandidates$_(i._$GetWorldInfo$_()._$GetLayer$_(), t, i._$GetWorldInfo$_()._$GetBoundingBox$_(), nM), 
            w = nM, e._$AddRegisteredCollisionCandidates$_(i, t, w)) : w = y._$GetInstances$_();
            for (let s = 0; s < w.length; ++s) {
                const h = w[s];
                if (e._$TestOverlap$_(i, h) || e._$CheckRegisteredCollision$_(i, h)) {
                    const s = Uy(m, i, h);
                    let e = !1, r = -2;
                    "number" == typeof s && (e = !0, r = s);
                    const a = !e || r < f;
                    if (jy(m, i, h, c), a) {
                        const s = d._$GetSolModifiers$_();
                        n._$PushCopySol$_(s);
                        const e = o._$GetCurrentSol$_(), r = t._$GetCurrentSol$_();
                        if (e._$_SetSelectAll$_(!1), r._$_SetSelectAll$_(!1), o === t) {
                            const t = e._$_GetOwnInstances$_();
                            Hy._$clearArray$_(t), t.push(i), t.push(h), o._$ApplySolToContainer$_();
                        } else {
                            const s = e._$_GetOwnInstances$_(), n = r._$_GetOwnInstances$_();
                            Hy._$clearArray$_(s), Hy._$clearArray$_(n), s.push(i), n.push(h), o._$ApplySolToContainer$_(), 
                            t._$ApplySolToContainer$_();
                        }
                        d._$Retrigger$_(l, p), n._$PopSol$_(s);
                    }
                } else By(m, i, h);
            }
            Hy._$clearArray$_(nM);
        }
        return h._$Pop$_(), !1;
    }, Xy._$IsOverlapping$_ = function(t) {
        return t = ky(t), Wy(Ly(this), t, 0, 0);
    }, Xy._$IsOverlappingOffset$_ = function(t, s, i) {
        return t = ky(t), Wy(Ly(this), t, s, i);
    }, Xy._$OnHierarchyReady$_ = function() {
        return !0;
    }, Xy._$HasParent$_ = function() {
        return Oy(this)._$HasParent$_();
    }, Xy._$HasChildren$_ = function() {
        return Oy(this)._$HasChildren$_();
    }, Xy._$PickParent$_ = function(t, s) {
        const i = ky(this);
        t = ky(t);
        const e = i._$GetRuntime$_(), n = this._$GetCurrentSol$_()._$GetInstances$_();
        if (0 === n.length) return !1;
        const h = t._$GetCurrentSol$_();
        let r = h._$GetInstances$_();
        if (h._$IsSelectAll$_()) {
            const s = [ ...e._$instancesPendingCreateForObjectClass$_(t) ];
            s.length > 0 && (r = r.concat(s));
        }
        if (0 === r.length) return !1;
        const o = h._$IsSelectAll$_() ? null : new Set(r), a = new Set;
        for (let i = 0, e = n.length; i < e; ++i) {
            const e = n[i];
            if (1 === s) for (const s of e._$parents$_()) s._$BelongsToObjectClass$_(t) && (null === o || o.has(s)) && a.add(s); else {
                let i;
                if (0 === s) {
                    if (i = e._$GetParent$_(), null === i) continue;
                } else i = e._$GetTopParent$_();
                i._$BelongsToObjectClass$_(t) && (null === o || o.has(i)) && a.add(i);
            }
        }
        return 0 !== a.size && (h._$SetSetPicked$_(a), t._$ApplySolToContainer$_(), !0);
    }, Xy._$PickChildren$_ = function(t, s) {
        const i = ky(this);
        t = ky(t);
        const e = i._$GetRuntime$_(), n = i._$GetCurrentSol$_()._$GetInstances$_();
        if (0 === n.length) return !1;
        const h = t._$GetCurrentSol$_();
        let r = h._$GetInstances$_();
        if (h._$IsSelectAll$_()) {
            const s = [ ...e._$instancesPendingCreateForObjectClass$_(t) ];
            s.length > 0 && (r = r.concat(s));
        }
        if (0 === r.length) return !1;
        const o = h._$IsSelectAll$_() ? null : new Set(r), a = new Set;
        for (let i = 0, e = n.length; i < e; ++i) {
            const e = n[i];
            2 !== s || e._$HasChildren$_() || !e._$BelongsToObjectClass$_(t) || null !== o && !o.has(e) || a.add(e);
            for (const i of 0 === s ? e.children() : e._$allChildren$_()) 2 === s && i._$HasChildren$_() || i._$BelongsToObjectClass$_(t) && (null === o || o.has(i)) && a.add(i);
        }
        return 0 !== a.size && (h._$SetSetPicked$_(a), t._$ApplySolToContainer$_(), !0);
    }, Xy._$PickNthChild$_ = function(t, s, i) {
        const e = ky(this);
        t = ky(t);
        const n = e._$GetRuntime$_(), h = e._$GetCurrentSol$_()._$GetInstances$_();
        if (0 === h.length) return !1;
        const r = t._$GetCurrentSol$_();
        let o = r._$GetInstances$_();
        if (r._$IsSelectAll$_()) {
            const s = [ ...n._$instancesPendingCreateForObjectClass$_(t) ];
            s.length > 0 && (o = o.concat(s));
        }
        if (0 === o.length) return !1;
        const a = r._$IsSelectAll$_() ? null : new Set(o), u = [];
        for (let e = 0, n = h.length; e < n; ++e) {
            const n = h[e];
            if (0 === s) {
                const s = n._$GetChildAt$_(i);
                null !== s && s._$BelongsToObjectClass$_(t) && (null === a || a.has(s)) && u.push(s);
            } else if (1 === s) for (const s of n.children()) if (s._$BelongsToObjectClass$_(t)) {
                if (0 === i) {
                    (null === a || a.has(s)) && u.push(s);
                    break;
                }
                --i;
            }
        }
        return 0 !== u.length && (r._$SetArrayPicked$_(u), t._$ApplySolToContainer$_(), 
        !0);
    }, Xy._$CompareChildCount$_ = function(t, s, i) {
        const e = Ly(this);
        switch (t) {
          case 0:
          default:
            return Hy.compare(e._$GetChildCount$_(), s, i);

          case 1:
            return Hy.compare(e._$GetAllChildCount$_(), s, i);
        }
    }, Xy._$AddChild$_ = function(t, s, i, e, n, h, r, o, a, u) {
        t = ky(t);
        const l = Ly(this), c = $y._$GetCurrentAction$_()._$GetObjectClass$_();
        for (const f of t._$allCorrespondingInstances$_(l, c)) {
            if (!f._$GetPlugin$_()._$SupportsSceneGraph$_()) return;
            l._$AddChild$_(f, {
                _$transformX$_: s,
                _$transformY$_: i,
                _$transformWidth$_: e,
                _$transformHeight$_: n,
                _$transformAngle$_: h,
                _$transformOpacity$_: r,
                _$transformZElevation$_: o,
                _$transformVisibility$_: a,
                _$destroyWithParent$_: u
            });
        }
    }, Xy._$RemoveChild$_ = function(t) {
        t = ky(t);
        const s = Ly(this), i = $y._$GetCurrentAction$_()._$GetObjectClass$_();
        for (const e of t._$allCorrespondingInstances$_(s, i)) s._$RemoveChild$_(e);
    }, Xy._$RemoveFromParent$_ = function() {
        const t = Ly(this);
        t._$HasParent$_() && t._$GetParent$_()._$RemoveChild$_(t);
    }, Xy._$ParentUID$_ = function() {
        const t = Ly(this)._$GetParent$_();
        return t ? t._$GetUID$_() : -1;
    }, Xy._$ChildCount$_ = function() {
        return Ly(this)._$GetChildCount$_();
    }, Xy._$AllChildCount$_ = function() {
        return Ly(this)._$GetAllChildCount$_();
    }, Xy._$SetMeshSize$_ = function(t, s) {
        t = Math.floor(t), s = Math.floor(s);
        const i = Oy(this);
        t < 2 || s < 2 || !isFinite(t) || !isFinite(s) ? (i._$ReleaseMesh$_(), i._$SetBboxChanged$_()) : i._$CreateMesh$_(t, s);
    }, Xy._$SetMeshPoint$_ = function(t, s, i, e, n, h, r, o) {
        const a = Oy(this);
        a._$SetMeshPoint$_(t, s, {
            mode: 0 === i ? "absolute" : "relative",
            x: e,
            y: n,
            _$zElevation$_: h,
            _$u$_: r,
            _$v$_: o
        }) && a._$SetBboxChanged$_();
    }, Xy._$MeshColumns$_ = function() {
        const t = Oy(this);
        return t._$HasMesh$_() ? t._$GetSourceMesh$_()._$GetHSize$_() : 0;
    }, Xy._$MeshRows$_ = function() {
        const t = Oy(this);
        return t._$HasMesh$_() ? t._$GetSourceMesh$_()._$GetVSize$_() : 0;
    }, Xy._$SetElementVisible$_ = function(t) {
        const s = Oy(this);
        t = 2 === t ? !s._$IsVisible$_() : 0 !== t, s._$IsVisible$_() !== t && s._$SetVisible$_(t);
    }, Xy._$SetElementCSSStyle$_ = function(t, s) {
        this instanceof self._$IInstance$_ ? this._$setElementCSSStyle$_(t, s) : this._$SetElementCSSStyle$_(t, s);
    }, Xy._$SetElementAttribute$_ = function(t, s) {
        this instanceof self._$IInstance$_ ? this._$setElementAttribute$_(t, "" + s) : this._$SetElementAttribute$_(t, "" + s);
    }, Xy._$RemoveElementAttribute$_ = function(t) {
        this instanceof self._$IInstance$_ ? this._$removeElementAttribute$_(t) : this._$RemoveElementAttribute$_(t);
    }, Xy._$SetElementFocus$_ = function() {
        this instanceof self._$IInstance$_ ? this._$focusElement$_() : this._$FocusElement$_();
    }, Xy._$SetElementBlur$_ = function() {
        this instanceof self._$IInstance$_ ? this._$blurElement$_() : this._$BlurElement$_();
    }, Xy._$IsElementFocused$_ = function() {
        return this instanceof self._$IInstance$_ ? this._$isElementFocused$_() : this._$IsElementFocused$_();
    }, Xy._$SetElementEnabled$_ = function(t) {
        this instanceof self._$IInstance$_ ? this._$_setEnabled$_(0 !== t) : this._$_SetEnabled$_(0 !== t);
    }, Xy._$IsElementEnabled$_ = function() {
        return this instanceof self._$IInstance$_ ? this._$_isEnabled$_() : this._$_IsEnabled$_();
    }, Zy._$CompareInstanceVar$_ = function(t, s, i) {
        return Hy.compare(this._$GetInstance$_()._$GetInstanceVariableValue$_(t), s, i);
    }, Ky._$CompareInstanceVar$_ = function(t, s, i) {
        return Hy.compare(Ry(this)._$GetInstanceVariableValue$_(t), s, i);
    }, Zy._$IsBoolInstanceVarSet$_ = function(t) {
        return !!this._$GetInstance$_()._$GetInstanceVariableValue$_(t);
    }, Ky._$IsBoolInstanceVarSet$_ = function(t) {
        return !!Ry(this)._$GetInstanceVariableValue$_(t);
    }, Xy._$PickInstVarHiLow$_ = function(t, s) {
        const i = ky(this), e = i._$GetCurrentSol$_(), n = e._$GetInstances$_();
        if (!n.length) return !1;
        const h = i._$IsFamily$_();
        let r = null, o = 0;
        for (let e = 0, a = n.length; e < a; ++e) {
            const a = n[e], u = h ? a._$GetObjectClass$_()._$GetFamilyInstanceVariableOffset$_(i._$GetFamilyIndex$_()) : 0, l = a._$GetInstanceVariableValue$_(u + s);
            (null === r || 0 === t && l < o || 1 === t && l > o) && (o = l, r = a);
        }
        return e._$PickOne$_(r), !0;
    }, Xy._$PickByUID$_ = function(t) {
        const s = ky(this);
        return s._$GetRuntime$_()._$GetCurrentCondition$_()._$IsInverted$_() ? Vy(s, t) : Yy(s, t);
    }, Xy._$HasTags$_ = function(t) {
        const s = new Set(Hy._$splitStringAndNormalize$_(t)), i = Ly(this)._$GetTagsSet$_();
        return s.isSubsetOf(i);
    }, Xy._$Tags$_ = function() {
        return Ly(this)._$GetTagsString$_();
    }, Xy._$TagsCount$_ = function() {
        return Ly(this)._$GetTagsSet$_().size;
    }, Xy._$TagAt$_ = function(t) {
        return Ly(this)._$GetTagAt$_(t);
    }, Xy._$ChangeTags$_ = function(t, s) {
        const i = Hy._$splitStringAndNormalize$_(s);
        if (0 === i.length) return;
        const e = Ly(this), n = new Set(e._$GetTagsSet$_());
        if (0 === t) for (const t of i) n.add(t); else if (1 === t) for (const t of i) n.delete(t);
        e._$SetTagsSet$_(n);
    }, Xy._$Destroy$_ = function() {
        $y._$DestroyInstance$_(Ly(this));
    }, Xy._$OnCreated$_ = function() {
        return !0;
    }, Xy._$OnDestroyed$_ = function() {
        return !0;
    }, Zy._$SetInstanceVar$_ = function(t, s) {
        this._$GetInstance$_()._$SetInstanceVariableValue$_(t, s);
    }, Ky._$SetInstanceVar$_ = function(t, s) {
        Ry(this)._$SetInstanceVariableValue$_(t, s);
    }, Zy._$AddInstanceVar$_ = function(t, s) {
        const i = this._$GetInstance$_(), e = i._$GetInstanceVariableValue$_(t);
        "number" == typeof e && "number" != typeof s ? s = parseFloat(s) : "string" == typeof e && "string" != typeof s && (s = s.toString()), 
        i._$SetInstanceVariableValue$_(t, e + s);
    }, Ky._$AddInstanceVar$_ = function(t, s) {
        const i = Ry(this), e = i._$GetInstanceVariableValue$_(t);
        "number" == typeof e && "number" != typeof s ? s = parseFloat(s) : "string" == typeof e && "string" != typeof s && (s = s.toString()), 
        i._$SetInstanceVariableValue$_(t, e + s);
    }, Zy._$SubInstanceVar$_ = function(t, s) {
        const i = this._$GetInstance$_(), e = i._$GetInstanceVariableValue$_(t);
        "number" == typeof e && ("number" != typeof s && (s = parseFloat(s)), i._$SetInstanceVariableValue$_(t, e - s));
    }, Ky._$SubInstanceVar$_ = function(t, s) {
        const i = Ry(this), e = i._$GetInstanceVariableValue$_(t);
        "number" == typeof e && ("number" != typeof s && (s = parseFloat(s)), i._$SetInstanceVariableValue$_(t, e - s));
    }, Zy._$SetBoolInstanceVar$_ = function(t, s) {
        this._$GetInstance$_()._$SetInstanceVariableValue$_(t, s ? 1 : 0);
    }, Ky._$SetBoolInstanceVar$_ = function(t, s) {
        Ry(this)._$SetInstanceVariableValue$_(t, s ? 1 : 0);
    }, Zy._$ToggleBoolInstanceVar$_ = function(t) {
        const s = this._$GetInstance$_();
        s._$SetInstanceVariableValue$_(t, 0 === s._$GetInstanceVariableValue$_(t) ? 1 : 0);
    }, Ky._$ToggleBoolInstanceVar$_ = function(t) {
        const s = Ry(this);
        s._$SetInstanceVariableValue$_(t, 0 === s._$GetInstanceVariableValue$_(t) ? 1 : 0);
    }, Xy._$LoadFromJsonString$_ = function(t) {
        let s;
        try {
            s = JSON.parse(t);
        } catch (t) {
            return void console.error("Failed to load from JSON string: ", t);
        }
        const i = Ly(this), e = "state";
        $y._$ClearIntancesNeedingAfterLoad$_(), i._$_OnBeforeLoad$_(e), i._$LoadFromJson$_(s, e), 
        $y._$DoAfterLoad$_(e, {
            _$setFromJson$_: !0
        });
    }, Xy._$AsJSON$_ = function() {
        return JSON.stringify(Ly(this)._$SaveToJson$_("state"));
    }, Xy._$ObjectTypeName$_ = function() {
        return Ly(this)._$GetObjectClass$_()._$GetName$_();
    }, Xy._$Count$_ = function() {
        const t = $y._$GetCurrentEventStackFrame$_()._$GetExpressionObjectClass$_();
        let s = t._$GetInstanceCount$_();
        for (const i of $y._$instancesPendingCreateForObjectClass$_(t)) ++s;
        return s;
    }, Xy._$PickedCount$_ = function() {
        return $y._$GetCurrentEventStackFrame$_()._$GetExpressionObjectClass$_()._$GetCurrentSol$_()._$GetInstances$_().length;
    }, Zy._$GetIID$_ = function() {
        return this._$GetInstance$_()._$GetIID$_();
    }, Ky._$GetIID$_ = function() {
        return Ry(this)._$GetIID$_();
    }, Zy._$GetUID$_ = function() {
        return this._$GetInstance$_()._$GetUID$_();
    }, Ky._$GetUID$_ = function() {
        return Ry(this)._$GetUID$_();
    }, Xy._$OnInstanceSignal$_ = function(t) {
        const s = Ly(this);
        return t.toLowerCase() === $y._$GetEventSheetManager$_()._$GetCurrentInstanceSignalTag$_(s);
    }, Xy._$InstanceSignal$_ = function(t) {
        const s = Ly(this);
        $y._$GetEventSheetManager$_()._$InstanceSignal$_(s, t);
    }, Xy._$InstanceWaitForSignal$_ = function(t) {
        const s = ky(this);
        return $y._$GetEventSheetManager$_()._$AddScheduledWait$_()._$InitInstanceSignals$_(s._$GetCurrentSol$_()._$GetInstances$_(), t), 
        !0;
    }, Xy._$TemplateName$_ = function() {
        return Ly(this)._$GetTemplateName$_();
    }, Hy._$AddCommonACEs$_ = function(t, s, i) {
        const e = t[1], n = t[3], h = t[4], r = t[5], o = t[6], a = t[7], u = t[8], l = t[10], c = t[11], f = t[12], d = t[13], p = t[14], m = t[15], g = t[16], y = s._$Cnds$_, M = s._$Acts$_, w = s._$Exps$_, S = Object.assign({}, Xy, i >= 2 ? Ky : Zy);
        n && (y._$CompareX$_ = S._$CompareX$_, y._$CompareY$_ = S._$CompareY$_, y._$IsOnScreen$_ = S._$IsOnScreen$_, 
        y._$IsOutsideLayout$_ = S._$IsOutsideLayout$_, y._$PickDistance$_ = S._$PickDistance$_, 
        M._$SetX$_ = S._$SetX$_, M._$SetY$_ = S._$SetY$_, M._$SetPos$_ = S._$SetPos$_, M._$SetPosToObject$_ = S._$SetPosToObject$_, 
        M._$MoveForward$_ = S._$MoveForward$_, M._$MoveAtAngle$_ = S._$MoveAtAngle$_, w._$X$_ = S._$GetX$_, 
        w._$Y$_ = S._$GetY$_, w._$dt$_ = S._$GetDt$_), h && (y._$CompareWidth$_ = S._$CompareWidth$_, 
        y._$CompareHeight$_ = S._$CompareHeight$_, M._$SetWidth$_ = S._$SetWidth$_, M._$SetHeight$_ = S._$SetHeight$_, 
        M._$SetSize$_ = S._$SetSize$_, w._$Width$_ = S._$GetWidth$_, w._$Height$_ = S._$GetHeight$_, 
        w._$BBoxLeft$_ = S._$GetBboxLeft$_, w._$BBoxTop$_ = S._$GetBboxTop$_, w._$BBoxRight$_ = S._$GetBboxRight$_, 
        w._$BBoxBottom$_ = S._$GetBboxBottom$_, w._$BBoxMidX$_ = S._$GetBboxMidX$_, w._$BBoxMidY$_ = S._$GetBboxMidY$_), 
        r && (y._$AngleWithin$_ = S._$IsAngleWithin$_, y._$IsClockwiseFrom$_ = S._$IsAngleClockwiseFrom$_, 
        y._$IsBetweenAngles$_ = S._$IsBetweenAngles$_, M._$SetAngle$_ = S._$SetAngle$_, 
        M._$RotateClockwise$_ = S._$RotateClockwise$_, M._$RotateCounterclockwise$_ = S._$RotateCounterclockwise$_, 
        M._$RotateTowardAngle$_ = S._$RotateTowardAngle$_, M._$RotateTowardPosition$_ = S._$RotateTowardPosition$_, 
        M._$SetTowardPosition$_ = S._$SetTowardPosition$_, w._$Angle$_ = S._$GetAngle$_), 
        o && (y._$IsVisible$_ = S._$IsVisible$_, y._$CompareOpacity$_ = S._$CompareOpacity$_, 
        M._$SetVisible$_ = S._$SetVisible$_, M._$SetOpacity$_ = S._$SetOpacity$_, M._$SetDefaultColor$_ = S._$SetDefaultColor$_, 
        w.Opacity = S._$GetOpacity$_, w.ColorValue = S._$GetColor$_), a && (y._$IsOnLayer$_ = S._$IsOnLayer$_, 
        y._$PickTopBottom$_ = S._$PickTopBottom$_, y._$CompareZElevation$_ = S._$CompareZElevation$_, 
        M._$MoveToTop$_ = S._$MoveToTop$_, M._$MoveToBottom$_ = S._$MoveToBottom$_, M._$MoveToLayer$_ = S._$MoveToLayer$_, 
        M._$ZMoveToObject$_ = S._$ZMoveToObject$_, M._$SetZElevation$_ = S._$SetZElevation$_, 
        w._$LayerNumber$_ = S._$LayerNumber$_, w._$LayerName$_ = S._$LayerName$_, w._$ZIndex$_ = S._$ZIndex$_, 
        w._$ZElevation$_ = S._$ZElevation$_, w._$TotalZElevation$_ = S._$TotalZElevation$_), 
        u && (y._$IsEffectEnabled$_ = S._$IsEffectEnabled$_, M._$SetEffectEnabled$_ = S._$SetEffectEnabled$_, 
        M._$SetEffectParam$_ = S._$SetEffectParam$_), d && (y._$OnHierarchyReady$_ = S._$OnHierarchyReady$_, 
        y._$HasParent$_ = S._$HasParent$_, y._$HasChildren$_ = S._$HasChildren$_, y._$PickParent$_ = S._$PickParent$_, 
        y._$PickChildren$_ = S._$PickChildren$_, y._$PickNthChild$_ = S._$PickNthChild$_, 
        y._$CompareChildCount$_ = S._$CompareChildCount$_, M._$AddChild$_ = S._$AddChild$_, 
        M._$RemoveChild$_ = S._$RemoveChild$_, M._$RemoveFromParent$_ = S._$RemoveFromParent$_, 
        w._$ParentUID$_ = S._$ParentUID$_, w._$ChildCount$_ = S._$ChildCount$_, w._$AllChildCount$_ = S._$AllChildCount$_), 
        p && (M._$SetMeshSize$_ = S._$SetMeshSize$_, M._$SetMeshPoint$_ = S._$SetMeshPoint$_, 
        w._$MeshColumns$_ = S._$MeshColumns$_, w._$MeshRows$_ = S._$MeshRows$_), l && (y._$IsVisible$_ = S._$IsVisible$_, 
        M._$SetVisible$_ = S._$SetElementVisible$_, M._$SetCSSStyle$_ = S._$SetElementCSSStyle$_, 
        M._$SetElemAttribute$_ = S._$SetElementAttribute$_, M._$RemoveElemAttribute$_ = S._$RemoveElementAttribute$_), 
        c && (y._$IsFocused$_ = S._$IsElementFocused$_, M._$SetFocus$_ = S._$SetElementFocus$_, 
        M._$SetBlur$_ = S._$SetElementBlur$_), f && (y._$IsEnabled$_ = S._$IsElementEnabled$_, 
        M._$SetEnabled$_ = S._$SetElementEnabled$_), m && (y._$OnCollision$_ = S._$OnCollision$_, 
        y._$IsOverlapping$_ = S._$IsOverlapping$_, y._$IsOverlappingOffset$_ = S._$IsOverlappingOffset$_, 
        s._$FinishCollisionCondition$_ = Qy), e || (y._$CompareInstanceVar$_ = S._$CompareInstanceVar$_, 
        y._$IsBoolInstanceVarSet$_ = S._$IsBoolInstanceVarSet$_, y._$PickInstVarHiLow$_ = S._$PickInstVarHiLow$_, 
        y._$PickByUID$_ = S._$PickByUID$_, y._$HasTags$_ = S._$HasTags$_, M._$SetInstanceVar$_ = S._$SetInstanceVar$_, 
        M._$AddInstanceVar$_ = S._$AddInstanceVar$_, M._$SubInstanceVar$_ = S._$SubInstanceVar$_, 
        M._$SetBoolInstanceVar$_ = S._$SetBoolInstanceVar$_, M._$ToggleBoolInstanceVar$_ = S._$ToggleBoolInstanceVar$_, 
        M._$ChangeTags$_ = S._$ChangeTags$_, y._$OnCreated$_ = S._$OnCreated$_, y._$OnDestroyed$_ = S._$OnDestroyed$_, 
        M._$Destroy$_ = S._$Destroy$_, M._$LoadFromJsonString$_ || (M._$LoadFromJsonString$_ = S._$LoadFromJsonString$_), 
        w._$AsJSON$_ || (w._$AsJSON$_ = S._$AsJSON$_), w._$Count$_ = S._$Count$_, w._$PickedCount$_ = S._$PickedCount$_, 
        w._$IID$_ = S._$GetIID$_, w._$UID$_ = S._$GetUID$_, w._$ObjectTypeName$_ = S._$ObjectTypeName$_, 
        w._$Tags$_ = S._$Tags$_, w._$TagsCount$_ = S._$TagsCount$_, w._$TagAt$_ = S._$TagAt$_, 
        y._$OnInstanceSignal$_ = S._$OnInstanceSignal$_, M._$InstanceSignal$_ = S._$InstanceSignal$_, 
        M._$InstanceWaitForSignal$_ = S._$InstanceWaitForSignal$_), g && (w._$TemplateName$_ = S._$TemplateName$_);
    };
}

{
    const cM = self._$C3$_;
    cM._$ScheduledWait$_ = class extends cM._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_eventSheetManager$_ = t, this._$_type$_ = "", this._$_time$_ = -1, 
            this._$_signalTag$_ = "", this._$_isSignalled$_ = !1, this._$_event$_ = null, this._$_actIndex$_ = 0, 
            this._$_solModifiers$_ = [], this._$_dynamicSolModifiers$_ = null, this._$_sols$_ = new Map, 
            this._$_pendingInstances$_ = null, this._$_callingFunctionBlock$_ = null, this._$_asyncId$_ = -1, 
            this._$_functionParameters$_ = null, this._$_functionInnerLocalVars$_ = null, this._$_shouldRelease$_ = !1;
        }
        _$Release$_() {
            this._$_type$_ = "", this._$_time$_ = -1, this._$_signalTag$_ = "", this._$_event$_ = null, 
            this._$_callingFunctionBlock$_ = null, this._$_functionParameters$_ = null, this._$_functionInnerLocalVars$_ = null, 
            this._$_asyncId$_ = -1, cM._$clearArray$_(this._$_solModifiers$_), this._$_dynamicSolModifiers$_ && (this._$_dynamicSolModifiers$_.clear(), 
            this._$_dynamicSolModifiers$_ = null);
            for (const t of this._$_sols$_.values()) t._$Release$_();
            this._$_sols$_.clear(), this._$_pendingInstances$_ = null;
        }
        _$_Init$_() {
            const t = this._$_eventSheetManager$_, s = t._$GetRuntime$_()._$GetAllObjectClasses$_(), i = t._$GetCurrentEventStackFrame$_();
            this._$_event$_ = i._$GetCurrentEvent$_(), this._$_actIndex$_ = i._$GetActionIndex$_() + 1;
            const e = t._$FindFirstFunctionBlockParent$_(this._$_event$_);
            e && (this._$_callingFunctionBlock$_ = e, this._$_functionParameters$_ = e._$CaptureFunctionParameters$_(), 
            this._$_functionInnerLocalVars$_ = e._$_GetAllInnerLocalVariables$_().map((t => t._$GetValue$_())), 
            e._$IsAsync$_() && (this._$_asyncId$_ = e._$PauseCurrentAsyncFunction$_()));
            for (const t of s) {
                const s = t._$GetCurrentSol$_();
                s._$IsSelectAll$_() && !this._$_event$_._$HasSolModifier$_(t) || (this._$_solModifiers$_.push(t), 
                this._$_sols$_.set(t, cM._$New$_(cM._$SolState$_, s)));
            }
            const n = t._$GetDynamicSolModifiersSet$_();
            this._$_dynamicSolModifiers$_ = n.size > 0 ? n : null;
        }
        _$InitTimer$_(t) {
            this._$_type$_ = "timer", this._$_Init$_(), this._$_time$_ = this._$_eventSheetManager$_._$GetRuntime$_()._$GetGameTime$_() + t;
        }
        _$InitWallTimer$_(t) {
            this._$_type$_ = "walltimer", this._$_Init$_(), this._$_time$_ = this._$_eventSheetManager$_._$GetRuntime$_()._$GetWallTime$_() + t;
        }
        _$InitSignal$_(t) {
            this._$_type$_ = "signal", this._$_Init$_(), this._$_signalTag$_ = t.toLowerCase();
        }
        _$InitInstanceSignals$_(t, s) {
            this._$_type$_ = "instance-signals", this._$_Init$_(), this._$_signalTag$_ = s.toLowerCase(), 
            this._$_pendingInstances$_ = new Set(t);
        }
        _$InitPromise$_(t) {
            this._$_type$_ = "promise", this._$_Init$_(), t.then((() => this._$SetSignalled$_())).catch((t => {
                console.warn("[C3 runtime] Promise rejected in 'Wait for previous actions to complete': ", t), 
                this._$SetSignalled$_();
            }));
        }
        _$IsTimer$_() {
            return "timer" === this._$_type$_;
        }
        _$IsWallTimer$_() {
            return "walltimer" === this._$_type$_;
        }
        _$IsSignal$_() {
            return "signal" === this._$_type$_;
        }
        _$IsInstanceSignals$_() {
            return "instance-signals" === this._$_type$_;
        }
        _$IsPromise$_() {
            return "promise" === this._$_type$_;
        }
        _$GetSignalTag$_() {
            return this._$_signalTag$_;
        }
        _$IsSignalled$_() {
            return this._$_isSignalled$_;
        }
        _$SetSignalled$_() {
            this._$_isSignalled$_ = !0;
        }
        _$SetInstanceSignalled$_(t) {
            this._$_pendingInstances$_.delete(t), 0 === this._$_pendingInstances$_.size && this._$SetSignalled$_();
        }
        _$_ShouldRun$_() {
            return this._$IsTimer$_() ? this._$_time$_ <= this._$_eventSheetManager$_._$GetRuntime$_()._$GetGameTime$_() : this._$IsWallTimer$_() ? this._$_time$_ <= this._$_eventSheetManager$_._$GetRuntime$_()._$GetWallTime$_() : this._$IsSignalled$_();
        }
        _$_RestoreState$_(t) {
            t._$_Restore$_(this._$_event$_, this._$_actIndex$_);
            for (const [t, s] of this._$_sols$_.entries()) {
                const i = t._$GetCurrentSol$_();
                s._$_Restore$_(i);
            }
            this._$_dynamicSolModifiers$_ && t._$SetDynamicSolModifiers$_([ ...this._$_dynamicSolModifiers$_ ]);
            const s = this._$_callingFunctionBlock$_;
            s && (s._$SetFunctionParameters$_(this._$_functionParameters$_), s._$_GetAllInnerLocalVariables$_().map(((t, s) => t._$SetValue$_(this._$_functionInnerLocalVars$_[s]))), 
            s._$IsAsync$_() && s._$ResumeAsyncFunction$_(this._$_asyncId$_));
        }
        _$_Run$_(t) {
            this._$_RestoreState$_(t), this._$_event$_._$_ResumeActionsAndSubEvents$_(t), this._$_callingFunctionBlock$_ && this._$_callingFunctionBlock$_._$IsAsync$_() && this._$_callingFunctionBlock$_._$MaybeFinishAsyncFunctionCall$_(this._$_asyncId$_), 
            this._$_eventSheetManager$_._$ClearSol$_(this._$_solModifiers$_), this._$_shouldRelease$_ = !0;
        }
        async _$_DebugRun$_(t) {
            this._$_RestoreState$_(t);
            for (const s of this._$_event$_._$_DebugResumeActionsAndSubEvents$_(t)) await this._$_eventSheetManager$_._$GetRuntime$_()._$DebugBreak$_(s);
            this._$_callingFunctionBlock$_ && this._$_callingFunctionBlock$_._$IsAsync$_() && this._$_callingFunctionBlock$_._$MaybeFinishAsyncFunctionCall$_(this._$_asyncId$_), 
            this._$_eventSheetManager$_._$ClearSol$_(this._$_solModifiers$_), this._$_shouldRelease$_ = !0;
        }
        _$ShouldRelease$_() {
            return this._$_shouldRelease$_;
        }
        _$RemoveInstances$_(t) {
            for (const s of this._$_sols$_.values()) s._$RemoveInstances$_(t);
            if ("instance-signals" === this._$_type$_) {
                for (const s of t) this._$_pendingInstances$_.delete(s);
                0 === this._$_pendingInstances$_.size && this._$SetSignalled$_();
            }
        }
        _$_SaveToJson$_() {
            const t = {}, s = {
                wt: this._$_type$_,
                t: this._$_time$_,
                st: this._$_signalTag$_,
                s: this._$_isSignalled$_,
                ev: this._$_event$_._$GetSID$_(),
                sm: this._$_solModifiers$_.map((t => t._$GetSID$_())),
                dsm: this._$_dynamicSolModifiers$_ ? [ ...this._$_dynamicSolModifiers$_ ].map((t => t._$GetSID$_())) : null,
                sols: t
            };
            this._$_event$_._$_HasActionIndex$_(this._$_actIndex$_) && (s.act = this._$_event$_._$GetActionAt$_(this._$_actIndex$_)._$GetSID$_());
            for (const [s, i] of this._$_sols$_) t[s._$GetSID$_().toString()] = i._$_SaveToJson$_();
            return "instance-signals" === this._$_type$_ && (s.pi = [ ...this._$_pendingInstances$_ ].map((t => t._$GetUID$_()))), 
            s;
        }
        static _$_CreateFromJson$_(t, s) {
            const i = t._$GetRuntime$_(), e = t._$GetEventBlockBySID$_(s.ev);
            if (!e) return null;
            let n = 0;
            if (s.hasOwnProperty("act")) {
                const i = t._$GetActionBySID$_(s.act);
                if (!i) return null;
                n = i._$GetIndex$_();
            }
            const h = cM._$New$_(cM._$ScheduledWait$_, t);
            h._$_time$_ = s.t, s.hasOwnProperty("wt") ? h._$_type$_ = s.wt : h._$_type$_ = -1 === h._$_time$_ ? "signal" : "timer", 
            h._$_signalTag$_ = s.st, h._$_isSignalled$_ = s.s, h._$_event$_ = e, h._$_actIndex$_ = n;
            for (const t of s.sm) {
                const s = i._$GetObjectClassBySID$_(t);
                s && h._$_solModifiers$_.push(s);
            }
            if (Array.isArray(s.dsm)) for (const t of s.dsm) {
                const s = i._$GetObjectClassBySID$_(t);
                s && (h._$_dynamicSolModifiers$_ || (h._$_dynamicSolModifiers$_ = new Set), h._$_dynamicSolModifiers$_.add(s));
            }
            for (const [e, n] of Object.entries(s.sols)) {
                const s = parseInt(e, 10), r = i._$GetObjectClassBySID$_(s);
                if (!r) continue;
                const o = cM._$New$_(cM._$SolState$_, null);
                o._$_LoadFromJson$_(t, n), h._$_sols$_.set(r, o);
            }
            if ("instance-signals" === h._$_type$_) {
                h._$_pendingInstances$_ = new Set;
                for (const t of s.pi) {
                    const s = i._$GetInstanceByUID$_(t);
                    s && h._$_pendingInstances$_.add(s);
                }
            }
            return h;
        }
    };
}

{
    const fM = self._$C3$_;
    fM._$SolState$_ = class extends fM._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_objectClass$_ = null, this._$_isSelectAll$_ = !0, this._$_instances$_ = [], 
            t && (this._$_objectClass$_ = t._$GetObjectClass$_(), this._$_isSelectAll$_ = t._$IsSelectAll$_(), 
            fM._$shallowAssignArray$_(this._$_instances$_, t._$_GetOwnInstances$_()));
        }
        _$Release$_() {
            this._$_objectClass$_ = null, fM._$clearArray$_(this._$_instances$_);
        }
        _$_Restore$_(t) {
            t._$_SetSelectAll$_(this._$_isSelectAll$_), fM._$shallowAssignArray$_(t._$_GetOwnInstances$_(), this._$_instances$_);
        }
        _$RemoveInstances$_(t) {
            fM._$arrayRemoveAllInSet$_(this._$_instances$_, t);
        }
        _$_SaveToJson$_() {
            return {
                sa: this._$_isSelectAll$_,
                insts: this._$_instances$_.map((t => t._$GetUID$_()))
            };
        }
        _$_LoadFromJson$_(t, s) {
            const i = t._$GetRuntime$_();
            this._$_isSelectAll$_ = !!s.sa, fM._$clearArray$_(this._$_instances$_);
            for (const t of s.insts) {
                const s = i._$GetInstanceByUID$_(t);
                s && this._$_instances$_.push(s);
            }
        }
    };
}

{
    let dM = function(t, s) {
        let i = t.get(s);
        return i || (i = new Map, t.set(s, i)), i;
    };
    0;
    const pM = self._$C3$_;
    pM._$SDKPluginBase$_ = class extends pM._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_runtime$_ = t.runtime, this._$_id$_ = t.id, this._$_name$_ = t.name ?? "", 
            this._$_isSingleGlobal$_ = !!t._$isSingleGlobal$_, this._$_isWorldType$_ = !!t._$isWorld$_, 
            this._$_isRotatable$_ = !!t._$isRotatable$_, this._$_mustPredraw$_ = !!t._$mustPredraw$_, 
            this._$_hasEffects$_ = !!t._$hasEffects$_, this._$_supportsSceneGraph$_ = !!t._$supportsSceneGraph$_, 
            this._$_supportsMesh$_ = !!t._$supportsMesh$_, this._$_isHTMLElementType$_ = !!t._$isHTMLElementType$_, 
            this._$_is3d$_ = !!t._$is3d$_, this._$_sdkVersion$_ = t._$sdkVersion$_, this._$_singleGlobalObjectClass$_ = null, 
            this._$_boundACEMethodCache$_ = new Map, this._$_boundACEMethodCache_1param$_ = new Map, 
            this._$_boundACEMethodCache_2params$_ = new Map, this._$_boundACEMethodCache_3params$_ = new Map, 
            this._$_scriptInterfaceClass$_ = t._$scriptInterfaceClass$_, this._$_iPlugin$_ = null;
        }
        _$Release$_() {
            this._$_runtime$_ = null;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetID$_() {
            return this._$_id$_;
        }
        _$GetName$_() {
            return this._$_name$_;
        }
        _$OnCreate$_() {}
        _$GetConstructor$_() {
            return this._$GetSdkVersion$_() >= 2 ? this._$_iPlugin$_.constructor : this.constructor;
        }
        _$GetSdkVersion$_() {
            return this._$_sdkVersion$_;
        }
        _$GetScriptInterfaceClass$_(t = !1) {
            let s = this._$_scriptInterfaceClass$_;
            return t && "function" != typeof s && this._$GetSdkVersion$_() >= 2 && (s = globalThis._$ISDKPluginBase$_), 
            s;
        }
        _$IsSingleGlobal$_() {
            return this._$_isSingleGlobal$_;
        }
        _$IsWorldType$_() {
            return this._$_isWorldType$_;
        }
        _$IsHTMLElementType$_() {
            return this._$_isHTMLElementType$_;
        }
        _$Is3D$_() {
            return this._$_is3d$_;
        }
        _$IsRotatable$_() {
            return this._$_isRotatable$_;
        }
        _$MustPreDraw$_() {
            return this._$_mustPredraw$_;
        }
        _$HasEffects$_() {
            return this._$_hasEffects$_;
        }
        _$SupportsSceneGraph$_() {
            return this._$_supportsSceneGraph$_;
        }
        _$SupportsMesh$_() {
            return this._$_supportsMesh$_;
        }
        _$_GetBoundACEMethod$_(t, s) {
            if (!s) throw new Error("missing 'this' binding");
            let i = this._$_boundACEMethodCache$_.get(t);
            return i || (i = t.bind(s), this._$_boundACEMethodCache$_.set(t, i), i);
        }
        _$_GetBoundACEMethod_1param$_(t, s, i) {
            if (!s) throw new Error("missing 'this' binding");
            const e = dM(this._$_boundACEMethodCache_1param$_, t);
            let n = e.get(i);
            return n || (n = t.bind(s, i), e.set(i, n), n);
        }
        _$_GetBoundACEMethod_2params$_(t, s, i, e) {
            if (!s) throw new Error("missing 'this' binding");
            const n = dM(this._$_boundACEMethodCache_2params$_, t), h = dM(n, i);
            let r = h.get(e);
            return r || (r = t.bind(s, i, e), h.set(e, r), r);
        }
        _$_GetBoundACEMethod_3params$_(t, s, i, e, n) {
            if (!s) throw new Error("missing 'this' binding");
            const h = dM(this._$_boundACEMethodCache_3params$_, t), r = dM(h, i), o = dM(r, e);
            let a = o.get(n);
            return a || (a = t.bind(s, i, e, n), o.set(n, a), a);
        }
        _$_SetSingleGlobalObjectClass$_(t) {
            if (!this._$IsSingleGlobal$_()) throw new Error("must be single-global plugin");
            this._$_singleGlobalObjectClass$_ = t;
        }
        _$GetSingleGlobalObjectClass$_() {
            if (!this._$IsSingleGlobal$_()) throw new Error("must be single-global plugin");
            return this._$_singleGlobalObjectClass$_;
        }
        _$GetSingleGlobalInstance$_() {
            if (!this._$IsSingleGlobal$_()) throw new Error("must be single-global plugin");
            return this._$_singleGlobalObjectClass$_._$GetSingleGlobalInstance$_();
        }
        _$_InitScriptInterface$_() {
            const t = this._$GetSdkVersion$_();
            pM._$AddonManager$_._$_PushInitObject$_(this, t);
            const s = this._$GetScriptInterfaceClass$_(!0);
            if (s) {
                if (this._$_iPlugin$_ = new s, !(this._$_iPlugin$_ instanceof self._$IPlugin$_)) throw new TypeError("plugin class must derive from IPlugin");
            } else this._$_iPlugin$_ = new self._$IPlugin$_;
            pM._$AddonManager$_._$_PopInitObject$_(t);
        }
        _$GetIPlugin$_() {
            return this._$_iPlugin$_;
        }
    };
}

{
    const mM = self._$C3$_;
    mM._$SDKDOMPluginBase$_ = class extends mM._$SDKPluginBase$_ {
        constructor(t, s) {
            super(t), this._$_domComponentId$_ = s, this._$_nextElementId$_ = 0, this._$_instMap$_ = new Map, 
            this._$AddElementMessageHandler$_("elem-focused", (t => t._$_OnElemFocused$_())), 
            this._$AddElementMessageHandler$_("elem-blurred", (t => {
                t && t._$_OnElemBlurred$_();
            }));
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$_AddElement$_(t) {
            const s = this._$_nextElementId$_++;
            return this._$_instMap$_.set(s, t), s;
        }
        _$_RemoveElement$_(t) {
            this._$_instMap$_.delete(t);
        }
        _$AddElementMessageHandler$_(t, s) {
            this._$_runtime$_._$AddDOMComponentMessageHandler$_(this._$_domComponentId$_, t, (t => {
                const i = this._$_instMap$_.get(t.elementId);
                s(i, t);
            }));
        }
    };
}

{
    const gM = self._$C3$_;
    gM._$SDKTypeBase$_ = class extends gM._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_objectClass$_ = t, this._$_runtime$_ = t._$GetRuntime$_(), this._$_plugin$_ = t._$GetPlugin$_();
        }
        _$Release$_() {
            this._$_objectClass$_ = null, this._$_runtime$_ = null, this._$_plugin$_ = null;
        }
        _$GetObjectClass$_() {
            return this._$_objectClass$_;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetPlugin$_() {
            return this._$_plugin$_;
        }
        _$GetImageInfo$_() {
            return this._$_objectClass$_._$GetImageInfo$_();
        }
        _$OnCreate$_() {}
        _$FinishCondition$_(t) {}
        _$BeforeRunAction$_(t) {}
        _$AfterRunAction$_(t) {}
        _$LoadTextures$_(t) {}
        _$ReleaseTextures$_() {}
        _$OnDynamicTextureLoadComplete$_() {}
        _$PreloadTexturesWithInstances$_(t) {}
        _$LoadTilemapData$_() {}
        _$GetScriptInterfaceClass$_() {
            return null;
        }
        _$DispatchScriptEvent$_(t, s, i) {
            const e = gM._$New$_(gM.Event, t, s);
            e._$objectClass$_ = this, i && Object.assign(e, i), this._$GetObjectClass$_()._$DispatchUserScriptEvent$_(e);
        }
    };
}

{
    const yM = self._$C3$_;
    yM._$SDKInstanceBase$_ = class extends yM._$DefendedBase$_ {
        constructor(t, s) {
            super(), this._$_inst$_ = t, this._$_domComponentId$_ = s, this._$_wrapperComponentId$_ = null, 
            this._$_runtime$_ = t._$GetRuntime$_(), this._$_objectClass$_ = this._$_inst$_._$GetObjectClass$_(), 
            this._$_sdkType$_ = this._$_objectClass$_._$GetSdkType$_(), this._$_tickFunc$_ = null, 
            this._$_tick2Func$_ = null, this._$_isTicking$_ = !1, this._$_isTicking2$_ = !1, 
            this._$_disposables$_ = null, this._$_wasReleased$_ = !1;
        }
        _$Release$_() {
            this._$_wasReleased$_ = !0, this._$_StopTicking$_(), this._$_StopTicking2$_(), this._$_tickFunc$_ = null, 
            this._$_tick2Func$_ = null, this._$_disposables$_ && (this._$_disposables$_._$Release$_(), 
            this._$_disposables$_ = null), this._$_inst$_ = null, this._$_runtime$_ = null, 
            this._$_objectClass$_ = null, this._$_sdkType$_ = null;
        }
        _$WasReleased$_() {
            return this._$_wasReleased$_;
        }
        _$GetInstance$_() {
            return this._$_inst$_;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetObjectClass$_() {
            return this._$_objectClass$_;
        }
        _$GetPlugin$_() {
            return this._$_sdkType$_._$GetPlugin$_();
        }
        _$GetSdkType$_() {
            return this._$_sdkType$_;
        }
        _$GetScriptInterface$_() {
            return this._$_inst$_._$GetInterfaceClass$_();
        }
        _$Trigger$_(t) {
            return this._$_runtime$_._$Trigger$_(t, this._$_inst$_, null);
        }
        _$DebugTrigger$_(t) {
            return this._$_runtime$_._$DebugTrigger$_(t, this._$_inst$_, null);
        }
        _$TriggerAsync$_(t) {
            return this._$_runtime$_._$TriggerAsync$_(t, this._$_inst$_, null);
        }
        _$FastTrigger$_(t, s) {
            return this._$_runtime$_._$FastTrigger$_(t, this._$_inst$_, s);
        }
        _$DebugFastTrigger$_(t, s) {
            return this._$_runtime$_._$DebugFastTrigger$_(t, this._$_inst$_, s);
        }
        _$ScheduleTriggers$_(t) {
            return this._$_runtime$_._$ScheduleTriggers$_(t);
        }
        _$AddDOMMessageHandler$_(t, s) {
            this._$_runtime$_._$AddDOMComponentMessageHandler$_(this._$_domComponentId$_, t, s);
        }
        _$AddDOMMessageHandlers$_(t) {
            for (const [s, i] of t) this._$AddDOMMessageHandler$_(s, i);
        }
        _$PostToDOM$_(t, s) {
            this._$_runtime$_._$PostComponentMessageToDOM$_(this._$_domComponentId$_, t, s);
        }
        _$PostToDOMAsync$_(t, s) {
            return this._$_runtime$_._$PostComponentMessageToDOMAsync$_(this._$_domComponentId$_, t, s);
        }
        _$_PostToDOMMaybeSync$_(t, s) {
            if (!this._$_runtime$_._$IsInWorker$_()) return window.c3_runtimeInterface._OnMessageFromRuntime({
                type: "event",
                component: this._$_domComponentId$_,
                handler: t,
                data: s,
                responseId: null
            });
            this._$PostToDOM$_(t, s);
        }
        _$SetWrapperExtensionComponentId$_(t) {
            if (!t) throw new Error("cannot set empty component id");
            this._$_wrapperComponentId$_ = t;
        }
        _$IsWrapperExtensionAvailable$_() {
            if (!this._$_wrapperComponentId$_) throw new Error("wrapper extension component id not set");
            return this._$_runtime$_._$HasWrapperComponentId$_(this._$_wrapperComponentId$_);
        }
        _$AddWrapperExtensionMessageHandler$_(t, s) {
            if (!this._$_wrapperComponentId$_) throw new Error("wrapper extension component id not set");
            this._$_runtime$_._$AddWrapperExtensionMessageHandler$_(this._$_wrapperComponentId$_, t, s);
        }
        _$AddWrapperExtensionMessageHandlers$_(t) {
            for (const [s, i] of t) this._$AddWrapperExtensionMessageHandler$_(s, i);
        }
        _$SendWrapperExtensionMessage$_(t, s) {
            if (!this._$_wrapperComponentId$_) throw new Error("wrapper extension component id not set");
            this._$_runtime$_._$SendWrapperExtensionMessage$_(this._$_wrapperComponentId$_, t, s);
        }
        _$SendWrapperExtensionMessageAsync$_(t, s) {
            if (!this._$_wrapperComponentId$_) throw new Error("wrapper extension component id not set");
            return this._$_runtime$_._$SendWrapperExtensionMessageAsync$_(this._$_wrapperComponentId$_, t, s);
        }
        _$Tick$_() {}
        _$Tick2$_() {}
        _$_StartTicking$_() {
            if (!this._$_isTicking$_) {
                if (!this._$_tickFunc$_) if (this._$_runtime$_._$IsDebug$_()) {
                    const t = globalThis._$C3Debugger$_, s = this._$GetPlugin$_();
                    this._$_tickFunc$_ = () => {
                        const i = performance.now();
                        this._$Tick$_(), t._$AddIndividualPluginTickTime$_(s, performance.now() - i);
                    };
                } else this._$_tickFunc$_ = () => this._$Tick$_();
                this._$_runtime$_._$Dispatcher$_().addEventListener("tick", this._$_tickFunc$_), 
                this._$_isTicking$_ = !0;
            }
        }
        _$_StopTicking$_() {
            this._$_isTicking$_ && (this._$_runtime$_._$Dispatcher$_().removeEventListener("tick", this._$_tickFunc$_), 
            this._$_isTicking$_ = !1);
        }
        _$IsTicking$_() {
            return this._$_isTicking$_;
        }
        _$_StartTicking2$_() {
            if (!this._$_isTicking2$_) {
                if (!this._$_tick2Func$_) if (this._$_runtime$_._$IsDebug$_()) {
                    const t = globalThis._$C3Debugger$_, s = this._$GetPlugin$_();
                    this._$_tick2Func$_ = () => {
                        const i = performance.now();
                        this._$Tick2$_(), t._$AddIndividualPluginTickTime$_(s, performance.now() - i);
                    };
                } else this._$_tick2Func$_ = () => this._$Tick2$_();
                this._$_runtime$_._$Dispatcher$_().addEventListener("tick2", this._$_tick2Func$_), 
                this._$_isTicking2$_ = !0;
            }
        }
        _$_StopTicking2$_() {
            this._$_isTicking2$_ && (this._$_runtime$_._$Dispatcher$_().removeEventListener("tick2", this._$_tick2Func$_), 
            this._$_isTicking2$_ = !1);
        }
        _$IsTicking2$_() {
            return this._$_isTicking2$_;
        }
        _$GetDebuggerProperties$_() {
            return [];
        }
        _$SaveToJson$_() {
            return null;
        }
        _$LoadFromJson$_(t) {}
        _$GetPropertyValueByIndex$_(t) {}
        _$SetPropertyValueByIndex$_(t, s) {}
        _$OffsetPropertyValueByIndex$_(t, s, i) {
            if (0 === s) return;
            const e = this._$GetPropertyValueByIndex$_(t);
            if ("number" != typeof e) throw new Error("expected number");
            this._$SetPropertyValueByIndex$_(t, e + s, i);
        }
        _$SetPropertyColorOffsetValueByIndex$_(t, s, i, e) {}
        _$CallAction$_(t, ...s) {
            t.call(this, ...s);
        }
        _$CallExpression$_(t, ...s) {
            return t.call(this, ...s);
        }
        _$GetScriptInterfaceClass$_() {
            return null;
        }
        _$DispatchScriptEvent$_(t, s, i) {
            if (!this._$_inst$_._$HasScriptInterface$_()) return;
            const e = this._$GetScriptInterface$_(), n = yM._$New$_(yM.Event, t, s);
            n._$instance$_ = e, i && Object.assign(n, i), e.dispatchEvent(n);
        }
        _$MustPreDraw$_() {
            return !1;
        }
    };
}

{
    const MM = self._$C3$_;
    MM._$SDKWorldInstanceBase$_ = class extends MM._$SDKInstanceBase$_ {
        constructor(t, s) {
            super(t, s), this._$_worldInfo$_ = t._$GetWorldInfo$_(), this._$_renderercontextlost_handler$_ = null, 
            this._$_renderercontextrestored_handler$_ = null;
        }
        _$Release$_() {
            if (this._$_renderercontextlost_handler$_) {
                const t = this._$_runtime$_._$Dispatcher$_();
                t.removeEventListener("renderercontextlost", this._$_renderercontextlost_handler$_), 
                t.removeEventListener("renderercontextrestored", this._$_renderercontextrestored_handler$_), 
                this._$_renderercontextlost_handler$_ = null, this._$_renderercontextrestored_handler$_ = null;
            }
            this._$_worldInfo$_ = null, super._$Release$_();
        }
        _$HandleWebGLContextLoss$_() {
            this._$HandleRendererContextLoss$_();
        }
        _$OnWebGLContextLost$_() {}
        _$OnWebGLContextRestored$_() {}
        _$HandleRendererContextLoss$_() {
            if (this._$_renderercontextlost_handler$_) return;
            this._$_renderercontextlost_handler$_ = () => this._$OnRendererContextLost$_(), 
            this._$_renderercontextrestored_handler$_ = () => this._$OnRendererContextRestored$_();
            const t = this._$_runtime$_._$Dispatcher$_();
            t.addEventListener("renderercontextlost", this._$_renderercontextlost_handler$_), 
            t.addEventListener("renderercontextrestored", this._$_renderercontextrestored_handler$_);
        }
        _$OnRendererContextLost$_() {
            this._$OnWebGLContextLost$_();
        }
        _$OnRendererContextRestored$_() {
            this._$OnWebGLContextRestored$_();
        }
        _$GetWorldInfo$_() {
            return this._$_worldInfo$_;
        }
        _$IsOriginalSizeKnown$_() {
            return !1;
        }
        _$GetOriginalWidth$_() {
            if (!this._$IsOriginalSizeKnown$_()) throw new Error("original size not known");
            const t = this._$GetCurrentImageInfo$_();
            if (t) return t._$GetWidth$_();
        }
        _$GetOriginalHeight$_() {
            if (!this._$IsOriginalSizeKnown$_()) throw new Error("original size not known");
            const t = this._$GetCurrentImageInfo$_();
            if (t) return t._$GetHeight$_();
        }
        _$GetCurrentImageInfo$_() {
            return null;
        }
        _$GetCurrentSurfaceSize$_() {
            const t = this._$GetCurrentImageInfo$_();
            if (t) {
                const s = t._$GetTexture$_();
                if (s) return [ s._$GetWidth$_(), s._$GetHeight$_() ];
            }
            return [ 100, 100 ];
        }
        _$GetCurrentTexRect$_() {
            const t = this._$GetCurrentImageInfo$_();
            return t ? t._$GetTexRect$_() : null;
        }
        _$GetCurrentTexQuad$_() {
            const t = this._$GetCurrentImageInfo$_();
            return t ? t._$GetTexQuad$_() : null;
        }
        _$IsCurrentTexRotated$_() {
            const t = this._$GetCurrentImageInfo$_();
            return !!t && t._$IsRotated$_();
        }
        _$GetImagePoint$_(t) {
            const s = this._$_inst$_._$GetWorldInfo$_();
            return [ s._$GetX$_(), s._$GetY$_(), s._$GetTotalZElevation$_() ];
        }
        _$LoadTilemapData$_(t, s, i) {}
        _$TestPointOverlapTile$_(t, s) {}
        _$RendersToOwnZPlane$_() {
            return !0;
        }
    };
}

{
    const wM = self._$C3$_, SM = wM._$New$_(wM.Rect);
    wM._$SDKDOMInstanceBase$_ = class extends wM._$SDKWorldInstanceBase$_ {
        constructor(t, s) {
            super(t, s), this._$_elementId$_ = this._$GetPlugin$_()._$_AddElement$_(this), this._$_isElementShowing$_ = !0, 
            this._$_elemHasFocus$_ = !1, this._$_autoFontSize$_ = !1, this._$_autoFontSizeOffset$_ = -.2, 
            this._$_lastRect$_ = wM._$New$_(wM.Rect, 0, 0, -1, -1);
            const i = this._$_runtime$_._$GetCanvasManager$_();
            this._$_lastWindowWidth$_ = i._$GetLastWidth$_(), this._$_lastWindowHeight$_ = i._$GetLastHeight$_(), 
            this._$_lastHTMLIndex$_ = -1, this._$_lastHTMLZIndex$_ = -1, this._$_isPendingUpdateState$_ = !1, 
            this._$_StartTicking$_();
        }
        _$Release$_() {
            this._$GetPlugin$_()._$_RemoveElement$_(this._$_elementId$_), this._$PostToDOMElement$_("destroy"), 
            this._$_elementId$_ = -1, super._$Release$_();
        }
        _$_GetElementInDOMMode$_() {
            if (this._$_runtime$_._$IsInWorker$_()) throw new Error("not valid in worker mode");
            return this._$_PostToDOMElementMaybeSync$_("get-element");
        }
        _$PostToDOMElement$_(t, s) {
            s || (s = {}), s.elementId = this._$_elementId$_, this._$PostToDOM$_(t, s);
        }
        _$_PostToDOMElementMaybeSync$_(t, s) {
            return s || (s = {}), s.elementId = this._$_elementId$_, this._$_PostToDOMMaybeSync$_(t, s);
        }
        _$PostToDOMElementAsync$_(t, s) {
            return s || (s = {}), s.elementId = this._$_elementId$_, this._$PostToDOMAsync$_(t, s);
        }
        _$CreateElement$_(t) {
            t || (t = {});
            const s = this._$GetWorldInfo$_();
            t.elementId = this._$_elementId$_, t.isVisible = s._$IsVisible$_(), t.htmlIndex = s._$GetLayer$_()._$GetHTMLIndex$_(), 
            t.htmlZIndex = s._$GetHTMLZIndex$_(), Object.assign(t, this._$GetElementState$_()), 
            this._$_isElementShowing$_ = !!t.isVisible, this._$_PostToDOMMaybeSync$_("create", t), 
            this._$_UpdatePosition$_(!0);
        }
        _$SetElementVisible$_(t) {
            t = !!t, this._$_isElementShowing$_ !== t && (this._$_isElementShowing$_ = t, this._$PostToDOMElement$_("set-visible", {
                isVisible: t
            }));
        }
        _$Tick$_() {
            this._$_UpdatePosition$_(!1);
        }
        _$_ShouldPreserveElement$_() {
            const t = this._$_runtime$_._$GetCanvasManager$_()._$GetFullscreenMode$_();
            return "Android" === wM._$Platform$_._$OS$_ && ("scale-inner" === t || "scale-outer" === t || "crop" === t);
        }
        _$_UpdatePosition$_(t) {
            if (this._$GetInstance$_()._$IsDestroyed$_()) return;
            const s = this._$GetWorldInfo$_(), i = s._$GetLayer$_(), e = s._$GetBoundingBox$_();
            let [n, h] = i._$LayerToCanvasCss$_(e._$getLeft$_(), e._$getTop$_()), [r, o] = i._$LayerToCanvasCss$_(e._$getRight$_(), e._$getBottom$_());
            const a = this._$_runtime$_._$GetCanvasManager$_(), u = a._$GetCssWidth$_(), l = a._$GetCssHeight$_();
            if (!s._$IsVisible$_() || !i._$IsVisible$_()) return void this._$SetElementVisible$_(!1);
            if (!this._$_ShouldPreserveElement$_() && (r <= 0 || o <= 0 || n >= u || h >= l)) return void this._$SetElementVisible$_(!1);
            SM.set(n, h, r, o);
            const c = a._$GetLastWidth$_(), f = a._$GetLastHeight$_(), d = i._$GetHTMLIndex$_(), p = s._$GetHTMLZIndex$_();
            if (!t && SM.equals(this._$_lastRect$_) && this._$_lastWindowWidth$_ === c && this._$_lastWindowHeight$_ === f && this._$_lastHTMLIndex$_ === d && this._$_lastHTMLZIndex$_ === p) return void this._$SetElementVisible$_(!0);
            this._$_lastRect$_._$copy$_(SM), this._$_lastWindowWidth$_ = c, this._$_lastWindowHeight$_ = f, 
            this._$_lastHTMLIndex$_ = d, this._$_lastHTMLZIndex$_ = p, this._$SetElementVisible$_(!0);
            let m = null;
            this._$_autoFontSize$_ && (m = i._$GetDisplayScale$_() + this._$_autoFontSizeOffset$_), 
            this._$PostToDOMElement$_("update-position", {
                left: Math.round(this._$_lastRect$_._$getLeft$_()),
                top: Math.round(this._$_lastRect$_._$getTop$_()),
                width: Math.round(this._$_lastRect$_.width()),
                height: Math.round(this._$_lastRect$_.height()),
                htmlIndex: d,
                htmlZIndex: p,
                fontSize: m
            });
        }
        _$FocusElement$_() {
            this._$_PostToDOMElementMaybeSync$_("focus", {
                focus: !0
            });
        }
        _$BlurElement$_() {
            this._$_PostToDOMElementMaybeSync$_("focus", {
                focus: !1
            });
        }
        _$_OnElemFocused$_() {
            this._$_elemHasFocus$_ = !0;
        }
        _$_OnElemBlurred$_() {
            this._$_elemHasFocus$_ = !1;
        }
        _$IsElementFocused$_() {
            return this._$_elemHasFocus$_;
        }
        _$SetElementCSSStyle$_(t, s) {
            this._$PostToDOMElement$_("set-css-style", {
                prop: wM._$CSSToCamelCase$_(t),
                val: s
            });
        }
        _$SetElementAttribute$_(t, s) {
            this._$PostToDOMElement$_("set-attribute", {
                name: t,
                val: s
            });
        }
        _$RemoveElementAttribute$_(t) {
            this._$PostToDOMElement$_("remove-attribute", {
                name: t
            });
        }
        _$UpdateElementState$_() {
            this._$_isPendingUpdateState$_ || (this._$_isPendingUpdateState$_ = !0, Promise.resolve().then((() => {
                this._$_isPendingUpdateState$_ = !1, this._$PostToDOMElement$_("update-state", this._$GetElementState$_());
            })));
        }
        _$GetElementState$_() {}
        _$GetElementId$_() {
            return this._$_elementId$_;
        }
    };
}

{
    const bM = self._$C3$_, TM = self._$IBehavior$_;
    bM._$SDKBehaviorBase$_ = class extends bM._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_runtime$_ = t.runtime, this._$_id$_ = t.id, this._$_name$_ = t.name ?? "", 
            this._$_myObjectClasses$_ = bM._$New$_(bM._$ArraySet$_), this._$_myInstances$_ = bM._$New$_(bM._$ArraySet$_), 
            this._$_sdkVersion$_ = t._$sdkVersion$_, this._$_scriptInterfaceClass$_ = t._$scriptInterfaceClass$_, 
            this._$_iBehavior$_ = null;
        }
        _$Release$_() {
            this._$_myInstances$_._$Release$_(), this._$_myObjectClasses$_._$Release$_(), this._$_runtime$_ = null;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetID$_() {
            return this._$_id$_;
        }
        _$GetName$_() {
            return this._$_name$_;
        }
        _$OnCreate$_() {}
        _$GetSdkVersion$_() {
            return this._$_sdkVersion$_;
        }
        _$GetScriptInterfaceClass$_(t = !1) {
            let s = this._$_scriptInterfaceClass$_;
            return t && "function" != typeof s && this._$GetSdkVersion$_() >= 2 && (s = globalThis._$ISDKBehaviorBase$_), 
            s;
        }
        _$_AddObjectClass$_(t) {
            this._$_myObjectClasses$_._$Add$_(t);
        }
        _$GetObjectClasses$_() {
            return this._$_myObjectClasses$_._$GetArray$_();
        }
        _$_AddInstance$_(t) {
            this._$_myInstances$_._$Add$_(t);
        }
        _$_RemoveInstance$_(t) {
            this._$_myInstances$_._$Delete$_(t);
        }
        _$GetInstances$_() {
            return this._$_myInstances$_._$GetArray$_();
        }
        _$_InitScriptInterface$_() {
            const t = this._$GetSdkVersion$_();
            bM._$AddonManager$_._$_PushInitObject$_(this, t);
            const s = this._$GetScriptInterfaceClass$_(!0);
            if (s) {
                if (this._$_iBehavior$_ = new s, !(this._$_iBehavior$_ instanceof TM)) throw new TypeError("behavior class must derive from IBehavior");
            } else this._$_iBehavior$_ = new TM;
            bM._$AddonManager$_._$_PopInitObject$_(t);
        }
        _$GetIBehavior$_() {
            return this._$_iBehavior$_;
        }
    };
}

{
    const vM = self._$C3$_;
    vM._$SDKBehaviorTypeBase$_ = class extends vM._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_runtime$_ = t._$GetRuntime$_(), this._$_behaviorType$_ = t, this._$_objectClass$_ = t._$GetObjectClass$_(), 
            this._$_behavior$_ = t._$GetBehavior$_(), this._$_behavior$_._$_AddObjectClass$_(this._$_objectClass$_);
        }
        _$Release$_() {
            this._$_runtime$_ = null, this._$_behaviorType$_ = null, this._$_objectClass$_ = null, 
            this._$_behavior$_ = null;
        }
        _$OnCreate$_() {}
        _$GetBehaviorType$_() {
            return this._$_behaviorType$_;
        }
        _$GetObjectClass$_() {
            return this._$_objectClass$_;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetBehavior$_() {
            return this._$_behavior$_;
        }
    };
}

{
    const xM = self._$C3$_;
    xM._$SDKBehaviorInstanceBase$_ = class extends xM._$DefendedBase$_ {
        constructor(t, s) {
            super(), this._$_behInst$_ = t, this._$_domComponentId$_ = s, this._$_inst$_ = t._$GetObjectInstance$_(), 
            this._$_runtime$_ = t._$GetRuntime$_(), this._$_behaviorType$_ = t._$GetBehaviorType$_(), 
            this._$_sdkType$_ = this._$_behaviorType$_._$GetSdkType$_(), this._$_isTicking$_ = !1, 
            this._$_isTicking2$_ = !1, this._$_isPostTicking$_ = !1, this._$_disposables$_ = null;
        }
        _$Release$_() {
            this._$_StopTicking$_(), this._$_StopTicking2$_(), this._$_StopPostTicking$_(), 
            this._$_disposables$_ && (this._$_disposables$_._$Release$_(), this._$_disposables$_ = null), 
            this._$_behInst$_ = null, this._$_inst$_ = null, this._$_runtime$_ = null, this._$_behaviorType$_ = null, 
            this._$_sdkType$_ = null;
        }
        _$GetBehavior$_() {
            return this._$_behaviorType$_._$GetBehavior$_();
        }
        _$GetBehaviorInstance$_() {
            return this._$_behInst$_;
        }
        _$GetObjectInstance$_() {
            return this._$_inst$_;
        }
        _$GetObjectClass$_() {
            return this._$_inst$_._$GetObjectClass$_();
        }
        _$GetWorldInfo$_() {
            return this._$_inst$_._$GetWorldInfo$_();
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetBehaviorType$_() {
            return this._$_behaviorType$_;
        }
        _$GetSdkType$_() {
            return this._$_sdkType$_;
        }
        _$GetScriptInterface$_() {
            return this._$_behInst$_._$GetScriptInterface$_();
        }
        _$Trigger$_(t) {
            return this._$_runtime$_._$Trigger$_(t, this._$_inst$_, this._$_behaviorType$_);
        }
        _$DebugTrigger$_(t) {
            return this._$_runtime$_._$DebugTrigger$_(t, this._$_inst$_, this._$_behaviorType$_);
        }
        _$TriggerAsync$_(t) {
            return this._$_runtime$_._$TriggerAsync$_(t, this._$_inst$_, this._$_behaviorType$_);
        }
        _$PostCreate$_() {}
        _$Tick$_() {}
        _$Tick2$_() {}
        _$PostTick$_() {}
        _$_StartTicking$_() {
            this._$_isTicking$_ || (this._$_runtime$_._$_AddBehInstToTick$_(this), this._$_isTicking$_ = !0);
        }
        _$_StopTicking$_() {
            this._$_isTicking$_ && (this._$_runtime$_._$_RemoveBehInstToTick$_(this), this._$_isTicking$_ = !1);
        }
        _$IsTicking$_() {
            return this._$_isTicking$_;
        }
        _$_StartTicking2$_() {
            this._$_isTicking2$_ || (this._$_runtime$_._$_AddBehInstToTick2$_(this), this._$_isTicking2$_ = !0);
        }
        _$_StopTicking2$_() {
            this._$_isTicking2$_ && (this._$_runtime$_._$_RemoveBehInstToTick2$_(this), this._$_isTicking2$_ = !1);
        }
        _$IsTicking2$_() {
            return this._$_isTicking2$_;
        }
        _$_StartPostTicking$_() {
            this._$_isPostTicking$_ || (this._$_runtime$_._$_AddBehInstToPostTick$_(this), this._$_isPostTicking$_ = !0);
        }
        _$_StopPostTicking$_() {
            this._$_isPostTicking$_ && (this._$_runtime$_._$_RemoveBehInstToPostTick$_(this), 
            this._$_isPostTicking$_ = !1);
        }
        _$IsPostTicking$_() {
            return this._$_isPostTicking$_;
        }
        _$GetDebuggerProperties$_() {
            return [];
        }
        _$AddDOMMessageHandler$_(t, s) {
            this._$_runtime$_._$AddDOMComponentMessageHandler$_(this._$_domComponentId$_, t, s);
        }
        _$OnSpriteFrameChanged$_(t, s) {}
        _$SaveToJson$_() {
            return null;
        }
        _$LoadFromJson$_(t) {}
        _$GetPropertyValueByIndex$_(t) {}
        _$SetPropertyValueByIndex$_(t, s) {}
        _$OffsetPropertyValueByIndex$_(t, s) {
            if (0 === s) return;
            const i = this._$GetPropertyValueByIndex$_(t);
            if ("number" != typeof i) throw new Error("expected number");
            this._$SetPropertyValueByIndex$_(t, i + s);
        }
        _$SetPropertyColorOffsetValueByIndex$_(t, s, i, e) {}
        _$CallAction$_(t, ...s) {
            t.call(this, ...s);
        }
        _$CallExpression$_(t, ...s) {
            return t.call(this, ...s);
        }
        _$GetScriptInterfaceClass$_() {
            return null;
        }
        _$DispatchScriptEvent$_(t, s, i) {
            if (!this._$_behInst$_._$HasScriptInterface$_()) return;
            const e = this._$GetScriptInterface$_(), n = xM._$New$_(xM.Event, t, s);
            n._$behaviorInstance$_ = e, n._$instance$_ = e._$instance$_, i && Object.assign(n, i), 
            e.dispatchEvent(n);
        }
    };
}

{
    let IM = function(t) {
        if (t !== CM) throw new Error("invalid internal API token");
    };
    0;
    const GM = self._$C3$_;
    GM._$Plugins$_ = {}, GM._$Behaviors$_ = {};
    const CM = GM._$_GetInternalAPIToken$_();
    let _M = [], EM = [], DM = [], AM = null, NM = null, LM = null, OM = null;
    const RM = new Map, PM = new Map;
    GM._$AddonManager$_ = class extends GM._$DefendedBase$_ {
        constructor(t, s) {
            super(), this._$_runtime$_ = t, this._$_allPlugins$_ = [], this._$_systemPlugin$_ = null, 
            this._$_allBehaviors$_ = [], this._$_delayCreateBehaviors$_ = new Map, this._$_solidBehavior$_ = null, 
            this._$_jumpthruBehavior$_ = null, this._$_wrapperComponentIds$_ = new Set(s);
        }
        _$CreatePlugin$_(t) {
            const s = t[19], i = this._$_runtime$_._$GetObjectReference$_(t[0]);
            if (!i) throw new Error("missing plugin");
            GM._$AddCommonACEs$_(t, i, s);
            const e = s >= 2 ? GM._$SDKPluginBase$_ : i, n = GM._$New$_(e, {
                runtime: this._$_runtime$_,
                _$isSingleGlobal$_: t[1],
                _$isWorld$_: t[2],
                _$isRotatable$_: t[5],
                _$hasEffects$_: t[8],
                _$mustPredraw$_: t[9],
                _$supportsSceneGraph$_: t[13],
                _$supportsMesh$_: t[14],
                _$isHTMLElementType$_: t[17],
                _$is3d$_: t[18],
                _$sdkVersion$_: s,
                id: t[20],
                name: t[21],
                _$scriptInterfaceClass$_: s >= 2 ? i : null
            });
            n._$OnCreate$_(), this._$_allPlugins$_.push(n), RM.set(i, n);
        }
        _$CreateSystemPlugin$_() {
            this._$_systemPlugin$_ = GM._$New$_(GM._$Plugins$_._$System$_, {
                runtime: this._$_runtime$_,
                _$isSingleGlobal$_: !0
            }), this._$_systemPlugin$_._$OnCreate$_();
        }
        _$CreateBehavior$_(t) {
            const s = t[1], i = t[2], e = t[3], n = this._$_runtime$_._$GetObjectReference$_(t[0]);
            if (!n) throw new Error("missing behavior");
            this._$_delayCreateBehaviors$_.set(n, (() => {
                const t = s >= 2 ? GM._$SDKBehaviorBase$_ : n, h = GM._$New$_(t, {
                    runtime: this._$_runtime$_,
                    id: i,
                    name: e,
                    _$sdkVersion$_: s,
                    _$scriptInterfaceClass$_: s >= 2 ? n : null
                });
                h._$OnCreate$_(), this._$_allBehaviors$_.push(h), PM.set(n, h), !this._$_solidBehavior$_ && GM._$Behaviors$_._$solid$_ && h instanceof GM._$Behaviors$_._$solid$_ ? this._$_solidBehavior$_ = h : !this._$_jumpthruBehavior$_ && GM._$Behaviors$_._$jumpthru$_ && h instanceof GM._$Behaviors$_._$jumpthru$_ && (this._$_jumpthruBehavior$_ = h), 
                h._$_InitScriptInterface$_();
            }));
        }
        _$_DelayCreateBehavior$_(t) {
            const s = this._$_delayCreateBehaviors$_.get(t);
            s && (s(), this._$_delayCreateBehaviors$_.delete(t));
        }
        static _$_PushInitObject$_(t, s = 1) {
            if (GM._$AddonManager$_._$_PushInitObject$_ !== AM) throw new Error("invalid method");
            1 === s && _M.push(t), EM.push(t);
        }
        static _$_PopInitObject$_(t = 1) {
            if (GM._$AddonManager$_._$_PopInitObject$_ !== NM) throw new Error("invalid method");
            1 === t && _M.pop(), EM.pop();
        }
        static _$_GetInitObject$_() {
            if (GM._$AddonManager$_._$_GetInitObject$_ !== LM) throw new Error("invalid method");
            if (0 === _M.length) throw new Error("no init object set");
            return _M.at(-1);
        }
        static _$_GetInitObject2$_(t) {
            if (GM._$AddonManager$_._$_GetInitObject2$_ !== OM) throw new Error("invalid method");
            if (IM(t), 0 === EM.length) throw new Error("no init object set");
            return EM.at(-1);
        }
        static _$_PushInitProperties$_(t) {
            DM.push(t);
        }
        static _$_PopInitProperties$_() {
            DM.pop();
        }
        static _$_GetInitProperties$_() {
            if (0 === DM.length) throw new Error("no init properties set");
            return DM.at(-1);
        }
        _$_InitAddonScriptInterfaces$_() {
            for (const t of this._$_allPlugins$_) t._$_InitScriptInterface$_();
        }
        static _$GetPluginByConstructorFunction$_(t) {
            return RM.get(t) || null;
        }
        static _$GetBehaviorByConstructorFunction$_(t) {
            return PM.get(t) || null;
        }
        _$GetSystemPlugin$_() {
            return this._$_systemPlugin$_;
        }
        _$GetSolidBehavior$_() {
            return this._$_solidBehavior$_;
        }
        _$GetJumpthruBehavior$_() {
            return this._$_jumpthruBehavior$_;
        }
        _$HasWrapperComponentId$_(t) {
            return this._$_wrapperComponentIds$_.has(t);
        }
    }, AM = GM._$AddonManager$_._$_PushInitObject$_, NM = GM._$AddonManager$_._$_PopInitObject$_, 
    LM = GM._$AddonManager$_._$_GetInitObject$_, OM = GM._$AddonManager$_._$_GetInitObject2$_;
}

{
    const kM = self._$C3$_, FM = new Set;
    kM._$ImageInfo$_ = class extends kM._$DefendedBase$_ {
        constructor() {
            super(), this._$_generation$_ = 0, this._$_url$_ = "", this._$_size$_ = 0, this._$_offsetX$_ = 0, 
            this._$_offsetY$_ = 0, this._$_width$_ = 0, this._$_height$_ = 0, this._$_isRotated$_ = !1, 
            this._$_hasMetaData$_ = !1, this._$_imageAsset$_ = null, this._$_textureState$_ = "", 
            this._$_rcTex$_ = kM._$New$_(kM.Rect), this._$_quadTex$_ = kM._$New$_(kM._$Quad$_), 
            this._$_blobUrl$_ = "", this._$_iImageInfo$_ = new self._$IImageInfo$_(this), FM.add(this);
        }
        _$Release$_() {
            this._$ReleaseTexture$_(), this._$_imageAsset$_ && 0 === this._$_imageAsset$_._$GetRefCount$_() && this._$_imageAsset$_._$Release$_(), 
            this._$_imageAsset$_ = null, FM.delete(this), this._$ReleaseBlobURL$_();
        }
        static _$OnRendererContextLost$_() {
            for (const t of FM) t._$_textureState$_ = "", t._$_rcTex$_.set(0, 0, 0, 0), t._$_quadTex$_._$setFromRect$_(t._$_rcTex$_);
        }
        _$LoadData$_(t) {
            this._$_url$_ = t[0], this._$_size$_ = t[1], this._$_offsetX$_ = t[2], this._$_offsetY$_ = t[3], 
            this._$_width$_ = t[4], this._$_height$_ = t[5], this._$_isRotated$_ = t[6], this._$_hasMetaData$_ = !0;
        }
        _$LoadDynamicAsset$_(t, s) {
            if (this._$_imageAsset$_) throw new Error("already loaded asset");
            this._$_url$_ = s;
            const i = {};
            return kM._$IsAbsoluteURL$_(s) && (i._$loadPolicy$_ = "remote"), this._$LoadAsset$_(t, i), 
            this._$_imageAsset$_._$Load$_();
        }
        _$LoadDynamicBlobAsset$_(t, s) {
            if (this._$_imageAsset$_) throw new Error("already loaded asset");
            this._$_url$_ = "", this._$_size$_ = s.size, this._$_imageAsset$_ = kM._$New$_(kM._$ImageAsset$_, t._$GetAssetManager$_(), {
                blob: s,
                size: this._$_size$_,
                _$loadPolicy$_: "local"
            });
        }
        _$ReplaceWith$_(t) {
            if (t === this) throw new Error("cannot replace with self");
            this._$_generation$_++, this._$ReleaseTexture$_(), this._$_url$_ = t._$_url$_, this._$_size$_ = t._$_size$_, 
            this._$_offsetX$_ = t._$_offsetX$_, this._$_offsetY$_ = t._$_offsetY$_, this._$_width$_ = t._$_width$_, 
            this._$_height$_ = t._$_height$_, this._$_isRotated$_ = t._$_isRotated$_, this._$_hasMetaData$_ = t._$_hasMetaData$_, 
            this._$_imageAsset$_ = t._$_imageAsset$_, this._$_textureState$_ = t._$_textureState$_, 
            this._$_rcTex$_ = t._$_rcTex$_, this._$_quadTex$_ = t._$_quadTex$_, this._$ReleaseBlobURL$_();
        }
        _$GetURL$_() {
            return this._$_url$_;
        }
        _$GetSize$_() {
            return this._$_size$_;
        }
        _$GetOffsetX$_() {
            return this._$_offsetX$_;
        }
        _$GetOffsetY$_() {
            return this._$_offsetY$_;
        }
        _$IsRotated$_() {
            return this._$_isRotated$_;
        }
        _$GetWidth$_() {
            return this._$_width$_;
        }
        _$GetHeight$_() {
            return this._$_height$_;
        }
        _$GetSheetWidth$_() {
            return this._$_imageAsset$_._$GetWidth$_();
        }
        _$GetSheetHeight$_() {
            return this._$_imageAsset$_._$GetHeight$_();
        }
        _$LoadAsset$_(t, s) {
            if (this._$_imageAsset$_) throw new Error("already got asset");
            s = Object.assign({}, s, {
                url: this._$GetURL$_(),
                size: this._$GetSize$_()
            }), this._$_imageAsset$_ = t._$LoadImage$_(s);
        }
        _$IsLoaded$_() {
            return this._$_imageAsset$_ && this._$_imageAsset$_._$IsLoaded$_();
        }
        async _$LoadStaticTexture$_(t, s) {
            if (!this._$_imageAsset$_) throw new Error("no asset");
            if (this._$_textureState$_) throw new Error("already loaded texture");
            const i = this._$_generation$_;
            this._$_textureState$_ = "loading";
            const e = await this._$_imageAsset$_._$LoadStaticTexture$_(t, s);
            if (this._$_generation$_ !== i) return null;
            if (!e) return this._$_textureState$_ = "", null;
            this._$_textureState$_ = "loaded", this._$_hasMetaData$_ || (this._$_width$_ = e._$GetWidth$_(), 
            this._$_height$_ = e._$GetHeight$_(), this._$_hasMetaData$_ = !0);
            const n = this._$_isRotated$_ ? this._$_height$_ : this._$_width$_, h = this._$_isRotated$_ ? this._$_width$_ : this._$_height$_;
            return this._$_rcTex$_.set(this._$_offsetX$_, this._$_offsetY$_, this._$_offsetX$_ + n, this._$_offsetY$_ + h), 
            this._$_rcTex$_._$divide$_(e._$GetWidth$_(), e._$GetHeight$_()), this._$_quadTex$_._$setFromRect$_(this._$_rcTex$_), 
            this._$_isRotated$_ && this._$_quadTex$_._$rotatePointsAnticlockwise$_(), e;
        }
        _$ReleaseTexture$_() {
            this._$_textureState$_ && (this._$_imageAsset$_ && this._$_imageAsset$_._$ReleaseTexture$_(), 
            this._$_textureState$_ = "", this._$_rcTex$_.set(0, 0, 0, 0), this._$_quadTex$_._$setFromRect$_(this._$_rcTex$_));
        }
        _$GetTexture$_() {
            return this._$_imageAsset$_ && "loaded" === this._$_textureState$_ ? this._$_imageAsset$_._$GetTexture$_() : null;
        }
        _$GetTexRect$_() {
            return this._$_rcTex$_;
        }
        _$GetTexQuad$_() {
            return this._$_quadTex$_;
        }
        _$GetIImageInfo$_() {
            return this._$_iImageInfo$_;
        }
        _$GetImageAsset$_() {
            return this._$_imageAsset$_;
        }
        async _$ExtractImageToCanvas$_(t) {
            t || (t = await this._$_imageAsset$_._$LoadToDrawable$_());
            const s = kM._$CreateCanvas$_(this._$_width$_, this._$_height$_), i = s.getContext("2d");
            return this._$_isRotated$_ ? (i.rotate(Math.PI / -2), i.translate(-this._$_height$_, 0), 
            i.drawImage(t, this._$_offsetX$_, this._$_offsetY$_, this._$_height$_, this._$_width$_, 0, 0, this._$_height$_, this._$_width$_)) : i.drawImage(t, this._$_offsetX$_, this._$_offsetY$_, this._$_width$_, this._$_height$_, 0, 0, this._$_width$_, this._$_height$_), 
            s;
        }
        async _$ExtractImageToBlobURL$_(t) {
            if (this._$_blobUrl$_) return this._$_blobUrl$_;
            const s = await this._$ExtractImageToCanvas$_(t), i = await kM._$CanvasToBlob$_(s);
            return this._$_blobUrl$_ = URL.createObjectURL(i), this._$_blobUrl$_;
        }
        _$ReleaseBlobURL$_() {
            this._$_blobUrl$_ && (URL.revokeObjectURL(this._$_blobUrl$_), this._$_blobUrl$_ = "");
        }
    };
}

{
    const jM = self._$C3$_;
    jM._$AnimationInfo$_ = class extends jM._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_name$_ = t[0], this._$_speed$_ = t[1], this._$_isLooping$_ = !!t[2], 
            this._$_repeatCount$_ = t[3], this._$_repeatTo$_ = t[4], this._$_isPingPong$_ = !!t[5], 
            this._$_sid$_ = t[6], this._$_frames$_ = t[7].map((t => jM._$New$_(jM._$AnimationFrameInfo$_, t))), 
            this._$_iAnimation$_ = new self._$IAnimation$_(this);
        }
        static _$CreateDynamic$_(t, s) {
            const i = jM._$New$_(jM._$AnimationInfo$_, [ s, 0, !1, 0, 0, !1, Math.floor(1e15 * Math.random()), [] ]);
            return i._$_frames$_.push(jM._$AnimationFrameInfo$_._$CreateDynamic$_(t)), i;
        }
        _$Release$_() {
            for (const t of this._$_frames$_) t._$Release$_();
            jM._$clearArray$_(this._$_frames$_);
        }
        _$LoadAllAssets$_(t) {
            for (const s of this._$_frames$_) s._$GetImageInfo$_()._$LoadAsset$_(t);
        }
        _$LoadAllTextures$_(t, s) {
            return Promise.all(this._$_frames$_.map((i => i._$GetImageInfo$_()._$LoadStaticTexture$_(t, s))));
        }
        _$ReleaseAllTextures$_() {
            for (const t of this._$_frames$_) t._$GetImageInfo$_()._$ReleaseTexture$_();
        }
        _$GetName$_() {
            return this._$_name$_;
        }
        _$GetSID$_() {
            return this._$_sid$_;
        }
        _$GetFrameCount$_() {
            return this._$_frames$_.length;
        }
        _$GetFrames$_() {
            return this._$_frames$_;
        }
        _$GetFrameAt$_(t) {
            if ((t = Math.floor(t)) < 0 || t >= this._$_frames$_.length) throw new RangeError("invalid frame");
            return this._$_frames$_[t];
        }
        _$InsertFrameAt$_(t, s) {
            (s = Math.floor(s)) < 0 ? this._$_frames$_.unshift(t) : s >= this._$_frames$_.length ? this._$_frames$_.push(t) : this._$_frames$_.splice(s, 0, t);
        }
        _$RemoveFrameAt$_(t) {
            if ((t = Math.floor(t)) < 0 || t >= this._$_frames$_.length) throw new RangeError("invalid frame");
            this._$_frames$_[t]._$Release$_(), this._$_frames$_.splice(t, 1);
        }
        _$GetFrameIndexByTag$_(t) {
            for (let s = 0, i = this._$_frames$_.length; s < i; ++s) if (jM._$equalsNoCase$_(this._$_frames$_[s]._$GetTag$_(), t)) return s;
            return -1;
        }
        _$FrameTagOrIndexToIndex$_(t) {
            if ("string" == typeof t) {
                const s = this._$GetFrameIndexByTag$_(t);
                if (-1 === s) throw new Error(`cannot find animation frame with tag ${t}`);
                return s;
            }
            return t;
        }
        _$GetSpeed$_() {
            return this._$_speed$_;
        }
        _$IsLooping$_() {
            return this._$_isLooping$_;
        }
        _$GetRepeatCount$_() {
            return this._$_repeatCount$_;
        }
        _$GetRepeatTo$_() {
            return this._$_repeatTo$_;
        }
        _$IsPingPong$_() {
            return this._$_isPingPong$_;
        }
        _$GetIAnimation$_() {
            return this._$_iAnimation$_;
        }
    };
}

{
    const BM = self._$C3$_, zM = (() => {
        const t = atob("iVBORw0KGgoAAAANSUhEUgAAAGQAAABkAQMAAABKLAcXAAAAAXNSR0IArs4c6QAAAANQTFRFAAAAp3o92gAAAAF0Uk5TAEDm2GYAAAATSURBVBgZYxgFo2AUjIJRQFcAAAV4AAHcRQIbAAAAAElFTkSuQmCC"), s = new Uint8Array(t.length);
        for (let i = 0, e = t.length; i < e; ++i) s[i] = t.charCodeAt(i);
        return new Blob([ s ], {
            type: "image/png"
        });
    })();
    BM._$AnimationFrameInfo$_ = class extends BM._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_imageInfo$_ = BM._$New$_(BM._$ImageInfo$_), this._$_imageInfo$_._$LoadData$_(t), 
            this._$_duration$_ = t[7], this._$_origin$_ = BM._$New$_(BM._$Vector2$_, t[8], t[9]), 
            this._$_imagePoints$_ = t[10].map((t => BM._$New$_(BM._$ImagePoint$_, this, t))), 
            this._$_imagePointsByName$_ = new Map;
            for (const t of this._$_imagePoints$_) this._$_imagePointsByName$_.set(t._$GetName$_().toLowerCase(), t);
            this._$_collisionPoly$_ = null;
            const s = t[11];
            s.length >= 6 && (this._$_collisionPoly$_ = BM._$New$_(BM._$CollisionPoly$_, s)), 
            this._$_tag$_ = t[12] ? t[12] : "", this._$_iAnimationFrame$_ = new self._$IAnimationFrame$_(this);
        }
        static _$CreateDynamic$_(t) {
            const s = BM._$New$_(BM._$AnimationFrameInfo$_, [ "", 0, 0, 0, 100, 100, !1, 1, 0, 0, [], [], "" ]);
            return s._$_imageInfo$_._$LoadDynamicBlobAsset$_(t, zM), s;
        }
        _$Release$_() {
            this._$_collisionPoly$_ && (this._$_collisionPoly$_._$Release$_(), this._$_collisionPoly$_ = null), 
            this._$_imageInfo$_._$Release$_(), this._$_imageInfo$_ = null;
        }
        _$GetImageInfo$_() {
            return this._$_imageInfo$_;
        }
        _$GetDuration$_() {
            return this._$_duration$_;
        }
        _$GetOriginX$_() {
            return this._$_origin$_._$getX$_();
        }
        _$GetOriginY$_() {
            return this._$_origin$_._$getY$_();
        }
        _$GetCollisionPoly$_() {
            return this._$_collisionPoly$_;
        }
        _$GetImagePointByName$_(t) {
            return this._$_imagePointsByName$_.get(t.toLowerCase()) || null;
        }
        _$GetImagePointByIndex$_(t) {
            return (t = Math.floor(t)) < 0 || t >= this._$_imagePoints$_.length ? null : this._$_imagePoints$_[t];
        }
        _$GetImagePointCount$_() {
            return this._$_imagePoints$_.length;
        }
        _$GetTag$_() {
            return this._$_tag$_;
        }
        _$GetIAnimationFrame$_() {
            return this._$_iAnimationFrame$_;
        }
    };
}

{
    const UM = self._$C3$_;
    UM._$ImagePoint$_ = class extends UM._$DefendedBase$_ {
        constructor(t, s) {
            super(), this._$_afi$_ = t, this._$_name$_ = s[0], this._$_pos$_ = UM._$New$_(UM._$Vector2$_, s[1], s[2]);
        }
        _$Release$_() {}
        _$GetName$_() {
            return this._$_name$_;
        }
        _$GetX$_() {
            return this._$_pos$_._$getX$_();
        }
        _$GetY$_() {
            return this._$_pos$_._$getY$_();
        }
        _$GetVec2$_() {
            return this._$_pos$_;
        }
    };
}

{
    const WM = self._$C3$_, JM = self._$C3Debugger$_, QM = self._$IObjectClass$_;
    self.assert;
    WM._$ObjectClass$_ = class extends WM._$DefendedBase$_ {
        constructor(t, s, i) {
            super();
            const e = t._$GetObjectReference$_(i[1]);
            this._$_runtime$_ = t, this._$_plugin$_ = WM._$AddonManager$_._$GetPluginByConstructorFunction$_(e), 
            this._$_sdkType$_ = null, this._$_instSdkCtor$_ = e.Instance, this._$_index$_ = s, 
            this._$_sid$_ = i[11], this._$_name$_ = i[0], this._$_jsPropName$_ = this._$_runtime$_._$GetJsPropName$_(i[14]), 
            this._$_isGlobal$_ = !!i[9], this._$_isFamily$_ = !!i[2], this._$_isOnLoaderLayout$_ = !!i[10], 
            this._$_instVars$_ = i[3].map((s => ({
                _$sid$_: s[0],
                type: s[1],
                name: s[2],
                _$jsPropName$_: t._$GetJsPropName$_(s[3])
            }))), this._$_behaviorsCount$_ = i[4], this._$_effectsCount$_ = i[5], this._$_isWorldType$_ = this._$_plugin$_._$IsWorldType$_(), 
            this._$_dispatcher$_ = WM._$New$_(WM.Event._$Dispatcher$_), this._$_effectList$_ = null;
            const [n, h] = t._$GetCollisionEngine$_()._$GetCollisionCellSize$_();
            if (this._$_collisionGrid$_ = WM._$New$_(WM._$SparseGrid$_, n, h), this._$_anyCollisionCellChanged$_ = !0, 
            this._$_familyMembers$_ = null, this._$_familyMembersSet$_ = null, this._$_familyIndex$_ = -1, 
            this._$_families$_ = null, this._$_familiesSet$_ = null, this._$_familyInstVarMap$_ = null, 
            this._$_familyBehaviorMap$_ = null, this._$_familyEffectMap$_ = null, this._$_isInContainer$_ = !1, 
            this._$_container$_ = null, this._$_behaviorTypes$_ = i[8].map((t => WM._$BehaviorType$_._$Create$_(this, t))), 
            this._$_behaviorTypesIncludingInherited$_ = [], this._$_behaviorsByName$_ = new Map, 
            this._$_behaviorNameToIndex$_ = new Map, this._$_usedBehaviorCtors$_ = new Set, 
            this._$_customActionMap$_ = new Map, this._$_solStack$_ = WM._$New$_(WM._$SolStack$_, this), 
            this._$_defaultInstanceData$_ = null, this._$_defaultLayerIndex$_ = 0, this._$_isContained$_ = !1, 
            this._$_container$_ = null, this._$_imageInfo$_ = null, this._$_animations$_ = null, 
            this._$_animationsByName$_ = null, this._$_animationsBySid$_ = null, this._$_textureRefCount$_ = 0, 
            this._$_savedData$_ = new Map, this._$_unsavedData$_ = new Map, this._$_instances$_ = [], 
            this._$_worldInfosByLayer$_ = new Map, this._$_iidsStale$_ = !0, this._$_plugin$_._$HasEffects$_() && (this._$_effectList$_ = WM._$New$_(WM._$EffectList$_, this, i[12])), 
            i[6] && (this._$_imageInfo$_ = WM._$New$_(WM._$ImageInfo$_), this._$_imageInfo$_._$LoadData$_(i[6])), 
            i[7]) {
                this._$_animations$_ = i[7].map((t => WM._$New$_(WM._$AnimationInfo$_, t))), this._$_animationsByName$_ = new Map, 
                this._$_animationsBySid$_ = new Map;
                for (const t of this._$_animations$_) this._$_animationsByName$_.set(t._$GetName$_().toLowerCase(), t), 
                this._$_animationsBySid$_.set(t._$GetSID$_(), t);
            }
            this._$_isFamily$_ ? (this._$_familyMembers$_ = [], this._$_familyMembersSet$_ = new Set, 
            this._$_familyIndex$_ = this._$_runtime$_._$_GetNextFamilyIndex$_()) : (this._$_families$_ = [], 
            this._$_familiesSet$_ = new Set, this._$_familyInstVarMap$_ = [], this._$_familyBehaviorMap$_ = [], 
            this._$_familyEffectMap$_ = []);
            const r = this._$_plugin$_._$GetSdkVersion$_();
            if (r < 2 && (this._$_sdkType$_ = WM._$New$_(e._$Type$_, this, i[15]), !(this._$_sdkType$_ instanceof WM._$SDKTypeBase$_))) throw new Error("v1 sdk type must derive from SDKTypeBase");
            let o;
            if (this._$_iObjectClass$_ = null, this._$_instanceUserScriptClass$_ = null, this._$_userScriptDispatcher$_ = WM._$New$_(WM.Event._$Dispatcher$_), 
            WM._$AddonManager$_._$_PushInitObject$_(this, r), r >= 2 ? (o = e._$Type$_, o || (o = globalThis._$ISDKObjectTypeBase$_)) : o = this._$_sdkType$_._$GetScriptInterfaceClass$_(), 
            o) {
                if (this._$_iObjectClass$_ = new o(r < 2 ? this : null), r < 2 && !(this._$_iObjectClass$_ instanceof QM)) throw new TypeError("script interface class must derive from IObjectClass");
                if (r >= 2 && !(this._$_iObjectClass$_ instanceof globalThis._$ISDKObjectTypeBase$_)) throw new TypeError("script interface class must derive from ISDKObjectTypeBase");
            } else this._$_iObjectClass$_ = new QM;
            if (WM._$AddonManager$_._$_PopInitObject$_(r), i[13]) {
                const t = i[13];
                if (t) {
                    const s = t[0], i = t[1], e = t[2];
                    this._$_sdkType$_._$LoadTilemapData$_(s, i, e);
                }
            }
            this._$_runtime$_._$UsesLoaderLayout$_() && !this._$_isFamily$_ && !this._$_isOnLoaderLayout$_ && this._$_isWorldType$_ || this._$OnCreate$_(), 
            this._$_plugin$_._$IsSingleGlobal$_() && (this._$_plugin$_._$_SetSingleGlobalObjectClass$_(this), 
            this._$_CreateSingleGlobalInstance$_(i)), this._$_loadInstancesJson$_ = null;
        }
        static _$Create$_(t, s, i) {
            return WM._$New$_(WM._$ObjectClass$_, t, s, i);
        }
        _$Release$_() {
            if (this._$_dispatcher$_._$Release$_(), this._$_dispatcher$_ = null, this._$_imageInfo$_ && (this._$_imageInfo$_._$Release$_(), 
            this._$_imageInfo$_ = null), this._$_animations$_) {
                for (const t of this._$_animations$_) t._$Release$_();
                WM._$clearArray$_(this._$_animations$_), this._$_animationsByName$_.clear(), this._$_animationsBySid$_.clear();
            }
            this._$_loadInstancesJson$_ = null, this._$_solStack$_._$Release$_(), this._$_solStack$_ = null, 
            this._$_savedData$_.clear(), this._$_unsavedData$_.clear(), this._$_container$_ = null, 
            this._$_runtime$_ = null;
        }
        _$_LoadFamily$_(t) {
            for (let s = 1, i = t.length; s < i; ++s) {
                const i = this._$_runtime$_._$GetObjectClassByIndex$_(t[s]);
                this._$_familyMembers$_.push(i), this._$_familyMembersSet$_.add(i), i._$_families$_.push(this), 
                i._$_familiesSet$_.add(this);
            }
        }
        _$_SetContainer$_(t) {
            this._$_isInContainer$_ = !0, this._$_container$_ = t;
        }
        _$IsInContainer$_() {
            return this._$_isInContainer$_;
        }
        _$GetContainer$_() {
            return this._$_container$_;
        }
        _$_OnAfterCreate$_() {
            let t = 0;
            if (!this._$_isFamily$_) for (const s of this._$_families$_) for (const i of s._$GetBehaviorTypes$_()) {
                const s = i._$GetName$_().toLowerCase();
                this._$_behaviorsByName$_.set(s, i), this._$_behaviorNameToIndex$_.set(s, t), this._$_behaviorTypesIncludingInherited$_.push(i), 
                ++t;
            }
            for (const s of this._$GetBehaviorTypes$_()) {
                const i = s._$GetName$_().toLowerCase();
                this._$_behaviorsByName$_.set(i, s), this._$_behaviorNameToIndex$_.set(i, t), this._$_behaviorTypesIncludingInherited$_.push(s), 
                ++t;
            }
            for (const t of this._$_behaviorTypesIncludingInherited$_) this._$_usedBehaviorCtors$_.add(t._$GetBehavior$_().constructor);
            if (!this._$_isFamily$_ && this._$_families$_.length) {
                const t = this._$_runtime$_._$GetFamilyCount$_();
                WM._$extendArray$_(this._$_familyInstVarMap$_, t, 0), WM._$extendArray$_(this._$_familyBehaviorMap$_, t, 0), 
                WM._$extendArray$_(this._$_familyEffectMap$_, t, 0);
                const s = [];
                let i = 0, e = 0, n = 0;
                for (const t of this._$_families$_) {
                    const h = t._$GetFamilyIndex$_();
                    this._$_familyInstVarMap$_[h] = i, i += t._$GetInstanceVariablesCount$_(), this._$_familyBehaviorMap$_[h] = e, 
                    e += t._$GetBehaviorTypesCount$_(), this._$_familyEffectMap$_[h] = n, n += t._$GetEffectTypesCount$_();
                    const r = t._$GetEffectList$_();
                    if (r && this._$_effectList$_) for (const t of r._$GetAllEffectTypes$_()) s.push(t._$Clone$_(this._$_effectList$_));
                }
                this._$_effectList$_ && this._$_effectList$_._$PrependEffectTypes$_(s);
            }
        }
        _$_CreateSingleGlobalInstance$_(t) {
            const s = this._$_runtime$_._$_GetNewUID$_(), i = WM._$New$_(WM.Instance, {
                runtime: this._$_runtime$_,
                objectType: this,
                uid: s
            });
            i._$_CreateSdkInstance$_(t[16], []), this._$_runtime$_._$_MapInstanceByUID$_(s, i), 
            this._$_instances$_.push(i);
        }
        _$GetSdkType$_() {
            return this._$_sdkType$_;
        }
        _$IsOnLoaderLayout$_() {
            return this._$_isOnLoaderLayout$_;
        }
        _$Dispatcher$_() {
            return this._$_dispatcher$_;
        }
        _$OnCreate$_() {
            this._$_isFamily$_ || (this._$_sdkType$_ ? this._$_sdkType$_._$OnCreate$_() : this._$_iObjectClass$_._$_onCreate$_());
        }
        _$HasLoadedTextures$_() {
            return this._$_textureRefCount$_ > 0;
        }
        async _$LoadTextures$_(t) {
            this._$_isFamily$_ || (this._$_textureRefCount$_++, 1 === this._$_textureRefCount$_ && (this._$_sdkType$_ ? await this._$_sdkType$_._$LoadTextures$_(t) : await this._$_iObjectClass$_._$_loadTextures$_(this._$_runtime$_._$GetCanvasManager$_()._$GetIRenderer$_())));
        }
        _$ReleaseTextures$_() {
            if (!this._$_isFamily$_) {
                if (this._$_textureRefCount$_--, this._$_textureRefCount$_ < 0) throw new Error("released textures too many times");
                0 === this._$_textureRefCount$_ && (this._$_sdkType$_ ? this._$_sdkType$_._$ReleaseTextures$_() : this._$_iObjectClass$_._$_releaseTextures$_(this._$_runtime$_._$GetCanvasManager$_()._$GetIRenderer$_()));
            }
        }
        _$OnDynamicTextureLoadComplete$_() {
            if (this._$_isFamily$_) throw new Error("not applicable to family");
            this._$_sdkType$_ ? this._$_sdkType$_._$OnDynamicTextureLoadComplete$_() : this._$_iObjectClass$_._$_onDynamicTextureLoadComplete$_();
        }
        async _$PreloadTexturesWithInstances$_(t) {
            this._$_isFamily$_ || (this._$_sdkType$_ ? await this._$_sdkType$_._$PreloadTexturesWithInstances$_(t) : await this._$_iObjectClass$_._$_preloadTexturesWithInstances$_(this._$_runtime$_._$GetCanvasManager$_()._$GetIRenderer$_()));
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetPlugin$_() {
            return this._$_plugin$_;
        }
        _$GetInstanceSdkCtor$_() {
            return this._$_instSdkCtor$_;
        }
        _$GetName$_() {
            return this._$_name$_;
        }
        _$GetJsPropName$_() {
            return this._$_jsPropName$_;
        }
        _$GetIndex$_() {
            return this._$_index$_;
        }
        _$GetSID$_() {
            return this._$_sid$_;
        }
        _$IsFamily$_() {
            return this._$_isFamily$_;
        }
        _$IsGlobal$_() {
            return this._$_isGlobal$_;
        }
        _$IsWorldType$_() {
            return this._$_isWorldType$_;
        }
        _$GetFamilyIndex$_() {
            return this._$_familyIndex$_;
        }
        _$GetBehaviorTypes$_() {
            return this._$_behaviorTypes$_;
        }
        _$GetBehaviorTypesCount$_() {
            return this._$_behaviorsCount$_;
        }
        _$UsesBehaviorByCtor$_(t) {
            return t && this._$_usedBehaviorCtors$_.has(t);
        }
        _$GetInstanceVariablesCount$_() {
            return this._$_instVars$_.length;
        }
        _$GetInstanceVariableSIDs$_() {
            return this._$_instVars$_.map((t => t._$sid$_));
        }
        _$GetInstanceVariableIndexBySID$_(t) {
            return this._$_instVars$_.findIndex((s => s._$sid$_ === t));
        }
        _$GetInstanceVariableIndexByName$_(t) {
            return this._$_instVars$_.findIndex((s => s.name === t));
        }
        _$_GetAllInstanceVariableNames$_() {
            return this._$_instVars$_.map((t => t.name));
        }
        _$_GetAllInstanceVariableJsPropNames$_() {
            return this._$_instVars$_.map((t => t._$jsPropName$_));
        }
        _$GetInstanceVariableType$_(t) {
            if ((t = Math.floor(t)) < 0 || t >= this._$_instVars$_.length) throw new RangeError("invalid instance variable index");
            return this._$_instVars$_[t].type;
        }
        _$GetInstanceVariableName$_(t) {
            if ((t = Math.floor(t)) < 0 || t >= this._$_instVars$_.length) throw new RangeError("invalid instance variable index");
            return this._$_instVars$_[t].name;
        }
        _$GetEffectTypesCount$_() {
            return this._$_effectsCount$_;
        }
        _$GetBehaviorTypesIncludingInherited$_() {
            return this._$_behaviorTypesIncludingInherited$_;
        }
        _$GetBehaviorTypeByName$_(t) {
            return this._$_behaviorsByName$_.get(t.toLowerCase()) || null;
        }
        _$GetBehaviorIndexByName$_(t) {
            const s = this._$_behaviorNameToIndex$_.get(t.toLowerCase());
            return void 0 === s ? -1 : s;
        }
        _$GetEffectList$_() {
            return this._$_effectList$_;
        }
        _$HasEffects$_() {
            return this._$_plugin$_._$HasEffects$_();
        }
        _$UsesEffects$_() {
            return this._$_effectList$_ && this._$_effectList$_._$HasAnyEffectType$_();
        }
        _$GetSolStack$_() {
            return this._$_solStack$_;
        }
        _$GetCurrentSol$_() {
            return this._$_solStack$_._$GetCurrentSol$_();
        }
        _$GetImageInfo$_() {
            return this._$_imageInfo$_;
        }
        _$SetDefaultInstanceData$_(t) {
            this._$_defaultInstanceData$_ = t;
        }
        _$GetDefaultInstanceData$_() {
            return this._$_defaultInstanceData$_;
        }
        _$_SetDefaultLayerIndex$_(t) {
            this._$_defaultLayerIndex$_ = t;
        }
        _$GetDefaultLayerIndex$_() {
            return this._$_defaultLayerIndex$_;
        }
        _$GetAnimations$_() {
            return this._$_animations$_;
        }
        _$GetAnimationCount$_() {
            return this._$_animations$_.length;
        }
        _$GetFamilies$_() {
            return this._$_families$_;
        }
        _$BelongsToFamily$_(t) {
            return this._$_familiesSet$_.has(t);
        }
        _$GetFamilyMembers$_() {
            return this._$_familyMembers$_;
        }
        _$FamilyHasMember$_(t) {
            return this._$_familyMembersSet$_.has(t);
        }
        _$GetFamilyBehaviorOffset$_(t) {
            return this._$_familyBehaviorMap$_[t];
        }
        _$GetFamilyInstanceVariableOffset$_(t) {
            return this._$_familyInstVarMap$_[t];
        }
        _$AddCustomAction$_(t) {
            this._$_customActionMap$_.set(t._$GetACEName$_().toLowerCase(), t);
        }
        _$HasOwnCustomActionByName$_(t) {
            return !!this._$GetOwnCustomActionByName$_(t);
        }
        _$GetOwnCustomActionByName$_(t) {
            const s = this._$_customActionMap$_.get(t.toLowerCase());
            return s && s._$IsEnabled$_() ? s : null;
        }
        _$GetAllAnimations$_() {
            return this._$_animations$_;
        }
        _$GetAnimationByName$_(t) {
            if (!this._$_animations$_) throw new Error("no animations");
            return this._$_animationsByName$_.get(t.toLowerCase()) || null;
        }
        _$GetAnimationBySID$_(t) {
            if (!this._$_animations$_) throw new Error("no animations");
            return this._$_animationsBySid$_.get(t) || null;
        }
        _$AddAnimation$_(t) {
            if (this._$GetAnimationByName$_(t)) throw new Error(`animation name '${t}' already exists`);
            const s = WM._$AnimationInfo$_._$CreateDynamic$_(this._$GetRuntime$_(), t);
            return this._$_animations$_.push(s), this._$_animationsByName$_.set(s._$GetName$_().toLowerCase(), s), 
            this._$_animationsBySid$_.set(s._$GetSID$_(), s), s;
        }
        _$RemoveAnimation$_(t) {
            const s = this._$GetAnimationByName$_(t);
            if (!s) throw new Error(`animation name '${t}' does not exist`);
            if (1 === this._$_animations$_.length) throw new Error("cannot remove last animation");
            const i = this._$_animations$_.indexOf(s);
            this._$_animations$_.splice(i, 1), this._$_animationsByName$_.delete(s._$GetName$_().toLowerCase()), 
            this._$_animationsBySid$_.delete(s._$GetSID$_()), s._$Release$_();
        }
        _$GetFirstAnimation$_() {
            if (!this._$_animations$_) throw new Error("no animations");
            return this._$_animations$_[0];
        }
        _$GetFirstAnimationFrame$_() {
            return this._$GetFirstAnimation$_()._$GetFrameAt$_(0);
        }
        _$GetDefaultInstanceSize$_() {
            if (this._$_animations$_) {
                const t = this._$GetFirstAnimationFrame$_()._$GetImageInfo$_();
                return [ t._$GetWidth$_(), t._$GetHeight$_() ];
            }
            return this._$_imageInfo$_ ? [ this._$_imageInfo$_._$GetWidth$_(), this._$_imageInfo$_._$GetHeight$_() ] : [ 100, 100 ];
        }
        _$GetSingleGlobalInstance$_() {
            if (!this._$_plugin$_._$IsSingleGlobal$_()) throw new Error("not a single-global plugin");
            return this._$_instances$_[0];
        }
        _$GetInstances$_() {
            return this._$_instances$_;
        }
        * _$instances$_() {
            yield* this._$_instances$_;
        }
        * _$instancesIncludingPendingCreate$_() {
            yield* this._$_instances$_, yield* this._$_runtime$_._$instancesPendingCreateForObjectClass$_(this);
        }
        _$GetInstanceCount$_() {
            return this._$_instances$_.length;
        }
        _$_AddInstance$_(t) {
            this._$_instances$_.push(t);
        }
        _$_SetIIDsStale$_() {
            this._$_iidsStale$_ = !0;
        }
        _$_UpdateIIDs$_() {
            if (!this._$_iidsStale$_ || this._$_isFamily$_) return;
            const t = this._$_instances$_;
            let s = 0;
            for (let i = t.length; s < i; ++s) t[s]._$_SetIID$_(s);
            const i = this._$_runtime$_._$_GetInstancesPendingCreate$_();
            for (const t of i) t._$GetObjectClass$_() === this && t._$_SetIID$_(s++);
            this._$_iidsStale$_ = !1;
        }
        _$GetInstanceByIID$_(t) {
            const s = this._$_instances$_;
            if (t < s.length) return s[t];
            t -= s.length;
            const i = this._$_runtime$_._$_GetInstancesPendingCreate$_();
            for (const s of i) if (s._$GetObjectClass$_() === this) {
                if (0 === t) return s;
                --t;
            }
            return null;
        }
        _$GetFirstPicked$_(t) {
            if (t && t._$IsInContainer$_() && t._$GetObjectClass$_() !== this) for (const s of t._$siblings$_()) if (s._$GetObjectClass$_() === this) return s;
            const s = this._$GetCurrentSol$_()._$GetInstances$_();
            return s.length ? s[0] : null;
        }
        _$GetPairedInstance$_(t) {
            const s = this._$GetCurrentSol$_()._$GetInstances$_();
            return s.length > 0 ? s[t._$GetIID$_() % s.length] : null;
        }
        * _$allCorrespondingInstances$_(t, s) {
            const i = this._$GetCurrentSol$_()._$GetInstances$_(), e = i.length, n = s._$GetCurrentSol$_(), h = s._$GetCurrentSol$_()._$GetInstances$_(), r = h.length;
            let o = t._$GetIID$_();
            !s._$IsFamily$_() && n._$IsSelectAll$_() || (o = h.indexOf(t));
            const a = Math.ceil(e / r), u = e % r;
            let l = 0, c = 0;
            0 === u || o < u ? (l = o * a, c = a) : (l = u * a + (o - u) * (a - 1), c = a - 1);
            for (let t = l, s = l + c; t < s; ++t) yield i[t];
        }
        _$FinishCondition$_(t) {
            this._$_sdkType$_?._$FinishCondition$_(t);
        }
        _$ApplySolToContainer$_() {
            if (!this._$_isInContainer$_ || this._$_isFamily$_) return;
            this._$_UpdateIIDs$_();
            const t = this._$GetCurrentSol$_(), s = t._$_GetOwnInstances$_(), i = t._$IsSelectAll$_(), e = this._$_runtime$_._$GetCurrentEventStackFrame$_(), n = e && e._$GetCurrentEvent$_() && e._$GetCurrentEvent$_()._$IsOrBlock$_();
            for (const e of this._$_container$_._$objectTypes$_()) {
                if (e === this) continue;
                e._$_UpdateIIDs$_();
                const h = e._$GetCurrentSol$_();
                if (h._$_SetSelectAll$_(i), !i) {
                    const i = h._$_GetOwnInstances$_();
                    WM._$clearArray$_(i);
                    for (const t of s) i.push(e._$GetInstanceByIID$_(t._$GetIID$_()));
                    if (n) {
                        const s = t._$_GetOwnElseInstances$_(), i = h._$_GetOwnElseInstances$_();
                        WM._$clearArray$_(i);
                        for (const t of s) i.push(e._$GetInstanceByIID$_(t._$GetIID$_()));
                    }
                }
            }
        }
        _$_TruncateContainerSols$_(t, s) {
            for (const i of this._$GetContainer$_()._$objectTypes$_()) {
                const e = i._$GetCurrentSol$_();
                t ? WM._$truncateArray$_(e._$_GetOwnElseInstances$_(), s) : WM._$truncateArray$_(e._$_GetOwnInstances$_(), s);
            }
        }
        _$_GetCollisionCellGrid$_() {
            return this._$_collisionGrid$_;
        }
        _$_SetAnyCollisionCellChanged$_(t) {
            this._$_anyCollisionCellChanged$_ = !!t;
        }
        _$_UpdateAllCollisionCells$_() {
            if (this._$_anyCollisionCellChanged$_ && this._$_isWorldType$_) {
                for (const t of this._$_instances$_) t._$GetWorldInfo$_()._$_UpdateCollisionCell$_();
                for (const t of this._$_runtime$_._$_GetInstancesPendingCreate$_()) t._$GetObjectClass$_() === this && t._$GetWorldInfo$_()._$_UpdateCollisionCell$_();
                this._$_anyCollisionCellChanged$_ = !1;
            }
        }
        _$_OnWorldInstanceLayerChanged$_(t, s, i) {
            if (s) {
                const i = this._$_worldInfosByLayer$_.get(s);
                i && (i.delete(t), 0 === i.size && this._$_worldInfosByLayer$_.delete(s));
            }
            if (i) {
                let s = this._$_worldInfosByLayer$_.get(i);
                s || (s = new Set, this._$_worldInfosByLayer$_.set(i, s)), s.add(t);
            }
        }
        _$layersHasInstancesOn$_() {
            if (this._$IsFamily$_()) {
                const t = new Set;
                for (const s of this._$_familyMembers$_) for (const i of s._$layersHasInstancesOn$_()) t.add(i);
                return t.values();
            }
            return this._$_worldInfosByLayer$_.keys();
        }
        _$GetSavedDataMap$_() {
            return this._$_savedData$_ || (this._$_savedData$_ = new Map), this._$_savedData$_;
        }
        _$GetUnsavedDataMap$_() {
            return this._$_unsavedData$_ || (this._$_unsavedData$_ = new Map), this._$_unsavedData$_;
        }
        _$HasSolidBehavior$_() {
            return this._$UsesBehaviorByCtor$_(WM._$Behaviors$_._$solid$_);
        }
        _$HasJumpthruBehavior$_() {
            return this._$UsesBehaviorByCtor$_(WM._$Behaviors$_._$jumpthru$_);
        }
        _$HasNoSaveBehavior$_() {
            return this._$UsesBehaviorByCtor$_(WM._$Behaviors$_._$NoSave$_);
        }
        _$HasPersistBehavior$_() {
            return this._$UsesBehaviorByCtor$_(WM._$Behaviors$_._$Persist$_);
        }
        _$_SaveToJson$_() {
            const t = {
                instances: this._$_instances$_.map((t => t._$SaveToJson$_()))
            };
            return this._$_savedData$_ && this._$_savedData$_.size && (t.ex = WM._$ToSuperJSON$_(this._$_savedData$_)), 
            t;
        }
        _$_LoadFromJson$_(t, s) {
            this._$_savedData$_ && (this._$_savedData$_.clear(), this._$_savedData$_ = null);
            const i = t.ex;
            i && (this._$_savedData$_ = WM._$FromSuperJSON$_(i));
            const e = this._$_instances$_, n = t.instances;
            for (let t = 0, s = Math.min(e.length, n.length); t < s; ++t) e[t]._$LoadFromJson$_(n[t]);
            for (let t = n.length, s = e.length; t < s; ++t) this._$_runtime$_._$DestroyInstance$_(e[t]);
            for (let t = e.length, i = n.length; t < i; ++t) {
                const i = n[t];
                let e = null;
                if (this._$IsWorldType$_() && (e = this._$_runtime$_._$GetMainRunningLayout$_()._$GetLayerBySID$_(i.w.l), 
                !e)) continue;
                const h = this._$_runtime$_._$CreateInstanceFromData$_(this._$_defaultInstanceData$_ || this, e, !1, 0, 0, !0);
                h._$LoadFromJson$_(i), s && s.add(h);
            }
            this._$_loadInstancesJson$_ = n, this._$_SetIIDsStale$_();
        }
        _$_GetLoadInstancesJson$_() {
            return this._$_loadInstancesJson$_;
        }
        _$_ClearLoadInstancesJson$_() {
            this._$_loadInstancesJson$_ = null;
        }
        _$_SetupSceneGraphConnectionsOnChangeOfLayout$_() {
            for (let t = 0, s = this._$_instances$_; t < s; ++t) this._$_instances$_[t]._$_SetupSceneGraphConnectionsOnChangeOfLayout$_();
        }
        _$GetIObjectClass$_() {
            return this._$_iObjectClass$_;
        }
        _$UserScriptDispatcher$_() {
            return this._$_userScriptDispatcher$_;
        }
        _$_GetUserScriptInstanceClass$_() {
            return this._$_instanceUserScriptClass$_;
        }
        _$_SetUserScriptInstanceClass$_(t) {
            this._$_instanceUserScriptClass$_ = t;
        }
        _$DispatchUserScriptEvent$_(t) {
            const s = this._$_runtime$_, i = s._$IsDebug$_() && !s._$GetEventSheetManager$_()._$IsInEventEngine$_();
            i && JM._$StartMeasuringScriptTime$_(), this._$_userScriptDispatcher$_.dispatchEvent(t), 
            i && JM._$AddScriptTime$_();
        }
    };
}

{
    const YM = self._$C3$_;
    YM._$Container$_ = class extends YM._$DefendedBase$_ {
        constructor(t, s) {
            super(), this._$_runtime$_ = t, this._$_objectTypes$_ = s;
            for (const t of this._$_objectTypes$_) t._$_SetContainer$_(this);
        }
        _$Release$_() {
            this._$_runtime$_ = null;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetObjectTypes$_() {
            return this._$_objectTypes$_;
        }
        _$objectTypes$_() {
            return this._$_objectTypes$_;
        }
        _$HasAnyWorldType$_() {
            return this._$_objectTypes$_.some((t => t._$IsWorldType$_()));
        }
    };
}

{
    const VM = self._$C3$_, HM = self._$C3Debugger$_, qM = (self._$IInstance$_, VM._$AddonManager$_), XM = [];
    let ZM = 0;
    const KM = new WeakMap, $M = new WeakMap;
    VM.Instance = class extends VM._$DefendedBase$_ {
        constructor(t) {
            if (VM._$AddonManager$_ !== qM) throw new Error("invalid addon manager");
            super(), this._$_runtime$_ = t.runtime, this._$_objectType$_ = t.objectType, this._$_worldInfo$_ = null, 
            this._$_sdkInst$_ = null, this._$_iScriptInterface$_ = null, this._$_iid$_ = 0, 
            this._$_uid$_ = t.uid, this._$_puid$_ = ZM++, this._$_flags$_ = 0, this._$_tagsSet$_ = null;
            const s = VM._$splitStringAndNormalize$_(t.tags);
            s.length > 0 && (this._$_tagsSet$_ = new Set(s)), this._$_instVarValues$_ = XM, 
            this._$_behaviorInstances$_ = XM;
            const i = this._$_objectType$_._$GetBehaviorTypesIncludingInherited$_();
            i.length > 0 && (this._$_behaviorInstances$_ = i.map(((t, s) => VM._$New$_(VM._$BehaviorInstance$_, {
                runtime: this._$_runtime$_,
                _$behaviorType$_: t,
                _$instance$_: this,
                index: s
            })))), this._$_siblings$_ = this._$_objectType$_._$IsInContainer$_() ? [] : null, 
            this._$_timeScale$_ = -1, this._$_dispatcher$_ = null;
            const e = this._$GetPlugin$_();
            if (e._$MustPreDraw$_() && (this._$_flags$_ |= 4), e._$IsWorldType$_()) if (this._$_worldInfo$_ = VM._$New$_(VM._$WorldInfo$_, this, t._$layer$_), 
            t._$worldData$_) this._$_worldInfo$_._$Init$_(t._$worldData$_); else {
                this._$_worldInfo$_._$InitNoData$_();
                const [t, s] = this._$_objectType$_._$GetDefaultInstanceSize$_();
                this._$_worldInfo$_._$SetSize$_(t, s), this._$GetObjectClass$_()._$UsesEffects$_() && this._$_worldInfo$_._$GetInstanceEffectList$_()._$LoadDefaultEffectParameters$_();
            }
            t._$instVarData$_ ? this._$_LoadInstanceVariableData$_(t._$instVarData$_) : this._$_LoadDefaultInstanceVariables$_();
        }
        _$Release$_() {
            if (this._$_iScriptInterface$_ && (this._$_iScriptInterface$_._$_release$_(), this._$_iScriptInterface$_ = null), 
            this._$_behaviorInstances$_.length > 0) {
                for (const t of this._$_behaviorInstances$_) t._$Release$_();
                VM._$clearArray$_(this._$_behaviorInstances$_);
            }
            this._$_sdkInst$_ && (this._$_sdkInst$_._$Release$_(), this._$_sdkInst$_ = null);
            const t = KM.get(this);
            t && (t.clear(), KM.delete(this));
            const s = $M.get(this);
            s && (s.clear(), $M.delete(this)), this._$_siblings$_ && VM._$clearArray$_(this._$_siblings$_), 
            this._$_dispatcher$_ && (this._$_dispatcher$_._$Release$_(), this._$_dispatcher$_ = null), 
            this._$_tagsSet$_ && this._$_tagsSet$_.clear(), this._$_tagsSet$_ = null, this._$_runtime$_ = null, 
            this._$_objectType$_ = null, this._$_instVarValues$_.length > 0 && VM._$clearArray$_(this._$_instVarValues$_), 
            this._$_worldInfo$_ && (this._$_worldInfo$_._$Release$_(), this._$_worldInfo$_ = null);
        }
        _$_LoadInstanceVariableData$_(t) {
            t.length > 0 && (this._$_instVarValues$_ = [], VM._$shallowAssignArray$_(this._$_instVarValues$_, t));
        }
        _$_LoadDefaultInstanceVariables$_() {
            const t = this._$_objectType$_._$GetInstanceVariablesCount$_();
            if (0 === t) return;
            this._$_instVarValues$_ = [];
            const s = [ 0, 0, "" ];
            for (let i = 0; i < t; ++i) this._$_instVarValues$_.push(s[this._$_objectType$_._$GetInstanceVariableType$_(i)]);
        }
        _$_CreateSdkInstance$_(t, s) {
            if (this._$_sdkInst$_) throw new Error("already got sdk instance");
            for (let t = 0, i = this._$_behaviorInstances$_.length; t < i; ++t) this._$_behaviorInstances$_[t]._$_CreateSdkInstance$_(s ? s[t] : null);
            if (this._$GetPlugin$_()._$GetSdkVersion$_() < 2) {
                if (this._$_sdkInst$_ = VM._$New$_(this._$_objectType$_._$GetInstanceSdkCtor$_(), this, t), 
                !(this._$_sdkInst$_ instanceof VM._$SDKInstanceBase$_)) throw new Error("sdk type must derive from SDKInstanceBase");
                !this._$GetPlugin$_()._$IsWorldType$_() && this._$_objectType$_._$_GetUserScriptInstanceClass$_() && this._$GetInterfaceClass$_();
            } else {
                const s = this._$GetPlugin$_()._$GetScriptInterfaceClass$_();
                this._$_InitUserScriptInterface$_(s.Instance, t);
            }
        }
        _$GetSdkInstance$_() {
            return this._$_sdkInst$_ ?? this._$_iScriptInterface$_;
        }
        _$GetWorldInfo$_() {
            return this._$_worldInfo$_;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetTimeScale$_() {
            return this._$_timeScale$_;
        }
        _$GetActiveTimeScale$_() {
            const t = this._$_timeScale$_;
            return -1 === t ? this._$GetRuntime$_()._$GetTimeScale$_() : t;
        }
        _$SetTimeScale$_(t) {
            ((t = +t) < 0 || !isFinite(t)) && (t = 0), this._$_timeScale$_ = t, this._$GetObjectClass$_()._$UsesEffects$_() && this._$_runtime$_._$_SetTrackingInstanceTime$_(this, !0);
        }
        _$RestoreTimeScale$_() {
            this._$_timeScale$_ = -1, this._$GetObjectClass$_()._$UsesEffects$_() && this._$_runtime$_._$_SetTrackingInstanceTime$_(this, !1);
        }
        _$GetInstanceGameTime$_() {
            return this._$_runtime$_._$_GetInstanceGameTime$_(this);
        }
        _$Dispatcher$_() {
            return this._$_dispatcher$_ || (this._$_dispatcher$_ = VM._$New$_(VM.Event._$Dispatcher$_)), 
            this._$_dispatcher$_;
        }
        _$Draw$_(t) {
            this._$_sdkInst$_ ? this._$_sdkInst$_._$Draw$_(t) : this._$_iScriptInterface$_._$_draw$_(this._$_runtime$_._$GetCanvasManager$_()._$GetIRenderer$_());
        }
        _$OnCreate$_(t) {
            this._$_sdkInst$_._$OnCreate$_(t);
        }
        _$_SetHasTilemap$_() {
            this._$_flags$_ |= 2;
        }
        _$HasTilemap$_() {
            return !!(2 & this._$_flags$_);
        }
        _$_MarkDestroyed$_() {
            this._$_flags$_ |= 1;
        }
        _$IsDestroyed$_() {
            return !!(1 & this._$_flags$_);
        }
        _$MustPreDraw$_() {
            return !!(4 & this._$_flags$_) || this._$_sdkInst$_._$MustPreDraw$_();
        }
        _$SetMustMitigateZFighting$_() {
            this._$_flags$_ |= 32;
        }
        _$MustMitigateZFighting$_() {
            return !!(32 & this._$_flags$_);
        }
        _$_IsSolidEnabled$_() {
            return !!(8 & this._$_flags$_);
        }
        _$_SetSolidEnabled$_(t) {
            t ? this._$_flags$_ |= 8 : this._$_flags$_ &= -9;
        }
        _$_IsJumpthruEnabled$_() {
            return !!(16 & this._$_flags$_);
        }
        _$_SetJumpthruEnabled$_(t) {
            t ? this._$_flags$_ |= 16 : this._$_flags$_ &= -17;
        }
        _$_IsDrawingWithEffects$_() {
            return !!(64 & this._$_flags$_);
        }
        _$_SetIsDrawingWithEffects$_(t) {
            t ? this._$_flags$_ |= 64 : this._$_flags$_ &= -65;
        }
        _$SetFlag$_(t, s) {
            t <<= 16, s ? this._$_flags$_ |= t : this._$_flags$_ &= ~t;
        }
        _$GetFlag$_(t) {
            return !!(this._$_flags$_ & t << 16);
        }
        _$GetCurrentImageInfo$_() {
            return this._$_sdkInst$_._$GetCurrentImageInfo$_();
        }
        _$GetCurrentSurfaceSize$_() {
            return this._$_sdkInst$_._$GetCurrentSurfaceSize$_();
        }
        _$GetCurrentTexRect$_() {
            return this._$_sdkInst$_._$GetCurrentTexRect$_();
        }
        _$GetCurrentTexQuad$_() {
            return this._$_sdkInst$_._$GetCurrentTexQuad$_();
        }
        _$IsCurrentTexRotated$_() {
            return this._$_sdkInst$_._$IsCurrentTexRotated$_();
        }
        _$GetImagePoint$_(t) {
            return this._$_sdkInst$_._$GetImagePoint$_(t);
        }
        _$GetObjectClass$_() {
            return this._$_objectType$_;
        }
        _$RendersToOwnZPlane$_() {
            return this._$_sdkInst$_._$RendersToOwnZPlane$_();
        }
        _$BelongsToObjectClass$_(t) {
            return t._$IsFamily$_() ? t._$FamilyHasMember$_(this._$GetObjectClass$_()) : this._$GetObjectClass$_() === t;
        }
        _$CollectInstancesToPick$_(t, s, i) {
            const e = (s, i) => {
                const e = i || s._$GetObjectClass$_(), n = t.get(e);
                n ? n.add(s) : t.set(e, new Set([ s ]));
            };
            if (e(this, s), this._$IsInContainer$_()) for (const t of this._$siblings$_()) e(t);
            if (i) for (const t of this._$allChildren$_()) e(t);
        }
        _$VerifySupportsSceneGraph$_() {
            if (!this._$GetPlugin$_()._$SupportsSceneGraph$_()) throw new Error("object does not support scene graph");
        }
        _$HasParent$_() {
            return null !== this._$GetParent$_();
        }
        _$GetParent$_() {
            const t = this._$GetWorldInfo$_();
            if (!t) return null;
            const s = t._$GetParent$_();
            return s ? s._$GetInstance$_() : null;
        }
        _$GetTopParent$_() {
            const t = this._$GetWorldInfo$_();
            if (!t) return null;
            const s = t._$GetTopParent$_();
            return s ? s._$GetInstance$_() : null;
        }
        * _$parents$_() {
            const t = this._$GetWorldInfo$_();
            if (t) for (const s of t._$parents$_()) yield s._$GetInstance$_();
        }
        _$HasChild$_(t) {
            if (!t) return !1;
            for (const s of this.children()) if (s === t) return !0;
            return !1;
        }
        _$HasChildren$_() {
            const t = this._$GetWorldInfo$_();
            return !!t && t._$HasChildren$_();
        }
        _$GetChildrenOfObjectClass$_(t) {
            const s = this._$GetWorldInfo$_();
            if (!s) return [];
            const i = t._$GetName$_();
            return s._$GetChildren$_().map((t => t._$GetInstance$_())).filter((t => t._$GetObjectClass$_()._$GetName$_() === i));
        }
        _$GetChildren$_() {
            const t = this._$GetWorldInfo$_();
            return t ? t._$GetChildren$_().map((t => t._$GetInstance$_())) : [];
        }
        * children() {
            const t = this._$GetWorldInfo$_();
            if (t) for (const s of t.children()) yield s._$GetInstance$_();
        }
        * _$allChildren$_() {
            const t = this._$GetWorldInfo$_();
            if (t) for (const s of t._$allChildren$_()) yield s._$GetInstance$_();
        }
        _$GetChildCount$_() {
            const t = this._$GetWorldInfo$_();
            return t ? t._$GetChildCount$_() : 0;
        }
        _$GetParentCount$_() {
            return [ ...this._$parents$_() ].length;
        }
        _$GetAllChildCount$_() {
            const t = this._$GetWorldInfo$_();
            return t ? t._$GetAllChildCount$_() : 0;
        }
        _$GetChildAt$_(t) {
            const s = this._$GetWorldInfo$_();
            if (!s) return null;
            const i = s._$GetChildAt$_(t);
            return i ? i._$GetInstance$_() : null;
        }
        _$GetIndexInParent$_() {
            const t = this._$GetWorldInfo$_();
            if (!t) return NaN;
            const s = t._$GetParent$_();
            return s ? s._$GetChildIndex$_(t) : NaN;
        }
        _$HasChildWithUID$_(t) {
            for (const s of this._$GetWorldInfo$_()._$GetChildren$_()) if (s._$GetInstance$_()._$GetUID$_() === t) return !0;
            return !1;
        }
        _$AddChild$_(t, s) {
            this._$VerifySupportsSceneGraph$_(), t._$VerifySupportsSceneGraph$_(), this._$GetWorldInfo$_()._$AddChild$_(t._$GetWorldInfo$_(), s || {});
        }
        _$RemoveChild$_(t) {
            const s = this._$GetWorldInfo$_();
            s && s._$RemoveChild$_(t._$GetWorldInfo$_());
        }
        _$GetDestroyWithParent$_() {
            const t = this._$GetWorldInfo$_();
            return !!t && t._$GetDestroyWithParent$_();
        }
        _$SetupInitialSceneGraphConnections$_() {
            const t = this._$GetWorldInfo$_();
            if (!t) return;
            const s = t._$GetSceneGraphChildrenExportData$_();
            if (s) for (const t of s) {
                const s = this._$_runtime$_._$GetInstanceByUID$_(t[2]);
                if (s) {
                    const i = t[3];
                    this._$AddChild$_(s, {
                        _$transformX$_: !!(1 & i),
                        _$transformY$_: !!(i >> 1 & 1),
                        _$transformWidth$_: !!(i >> 2 & 1),
                        _$transformHeight$_: !!(i >> 3 & 1),
                        _$transformAngle$_: !!(i >> 4 & 1),
                        _$destroyWithParent$_: !!(i >> 5 & 1),
                        _$transformZElevation$_: !!(i >> 6 & 1),
                        _$transformOpacity$_: !!(i >> 7 & 1),
                        _$transformVisibility$_: !!(i >> 8 & 1)
                    });
                }
            }
        }
        _$SetupPersistedSceneGraphConnections$_(t, s) {
            const i = t.get(this);
            if (i) for (const t of i.sceneGraphJson.children) {
                const i = s.get(t.index);
                if (!i) continue;
                const e = t.flags;
                this._$AddChild$_(i, {
                    _$transformX$_: !!(1 & e),
                    _$transformY$_: !!(e >> 1 & 1),
                    _$transformWidth$_: !!(e >> 2 & 1),
                    _$transformHeight$_: !!(e >> 3 & 1),
                    _$transformAngle$_: !!(e >> 4 & 1),
                    _$destroyWithParent$_: !!(e >> 5 & 1),
                    _$transformZElevation$_: !!(e >> 6 & 1),
                    _$transformOpacity$_: !!(e >> 7 & 1),
                    _$transformVisibility$_: !!(e >> 8 & 1)
                });
            }
        }
        _$GetTemplateName$_() {
            const t = this._$_runtime$_._$GetTemplateManager$_();
            return t ? t._$GetInstanceTemplateName$_(this) : "";
        }
        _$IsInContainer$_() {
            return null !== this._$_siblings$_;
        }
        _$_ClearSiblings$_() {
            VM._$clearArray$_(this._$_siblings$_);
        }
        _$_AddSibling$_(t) {
            this._$_siblings$_.push(t);
        }
        _$GetSiblings$_() {
            return this._$_siblings$_;
        }
        _$HasSibling$_(t) {
            return !!this._$GetSibling$_(t);
        }
        _$GetSibling$_(t) {
            const s = this._$siblings$_();
            if (null === s || 0 === s.length) return !1;
            for (const i of s) if (i._$GetObjectClass$_() === t) return i;
            return null;
        }
        _$siblings$_() {
            return this._$_siblings$_;
        }
        _$SetSiblingsSinglePicked$_() {
            for (const t of this._$siblings$_()) t._$GetObjectClass$_()._$GetCurrentSol$_()._$SetSinglePicked$_(t);
        }
        _$_PushSiblingsToSolInstances$_() {
            for (const t of this._$siblings$_()) t._$GetObjectClass$_()._$GetCurrentSol$_()._$_PushInstance$_(t);
        }
        _$_SetSiblingsToSolInstancesIndex$_(t) {
            for (const s of this._$siblings$_()) s._$GetObjectClass$_()._$GetCurrentSol$_()._$_GetOwnInstances$_()[t] = s;
        }
        _$_PushSiblingsToSolElseInstances$_() {
            for (const t of this._$siblings$_()) t._$GetObjectClass$_()._$GetCurrentSol$_()._$_PushElseInstance$_(t);
        }
        _$_SetSiblingsToSolElseInstancesIndex$_(t) {
            for (const s of this._$siblings$_()) s._$GetObjectClass$_()._$GetCurrentSol$_()._$_GetOwnElseInstances$_()[t] = s;
        }
        _$GetPlugin$_() {
            return this._$_objectType$_._$GetPlugin$_();
        }
        _$_SetIID$_(t) {
            this._$_iid$_ = t;
        }
        _$GetIID$_() {
            return this._$_objectType$_._$_UpdateIIDs$_(), this._$_iid$_;
        }
        _$GetUID$_() {
            return this._$_uid$_;
        }
        _$GetPUID$_() {
            return this._$_puid$_;
        }
        _$_SetTagsSetFromJson$_(t) {
            t ? this._$SetTagsSet$_(new Set(t)) : this._$_tagsSet$_ = null;
        }
        _$SetTagsSet$_(t) {
            if (0 === t.size) this._$_tagsSet$_ = null; else {
                this._$_tagsSet$_ ? this._$_tagsSet$_.clear() : this._$_tagsSet$_ = new Set;
                for (const s of t) this._$_tagsSet$_.add(s);
            }
        }
        _$GetTagsSet$_() {
            return this._$_tagsSet$_ ?? new Set;
        }
        _$GetTagsString$_() {
            return Array.from(this._$GetTagsSet$_()).join(" ");
        }
        _$GetTagAt$_(t) {
            t = Math.floor(t);
            for (const s of this._$GetTagsSet$_()) {
                if (0 === t) return s;
                --t;
            }
            return "";
        }
        _$GetBehaviorInstances$_() {
            return this._$_behaviorInstances$_;
        }
        _$GetBehaviorInstanceFromCtor$_(t) {
            if (!t) return null;
            for (const s of this._$_behaviorInstances$_) if (s._$GetBehavior$_() instanceof t) return s;
            return null;
        }
        _$GetBehaviorSdkInstanceFromCtor$_(t) {
            if (!t) return null;
            const s = this._$GetBehaviorInstanceFromCtor$_(t);
            return s ? s._$GetSdkInstance$_() : null;
        }
        _$GetBehaviorIndexBySID$_(t) {
            const s = this._$_behaviorInstances$_;
            for (let i = 0, e = s.length; i < e; ++i) if (s[i]._$GetBehaviorType$_()._$GetSID$_() === t) return i;
            return -1;
        }
        _$GetAllInstanceVariableValues$_() {
            return this._$_instVarValues$_;
        }
        _$_GetAllInstanceVariableNames$_() {
            return this._$_objectType$_._$_GetAllInstanceVariableNames$_();
        }
        _$GetInstanceVariableCount$_() {
            return this._$_instVarValues$_.length;
        }
        _$GetInstanceVariableValue$_(t) {
            t |= 0;
            const s = this._$_instVarValues$_;
            if (t < 0 || t >= s.length) throw new RangeError("invalid instance variable");
            return s[t];
        }
        _$_GetInstanceVariableValueUnchecked$_(t) {
            return this._$_instVarValues$_[t];
        }
        _$_GetInstanceVariableTypedValue$_(t) {
            const s = this._$_instVarValues$_[t];
            return 0 === this._$_objectType$_._$GetInstanceVariableType$_(t) ? !!s : s;
        }
        _$SetInstanceVariableValue$_(t, s) {
            t |= 0;
            const i = this._$_instVarValues$_;
            if (t < 0 || t >= i.length) throw new RangeError("invalid instance variable");
            switch (this._$_objectType$_._$GetInstanceVariableType$_(t)) {
              case 0:
                i[t] = s ? 1 : 0;
                break;

              case 1:
                i[t] = "number" == typeof s ? s : parseFloat(s);
                break;

              case 2:
                i[t] = "string" == typeof s ? s : s.toString();
                break;

              default:
                throw new Error("unknown instance variable type");
            }
        }
        _$SetInstanceVariableOffset$_(t, s) {
            if (0 === s) return;
            t |= 0;
            const i = this._$_instVarValues$_;
            if (t < 0 || t >= i.length) throw new RangeError("invalid instance variable");
            const e = i[t];
            if ("number" != typeof e) throw "boolean" == typeof e ? new Error("can not set offset of boolean variable") : "string" == typeof e ? new Error("can not set offset of string variable") : new Error("unknown instance variable type");
            i[t] += "number" == typeof s ? s : parseFloat(s);
        }
        _$GetSavedDataMap$_() {
            let t = KM.get(this);
            return t || (t = new Map, KM.set(this, t), t);
        }
        _$GetUnsavedDataMap$_() {
            let t = $M.get(this);
            return t || (t = new Map, $M.set(this, t), t);
        }
        _$_HasAnyCreateDestroyHandler$_(t) {
            const s = this._$GetObjectClass$_();
            if (s._$UserScriptDispatcher$_()._$HasAnyHandlerFor$_(t)) return !0;
            for (const i of s._$GetFamilies$_()) if (i._$UserScriptDispatcher$_()._$HasAnyHandlerFor$_(t)) return !0;
            return !!this._$_runtime$_._$UserScriptDispatcher$_()._$HasAnyHandlerFor$_(t);
        }
        _$_TriggerOnCreatedOnSelfAndRelated$_() {
            const t = new Set;
            t.add(this);
            const s = this._$GetWorldInfo$_();
            if (s && s._$HasChildren$_()) for (const s of this._$allChildren$_()) if (t.add(s), 
            s._$IsInContainer$_()) for (const i of s._$siblings$_()) t.add(i);
            if (this._$IsInContainer$_()) for (const s of this._$siblings$_()) t.add(s);
            for (const s of t.values()) s._$_TriggerOnCreated$_();
            this._$_OnHierarchyReady$_();
        }
        _$_OnCreatedCommon$_() {
            this._$_objectType$_._$_GetUserScriptInstanceClass$_() && this._$GetInterfaceClass$_();
            for (const t of this._$_behaviorInstances$_) t._$PostCreate$_();
        }
        _$_OnCreatedForLoadingSavegame$_() {
            this._$_OnCreatedCommon$_();
        }
        _$_TriggerOnCreated$_() {
            if (this._$_OnCreatedCommon$_(), this._$_HasAnyCreateDestroyHandler$_("instancecreate")) {
                const t = this._$GetObjectClass$_(), s = new VM.Event("instancecreate");
                s._$instance$_ = this._$GetInterfaceClass$_(), t._$DispatchUserScriptEvent$_(s);
                for (const i of t._$GetFamilies$_()) i._$DispatchUserScriptEvent$_(s);
                this._$_runtime$_._$DispatchUserScriptEvent$_(s);
            }
            this._$_runtime$_._$Trigger$_(this._$GetPlugin$_()._$GetConstructor$_()._$Cnds$_._$OnCreated$_, this, null);
        }
        _$_OnHierarchyReady$_() {
            if (this._$GetPlugin$_()._$SupportsSceneGraph$_()) {
                if (this._$DispatchUserScriptEvent$_(new VM.Event("hierarchyready")), this._$_HasAnyCreateDestroyHandler$_("hierarchyready")) {
                    const t = this._$GetObjectClass$_(), s = new VM.Event("hierarchyready");
                    s._$instance$_ = this._$GetInterfaceClass$_(), t._$DispatchUserScriptEvent$_(s);
                    for (const i of t._$GetFamilies$_()) i._$DispatchUserScriptEvent$_(s);
                    this._$_runtime$_._$DispatchUserScriptEvent$_(s);
                }
                this._$_runtime$_._$Trigger$_(this._$GetPlugin$_()._$GetConstructor$_()._$Cnds$_._$OnHierarchyReady$_, this, null);
            }
        }
        _$_TriggerOnDestroyed$_() {
            this._$_runtime$_._$Trigger$_(this._$GetPlugin$_()._$GetConstructor$_()._$Cnds$_._$OnDestroyed$_, this, null);
        }
        _$_FireDestroyedScriptEvents$_(t) {
            if (this._$_iScriptInterface$_) {
                const s = new VM.Event("destroy");
                s._$isEndingLayout$_ = t, this._$DispatchUserScriptEvent$_(s);
            }
            if (!this._$_HasAnyCreateDestroyHandler$_("instancedestroy")) return;
            const s = this._$GetObjectClass$_(), i = new VM.Event("instancedestroy");
            i._$instance$_ = this._$GetInterfaceClass$_(), i._$isEndingLayout$_ = t, s._$DispatchUserScriptEvent$_(i);
            for (const t of s._$GetFamilies$_()) t._$DispatchUserScriptEvent$_(i);
            this._$_runtime$_._$DispatchUserScriptEvent$_(i);
        }
        _$_GetDebuggerProperties$_() {
            return this._$_sdkInst$_ ? this._$_sdkInst$_._$GetDebuggerProperties$_() : this._$_iScriptInterface$_._$_getDebuggerProperties$_();
        }
        _$SaveToJson$_(t = "full", s = null) {
            const i = {};
            "full" === t ? i.uid = this._$GetUID$_() : i.c3 = !0;
            const e = this._$GetTagsSet$_();
            if (e.size > 0 && (i.tags = Array.from(e)), "visual-state" !== t) {
                const s = KM.get(this);
                if (s && s.size && (i.ex = VM._$ToSuperJSON$_(s)), -1 !== this._$GetTimeScale$_() && (i.mts = this._$GetTimeScale$_()), 
                this._$_objectType$_._$GetInstanceVariablesCount$_() > 0) {
                    const t = {}, s = this._$_objectType$_._$GetInstanceVariableSIDs$_();
                    for (let i = 0, e = this._$_instVarValues$_.length; i < e; ++i) t[s[i].toString()] = this._$_instVarValues$_[i];
                    i.ivs = t;
                }
                if (this._$_behaviorInstances$_.length) {
                    const s = {};
                    for (const i of this._$_behaviorInstances$_) {
                        const e = i._$SaveToJson$_(t);
                        e && (s[i._$GetBehaviorType$_()._$GetSID$_().toString()] = e);
                    }
                    i.behs = s;
                }
            }
            this._$_worldInfo$_ && (i.w = this._$_worldInfo$_._$_SaveToJson$_(t, s));
            const n = this._$_sdkInst$_ ? this._$_sdkInst$_._$SaveToJson$_() : this._$_iScriptInterface$_._$_saveToJson$_();
            return n && (i.data = n), i;
        }
        _$_OnBeforeLoad$_(t = "full", s = null) {
            this._$_worldInfo$_ && this._$_worldInfo$_._$_OnBeforeLoad$_(t);
        }
        _$_OnAfterLoad$_(t, s = "full", i = null) {
            this._$_worldInfo$_ && this._$_worldInfo$_._$_OnAfterLoad$_(t, s, i);
        }
        _$_OnAfterLoad2$_(t, s = "full", i = null) {
            this._$_worldInfo$_ && this._$_worldInfo$_._$_OnAfterLoad2$_(t, s, i);
        }
        _$_SetupSceneGraphConnectionsOnChangeOfLayout$_() {
            this._$GetPlugin$_()._$IsWorldType$_() && this._$_worldInfo$_._$_SetupSceneGraphConnectionsOnChangeOfLayout$_();
        }
        _$LoadFromJson$_(t, s = "full", i = null) {
            if ("full" === s) this._$_uid$_ = t.uid; else if (!t.c3) return;
            if (this._$_SetTagsSetFromJson$_(t.tags), "visual-state" !== s) {
                let s = KM.get(this);
                s && (s.clear(), KM.delete(this));
                const i = t.ex;
                i && (s = VM._$FromSuperJSON$_(i), KM.set(this, s)), this._$_timeScale$_ = t.hasOwnProperty("mts") ? t.mts : -1;
                const e = t.ivs;
                if (e) for (const [t, s] of Object.entries(e)) {
                    const i = parseInt(t, 10), e = this._$_objectType$_._$GetInstanceVariableIndexBySID$_(i);
                    if (e < 0 || e >= this._$_instVarValues$_.length) continue;
                    let n = s;
                    null === n && (n = NaN), this._$_instVarValues$_[e] = n;
                }
            }
            if (this._$GetPlugin$_()._$IsWorldType$_()) {
                const e = t.w;
                if (e) {
                    const t = e.l;
                    if (this._$_worldInfo$_._$GetLayer$_()._$GetSID$_() !== t) {
                        const i = this._$_worldInfo$_._$GetLayer$_(), e = i._$GetLayout$_()._$GetLayerBySID$_(t);
                        e ? (this._$_worldInfo$_._$_SetLayer$_(e), i._$_RemoveInstance$_(this, !0), e._$_AddInstance$_(this, !0), 
                        e._$SetZIndicesChanged$_(this), this._$_worldInfo$_._$SetBboxChanged$_()) : "full" === s && this._$_runtime$_._$DestroyInstance$_(this);
                    }
                    this._$_worldInfo$_._$_LoadFromJson$_(e, s, i);
                }
            }
            if ("visual-state" !== s) {
                const i = t.behs;
                if (i) for (const [t, e] of Object.entries(i)) {
                    const i = parseInt(t, 10), n = this._$GetBehaviorIndexBySID$_(i);
                    n < 0 || n >= this._$_behaviorInstances$_.length || this._$_behaviorInstances$_[n]._$LoadFromJson$_(e, s);
                }
            }
            const e = t.data;
            e && (this._$_sdkInst$_ ? this._$_sdkInst$_._$LoadFromJson$_(e, s) : this._$_iScriptInterface$_._$_loadFromJson$_(e));
        }
        _$GetInterfaceClass$_() {
            return this._$_iScriptInterface$_ || this._$_InitUserScriptInterface$_();
        }
        _$HasScriptInterface$_() {
            return !!this._$_iScriptInterface$_;
        }
        _$_InitUserScriptInterface$_(t, s) {
            const i = this._$_worldInfo$_ ? t ? self._$ISDKWorldInstanceBase$_ : self._$IWorldInstance$_ : t ? self._$ISDKInstanceBase$_ : self._$IInstance$_, e = t || this._$_sdkInst$_._$GetScriptInterfaceClass$_(), n = this._$_objectType$_._$_GetUserScriptInstanceClass$_(), h = n || e || i, r = this._$GetPlugin$_()._$GetSdkVersion$_();
            if (VM._$AddonManager$_._$_PushInitObject$_(this, r), VM._$AddonManager$_._$_PushInitProperties$_(s), 
            this._$_iScriptInterface$_ = new h, VM._$AddonManager$_._$_PopInitProperties$_(), 
            VM._$AddonManager$_._$_PopInitObject$_(r), e && !(this._$_iScriptInterface$_ instanceof i)) throw new TypeError(`script interface class '${e.name}' does not extend the right base class '${i.name}'`);
            if (n) {
                const t = e || i;
                if (!(this._$_iScriptInterface$_ instanceof t)) throw new TypeError(`setInstanceClass(): class '${n.name}' does not extend the right base class - check it extends the right class, e.g. globalThis.InstanceType.MyObjectName`);
            }
            return this._$_iScriptInterface$_;
        }
        _$_GetInstVarsScriptDescriptor$_(t) {
            if (0 === this._$_instVarValues$_.length) return;
            const s = {}, i = this._$_objectType$_._$_GetAllInstanceVariableJsPropNames$_();
            for (let t = 0, e = i.length; t < e; ++t) s[i[t]] = {
                configurable: !1,
                enumerable: !0,
                get: VM.Instance.prototype._$_GetInstanceVariableTypedValue$_.bind(this, t),
                set: VM.Instance.prototype._$SetInstanceVariableValue$_.bind(this, t)
            };
            const e = Object.create(Object.prototype, s);
            t._$instVars$_ = {
                value: e,
                writable: !1
            };
        }
        _$_GetBehaviorsScriptDescriptor$_(t) {
            const s = this._$_behaviorInstances$_;
            if (0 === s.length) return;
            const i = {};
            for (const t of s) i[t._$GetBehaviorType$_()._$GetJsPropName$_()] = {
                value: t._$GetScriptInterface$_(),
                writable: !1
            };
            const e = Object.create(Object.prototype, i);
            t._$behaviors$_ = {
                value: e,
                writable: !1
            };
        }
        _$DispatchUserScriptEvent$_(t) {
            if (!this._$HasScriptInterface$_()) return;
            const s = this._$GetInterfaceClass$_();
            t._$instance$_ = s;
            const i = this._$_runtime$_, e = i._$IsDebug$_() && !i._$GetEventSheetManager$_()._$IsInEventEngine$_();
            e && HM._$StartMeasuringScriptTime$_(), s.dispatchEvent(t), e && HM._$AddScriptTime$_();
        }
    };
}

{
    const tw = self._$C3$_;
    tw._$SceneGraphInfo$_ = class extends tw._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_owner$_ = t, this._$_parent$_ = null, this._$_children$_ = [], 
            this._$_startWidth$_ = t._$GetWidth$_(), this._$_startHeight$_ = t._$GetHeight$_(), 
            this._$_startScaleX$_ = 1, this._$_startScaleY$_ = 1, this._$_parentStartAngle$_ = 0, 
            this._$_ownOpacity$_ = 1, this._$_startOpacity$_ = t._$GetOpacity$_(), this._$_tmpSceneGraphChildren$_ = null, 
            this._$_tmpSceneGraphChildrenIndexes$_ = null, this._$_indexInParent$_ = NaN, this._$_originalSizeKnown$_ = !1, 
            this._$_originalWidth$_ = NaN, this._$_originalHeight$_ = NaN, this._$_on_instance_create$_ = s => {
                if (s._$instance$_ !== this._$_parent$_._$GetInstance$_()) return;
                t._$GetRuntime$_()._$Dispatcher$_().removeEventListener("instancecreate", this._$_on_instance_create$_);
                const i = this._$_parent$_._$GetInstance$_()._$GetSdkInstance$_();
                this._$_originalSizeKnown$_ = !!i._$IsOriginalSizeKnown$_(), this._$_originalWidth$_ = this._$_originalSizeKnown$_ ? i._$GetOriginalWidth$_() : NaN, 
                this._$_originalHeight$_ = this._$_originalSizeKnown$_ ? i._$GetOriginalHeight$_() : NaN;
            };
        }
        _$Release$_() {
            this._$_parent$_ = null, this._$_tmpSceneGraphChildren$_ = null, this._$_tmpSceneGraphChildrenIndexes$_ = null, 
            this._$_indexInParent$_ = NaN, this._$_originalSizeKnown$_ = !1, this._$_originalWidth$_ = NaN, 
            this._$_originalHeight$_ = NaN, tw._$clearArray$_(this._$_children$_);
        }
        _$SetParent$_(t) {
            if (this._$_ownOpacity$_ = this._$_owner$_._$GetOpacity$_(), this._$_startOpacity$_ = this._$_ownOpacity$_, 
            this._$_parent$_ = t, this._$_parentStartAngle$_ = t ? t._$GetAngle$_() : 0, this._$_parent$_) {
                const t = this._$_owner$_._$GetRuntime$_();
                if (this._$_parent$_._$GetInstance$_()._$GetPlugin$_()._$GetSdkVersion$_() < 2) {
                    const s = this._$_parent$_._$GetInstance$_()._$GetSdkInstance$_();
                    s ? (this._$_originalSizeKnown$_ = !!s._$IsOriginalSizeKnown$_(), this._$_originalWidth$_ = this._$_originalSizeKnown$_ ? s._$GetOriginalWidth$_() : NaN, 
                    this._$_originalHeight$_ = this._$_originalSizeKnown$_ ? s._$GetOriginalHeight$_() : NaN) : this._$_parent$_._$GetInstance$_()._$IsDestroyed$_() || t._$Dispatcher$_().addEventListener("instancecreate", this._$_on_instance_create$_);
                } else this._$_originalSizeKnown$_ = !1, this._$_originalWidth$_ = NaN, this._$_originalHeight$_ = NaN;
            } else this._$_originalSizeKnown$_ = !1, this._$_originalWidth$_ = NaN, this._$_originalHeight$_ = NaN;
        }
        _$GetParent$_() {
            return this._$_parent$_;
        }
        _$HasChildren$_() {
            return this._$_children$_.length > 0;
        }
        _$GetChildren$_() {
            return this._$_children$_;
        }
        _$_MaybeSortChildren$_() {
            this._$HasChildren$_() && 1 !== this._$_children$_.length && (this._$_tmpSceneGraphChildrenIndexes$_ ? this._$_children$_.sort(((t, s) => {
                const i = this._$_tmpSceneGraphChildrenIndexes$_.get(t._$GetInstance$_()), e = this._$_tmpSceneGraphChildrenIndexes$_.get(s._$GetInstance$_());
                return tw._$IsFiniteNumber$_(i) && tw._$IsFiniteNumber$_(e) ? i - e : 0;
            })) : this._$_children$_.sort(((t, s) => {
                const i = t._$_GetSceneGraphInfo$_()._$_GetIndexInParent$_(), e = s._$_GetSceneGraphInfo$_()._$_GetIndexInParent$_();
                return tw._$IsFiniteNumber$_(i) && tw._$IsFiniteNumber$_(e) ? i - e : 0;
            })));
        }
        _$_GetIndexInParent$_() {
            return this._$_indexInParent$_;
        }
        _$GetStartScaleX$_() {
            return this._$_startScaleX$_;
        }
        _$SetStartScaleX$_(t) {
            this._$_startScaleX$_ = t;
        }
        _$GetStartScaleY$_() {
            return this._$_startScaleY$_;
        }
        _$SetStartScaleY$_(t) {
            this._$_startScaleY$_ = t;
        }
        _$GetStartOpacity$_() {
            return this._$_startOpacity$_;
        }
        _$GetOwnOpacity$_() {
            return this._$_ownOpacity$_;
        }
        _$SetOwnOpacity$_(t) {
            this._$_ownOpacity$_ = t;
        }
        _$_GetStartWidth$_() {
            return 0 === this._$_startWidth$_ ? Number.EPSILON : this._$_startWidth$_;
        }
        _$_GetStartHeight$_() {
            return 0 === this._$_startHeight$_ ? Number.EPSILON : this._$_startHeight$_;
        }
        _$GetParentScaleX$_() {
            if (this._$_owner$_._$GetTransformWithParentWidth$_()) {
                const t = this._$_parent$_;
                let s = t._$GetWidth$_(), i = t._$_GetSceneGraphInfo$_()._$_GetStartWidth$_();
                return 0 === s && (s = Number.EPSILON), i === Number.EPSILON && s === Number.EPSILON ? 1 : i === Number.EPSILON && s !== Number.EPSILON && this._$_originalSizeKnown$_ ? 1 + s / this._$_originalWidth$_ : s / i;
            }
            return 1;
        }
        _$GetParentScaleY$_() {
            if (this._$_owner$_._$GetTransformWithParentHeight$_()) {
                const t = this._$_parent$_;
                let s = t._$GetHeight$_(), i = t._$_GetSceneGraphInfo$_()._$_GetStartHeight$_();
                return 0 === s && (s = Number.EPSILON), i === Number.EPSILON && s === Number.EPSILON ? 1 : i === Number.EPSILON && s !== Number.EPSILON && this._$_originalSizeKnown$_ ? 1 + s / this._$_originalHeight$_ : s / i;
            }
            return 1;
        }
        _$GetParentStartAngle$_() {
            return 0;
        }
        _$_SaveToJsonProperties$_() {
            return {
                sw: this._$_startWidth$_,
                sh: this._$_startHeight$_,
                sx: this._$_startScaleX$_,
                sy: this._$_startScaleY$_,
                psa: this._$_parentStartAngle$_,
                oo: this._$_ownOpacity$_,
                so: this._$_startOpacity$_,
                pi: this._$_owner$_._$GetInstance$_()._$GetIndexInParent$_()
            };
        }
        _$_SaveToJson$_(t, s = null) {
            const i = this._$_SaveToJsonProperties$_();
            return s && s.selfOnly ? Object.assign(i, {
                p: null,
                c: []
            }) : Object.assign(i, {
                p: this._$_GetParentJson$_(t),
                c: this._$_GetChildrenJson$_(t)
            });
        }
        _$_GetFlagsString$_(t) {
            let s = "";
            return t._$GetTransformWithParentX$_() && (s += "x"), t._$GetTransformWithParentY$_() && (s += "y"), 
            t._$GetTransformWithParentWidth$_() && (s += "w"), t._$GetTransformWithParentHeight$_() && (s += "h"), 
            t._$GetTransformWithParentAngle$_() && (s += "a"), t._$GetTransformWithParentZElevation$_() && (s += "z"), 
            t._$GetDestroyWithParent$_() && (s += "d"), t._$GetTransformWithParentOpacity$_() && (s += "o"), 
            t._$GetTransformWithParentVisibility$_() && (s += "v"), s;
        }
        _$_GetParentJson$_(t) {
            return this._$_parent$_ ? !this._$_parent$_._$GetInstance$_() || this._$_parent$_._$GetInstance$_()._$IsDestroyed$_() ? null : this._$_GetInstanceJson$_(this._$_parent$_, this._$_owner$_, t) : null;
        }
        _$_GetChildrenJson$_(t) {
            return this._$_children$_.map((s => this._$_GetInstanceJson$_(s, s, t))).filter((t => t));
        }
        _$_GetInstanceJson$_(t, s, i) {
            const e = t._$GetInstance$_();
            if (e && e._$IsDestroyed$_()) return null;
            const n = {};
            return n.uid = e._$GetUID$_(), n.f = this._$_GetFlagsString$_(s), n.offsets = s._$_SaveSceneGraphPropertiesToJson$_(), 
            n.data = tw._$SceneGraphInfo$_._$GetSceneGraphInstanceDataFromInstance$_(e), n.oci = e._$GetObjectClass$_()._$GetIndex$_(), 
            "state" === i ? (n.inst = e._$SaveToJson$_("full", {
                selfOnly: !0
            }), n.instIndex = NaN) : (n.instIndex = e._$GetObjectClass$_()._$GetInstances$_().indexOf(e), 
            n.inst = null), n;
        }
        _$_LoadFromJson$_(t) {
            this._$_startWidth$_ = t.sw, this._$_startHeight$_ = t.sh, this._$_startScaleX$_ = t.sx, 
            this._$_startScaleY$_ = t.sy, this._$_parentStartAngle$_ = t.psa, this._$_ownOpacity$_ = t.oo, 
            this._$_startOpacity$_ = t.so, this._$_indexInParent$_ = tw._$IsFiniteNumber$_(t.pi) ? t.pi : NaN;
        }
        _$_SetTmpSceneGraphChildren$_(t, s, i, e) {
            if (!t && !s) if (e?._$setFromJson$_) {
                if (this._$_tmpSceneGraphChildren$_) for (const t of this._$_tmpSceneGraphChildren$_) t._$IsDestroyed$_() || t._$HasParent$_() || t._$GetRuntime$_()._$DestroyInstance$_(t);
            } else if (this._$_tmpSceneGraphChildren$_) for (const t of this._$_tmpSceneGraphChildren$_) if (i.c && i.c.length) {
                if (!i.c.some((s => s.uid === t._$GetUID$_()))) continue;
                t._$IsDestroyed$_() || t._$HasParent$_() || t._$GetRuntime$_()._$DestroyInstance$_(t);
            }
            this._$_tmpSceneGraphChildren$_ = t, this._$_tmpSceneGraphChildrenIndexes$_ = s;
        }
        _$_OnAfterLoad$_(t, s) {
            const i = this._$_owner$_, e = i._$GetRuntime$_(), n = new Set;
            if (t.p && !this._$_parent$_) {
                const h = t.p.uid, r = e._$GetInstanceByUID$_(h);
                if (r) {
                    const h = r._$GetWorldInfo$_();
                    r._$HasChild$_(i._$GetInstance$_()) ? this._$_parent$_ = h : (r._$HasChildWithUID$_(i._$GetInstance$_()._$GetUID$_()) ? (e._$DestroyInstance$_(i._$GetInstance$_()), 
                    e._$_RemoveInstanceFromUIDMap$_(i._$GetInstance$_()._$GetUID$_())) : r._$AddChild$_(i._$GetInstance$_(), this._$_GetFlagsObj$_(t.p.f)), 
                    n.has(i) || (i._$_LoadSceneGraphPropertiesFromJson$_(t.p.offsets), this._$_LoadInstancePropertiesFromJson$_(r, t.p, s), 
                    this._$_UpdateUIDInstanceMap$_(i._$GetInstance$_(), i._$GetInstance$_()._$GetUID$_(), i._$GetRuntime$_(), s)), 
                    n.add(i), r._$GetWorldInfo$_()._$_GetSceneGraphInfo$_()._$_MaybeSortChildren$_());
                } else if (tw._$IsFiniteNumber$_(t.p.oci)) {
                    const n = e._$GetObjectClassByIndex$_(t.p.oci), h = (e._$GetSystemPlugin$_(), e._$CreateInstance$_(n, i._$GetLayer$_(), 0, 0, !0));
                    if (h) {
                        const n = this._$_GetInstanceData$_(t.p, e);
                        n && h._$LoadFromJson$_(n), h._$GetWorldInfo$_()._$GetLayer$_()._$SortAndAddInstancesByZIndex$_(h), 
                        h._$AddChild$_(i._$GetInstance$_(), this._$_GetFlagsObj$_(t.p.f)), this._$_UpdateUIDInstanceMap$_(h, h._$GetUID$_(), e, s), 
                        h._$GetWorldInfo$_()._$_GetSceneGraphInfo$_()._$_MaybeSortChildren$_();
                    }
                }
            }
            const h = [];
            for (const s of t.c) {
                const t = s.uid, i = e._$GetInstanceByUID$_(t);
                i && h.push(i);
            }
            let r = 0;
            for (const o of t.c) {
                const a = o.uid, u = e._$GetInstanceByUID$_(a);
                if (u) {
                    if (this._$_tmpSceneGraphChildren$_) {
                        if (this._$_tmpSceneGraphChildren$_.includes(u)) {
                            const e = u;
                            if (e._$GetObjectClass$_() !== u._$GetObjectClass$_()) {
                                r++;
                                continue;
                            }
                            if (e._$IsDestroyed$_()) {
                                r++;
                                continue;
                            }
                            const o = t.c[r];
                            if (!s?._$setFromJson$_ && this._$_HasAllChildrenOfType$_(e, h, i)) {
                                if (i._$GetInstance$_()._$GetChildAt$_(r)) {
                                    const h = e._$GetObjectClass$_()._$GetIndex$_(), a = o.oci, u = i._$GetInstance$_()._$GetChildAt$_(r)._$GetObjectClass$_()._$GetIndex$_();
                                    if (h !== a || a !== u) {
                                        this._$_RefreshAllChildren$_(t.c, i, n, s);
                                        break;
                                    }
                                    this._$_UpdateInstance$_(r, o, i, n, s);
                                } else this._$_UpdateInstance$_(r, o, i, n, s);
                                r++;
                                continue;
                            }
                            if (e._$HasParent$_() && e._$GetParent$_() !== i._$GetInstance$_()) {
                                const t = this._$_CreateNewChildInstance$_(o, s);
                                this._$_AddAndSetChildInstance$_(t, o, n, s), r++;
                                continue;
                            }
                            this._$_AddAndSetChildInstance$_(e._$GetWorldInfo$_(), o, n, s, !0), r++;
                            continue;
                        }
                        if (this._$_tmpSceneGraphChildren$_[r]) {
                            const e = this._$_tmpSceneGraphChildren$_[r];
                            if (e._$GetObjectClass$_() !== u._$GetObjectClass$_()) {
                                r++;
                                continue;
                            }
                            if (e._$IsDestroyed$_()) {
                                r++;
                                continue;
                            }
                            const o = t.c[r];
                            if (!s?._$setFromJson$_ && this._$_HasAllChildrenOfType$_(e, h, i)) {
                                if (i._$GetInstance$_()._$GetChildAt$_(r)) {
                                    const h = e._$GetObjectClass$_()._$GetIndex$_(), a = o.oci, u = i._$GetInstance$_()._$GetChildAt$_(r)._$GetObjectClass$_()._$GetIndex$_();
                                    if (h !== a || a !== u) {
                                        this._$_RefreshAllChildren$_(t.c, i, n, s);
                                        break;
                                    }
                                    this._$_UpdateInstance$_(r, o, i, n, s);
                                } else this._$_UpdateInstance$_(r, o, i, n, s);
                                r++;
                                continue;
                            }
                            if (e._$HasParent$_() && e._$GetParent$_() !== i._$GetInstance$_()) {
                                const t = this._$_CreateNewChildInstance$_(o, s);
                                this._$_AddAndSetChildInstance$_(t, o, n, s), r++;
                                continue;
                            }
                            this._$_AddAndSetChildInstance$_(e._$GetWorldInfo$_(), o, n, s, !0), r++;
                            continue;
                        }
                    }
                    const e = u._$GetObjectClass$_();
                    if (this._$_GetInstancesOfObjectClassCount$_(h, e) === i._$GetInstance$_()._$GetChildrenOfObjectClass$_(e).length) {
                        const t = i._$GetInstance$_()._$GetChildAt$_(r);
                        if (t) {
                            const i = t._$GetWorldInfo$_();
                            i && (n.has(i) || (i._$_LoadSceneGraphPropertiesFromJson$_(o.offsets), this._$_LoadInstancePropertiesFromJson$_(t, o, s)), 
                            n.add(i));
                        }
                        r++;
                        continue;
                    }
                    if (u._$HasParent$_() && u._$GetParent$_() !== i._$GetInstance$_()) {
                        const t = this._$_CreateNewChildInstance$_(o, s);
                        this._$_AddAndSetChildInstance$_(t, o, n, s), r++;
                        continue;
                    }
                    this._$_AddAndSetChildInstance$_(u._$GetWorldInfo$_(), o, n, s);
                } else if (this._$_tmpSceneGraphChildren$_ && this._$_tmpSceneGraphChildren$_[r]) {
                    const a = this._$_tmpSceneGraphChildren$_[r], u = e._$GetObjectClassByIndex$_(this._$_GetObjectClassIndex$_(o));
                    if (a._$GetObjectClass$_() !== u) {
                        r++;
                        continue;
                    }
                    if (a._$IsDestroyed$_()) {
                        r++;
                        continue;
                    }
                    const l = t.c[r];
                    if (!s?._$setFromJson$_ && this._$_HasAllChildrenOfType$_(a, h, i)) {
                        if (i._$GetInstance$_()._$GetChildAt$_(r)) {
                            const e = a._$GetObjectClass$_()._$GetIndex$_(), h = l.oci, o = i._$GetInstance$_()._$GetChildAt$_(r)._$GetObjectClass$_()._$GetIndex$_();
                            if (e !== h || h !== o) {
                                this._$_RefreshAllChildren$_(t.c, i, n, s);
                                break;
                            }
                            this._$_UpdateInstance$_(r, l, i, n, s);
                        } else this._$_UpdateInstance$_(r, l, i, n, s);
                        r++;
                        continue;
                    }
                    if (a._$HasParent$_() && a._$GetParent$_() !== i._$GetInstance$_()) {
                        const t = this._$_CreateNewChildInstance$_(l, s);
                        this._$_AddAndSetChildInstance$_(t, l, n, s), r++;
                        continue;
                    }
                    this._$_AddAndSetChildInstance$_(a._$GetWorldInfo$_(), l, n, s);
                } else {
                    const t = this._$_CreateNewChildInstance$_(o, s);
                    this._$_AddAndSetChildInstance$_(t, o, n, s);
                }
                r++;
            }
        }
        _$_RefreshAllChildren$_(t, s, i, e) {
            const n = s._$GetRuntime$_();
            for (const t of s._$GetInstance$_().children()) t && !t._$IsDestroyed$_() && (n._$DestroyInstance$_(t), 
            n._$_RemoveInstanceFromUIDMap$_(t._$GetUID$_()));
            this._$_tmpSceneGraphChildren$_ && (this._$_tmpSceneGraphChildren$_ = []), this._$_tmpSceneGraphChildrenIndexes$_ && (this._$_tmpSceneGraphChildrenIndexes$_ = new WeakMap);
            for (const s of t) {
                const t = this._$_CreateNewChildInstance$_(s, e);
                this._$_AddAndSetChildInstance$_(t, s, i, e), this._$_tmpSceneGraphChildren$_.push(t._$GetInstance$_()), 
                this._$_tmpSceneGraphChildrenIndexes$_.set(t._$GetInstance$_(), this._$_tmpSceneGraphChildren$_.length - 1);
            }
            s._$_GetSceneGraphInfo$_()._$_MaybeSortChildren$_();
        }
        _$_HasAllChildrenOfType$_(t, s, i) {
            const e = t._$GetObjectClass$_();
            return this._$_GetInstancesOfObjectClassCount$_(s, e) === i._$GetInstance$_()._$GetChildrenOfObjectClass$_(e).length;
        }
        _$_UpdateInstance$_(t, s, i, e, n) {
            const h = i._$GetInstance$_()._$GetChildAt$_(t);
            if (!h) return;
            const r = h._$GetWorldInfo$_();
            r && (e.has(r) || (r._$_LoadSceneGraphPropertiesFromJson$_(s.offsets), this._$_LoadInstancePropertiesFromJson$_(h, s, n)), 
            e.add(r));
        }
        _$_GetFlagsObj$_(t) {
            const s = {};
            return s._$transformX$_ = t.includes("x"), s._$transformY$_ = t.includes("y"), s._$transformWidth$_ = t.includes("w"), 
            s._$transformHeight$_ = t.includes("h"), s._$transformAngle$_ = t.includes("a"), 
            s._$transformZElevation$_ = t.includes("z"), s._$destroyWithParent$_ = t.includes("d"), 
            s._$transformOpacity$_ = t.includes("o"), s._$transformVisibility$_ = t.includes("v"), 
            s;
        }
        _$_GetObjectClassIndex$_(t) {
            return tw._$IsFiniteNumber$_(t.oci) ? t.oci : t[1];
        }
        _$_CreateNewChildInstance$_(t, s) {
            if (!tw._$IsFiniteNumber$_(t.oci)) return;
            const i = this._$_owner$_, e = i._$GetRuntime$_();
            let n;
            if (t.data) n = e._$CreateInstanceFromData$_(t.data, i._$GetLayer$_(), !1, 0, 0, !1, !0); else {
                const s = e._$GetObjectClassByIndex$_(t.oci);
                n = e._$CreateInstance$_(s, i._$GetLayer$_(), 0, 0, !0);
            }
            if (!n) return;
            const h = this._$_GetInstanceData$_(t, e);
            h && n._$LoadFromJson$_(h);
            const r = n._$GetWorldInfo$_();
            return r._$GetLayer$_()._$SortAndAddInstancesByZIndex$_(n, !0), r;
        }
        _$_UpdateUIDInstanceMap$_(t, s, i, e) {
            if (i._$GetInstanceByUID$_(s)) {
                if (!e?._$setFromJson$_) {
                    const e = i._$GetInstanceByUID$_(s);
                    e !== t && i._$DestroyInstance$_(e);
                }
                i._$_RemoveInstanceFromUIDMap$_(s);
            }
            i._$_MapInstanceByUID$_(s, t);
        }
        _$_AddAndSetChildInstance$_(t, s, i, e, n = !0) {
            const h = this._$_owner$_, r = h._$AddChild$_(t, this._$_GetFlagsObj$_(s.f));
            r && n ? (i.has(t) || (t._$_LoadSceneGraphPropertiesFromJson$_(s.offsets), this._$_LoadInstancePropertiesFromJson$_(t._$GetInstance$_(), s, e)), 
            i.add(t)) : r && this._$_UpdateUIDInstanceMap$_(t._$GetInstance$_(), s.uid, h._$GetRuntime$_(), e), 
            this._$_MaybeSortChildren$_();
        }
        _$_LoadInstancePropertiesFromJson$_(t, s, i) {
            let e = this._$_GetInstanceData$_(s, this._$_owner$_._$GetRuntime$_());
            if (!e) return;
            const n = t._$GetRuntime$_();
            e = JSON.parse(JSON.stringify(e));
            const h = e.w?.zi;
            e.w = null, t._$LoadFromJson$_(e), tw._$IsFiniteNumber$_(h) && t._$GetWorldInfo$_()._$_SetZIndex$_(h), 
            this._$_UpdateUIDInstanceMap$_(t, e.uid, n, i);
        }
        _$_GetInstancesOfObjectClassCount$_(t, s) {
            return t.filter((t => t._$GetObjectClass$_()._$GetName$_() === s._$GetName$_())).length;
        }
        _$_GetInstanceData$_(t, s) {
            if (tw._$IsFiniteNumber$_(t.instIndex)) {
                const i = s._$GetObjectClassByIndex$_(t.oci)._$_GetLoadInstancesJson$_();
                return i ? i[t.instIndex] : null;
            }
            return tw._$IsString$_(t.inst) ? JSON.parse(t.inst) : t.inst ? t.inst : void 0;
        }
        static _$GetSceneGraphInstanceDataFromInstance$_(t) {
            let s = t._$GetWorldInfo$_()._$GetLayer$_()._$GetInitialInstanceData$_(t._$GetUID$_());
            if (!s) return null;
            s = JSON.parse(JSON.stringify(s));
            const i = [];
            for (const s of [ ...t._$GetChildren$_() ]) {
                const t = s._$GetWorldInfo$_();
                i.push([ t._$GetLayout$_()._$GetSID$_(), t._$GetLayer$_()._$GetIndex$_(), s._$GetUID$_(), tw._$SceneGraphInfo$_._$_GetFlagsNumber$_(t), s._$GetObjectClass$_()._$IsInContainer$_() ? 1 : 0, t._$GetZIndex$_(), tw._$SceneGraphInfo$_._$GetSceneGraphInstanceDataFromInstance$_(s) ]);
            }
            return tw._$IsArray$_(s[0][14]) ? s[0][14][1] = i : (s[0][14] = [], s[0][14][0] = tw._$SceneGraphInfo$_._$_GetDefaultFlagsNumber$_(), 
            s[0][14][1] = i, s[0][14][2] = t._$GetWorldInfo$_()._$GetZIndex$_()), s;
        }
        static _$_GetFlagsNumber$_(t) {
            let s = 0;
            return s |= Number(t._$GetTransformWithParentVisibility$_()) << 8, s |= Number(t._$GetTransformWithParentOpacity$_()) << 7, 
            s |= Number(t._$GetTransformWithParentZElevation$_()) << 6, s |= Number(t._$GetDestroyWithParent$_()) << 5, 
            s |= Number(t._$GetTransformWithParentAngle$_()) << 4, s |= Number(t._$GetTransformWithParentHeight$_()) << 3, 
            s |= Number(t._$GetTransformWithParentWidth$_()) << 2, s |= Number(t._$GetTransformWithParentY$_()) << 1, 
            s |= 0 | Number(t._$GetTransformWithParentX$_()), s;
        }
        static _$_GetDefaultFlagsNumber$_(t) {
            let s = 0;
            return s |= 256, s |= 128, s |= 64, s |= 32, s |= 16, s |= 8, s |= 4, s |= 2, s |= 1, 
            511;
        }
    };
}

{
    const sw = self._$C3$_, iw = self._$glMatrix$_, ew = (iw._$vec3$_, iw._$vec4$_, 
    sw._$New$_(sw.Rect)), nw = sw._$New$_(sw._$Quad$_), hw = sw._$New$_(sw.Event, "bboxchange", !1), rw = sw._$New$_(sw._$Color$_, 0, 0, 0, 0), ow = sw._$New$_(sw._$CollisionPoly$_), aw = sw._$New$_(sw._$Color$_, 1, 1, 1, 1), uw = sw._$New$_(sw.Rect, 0, 0, -1, -1), lw = sw._$New$_(sw.Rect, 0, 0, -1, -1), cw = new Set([ "absolute", "relative" ]), fw = [];
    let dw = !0;
    const pw = new WeakMap, mw = new WeakMap;
    sw._$WorldInfo$_ = class extends sw._$DefendedBase$_ {
        constructor(t, s) {
            super(), this._$_inst$_ = t, this._$_objectClass$_ = t._$GetObjectClass$_(), this._$_runtime$_ = t._$GetRuntime$_(), 
            this._$_layer$_ = s, this._$_objectClass$_._$_OnWorldInstanceLayerChanged$_(this, null, s), 
            this._$_zIndex$_ = -1, this._$_htmlZIndex$_ = -1, this._$_flags$_ = 196635, this._$_objectClass$_._$GetPlugin$_()._$IsRotatable$_() && (this._$_flags$_ |= 128), 
            this._$_x$_ = NaN, this._$_y$_ = NaN, this._$_zElevation$_ = NaN, this._$_w$_ = NaN, 
            this._$_h$_ = NaN, this._$_depth$_ = NaN, this._$_a$_ = NaN, this._$_sinA$_ = NaN, 
            this._$_cosA$_ = NaN, this._$_ox$_ = NaN, this._$_oy$_ = NaN, this._$_boundingBox$_ = sw._$New$_(sw.Rect), 
            this._$_boundingQuad$_ = sw._$New$_(sw._$Quad$_), this._$_collisionCells$_ = lw, 
            this._$_renderCells$_ = uw, this._$_sourceCollisionPoly$_ = null, this._$_transformedPolyInfo$_ = null, 
            this._$_solidFilterTags$_ = null, this._$_color$_ = aw, this._$_colorPremultiplied$_ = aw, 
            this._$_stateGroup$_ = null, this._$_instanceEffectList$_ = null, this._$_inst$_._$GetObjectClass$_()._$UsesEffects$_() && (this._$_instanceEffectList$_ = sw._$New$_(sw._$InstanceEffectList$_, this._$_inst$_, this)), 
            this._$_sceneGraphInfo$_ = null, this._$_tmpSceneGraphChildren$_ = null, this._$_tmpSceneGraphChildrenIndexes$_ = null, 
            this._$_tmpHierarchyPosition$_ = -1, this._$_meshInfo$_ = null;
        }
        _$_MarkDestroyed$_() {
            this._$_flags$_ |= 256;
        }
        _$Release$_() {
            if (this._$_objectClass$_._$_OnWorldInstanceLayerChanged$_(this, this._$_layer$_, null), 
            this._$_stateGroup$_ && (this._$_runtime$_._$GetRenderer$_()._$ReleaseStateGroup$_(this._$_stateGroup$_), 
            this._$_stateGroup$_ = null), this._$_sourceCollisionPoly$_ = null, this._$_transformedPolyInfo$_ && (this._$_transformedPolyInfo$_._$poly$_._$Release$_(), 
            this._$_transformedPolyInfo$_ = null), this._$_solidFilterTags$_ && (this._$_solidFilterTags$_.clear(), 
            this._$_solidFilterTags$_ = null), this._$ReleaseMesh$_(), this._$_instanceEffectList$_ && this._$_instanceEffectList$_._$Release$_(), 
            this._$HasParent$_() && this._$GetParent$_()._$RemoveChild$_(this), this._$HasChildren$_()) {
                const t = [ ...this._$GetChildren$_() ];
                for (const s of t) this._$RemoveChild$_(s);
            }
            this._$_ReleaseSceneGraphInfo$_(), this._$_ReleaseTmpSceneGraphInfo$_(), pw.delete(this), 
            mw.delete(this), this._$_inst$_ = null, this._$_objectClass$_ = null, this._$_runtime$_ = null, 
            this._$_layer$_ = null;
        }
        _$Init$_(t) {
            if (dw = !1, this._$SetXY$_(t[0], t[1]), this._$SetZElevation$_(t[2]), this._$SetSize$_(t[3], t[4]), 
            this._$_depth$_ = 0, this._$IsRotatable$_() ? this._$SetAngle$_(t[6]) : this._$_a$_ = 0, 
            rw._$setFromJSON$_(t[7]), this._$_SetColor$_(rw), this._$SetOriginX$_(t[8]), this._$SetOriginY$_(t[9]), 
            this._$SetBlendMode$_(t[10]), this._$_instanceEffectList$_ && this._$_instanceEffectList$_._$_LoadEffectParameters$_(t[12]), 
            t[14] && pw.set(this, {
                _$childrenData$_: t[14][1],
                _$zIndexData$_: t[14][2]
            }), t[15]) {
                const s = t[15];
                this._$CreateMesh$_(s[0], s[1]);
                const i = this._$GetSourceMesh$_(), e = s[2];
                for (let t = 0, s = e.length; t < s; ++t) {
                    const s = e[t];
                    for (let e = 0, n = s.length; e < n; ++e) {
                        const n = s[e], h = i._$GetMeshPointAt$_(e, t);
                        h._$SetX$_(n[0]), h._$SetY$_(n[1]), h._$SetZElevation$_(n[2]), h._$SetU$_(n[3]), 
                        h._$SetV$_(n[4]);
                    }
                }
            }
            if (t[16]) {
                const s = t[16][0], i = t[16][1], e = !!i, n = !e, h = this._$_runtime$_._$GetTemplateManager$_();
                e && h && h._$MapInstanceToTemplateName$_(this._$GetInstance$_(), i), n && h && h._$MapInstanceToTemplateName$_(this._$GetInstance$_(), s);
            }
            dw = !0, this._$_UpdateRendererStateGroup$_();
        }
        _$InitNoData$_() {
            this._$_x$_ = 0, this._$_y$_ = 0, this._$_zElevation$_ = 0, this._$_w$_ = 0, this._$_h$_ = 0, 
            this._$_depth$_ = 0, this._$_a$_ = 0, this._$_sinA$_ = 0, this._$_cosA$_ = 1, this._$_ox$_ = 0, 
            this._$_oy$_ = 0, this._$_UpdateRendererStateGroup$_();
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetObjectClass$_() {
            return this._$_objectClass$_;
        }
        _$GetInstance$_() {
            return this._$_inst$_;
        }
        _$_GetParentOffsetAngle$_() {
            return this._$GetTransformWithParentAngle$_() ? this._$_MaybeReflectAngleForMirrorFlip$_(this._$GetParent$_()._$_GetAngleNoReflect$_() - this._$_sceneGraphInfo$_._$GetParentStartAngle$_()) : 0;
        }
        _$SetX$_(t) {
            if (t = +t, this._$GetTransformWithParentX$_()) {
                const s = this._$_sceneGraphInfo$_, i = t - this._$GetX$_(), e = -this._$_GetParentOffsetAngle$_();
                0 === e ? this._$_x$_ += i / s._$GetParentScaleX$_() : (this._$_x$_ += Math.cos(e) * i / s._$GetParentScaleX$_(), 
                this._$GetTransformWithParentY$_() && (this._$_y$_ += Math.sin(e) * i / s._$GetParentScaleY$_()));
            } else this._$_x$_ = t;
        }
        _$OffsetX$_(t, s = !1) {
            t = +t, s ? this._$_x$_ += t : this._$GetTransformWithParentX$_() ? this._$SetX$_(this._$GetX$_() + t) : this._$_x$_ += t;
        }
        _$GetX$_() {
            if (this._$GetTransformWithParentX$_()) {
                let t = this._$_x$_;
                const s = this._$_sceneGraphInfo$_, i = this._$GetParent$_(), e = this._$_GetParentOffsetAngle$_();
                return 0 === e ? t *= s._$GetParentScaleX$_() : (t = t * s._$GetParentScaleX$_() * Math.cos(e), 
                this._$GetTransformWithParentY$_() && (t -= this._$_y$_ * s._$GetParentScaleY$_() * Math.sin(e))), 
                i._$GetX$_() + t;
            }
            return this._$_x$_;
        }
        _$SetY$_(t) {
            if (t = +t, this._$GetTransformWithParentY$_()) {
                const s = this._$_sceneGraphInfo$_, i = t - this._$GetY$_(), e = -this._$_GetParentOffsetAngle$_();
                0 === e ? this._$_y$_ += i / s._$GetParentScaleY$_() : (this._$GetTransformWithParentX$_() && (this._$_x$_ -= Math.sin(e) * i / s._$GetParentScaleX$_()), 
                this._$_y$_ += Math.cos(e) * i / s._$GetParentScaleY$_());
            } else this._$_y$_ = t;
        }
        _$OffsetY$_(t, s = !1) {
            t = +t, s ? this._$_y$_ += t : this._$GetTransformWithParentY$_() ? this._$SetY$_(this._$GetY$_() + t) : this._$_y$_ += t;
        }
        _$GetY$_() {
            if (this._$GetTransformWithParentY$_()) {
                let t = this._$_y$_;
                const s = this._$_sceneGraphInfo$_, i = this._$GetParent$_(), e = this._$_GetParentOffsetAngle$_();
                return 0 === e ? t *= s._$GetParentScaleY$_() : (t = t * s._$GetParentScaleY$_() * Math.cos(e), 
                this._$GetTransformWithParentX$_() && (t += this._$_x$_ * s._$GetParentScaleX$_() * Math.sin(e))), 
                i._$GetY$_() + t;
            }
            return this._$_y$_;
        }
        _$SetXY$_(t, s) {
            if (t = +t, s = +s, this._$GetTransformWithParentXOrY$_()) {
                const i = this._$GetTransformWithParentX$_(), e = this._$GetTransformWithParentY$_(), n = this._$_sceneGraphInfo$_, h = t - this._$GetX$_(), r = s - this._$GetY$_(), o = -this._$_GetParentOffsetAngle$_();
                if (0 === o) i ? this._$_x$_ += h / n._$GetParentScaleX$_() : this._$_x$_ = t, e ? this._$_y$_ += r / n._$GetParentScaleY$_() : this._$_y$_ = s; else {
                    const a = Math.sin(o), u = Math.cos(o);
                    i ? this._$_x$_ += e ? (u * h - a * r) / n._$GetParentScaleX$_() : u * h / n._$GetParentScaleX$_() : this._$_x$_ = t, 
                    e ? this._$_y$_ += i ? (a * h + u * r) / n._$GetParentScaleY$_() : u * r / n._$GetParentScaleY$_() : this._$_y$_ = s;
                }
            } else this._$_x$_ = t, this._$_y$_ = s;
        }
        _$GetXY$_() {
            return [ this._$GetX$_(), this._$GetY$_() ];
        }
        _$OffsetXY$_(t, s) {
            t = +t, s = +s, this._$GetTransformWithParentXOrY$_() ? this._$SetXY$_(this._$GetX$_() + t, this._$GetY$_() + s) : (this._$_x$_ += t, 
            this._$_y$_ += s);
        }
        _$EqualsXY$_(t, s) {
            return this._$GetX$_() === t && this._$GetY$_() === s;
        }
        _$SetZElevation$_(t) {
            if (t = +t, this._$GetTransformWithParentZElevation$_() && (t -= this._$GetParent$_()._$GetZElevation$_()), 
            this._$_zElevation$_ === t) return;
            this._$_zElevation$_ = t, this._$_UpdateZElevation$_();
            const s = this._$GetLayer$_();
            0 !== this._$_zElevation$_ && s._$_SetAnyInstanceZElevated$_(), s._$SetZIndicesChanged$_(this);
        }
        _$_UpdateZElevation$_() {
            if (this._$_UpdateRendererStateGroup$_(), this._$HasChildren$_()) {
                const t = this._$GetChildren$_();
                for (let s = 0, i = t.length; s < i; s++) {
                    const i = t[s];
                    i._$GetTransformWithParentZElevation$_() && i._$_UpdateZElevation$_();
                }
            }
        }
        _$OffsetZElevation$_(t) {
            this._$SetZElevation$_(this._$GetZElevation$_() + t);
        }
        _$GetZElevation$_() {
            return this._$GetTransformWithParentZElevation$_() ? this._$GetParent$_()._$GetZElevation$_() + this._$_zElevation$_ : this._$_zElevation$_;
        }
        _$GetTotalZElevation$_() {
            return this._$GetLayer$_()._$GetZElevation$_() + this._$GetZElevation$_();
        }
        _$IsOriginalSizeKnown$_() {
            return this._$GetInstance$_()._$GetPlugin$_()._$GetSdkVersion$_() < 2 && this._$GetInstance$_()._$GetSdkInstance$_()._$IsOriginalSizeKnown$_();
        }
        _$SetWidth$_(t) {
            if (t = +t, this._$GetTransformWithParentWidth$_()) {
                const s = this._$GetWidth$_();
                0 === s ? this._$_w$_ = Number.EPSILON : this._$_w$_ *= t / s;
            } else this._$_w$_ = t;
            this._$_MarkSinCosAngleChanged$_();
        }
        _$OffsetWidth$_(t, s) {
            t = +t, s ? this._$_w$_ += t : this._$GetTransformWithParentWidth$_() ? this._$SetWidth$_(this._$GetWidth$_() + t) : this._$_w$_ += t, 
            this._$_MarkSinCosAngleChanged$_();
        }
        _$GetWidth$_() {
            if (this._$GetTransformWithParentWidth$_()) {
                const t = this._$GetParent$_(), s = t._$GetWidth$_();
                return t._$_GetSceneGraphInfo$_()._$_GetStartWidth$_() === Number.EPSILON ? (this._$_GetSceneGraphInfo$_()._$_GetStartWidth$_() + s) * this._$_w$_ : s * this._$_w$_;
            }
            return this._$_w$_;
        }
        _$SetHeight$_(t) {
            if (t = +t, this._$GetTransformWithParentHeight$_()) {
                const s = this._$GetHeight$_();
                0 === s ? this._$_h$_ = Number.EPSILON : this._$_h$_ *= t / s;
            } else this._$_h$_ = t;
            this._$_MarkSinCosAngleChanged$_();
        }
        _$OffsetHeight$_(t, s) {
            t = +t, s ? this._$_h$_ += t : this._$GetTransformWithParentHeight$_() ? this._$SetHeight$_(this._$GetHeight$_() + t) : this._$_h$_ += t, 
            this._$_MarkSinCosAngleChanged$_();
        }
        _$GetHeight$_() {
            if (this._$GetTransformWithParentHeight$_()) {
                const t = this._$GetParent$_(), s = t._$GetHeight$_();
                return t._$_GetSceneGraphInfo$_()._$_GetStartHeight$_() === Number.EPSILON ? (this._$_GetSceneGraphInfo$_()._$_GetStartHeight$_() + s) * this._$_h$_ : s * this._$_h$_;
            }
            return this._$_h$_;
        }
        _$SetSize$_(t, s) {
            if (t = +t, s = +s, this._$GetTransformWithParentWidth$_()) {
                const s = this._$GetWidth$_();
                0 === s ? this._$_w$_ = Number.EPSILON : this._$_w$_ *= t / s;
            } else this._$_w$_ = t;
            if (this._$GetTransformWithParentHeight$_()) {
                const t = this._$GetHeight$_();
                0 === t ? this._$_h$_ = Number.EPSILON : this._$_h$_ *= s / t;
            } else this._$_h$_ = s;
            this._$_MarkSinCosAngleChanged$_();
        }
        _$GetSize$_() {
            return [ this._$GetWidth$_(), this._$GetHeight$_() ];
        }
        _$GetDepth$_() {
            return this._$_depth$_;
        }
        _$SetDepth$_(t) {
            if (t < 0) throw new RangeError("invalid depth");
            this._$_depth$_ = t;
        }
        _$GetSceneGraphScale$_() {
            if (this._$HasParent$_()) {
                const t = this._$_sceneGraphInfo$_;
                return Math.min(t._$GetParentScaleX$_(), t._$GetParentScaleY$_());
            }
            return 1;
        }
        _$IsRotatable$_() {
            return !!(128 & this._$_flags$_);
        }
        _$SetAngle$_(t) {
            t = +t, this._$IsRotatable$_() && (this._$GetTransformWithParentAngle$_() && (t -= this._$GetParent$_()._$GetAngle$_()), 
            t = sw._$clampAngle$_(t), this._$_a$_ !== t && (this._$_a$_ = t, this._$_MarkSinCosAngleChanged$_()));
        }
        _$OffsetAngle$_(t) {
            0 != (t = +t) && this._$IsRotatable$_() && (this._$_a$_ = sw._$clampAngle$_(this._$_a$_ + t), 
            this._$_MarkSinCosAngleChanged$_());
        }
        _$_MarkSinCosAngleChanged$_() {
            if (this._$_flags$_ |= 262144, this._$HasChildren$_()) {
                const t = this._$GetChildren$_();
                for (let s = 0, i = t.length; s < i; s++) t[s]._$_MarkSinCosAngleChanged$_();
            }
        }
        _$GetAngle$_() {
            return this._$GetTransformWithParentAngle$_() && this._$IsRotatable$_() ? this._$_MaybeReflectAngleForMirrorFlip$_(sw._$clampAngle$_(this._$GetParent$_()._$_GetAngleNoReflect$_() + this._$_a$_)) : this._$_a$_;
        }
        _$_GetAngleNoReflect$_() {
            return this._$GetTransformWithParentAngle$_() && this._$IsRotatable$_() ? sw._$clampAngle$_(this._$GetParent$_()._$_GetAngleNoReflect$_() + this._$_a$_) : this._$_a$_;
        }
        _$_MaybeReflectAngleForMirrorFlip$_(t) {
            return this._$GetTransformWithParentWidth$_() && this._$GetTopParent$_()._$GetWidth$_() < 0 && (t = sw._$clampAngle$_(sw._$angleReflect$_(t, this._$GetTopParent$_()._$GetAngle$_() + Math.PI))), 
            this._$GetTransformWithParentHeight$_() && this._$GetTopParent$_()._$GetHeight$_() < 0 && (t = sw._$angleReflect$_(t, this._$GetTopParent$_()._$GetAngle$_())), 
            t;
        }
        _$_NeedsReflectAngleForMirrorOrFlip$_() {
            const t = this._$GetParent$_();
            return !!(this._$GetTransformWithParentWidth$_() && t._$GetWidth$_() < 0) || !!(this._$GetTransformWithParentHeight$_() && t._$GetHeight$_() < 0);
        }
        _$_NeedsReflectAngleForMirrorAndFlip$_() {
            const t = this._$GetParent$_();
            return !!(this._$GetTransformWithParentWidth$_() && t._$GetWidth$_() < 0 && this._$GetTransformWithParentHeight$_() && t._$GetHeight$_() < 0);
        }
        _$_MaybeUpdateSinCosAngle$_() {
            const t = this._$_flags$_;
            if (!(262144 & t)) return;
            const s = this._$GetAngle$_();
            this._$_sinA$_ = Math.sin(s), this._$_cosA$_ = Math.cos(s), this._$_flags$_ = -262145 & t;
        }
        _$GetSinAngle$_() {
            return this._$_MaybeUpdateSinCosAngle$_(), this._$_sinA$_;
        }
        _$GetCosAngle$_() {
            return this._$_MaybeUpdateSinCosAngle$_(), this._$_cosA$_;
        }
        _$SetOriginX$_(t) {
            this._$_ox$_ = +t;
        }
        _$OffsetOriginX$_(t) {
            this._$_ox$_ += +t;
        }
        _$GetOriginX$_() {
            return this._$_ox$_;
        }
        _$SetOriginY$_(t) {
            this._$_oy$_ = +t;
        }
        _$OffsetOriginY$_(t) {
            this._$_oy$_ += +t;
        }
        _$GetOriginY$_() {
            return this._$_oy$_;
        }
        _$_SetColor$_(t) {
            this._$_color$_.equals(t) || (this._$_color$_ === aw ? (this._$_color$_ = sw._$New$_(sw._$Color$_, t), 
            this._$_colorPremultiplied$_ = sw._$New$_(sw._$Color$_, t), this._$_colorPremultiplied$_._$premultiply$_()) : t._$equalsRgba$_(1, 1, 1, 1) ? (this._$_color$_ = aw, 
            this._$_colorPremultiplied$_ = aw) : (this._$_color$_.set(t), this._$_colorPremultiplied$_.set(t), 
            this._$_colorPremultiplied$_._$premultiply$_()), this._$_UpdateRendererStateGroup$_());
        }
        _$SetOpacity$_(t) {
            if (t = sw._$clamp$_(+t, 0, 1), this._$GetTransformWithParentOpacity$_()) {
                if (this._$_GetSceneGraphInfo$_()._$GetOwnOpacity$_() === t) return;
                this._$_GetSceneGraphInfo$_()._$SetOwnOpacity$_(t), t = this._$GetOpacity$_();
            } else if (this._$_color$_.a === t) return;
            this._$_SetColorWithOpacity$_(t);
        }
        _$_SetOpacityOfChildren$_() {
            if (!this._$HasChildren$_()) return;
            const t = this._$GetChildren$_();
            for (let s = 0, i = t.length; s < i; s++) {
                const i = t[s];
                i._$_SetColorWithOpacity$_(i._$GetOpacity$_());
            }
        }
        _$_SetColorWithOpacity$_(t) {
            rw._$copyRgb$_(this._$_color$_), rw.a = t, this._$_SetColor$_(rw), this._$_SetOpacityOfChildren$_();
        }
        _$OffsetOpacity$_(t) {
            this._$GetTransformWithParentOpacity$_() ? this._$SetOpacity$_(this._$_GetSceneGraphInfo$_()._$GetOwnOpacity$_() + t) : this._$SetOpacity$_(this._$GetOpacity$_() + t);
        }
        _$GetOpacity$_() {
            return this._$GetTransformWithParentOpacity$_() ? this._$GetParent$_()._$GetOpacity$_() * this._$_GetSceneGraphInfo$_()._$GetOwnOpacity$_() : this._$_color$_.a;
        }
        _$SetUnpremultipliedColor$_(t) {
            this._$_color$_._$equalsIgnoringAlpha$_(t) || (rw._$copyRgb$_(t), rw.a = this._$GetOpacity$_(), 
            this._$_SetColor$_(rw));
        }
        _$SetUnpremultipliedColorRGB$_(t, s, i) {
            rw._$setRgb$_(t, s, i), this._$SetUnpremultipliedColor$_(rw);
        }
        _$OffsetUnpremultipliedColorRGB$_(t, s, i) {
            0 === t && 0 === s && 0 === i || (rw._$copyRgb$_(this._$_color$_), rw.r += t, rw.g += s, 
            rw.b += i, this._$SetUnpremultipliedColor$_(rw));
        }
        _$GetUnpremultipliedColor$_() {
            return this._$_color$_;
        }
        _$GetPremultipliedColor$_() {
            return this._$_colorPremultiplied$_;
        }
        _$GetDestroyWithParent$_() {
            return !!(512 & this._$_flags$_);
        }
        _$SetDestroyWithParent$_(t) {
            this._$_SetFlag$_(512, t);
        }
        _$GetTransformWithParentX$_() {
            return !!(1024 & this._$_flags$_);
        }
        _$SetTransformWithParentX$_(t) {
            this._$_SetFlag$_(1024, t);
        }
        _$GetTransformWithParentY$_() {
            return !!(2048 & this._$_flags$_);
        }
        _$GetTransformWithParentXOrY$_() {
            return !!(3072 & this._$_flags$_);
        }
        _$SetTransformWithParentY$_(t) {
            this._$_SetFlag$_(2048, t);
        }
        _$GetTransformWithParentWidth$_() {
            return !!(4096 & this._$_flags$_);
        }
        _$SetTransformWithParentWidth$_(t) {
            this._$_SetFlag$_(4096, t);
        }
        _$GetTransformWithParentHeight$_() {
            return !!(8192 & this._$_flags$_);
        }
        _$SetTransformWithParentHeight$_(t) {
            this._$_SetFlag$_(8192, t);
        }
        _$GetTransformWithParentAngle$_() {
            return !!(16384 & this._$_flags$_);
        }
        _$SetTransformWithParentAngle$_(t) {
            this._$_SetFlag$_(16384, t);
        }
        _$GetTransformWithParentZElevation$_() {
            return !!(32768 & this._$_flags$_);
        }
        _$SetTransformWithParentZElevation$_(t) {
            this._$_SetFlag$_(32768, t);
        }
        _$GetTransformWithParentOpacity$_() {
            return !!(4194304 & this._$_flags$_);
        }
        _$SetTransformWithParentOpacity$_(t) {
            this._$_SetFlag$_(4194304, t);
        }
        _$GetTransformWithParentVisibility$_() {
            return !!(8388608 & this._$_flags$_);
        }
        _$SetTransformWithParentVisibility$_(t) {
            this._$_SetFlag$_(8388608, t);
        }
        _$_ClearAllSceneGraphFlags$_() {
            this._$_flags$_ &= -12647937;
        }
        _$AddChild$_(t, s) {
            if (t === this) return !1;
            if (t._$HasParent$_()) return !1;
            if (this._$_HasChildRecursive$_(t)) return !1;
            if (this._$_HasAnyParent$_(t)) return !1;
            const i = t._$GetX$_(), e = t._$GetY$_(), n = t._$GetWidth$_(), h = t._$GetHeight$_(), r = t._$GetAngle$_(), o = t._$GetZElevation$_(), a = t._$GetOpacity$_();
            t._$_SetParent$_(this), t._$SetTransformWithParentX$_(s._$transformX$_), t._$SetTransformWithParentY$_(s._$transformY$_), 
            t._$SetTransformWithParentWidth$_(s._$transformWidth$_), t._$SetTransformWithParentHeight$_(s._$transformHeight$_), 
            t._$SetTransformWithParentAngle$_(s._$transformAngle$_), t._$SetTransformWithParentZElevation$_(s._$transformZElevation$_), 
            t._$SetTransformWithParentOpacity$_(s._$transformOpacity$_), t._$SetTransformWithParentVisibility$_(s._$transformVisibility$_), 
            t._$SetDestroyWithParent$_(s._$destroyWithParent$_);
            const u = i - this._$GetX$_(), l = e - this._$GetY$_(), c = -this._$GetAngle$_(), f = Math.cos(c), d = Math.sin(c);
            if (s._$transformX$_ && (s._$transformAngle$_ ? t._$_x$_ = u * f - l * d : t._$_x$_ = u, 
            s._$transformWidth$_)) {
                const s = this._$GetWidth$_() / this._$_sceneGraphInfo$_._$_GetStartWidth$_();
                0 !== s && (t._$_x$_ /= s);
            }
            if (s._$transformY$_ && (s._$transformAngle$_ ? t._$_y$_ = u * d + l * f : t._$_y$_ = l, 
            s._$transformHeight$_)) {
                const s = this._$GetHeight$_() / this._$_sceneGraphInfo$_._$_GetStartHeight$_();
                0 !== s && (t._$_y$_ /= s);
            }
            if (s._$transformWidth$_) {
                const s = this._$GetWidth$_();
                0 === s || s === Number.EPSILON ? (t._$_w$_ = 1, t._$_sceneGraphInfo$_._$SetStartScaleX$_(1)) : (t._$_w$_ = n / this._$GetWidth$_(), 
                t._$_sceneGraphInfo$_._$SetStartScaleX$_(t._$_w$_));
            }
            if (s._$transformHeight$_) {
                const s = this._$GetHeight$_();
                0 === s || s === Number.EPSILON ? (t._$_h$_ = 1, t._$_sceneGraphInfo$_._$SetStartScaleY$_(1)) : (t._$_h$_ = h / this._$GetHeight$_(), 
                t._$_sceneGraphInfo$_._$SetStartScaleY$_(t._$_h$_));
            }
            return s._$transformAngle$_ && (t._$_a$_ = r - this._$GetAngle$_()), s._$transformZElevation$_ && (t._$_zElevation$_ = o - this._$GetZElevation$_()), 
            s._$transformOpacity$_ && t._$_sceneGraphInfo$_._$SetOwnOpacity$_(a), s._$transformVisibility$_ && t._$SetVisible$_(this._$IsVisible$_()), 
            this._$_AddChildToSceneGraphInfo$_(t), this._$SetBboxChanged$_(), this._$_SetOpacityOfChildren$_(), 
            !0;
        }
        _$RemoveChild$_(t) {
            if (t._$GetParent$_() !== this) return;
            const s = t._$GetX$_(), i = t._$GetY$_(), e = t._$GetWidth$_(), n = t._$GetHeight$_(), h = t._$GetAngle$_(), r = t._$GetZElevation$_(), o = t._$GetOpacity$_();
            t._$_SetParent$_(null), t._$_ClearAllSceneGraphFlags$_(), t._$SetXY$_(s, i), t._$SetSize$_(e, n), 
            t._$SetAngle$_(h), t._$SetZElevation$_(r), t._$SetOpacity$_(o), this._$_RemoveChildFromSceneGraphInfo$_(t), 
            this._$SetBboxChanged$_();
        }
        _$GetTmpHierarchyPosition$_() {
            return this._$_tmpHierarchyPosition$_;
        }
        _$_ResetAllSceneGraphState$_() {
            this._$_BuildTmpSceneGraphData$_();
            const t = [ ...this.children() ];
            for (const s of t) this._$RemoveChild$_(s);
            const s = this._$GetParent$_();
            s && s._$RemoveChild$_(this), this._$_ClearAllSceneGraphFlags$_();
        }
        _$_BuildTmpSceneGraphData$_() {
            if (this._$_SetTmpHierarchyPosition$_(), !this._$_tmpSceneGraphChildren$_) {
                const t = [ ...this.children() ];
                t.length && (this._$_tmpSceneGraphChildren$_ = [], this._$_tmpSceneGraphChildrenIndexes$_ = new WeakMap);
                let s = 0;
                for (const i of t) {
                    const t = i._$GetInstance$_();
                    this._$_tmpSceneGraphChildren$_.push(t), this._$_tmpSceneGraphChildrenIndexes$_.set(t, s), 
                    s++;
                }
            }
            const t = this._$GetParent$_();
            t && t._$_BuildTmpSceneGraphData$_();
        }
        _$_SetTmpHierarchyPosition$_() {
            if (-1 !== this._$_tmpHierarchyPosition$_) return;
            const t = [ ...this._$parents$_() ];
            this._$_tmpHierarchyPosition$_ = t.length;
            for (const s of t) s._$_SetTmpHierarchyPosition$_();
            const s = [ ...this.children() ];
            for (const t of s) t._$_SetTmpHierarchyPosition$_();
        }
        _$_ReleaseTmpSceneGraphInfo$_() {
            this._$_tmpSceneGraphChildren$_ && (this._$_tmpSceneGraphChildren$_.length = 0), 
            this._$_tmpSceneGraphChildren$_ = null, this._$_tmpSceneGraphChildrenIndexes$_ = null;
            const t = this._$GetParent$_();
            t && t._$_ReleaseTmpSceneGraphInfo$_(), this._$_tmpHierarchyPosition$_ = -1;
        }
        _$HasParent$_() {
            return null !== this._$GetParent$_();
        }
        _$GetParent$_() {
            const t = this._$_sceneGraphInfo$_;
            return null !== t ? t._$GetParent$_() : null;
        }
        _$GetTopParent$_() {
            let t = this;
            for (;t._$HasParent$_(); ) t = t._$GetParent$_();
            return t;
        }
        * _$parents$_() {
            let t = this._$GetParent$_();
            for (;t; ) yield t, t = t._$GetParent$_();
        }
        _$HasChild$_(t) {
            return this._$GetChildren$_().includes(t);
        }
        _$HasChildren$_() {
            const t = this._$_sceneGraphInfo$_;
            return null !== t && t._$HasChildren$_();
        }
        _$GetChildren$_() {
            const t = this._$_sceneGraphInfo$_;
            return null !== t ? t._$GetChildren$_() : fw;
        }
        children() {
            return this._$GetChildren$_();
        }
        * _$allChildren$_() {
            for (const t of this.children()) yield t, yield* t._$allChildren$_();
        }
        _$GetChildCount$_() {
            return this._$GetChildren$_().length;
        }
        _$GetAllChildCount$_() {
            return [ ...this._$allChildren$_() ].length;
        }
        _$GetChildAt$_(t) {
            const s = this._$GetChildren$_();
            return (t = Math.floor(+t)) < 0 || t >= s.length ? null : s[t];
        }
        _$GetChildIndex$_(t) {
            if (!t) return NaN;
            const s = this._$GetChildren$_();
            if (!s) return NaN;
            for (let i = 0; i < s.length; i++) if (t === s[i]) return i;
            return NaN;
        }
        _$_CreateSceneGraphInfo$_(t) {
            this._$_sceneGraphInfo$_ || (this._$_sceneGraphInfo$_ = sw._$New$_(sw._$SceneGraphInfo$_, this)), 
            t && this._$_sceneGraphInfo$_._$SetParent$_(t);
        }
        _$_GetSceneGraphInfo$_() {
            return this._$_sceneGraphInfo$_;
        }
        _$_ReleaseSceneGraphInfo$_() {
            this._$_sceneGraphInfo$_ && (this._$_sceneGraphInfo$_._$Release$_(), this._$_sceneGraphInfo$_ = null);
        }
        _$_SetParent$_(t) {
            t ? (t._$_CreateSceneGraphInfo$_(null), this._$_CreateSceneGraphInfo$_(t)) : (this._$_sceneGraphInfo$_ && this._$_sceneGraphInfo$_._$SetParent$_(null), 
            this._$HasChildren$_() || this._$_ReleaseSceneGraphInfo$_());
        }
        _$_HasAnyParent$_(t) {
            if (!this._$HasParent$_()) return !1;
            const s = this._$GetParent$_();
            return s === t || s._$_HasAnyParent$_(t);
        }
        _$_HasChildRecursive$_(t) {
            if (this._$HasChild$_(t)) return !0;
            for (const s of this._$GetChildren$_()) if (s._$_HasChildRecursive$_(t)) return !0;
            return !1;
        }
        _$_AddChildToSceneGraphInfo$_(t) {
            this._$_sceneGraphInfo$_._$GetChildren$_().push(t);
        }
        _$_RemoveChildFromSceneGraphInfo$_(t) {
            const s = this._$_sceneGraphInfo$_._$GetChildren$_(), i = s.indexOf(t);
            -1 !== i && s.splice(i, 1), 0 !== s.length || this._$HasParent$_() || this._$_ReleaseSceneGraphInfo$_(), 
            t._$HasChildren$_() || t._$_ReleaseSceneGraphInfo$_();
        }
        _$GetSceneGraphChildrenExportData$_() {
            const t = pw.get(this);
            return t ? t._$childrenData$_ : null;
        }
        _$GetSceneGraphZIndexExportData$_() {
            const t = pw.get(this);
            return t ? t._$zIndexData$_ : NaN;
        }
        _$GetSceneGraphZIndex$_() {
            const t = mw.get(this);
            return sw._$IsFiniteNumber$_(t) ? t : NaN;
        }
        _$SetSceneGraphZIndex$_(t) {
            mw.set(this, t);
        }
        _$SetUsePointsShaderProgram$_() {
            this._$_SetFlag$_(524288, !0), this._$_UpdateRendererStateGroup$_();
        }
        _$_UpdateRendererStateGroup$_() {
            if (!dw) return;
            const t = this._$_runtime$_._$GetRenderer$_();
            let s;
            this._$_stateGroup$_ && t._$ReleaseStateGroup$_(this._$_stateGroup$_), s = 524288 & this._$_flags$_ ? t._$GetPointsRenderingProgram$_() || "<point>" : t._$GetTextureFillShaderProgram$_() || "<default>", 
            this._$_stateGroup$_ = t._$AcquireStateGroup$_(s, this._$GetBlendMode$_(), this._$_colorPremultiplied$_, this._$GetZElevation$_());
        }
        _$GetRendererStateGroup$_() {
            return this._$_stateGroup$_;
        }
        _$HasDefaultColor$_() {
            return this._$_color$_ === aw;
        }
        _$SetBlendMode$_(t) {
            if ((t |= 0) < 0 || t > 31) throw new RangeError("invalid blend mode");
            this._$GetBlendMode$_() !== t && (this._$_flags$_ = -2080374785 & this._$_flags$_ | t << 26, 
            this._$_UpdateRendererStateGroup$_());
        }
        _$GetBlendMode$_() {
            return (2080374784 & this._$_flags$_) >> 26;
        }
        _$_SetLayer$_(t, s) {
            const i = s && this._$_layer$_ !== t;
            i && this._$_RemoveFromRenderCells$_(), this._$_objectClass$_._$_OnWorldInstanceLayerChanged$_(this, this._$_layer$_, t), 
            this._$_layer$_ = t, i && this._$_UpdateRenderCell$_(), 0 !== this._$GetZElevation$_() && this._$_layer$_._$_SetAnyInstanceZElevated$_();
        }
        _$GetLayer$_() {
            return this._$_layer$_;
        }
        _$GetLayout$_() {
            return this._$GetLayer$_()._$GetLayout$_();
        }
        _$_SetZIndex$_(t) {
            this._$_zIndex$_ = 0 | t;
        }
        _$GetZIndex$_() {
            return this._$_layer$_._$_UpdateZIndices$_(), this._$_zIndex$_;
        }
        _$_SetHTMLZIndex$_(t) {
            this._$_htmlZIndex$_ = 0 | t;
        }
        _$GetHTMLZIndex$_() {
            return this._$_layer$_._$_UpdateHTMLZIndices$_(), this._$_htmlZIndex$_;
        }
        _$_GetLastCachedZIndex$_() {
            return this._$_zIndex$_;
        }
        _$_SetFlag$_(t, s) {
            s ? this._$_flags$_ |= t : this._$_flags$_ &= ~t;
        }
        _$IsVisible$_() {
            return !!(1 & this._$_flags$_);
        }
        _$SetVisible$_(t) {
            if (this._$_SetFlag$_(1, t), this._$HasChildren$_()) for (const s of this._$GetChildren$_()) s._$GetTransformWithParentVisibility$_() && s._$SetVisible$_(t);
        }
        _$IsCollisionEnabled$_() {
            return !!(8 & this._$_flags$_);
        }
        _$SetCollisionEnabled$_(t) {
            t = !!t, this._$IsCollisionEnabled$_() !== t && (this._$_SetFlag$_(8, t), t ? this._$SetBboxChanged$_() : this._$_RemoveFromCollisionCells$_());
        }
        _$SetSolidCollisionFilter$_(t, s) {
            if (this._$_SetFlag$_(32, t), this._$_solidFilterTags$_ && this._$_solidFilterTags$_.clear(), 
            s.trim()) {
                this._$_solidFilterTags$_ || (this._$_solidFilterTags$_ = new Set);
                for (const t of s.split(" ")) t && this._$_solidFilterTags$_.add(t.toLowerCase());
            } else this._$_solidFilterTags$_ = null;
        }
        _$IsSolidCollisionAllowed$_(t) {
            const s = !!(32 & this._$_flags$_), i = this._$_solidFilterTags$_;
            if (!t || !i) return !s;
            for (const e of i) if (t.has(e)) return s;
            return !s;
        }
        _$SetBboxChanged$_() {
            if (this._$_flags$_ |= 65554, this._$_objectClass$_._$_SetAnyCollisionCellChanged$_(!0), 
            this._$_runtime$_._$UpdateRender$_(), this._$_layer$_._$UsesRenderCells$_() && (this._$CalculateBbox$_(this._$_boundingBox$_, this._$_boundingQuad$_, !0), 
            this._$_flags$_ &= -3, this._$_UpdateRenderCell$_()), 4 & this._$_flags$_ && this._$_inst$_._$Dispatcher$_().dispatchEvent(hw), 
            null !== this._$_sceneGraphInfo$_) {
                const t = this._$_sceneGraphInfo$_._$GetChildren$_();
                for (let s = 0, i = t.length; s < i; ++s) t[s]._$SetBboxChanged$_();
            }
        }
        _$CalculateBbox$_(t, s, i) {
            const e = this._$GetX$_(), n = this._$GetY$_(), h = this._$GetWidth$_(), r = this._$GetHeight$_(), o = this._$GetAngle$_();
            t._$setWH$_(e - this._$_ox$_ * h, n - this._$_oy$_ * r, h, r), i && this._$HasMesh$_() && this._$_ExpandBboxForMesh$_(t), 
            0 === o ? s._$setFromRect$_(t) : (t.offset(-e, -n), s._$setFromRotatedRectPrecalc$_(t, this._$GetSinAngle$_(), this._$GetCosAngle$_()), 
            s.offset(e, n), s._$getBoundingBox$_(t)), t.normalize();
        }
        _$_UpdateBbox$_() {
            const t = this._$_flags$_;
            2 & t && (this._$CalculateBbox$_(this._$_boundingBox$_, this._$_boundingQuad$_, !0), 
            this._$_flags$_ = -3 & t);
        }
        _$GetBoundingBox$_() {
            return this._$_UpdateBbox$_(), this._$_boundingBox$_;
        }
        _$GetBoundingQuad$_() {
            return this._$_UpdateBbox$_(), this._$_boundingQuad$_;
        }
        _$PixelRoundQuad$_(t) {
            const s = this._$GetX$_(), i = this._$GetY$_(), e = Math.round(s) - s, n = Math.round(i) - i;
            return 0 === e && 0 === n ? t : (nw._$copy$_(t), nw.offset(e, n), nw);
        }
        _$OverwriteBoundingBox$_(t) {
            this._$_boundingBox$_._$copy$_(t), this._$_boundingQuad$_._$setFromRect$_(this._$_boundingBox$_), 
            this._$_flags$_ &= -3, this._$_UpdateCollisionCell$_(), this._$_UpdateRenderCell$_();
        }
        _$SetBboxChangeEventEnabled$_(t) {
            this._$_SetFlag$_(4, t);
        }
        _$IsBboxChangeEventEnabled$_() {
            return !!(4 & this._$_flags$_);
        }
        _$IsInViewport$_(t, s, i) {
            return s && 0 !== this._$GetDepth$_() ? this._$IsInViewport3D$_(this._$GetLayer$_()._$_GetViewFrustum$_()) : 0 === this._$GetZElevation$_() || i ? t._$intersectsRect$_(this._$GetBoundingBox$_()) : this._$_IsInViewport_ZElevated$_();
        }
        _$_IsInViewport_ZElevated$_() {
            const t = this._$GetLayer$_(), s = this._$GetTotalZElevation$_();
            return !(s >= t._$Get2DCameraZ$_()) && (t._$GetViewportForZ$_(s, ew), ew._$intersectsRect$_(this._$GetBoundingBox$_()));
        }
        _$IsInViewport3D$_(t) {
            const s = this._$GetBoundingBox$_(), i = s._$getLeft$_(), e = s._$getRight$_(), n = s._$getTop$_(), h = s._$getBottom$_(), r = this._$GetTotalZElevation$_(), o = r + this._$GetDepth$_();
            return t._$ContainsAABB$_(i, n, r, e, h, o);
        }
        _$IsInViewport2$_() {
            const t = this._$GetLayer$_();
            if (t._$Has3DCamera$_()) return this._$IsInViewport3D$_(t._$_GetViewFrustum$_());
            {
                const s = t._$GetLayout$_();
                return this._$IsInViewport$_(t._$GetViewport$_(), s._$HasVanishingPointOutsideViewport$_(), s._$IsOrthographicProjection$_());
            }
        }
        _$_SetDrawBackFaceOnly$_(t) {
            this._$_SetFlag$_(1048576, t);
        }
        _$_SetDrawNonBackFacesOnly$_(t) {
            this._$_SetFlag$_(2097152, t);
        }
        _$IsDrawBackFaceOnly$_() {
            return !!(1048576 & this._$_flags$_);
        }
        _$IsDrawNonBackFacesOnly$_() {
            return !!(2097152 & this._$_flags$_);
        }
        _$SetSourceCollisionPoly$_(t) {
            this._$_sourceCollisionPoly$_ = t, this._$_DiscardTransformedCollisionPoly$_(), 
            this._$HasMesh$_() && (this._$_meshInfo$_._$meshPoly$_ = null);
        }
        _$GetSourceCollisionPoly$_() {
            return this._$_sourceCollisionPoly$_;
        }
        _$HasOwnCollisionPoly$_() {
            return null !== this._$_sourceCollisionPoly$_ || this._$HasMesh$_();
        }
        _$GetTransformedCollisionPoly$_() {
            return this._$_GetCustomTransformedCollisionPolyPrecalc$_(this._$GetWidth$_(), this._$GetHeight$_(), this._$GetAngle$_(), this._$GetSinAngle$_(), this._$GetCosAngle$_());
        }
        _$GetCustomTransformedCollisionPoly$_(t, s, i) {
            let e = 0, n = 1;
            return 0 !== i && (e = Math.sin(i), n = Math.cos(i)), this._$_GetCustomTransformedCollisionPolyPrecalc$_(t, s, i, e, n);
        }
        _$_GetCustomTransformedCollisionPolyPrecalc$_(t, s, i, e, n) {
            let h = this._$_transformedPolyInfo$_;
            null === h && (h = {
                _$poly$_: sw._$New$_(sw._$CollisionPoly$_),
                width: NaN,
                height: NaN,
                angle: NaN
            }, this._$_transformedPolyInfo$_ = h);
            const r = h._$poly$_;
            if (h.width === t && h.height === s && h.angle === i) return r;
            const o = this._$_sourceCollisionPoly$_;
            if (this._$HasMesh$_()) {
                const i = this._$GetOriginX$_(), h = this._$GetOriginY$_(), a = this._$GetSourceMesh$_();
                let u = this._$_meshInfo$_._$meshPoly$_;
                u || (o ? (ow._$copy$_(o), ow.offset(i, h)) : ow._$setDefaultPoints$_(), u = a._$InsertPolyMeshVertices$_(ow), 
                this._$_meshInfo$_._$meshPoly$_ = u), a._$TransformCollisionPoly$_(u, r), r.offset(-i, -h), 
                r._$transformPrecalc$_(t, s, e, n);
            } else o ? (r._$copy$_(o), r._$transformPrecalc$_(t, s, e, n)) : r._$setFromQuad$_(this._$GetBoundingQuad$_(), -this._$GetX$_(), -this._$GetY$_());
            return h.width = t, h.height = s, h.angle = i, r;
        }
        _$_DiscardTransformedCollisionPoly$_() {
            this._$SetPhysicsBodyChanged$_(!0);
            const t = this._$_transformedPolyInfo$_;
            null !== t && (t.width = NaN);
        }
        _$CreateMesh$_(t, s) {
            if (t = Math.floor(t), s = Math.floor(s), !this._$GetInstance$_()._$GetPlugin$_()._$SupportsMesh$_()) throw new Error("object does not support mesh");
            this._$ReleaseMesh$_(), this._$_meshInfo$_ = {
                _$sourceMesh$_: sw._$New$_(sw._$Gfx$_._$Mesh$_, t, s),
                _$transformedMesh$_: sw._$New$_(sw._$Gfx$_._$Mesh$_, t, s),
                _$meshPoly$_: null
            };
        }
        _$HasMesh$_() {
            return null !== this._$_meshInfo$_;
        }
        _$GetSourceMesh$_() {
            if (!this._$HasMesh$_()) throw new Error("no mesh");
            return this._$_meshInfo$_._$sourceMesh$_;
        }
        _$GetTransformedMesh$_() {
            if (!this._$HasMesh$_()) throw new Error("no mesh");
            return this._$_meshInfo$_._$transformedMesh$_;
        }
        _$SetMeshChanged$_(t) {
            this._$_SetFlag$_(65536, t);
        }
        _$IsMeshChanged$_() {
            return !!(65536 & this._$_flags$_);
        }
        _$SetPhysicsBodyChanged$_(t) {
            this._$_SetFlag$_(131072, t);
        }
        _$IsPhysicsBodyChanged$_() {
            return !!(131072 & this._$_flags$_);
        }
        _$_ExpandBboxForMesh$_(t) {
            const s = this._$_meshInfo$_._$sourceMesh$_, i = Math.min(s._$GetMinX$_(), 0), e = Math.min(s._$GetMinY$_(), 0), n = Math.max(s._$GetMaxX$_(), 1), h = Math.max(s._$GetMaxY$_(), 1), r = t.width(), o = t.height();
            t.offsetLeft(i * r), t.offsetTop(e * o), t._$offsetRight$_((n - 1) * r), t._$offsetBottom$_((h - 1) * o), 
            this._$_depth$_ = s._$GetMaxZ$_();
        }
        _$ReleaseMesh$_() {
            this._$_meshInfo$_ && (this._$_meshInfo$_._$sourceMesh$_._$Release$_(), this._$_meshInfo$_._$transformedMesh$_._$Release$_(), 
            this._$_meshInfo$_ = null, this._$_DiscardTransformedCollisionPoly$_());
        }
        _$SetMeshPoint$_(t, s, i) {
            t = Math.floor(t), s = Math.floor(s);
            const e = i.mode || "absolute";
            if (!cw.has(e)) throw new Error("invalid mode");
            const n = "relative" === e;
            let h = i.x, r = i.y;
            const o = i._$zElevation$_;
            let a = "number" == typeof i._$u$_ ? i._$u$_ : n ? 0 : -1, u = "number" == typeof i._$v$_ ? i._$v$_ : n ? 0 : -1;
            if (!this._$HasMesh$_()) return !1;
            const l = this._$GetSourceMesh$_(), c = l._$GetMeshPointAt$_(t, s);
            if (null === c) return !1;
            let f = !1;
            return "number" == typeof o && c._$GetZElevation$_() !== o && (c._$SetZElevation$_(o), 
            f = !0), n && (h += t / (l._$GetHSize$_() - 1), r += s / (l._$GetVSize$_() - 1)), 
            -1 !== a || n ? (n && (a += t / (l._$GetHSize$_() - 1)), a = sw._$clamp$_(a, 0, 1)) : a = c._$GetU$_(), 
            -1 !== u || n ? (n && (u += s / (l._$GetVSize$_() - 1)), u = sw._$clamp$_(u, 0, 1)) : u = c._$GetV$_(), 
            c._$GetX$_() === h && c._$GetY$_() === r && c._$GetU$_() === a && c._$GetV$_() === u ? f : (c._$SetX$_(h), 
            c._$SetY$_(r), c._$SetU$_(a), c._$SetV$_(u), this._$_DiscardTransformedCollisionPoly$_(), 
            !0);
        }
        _$HasTilemap$_() {
            return this._$_inst$_._$HasTilemap$_();
        }
        _$ContainsPoint$_(t, s) {
            return !!this._$GetBoundingBox$_()._$containsPoint$_(t, s) && !!this._$GetBoundingQuad$_()._$containsPoint$_(t, s) && (this._$HasTilemap$_() ? this._$_inst$_._$GetSdkInstance$_()._$TestPointOverlapTile$_(t, s) : !this._$HasOwnCollisionPoly$_() || this._$GetTransformedCollisionPoly$_()._$containsPoint$_(t - this._$GetX$_(), s - this._$GetY$_()));
        }
        _$_IsCollisionCellChanged$_() {
            return !!(16 & this._$_flags$_);
        }
        _$_UpdateCollisionCell$_() {
            if (!this._$_IsCollisionCellChanged$_() || !this._$IsCollisionEnabled$_() || 256 & this._$_flags$_) return;
            const t = this._$GetBoundingBox$_(), s = this._$_objectClass$_._$_GetCollisionCellGrid$_(), i = this._$_collisionCells$_;
            if (ew.set(s._$XToCell$_(t._$getLeft$_()), s._$YToCell$_(t._$getTop$_()), s._$XToCell$_(t._$getRight$_()), s._$YToCell$_(t._$getBottom$_())), 
            i.equals(ew)) return;
            const e = this._$_inst$_;
            i === lw ? (s._$Update$_(e, null, ew), this._$_collisionCells$_ = sw._$New$_(sw.Rect, ew)) : (s._$Update$_(e, i, ew), 
            i._$copy$_(ew)), this._$_flags$_ &= -17;
        }
        _$_SetCollisionCellChanged$_() {
            this._$_flags$_ |= 16;
        }
        _$_RemoveFromCollisionCells$_() {
            const t = this._$_collisionCells$_;
            t !== lw && (this._$_objectClass$_._$_GetCollisionCellGrid$_()._$Update$_(this._$_inst$_, t, null), 
            this._$_collisionCells$_ = lw);
        }
        _$_UpdateRenderCell$_() {
            const t = this._$GetLayer$_();
            if (!t._$UsesRenderCells$_() || 256 & this._$_flags$_) return;
            const s = t._$GetRenderGrid$_(), i = this._$GetBoundingBox$_(), e = this._$_renderCells$_;
            if (ew.set(s._$XToCell$_(i._$getLeft$_()), s._$YToCell$_(i._$getTop$_()), s._$XToCell$_(i._$getRight$_()), s._$YToCell$_(i._$getBottom$_())), 
            e.equals(ew)) return;
            const n = this._$_inst$_;
            e === uw ? (s._$Update$_(n, null, ew), this._$_renderCells$_ = sw._$New$_(sw.Rect, ew)) : (s._$Update$_(n, e, ew), 
            e._$copy$_(ew)), t._$SetRenderListStale$_();
        }
        _$_RemoveFromRenderCells$_() {
            const t = this._$_renderCells$_;
            t !== uw && (this._$GetLayer$_()._$GetRenderGrid$_()._$Update$_(this._$_inst$_, t, null), 
            this._$_renderCells$_ = uw);
        }
        _$GetRenderCellRange$_() {
            return this._$_renderCells$_;
        }
        _$ZOrderMoveToTop$_() {
            const t = this._$_inst$_, s = this._$_layer$_, i = s._$_GetInstances$_();
            i.length && i.at(-1) === t || (s._$_RemoveInstance$_(t, !1), s._$_AddInstance$_(t, !1), 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$ZOrderMoveToBottom$_() {
            const t = this._$_inst$_, s = this._$_layer$_, i = s._$_GetInstances$_();
            i.length && i[0] === t || (s._$_RemoveInstance$_(t, !1), s._$_PrependInstance$_(t, !1), 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$ZOrderMoveToLayer$_(t) {
            const s = this._$_inst$_, i = this._$_layer$_;
            if (i._$GetLayout$_() !== t._$GetLayout$_()) throw new Error("layer from different layout");
            t !== i && (i._$_RemoveInstance$_(s, !0), this._$_SetLayer$_(t), t._$_AddInstance$_(s, !0), 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$ZOrderMoveAdjacentToInstance$_(t, s) {
            const i = this._$_inst$_;
            let e = !1;
            const n = this._$_layer$_;
            if (t._$GetUID$_() === i._$GetUID$_()) return;
            const h = t._$GetWorldInfo$_();
            if (!h) throw new Error("expected world instance");
            const r = h._$GetLayer$_();
            n._$GetIndex$_() !== r._$GetIndex$_() && (n._$_RemoveInstance$_(i, !0), this._$_SetLayer$_(r), 
            r._$_AddInstance$_(i, !0), e = !0);
            const o = r._$MoveInstanceAdjacent$_(i, t, !!s);
            (e || o) && this._$_runtime$_._$UpdateRender$_();
        }
        _$GetInstanceEffectList$_() {
            return this._$_instanceEffectList$_;
        }
        _$_SetHasAnyActiveEffect$_(t) {
            this._$_SetFlag$_(64, t);
        }
        _$HasAnyActiveEffect$_() {
            return !!(64 & this._$_flags$_);
        }
        _$_SaveToJson$_(t, s = null) {
            const i = {
                x: this._$GetX$_(),
                y: this._$GetY$_(),
                w: this._$GetWidth$_(),
                h: this._$GetHeight$_(),
                l: this._$GetLayer$_()._$GetSID$_(),
                zi: this._$GetZIndex$_()
            };
            0 !== this._$GetZElevation$_() && (i.ze = this._$GetZElevation$_()), 0 !== this._$GetAngle$_() && (i.a = this._$_GetAngleNoReflect$_()), 
            this._$HasDefaultColor$_() || (i.c = this._$_color$_.toJSON()), .5 !== this._$GetOriginX$_() && (i.oX = this._$GetOriginX$_()), 
            .5 !== this._$GetOriginY$_() && (i.oY = this._$GetOriginY$_()), 0 !== this._$GetBlendMode$_() && (i.bm = this._$GetBlendMode$_()), 
            this._$IsVisible$_() || (i.v = this._$IsVisible$_()), this._$IsCollisionEnabled$_() || (i.ce = this._$IsCollisionEnabled$_()), 
            this._$IsBboxChangeEventEnabled$_() && (i.be = this._$IsBboxChangeEventEnabled$_()), 
            this._$_instanceEffectList$_ && (i.fx = this._$_instanceEffectList$_._$_SaveToJson$_());
            const e = !!(32 & this._$_flags$_);
            return e && (i.sfi = e), this._$_solidFilterTags$_ && (i.sft = [ ...this._$_solidFilterTags$_ ].join(" ")), 
            this._$_sceneGraphInfo$_ && "visual-state" !== t && (i.sgi = this._$_sceneGraphInfo$_._$_SaveToJson$_(t, s), 
            pw.has(this) && (i.sgcd = pw.get(this)._$childrenData$_, i.sgzid = pw.get(this)._$zIndexData$_)), 
            this._$HasMesh$_() && (i.mesh = this._$GetSourceMesh$_()._$SaveToJson$_()), i;
        }
        _$_SaveSceneGraphPropertiesToJson$_() {
            return {
                x: this._$_x$_,
                y: this._$_y$_,
                z: this._$_zElevation$_,
                w: this._$_w$_,
                h: this._$_h$_,
                a: this._$_a$_,
                sgi: this._$_GetSceneGraphInfo$_() ? this._$_GetSceneGraphInfo$_()._$_SaveToJsonProperties$_() : null
            };
        }
        _$_LoadSceneGraphPropertiesFromJson$_(t) {
            t && (this._$_x$_ = t.x, this._$_y$_ = t.y, this._$_zElevation$_ = t.z, this._$_w$_ = t.w, 
            this._$_h$_ = t.h, this._$_a$_ = t.a, t.sgi && this._$_GetSceneGraphInfo$_() && this._$_GetSceneGraphInfo$_()._$_LoadFromJson$_(t.sgi), 
            this._$_MarkSinCosAngleChanged$_(), this._$SetBboxChanged$_());
        }
        _$_SetupSceneGraphConnectionsOnChangeOfLayout$_() {
            this._$_ReleaseTmpSceneGraphInfo$_(), this._$_ResetAllSceneGraphState$_(), this._$_CreateSceneGraphInfo$_(null), 
            this._$_sceneGraphInfo$_ && this._$_sceneGraphInfo$_._$_SetTmpSceneGraphChildren$_(this._$_tmpSceneGraphChildren$_, this._$_tmpSceneGraphChildrenIndexes$_);
        }
        _$_OnBeforeLoad$_(t) {
            "visual-state" !== t && this._$_ResetAllSceneGraphState$_();
        }
        _$_OnAfterLoad$_(t, s = "full", i = null) {
            if (t.hasOwnProperty("sgi") && "visual-state" !== s) {
                if (256 & this._$_flags$_) return;
                this._$_sceneGraphInfo$_._$_OnAfterLoad$_(t.sgi, i);
            }
        }
        _$_OnAfterLoad2$_(t, s = "full", i = null) {
            if ("visual-state" !== s) if (256 & this._$_flags$_) this._$_ReleaseTmpSceneGraphInfo$_(); else {
                if (t.hasOwnProperty("sgi")) this._$_sceneGraphInfo$_._$_SetTmpSceneGraphChildren$_(null, null, t.sgi, i); else if (i?._$setFromJson$_ && this._$_tmpSceneGraphChildren$_) for (const t of this._$_tmpSceneGraphChildren$_) t._$IsDestroyed$_() || this._$_runtime$_._$DestroyInstance$_(t);
                this._$_ReleaseTmpSceneGraphInfo$_(), this._$SetBboxChanged$_();
            }
        }
        _$_LoadFromJson$_(t, s, i = null) {
            if (dw = !1, this._$SetX$_(t.x), this._$SetY$_(t.y), this._$SetWidth$_(t.w), this._$SetHeight$_(t.h), 
            this._$_SetZIndex$_(t.zi), this._$SetZElevation$_(t.hasOwnProperty("ze") ? t.ze : 0), 
            this._$SetAngle$_(t.hasOwnProperty("a") ? t.a : 0), t.hasOwnProperty("c") ? rw._$setFromJSON$_(t.c) : t.hasOwnProperty("o") ? (rw._$copyRgb$_(this._$_color$_), 
            rw.a = t.o) : rw._$setRgba$_(1, 1, 1, 1), this._$_SetColor$_(rw), this._$SetOriginX$_(t.hasOwnProperty("oX") ? t.oX : .5), 
            this._$SetOriginY$_(t.hasOwnProperty("oY") ? t.oY : .5), this._$SetBlendMode$_(t.hasOwnProperty("bm") ? t.bm : 0), 
            this._$SetVisible$_(!t.hasOwnProperty("v") || t.v), this._$SetCollisionEnabled$_(!t.hasOwnProperty("ce") || t.ce), 
            this._$SetBboxChangeEventEnabled$_(!!t.hasOwnProperty("be") && t.be), this._$SetSolidCollisionFilter$_(!!t.hasOwnProperty("sfi") && t.sfi, t.hasOwnProperty("sft") ? t.sft : ""), 
            this._$_instanceEffectList$_ && t.hasOwnProperty("fx") && this._$_instanceEffectList$_._$_LoadFromJson$_(t.fx), 
            t.hasOwnProperty("sgi") && "visual-state" !== s) {
                this._$_CreateSceneGraphInfo$_(null);
                const s = this._$_sceneGraphInfo$_, i = t.sgi;
                s._$_LoadFromJson$_(i), s._$_SetTmpSceneGraphChildren$_(this._$_tmpSceneGraphChildren$_, this._$_tmpSceneGraphChildrenIndexes$_), 
                t.sgcd && sw._$IsFiniteNumber$_(t.sgzid) && pw.set(this, {
                    _$childrenData$_: t.sgcd,
                    _$zIndexData$_: t.sgzid
                });
            }
            if (t.hasOwnProperty("mesh")) {
                const s = t.mesh;
                this._$CreateMesh$_(s.cols, s.rows), this._$GetSourceMesh$_()._$LoadFromJson$_(s);
            } else this._$ReleaseMesh$_();
            this._$SetBboxChanged$_(), dw = !0, this._$_UpdateRendererStateGroup$_(), "visual-state" !== s && this._$_runtime$_._$AddInstanceNeedingAfterLoad$_(this._$GetInstance$_(), t);
        }
    };
}

{
    const gw = self._$C3$_;
    gw._$BehaviorType$_ = class extends gw._$DefendedBase$_ {
        constructor(t, s) {
            super();
            const i = t._$GetRuntime$_(), e = i._$GetObjectReference$_(s[1]);
            i._$GetAddonManager$_()._$_DelayCreateBehavior$_(e), this._$_runtime$_ = i, this._$_objectClass$_ = t, 
            this._$_behavior$_ = gw._$AddonManager$_._$GetBehaviorByConstructorFunction$_(e), 
            this._$_sdkType$_ = null, this._$_iBehaviorType$_ = null, this._$_instSdkCtor$_ = e.Instance, 
            this._$_sid$_ = s[2], this._$_name$_ = s[0], this._$_jsPropName$_ = this._$_runtime$_._$GetJsPropName$_(s[3]);
            const n = this._$_behavior$_._$GetSdkVersion$_();
            if (n < 2 && (this._$_sdkType$_ = gw._$New$_(e._$Type$_, this), !(this._$_sdkType$_ instanceof gw._$SDKBehaviorTypeBase$_))) throw new Error("v1 sdk type must derive from SDKBehaviorBase");
            if (gw._$AddonManager$_._$_PushInitObject$_(this, n), n >= 2) {
                const t = e._$Type$_ ?? globalThis._$ISDKBehaviorTypeBase$_;
                if (this._$_iBehaviorType$_ = new t, !(this._$_iBehaviorType$_ instanceof globalThis._$ISDKBehaviorTypeBase$_)) throw new Error("script interface class must derive from ISDKBehaviorTypeBase");
            } else this._$_iBehaviorType$_ = new globalThis._$IBehaviorType$_;
            gw._$AddonManager$_._$_PopInitObject$_(n), this._$OnCreate$_();
        }
        static _$Create$_(t, s) {
            return gw._$New$_(gw._$BehaviorType$_, t, s);
        }
        _$Release$_() {
            this._$_runtime$_ = null, this._$_behavior$_ = null, this._$_sdkType$_ && (this._$_sdkType$_._$Release$_(), 
            this._$_sdkType$_ = null), this._$_instSdkCtor$_ = null;
        }
        _$GetSdkType$_() {
            return this._$_sdkType$_;
        }
        _$OnCreate$_() {
            this._$_sdkType$_ ? this._$_sdkType$_._$OnCreate$_() : this._$_iBehaviorType$_ && this._$_iBehaviorType$_._$_onCreate$_();
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetObjectClass$_() {
            return this._$_objectClass$_;
        }
        _$GetBehavior$_() {
            return this._$_behavior$_;
        }
        _$GetInstanceSdkCtor$_() {
            return this._$_instSdkCtor$_;
        }
        _$GetName$_() {
            return this._$_name$_;
        }
        _$GetSID$_() {
            return this._$_sid$_;
        }
        _$GetIBehaviorType$_() {
            return this._$_iBehaviorType$_;
        }
        _$GetJsPropName$_() {
            return this._$_jsPropName$_;
        }
    };
}

{
    const yw = self._$C3$_, Mw = self._$IBehaviorInstance$_;
    yw._$BehaviorInstance$_ = class extends yw._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_runtime$_ = t.runtime, this._$_behaviorType$_ = t._$behaviorType$_, 
            this._$_behavior$_ = this._$_behaviorType$_._$GetBehavior$_(), this._$_inst$_ = t._$instance$_, 
            this._$_index$_ = t.index, this._$_sdkInst$_ = null, this._$_iScriptInterface$_ = null, 
            this._$_behavior$_._$_AddInstance$_(this._$_inst$_);
        }
        _$Release$_() {
            this._$_iScriptInterface$_ && (this._$_iScriptInterface$_._$_release$_(), this._$_iScriptInterface$_ = null), 
            this._$_behavior$_._$_RemoveInstance$_(this._$_inst$_), this._$_sdkInst$_ && (this._$_sdkInst$_._$Release$_(), 
            this._$_sdkInst$_ = null), this._$_runtime$_ = null, this._$_behaviorType$_ = null, 
            this._$_behavior$_ = null, this._$_inst$_ = null;
        }
        _$_CreateSdkInstance$_(t) {
            if (this._$_sdkInst$_) throw new Error("already got sdk instance");
            if (this._$GetBehavior$_()._$GetSdkVersion$_() < 2) {
                if (this._$_sdkInst$_ = yw._$New$_(this._$_behaviorType$_._$GetInstanceSdkCtor$_(), this, t), 
                !(this._$_sdkInst$_ instanceof yw._$SDKBehaviorInstanceBase$_)) throw new Error("v1 sdk type must derive from SDKBehaviorInstanceBase");
            } else {
                const s = this._$GetBehavior$_()._$GetScriptInterfaceClass$_();
                this._$_InitScriptInterface$_(s.Instance, t);
            }
        }
        _$GetSdkInstance$_() {
            return this._$_sdkInst$_ ?? this._$_iScriptInterface$_;
        }
        _$GetObjectInstance$_() {
            return this._$_inst$_;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetBehaviorType$_() {
            return this._$_behaviorType$_;
        }
        _$GetBehavior$_() {
            return this._$_behavior$_;
        }
        _$_GetIndex$_() {
            return this._$_index$_;
        }
        _$PostCreate$_() {
            this._$_sdkInst$_ ? this._$_sdkInst$_._$PostCreate$_() : this._$_iScriptInterface$_._$_postCreate$_();
        }
        _$OnSpriteFrameChanged$_(t, s) {
            this._$_sdkInst$_ && this._$_sdkInst$_._$OnSpriteFrameChanged$_(t, s);
        }
        _$_GetDebuggerProperties$_() {
            return this._$_sdkInst$_ ? this._$_sdkInst$_._$GetDebuggerProperties$_() : this._$_iScriptInterface$_._$_getDebuggerProperties$_();
        }
        _$SaveToJson$_(t = "full") {
            return this._$_sdkInst$_ ? this._$_sdkInst$_._$SaveToJson$_(t) : this._$_iScriptInterface$_._$_saveToJson$_(t);
        }
        _$LoadFromJson$_(t, s = "full") {
            if (this._$_sdkInst$_) return this._$_sdkInst$_._$LoadFromJson$_(t, s);
            this._$_iScriptInterface$_._$_loadFromJson$_(t, s);
        }
        static _$SortByTickSequence$_(t, s, i) {
            const e = globalThis._$ISDKBehaviorInstanceBase$_;
            let n, h;
            n = s instanceof e ? t._$_UnwrapScriptInterface$_(s) : s._$GetBehaviorInstance$_(), 
            h = i instanceof e ? t._$_UnwrapScriptInterface$_(i) : i._$GetBehaviorInstance$_();
            const r = n._$GetObjectInstance$_(), o = h._$GetObjectInstance$_(), a = r._$GetObjectClass$_()._$GetIndex$_(), u = o._$GetObjectClass$_()._$GetIndex$_();
            if (a !== u) return a - u;
            const l = r._$GetPUID$_(), c = o._$GetPUID$_();
            return l !== c ? l - c : n._$_GetIndex$_() - h._$_GetIndex$_();
        }
        _$_InitScriptInterface$_(t, s) {
            const i = Mw, e = t ?? this._$_sdkInst$_._$GetScriptInterfaceClass$_(), n = e || i, h = this._$GetBehavior$_()._$GetSdkVersion$_();
            if (yw._$AddonManager$_._$_PushInitObject$_(this, h), yw._$AddonManager$_._$_PushInitProperties$_(s), 
            this._$_iScriptInterface$_ = new n, yw._$AddonManager$_._$_PopInitProperties$_(), 
            yw._$AddonManager$_._$_PopInitObject$_(h), e && !(this._$_iScriptInterface$_ instanceof i)) throw new TypeError(`script interface class '${e.name}' does not extend the right base class '${i.name}'`);
            return this._$_iScriptInterface$_;
        }
        _$GetScriptInterface$_() {
            return this._$_iScriptInterface$_ || this._$_InitScriptInterface$_();
        }
        _$HasScriptInterface$_() {
            return !!this._$_iScriptInterface$_;
        }
    };
}

{
    const ww = self._$C3$_;
    ww._$EffectList$_ = class extends ww._$DefendedBase$_ {
        constructor(t, s) {
            super(), this._$_owner$_ = t, this._$_allEffectTypes$_ = [], this._$_activeEffectTypes$_ = [], 
            this._$_effectTypesByName$_ = new Map, this._$_effectParams$_ = [], this._$_effectParamBuffers$_ = [], 
            this._$_allInstanceEffectLists$_ = new Set, this._$_preservesOpaqueness$_ = !0;
            for (const t of s) {
                const s = ww._$New$_(ww._$EffectType$_, this, t, this._$_allEffectTypes$_.length);
                this._$_allEffectTypes$_.push(s), this._$_effectTypesByName$_.set(s._$GetName$_().toLowerCase(), s), 
                t.length >= 3 && this._$_effectParams$_.push(this._$_LoadSingleEffectParameters$_(s, t[2]));
            }
            this._$GetRuntime$_()._$_AddEffectList$_(this);
        }
        _$Release$_() {
            this._$GetRuntime$_()._$_RemoveEffectList$_(this);
            for (const t of this._$_effectParamBuffers$_) t._$Release$_();
            ww._$clearArray$_(this._$_effectParamBuffers$_), ww._$clearArray$_(this._$_allEffectTypes$_), 
            ww._$clearArray$_(this._$_activeEffectTypes$_), this._$_effectTypesByName$_.clear(), 
            ww._$clearArray$_(this._$_effectParams$_), this._$_owner$_ = null;
        }
        _$_AddInstanceEffectList$_(t) {
            this._$_allInstanceEffectLists$_.add(t);
        }
        _$_RemoveInstanceEffectList$_(t) {
            this._$_allInstanceEffectLists$_.delete(t);
        }
        _$_InitRenderer$_(t) {
            t._$IsWebGPU$_() && (this._$_effectParamBuffers$_ = this._$_allEffectTypes$_.map((t => {
                const s = t._$GetShaderProgram$_();
                return s._$GetCustomParametersByteSize$_() > 0 ? ww._$New$_(ww._$Gfx$_._$WebGPUEffectCustomParamsBuffer$_, s) : null;
            })), this._$_UpdateAllEffectParamBuffers$_());
            for (const s of this._$_allInstanceEffectLists$_) s._$_InitRenderer$_(t);
        }
        _$PrependEffectTypes$_(t) {
            if (t.length) {
                this._$_allEffectTypes$_ = t.concat(this._$_allEffectTypes$_);
                for (const s of t) this._$_effectTypesByName$_.set(s._$GetName$_().toLowerCase(), s);
                for (let t = 0, s = this._$_allEffectTypes$_.length; t < s; ++t) this._$_allEffectTypes$_[t]._$_SetIndex$_(t);
            }
        }
        _$_LoadSingleEffectParameters$_(t, s) {
            t._$SetActive$_(s[0]);
            const i = s.slice(1);
            for (let t = 0, s = i.length; t < s; ++t) {
                const s = i[t];
                if (Array.isArray(s)) {
                    const e = ww._$New$_(ww._$Color$_);
                    e._$setFromJSON$_(s), i[t] = e;
                }
            }
            return i;
        }
        _$GetOwner$_() {
            return this._$_owner$_;
        }
        _$GetRuntime$_() {
            return this._$_owner$_._$GetRuntime$_();
        }
        _$UpdateActiveEffects$_() {
            ww._$clearArray$_(this._$_activeEffectTypes$_);
            let t = !0;
            for (const s of this._$_allEffectTypes$_) s._$IsActive$_() && (this._$_activeEffectTypes$_.push(s), 
            s._$GetShaderProgram$_()._$PreservesOpaqueness$_() || (t = !1));
            this._$_preservesOpaqueness$_ = t;
        }
        _$GetAllEffectTypes$_() {
            return this._$_allEffectTypes$_;
        }
        _$HasAnyEffectType$_() {
            return this._$_allEffectTypes$_.length > 0;
        }
        _$GetEffectTypeByName$_(t) {
            return this._$_effectTypesByName$_.get(t.toLowerCase()) || null;
        }
        _$GetEffectTypeByIndex$_(t) {
            if ((t = Math.floor(+t)) < 0 || t >= this._$_allEffectTypes$_.length) throw new RangeError("invalid effect type index");
            return this._$_allEffectTypes$_[t];
        }
        _$IsEffectIndexActive$_(t) {
            return this._$GetEffectTypeByIndex$_(t)._$IsActive$_();
        }
        _$SetEffectIndexActive$_(t, s) {
            this._$GetEffectTypeByIndex$_(t)._$SetActive$_(s);
        }
        _$GetActiveEffectTypes$_() {
            return this._$_activeEffectTypes$_;
        }
        _$HasAnyActiveEffect$_() {
            return this._$_activeEffectTypes$_.length > 0;
        }
        _$PreservesOpaqueness$_() {
            return this._$_preservesOpaqueness$_;
        }
        _$GetEffectParametersForIndex$_(t) {
            return this._$_effectParams$_[t];
        }
        _$_GetEffectChainShaderParametersForIndex$_(t) {
            return t < this._$_effectParamBuffers$_.length ? this._$_effectParamBuffers$_[t] : this._$_effectParams$_[t];
        }
        _$GetEffectParameter$_(t, s) {
            if (t < 0 || t >= this._$_effectParams$_.length) return null;
            const i = this._$_effectParams$_[t];
            return s < 0 || s >= i.length ? null : i[s];
        }
        _$SetEffectParameter$_(t, s, i) {
            if (t < 0 || t >= this._$_effectParams$_.length) return !1;
            const e = this._$_effectParams$_[t];
            if (s < 0 || s >= e.length) return !1;
            const n = e[s];
            if (n instanceof ww._$Color$_) {
                if (n._$equalsIgnoringAlpha$_(i)) return !1;
                n._$copyRgb$_(i);
            } else {
                if (n === i) return !1;
                e[s] = i;
            }
            return t < this._$_effectParamBuffers$_.length && this._$_effectParamBuffers$_[t]._$SetParameterValue$_(s, i), 
            !0;
        }
        _$_UpdateAllEffectParamBuffers$_() {
            const t = this._$_effectParams$_, s = this._$_effectParamBuffers$_;
            for (let i = 0, e = Math.min(t.length, s.length); i < e; ++i) {
                const e = s[i], n = t[i];
                for (let t = 0, s = n.length; t < s; ++t) e._$SetParameterValue$_(t, n[t]);
            }
        }
        static _$SaveFxParamToJson$_(t) {
            return t && t instanceof ww._$Color$_ ? {
                t: "color",
                v: t.toJSON()
            } : t;
        }
        static _$LoadFxParamFromJson$_(t) {
            if (null === t) return NaN;
            if ("object" == typeof t) {
                if ("color" === t.t) {
                    const s = ww._$New$_(ww._$Color$_);
                    return s._$setFromJSON$_(t.v), s;
                }
                throw new Error("invalid effect parameter type");
            }
            return t;
        }
        static _$SaveFxParamsToJson$_(t) {
            return t.map(ww._$EffectList$_._$SaveFxParamToJson$_);
        }
        static _$LoadFxParamsFromJson$_(t) {
            return t.map(ww._$EffectList$_._$LoadFxParamFromJson$_);
        }
        _$SaveToJson$_() {
            return this._$_allEffectTypes$_.map((t => ({
                name: t._$GetName$_(),
                active: t._$IsActive$_(),
                params: ww._$EffectList$_._$SaveFxParamsToJson$_(this._$_effectParams$_[t._$GetIndex$_()])
            })));
        }
        _$LoadFromJson$_(t) {
            for (const s of t) {
                const t = this._$GetEffectTypeByName$_(s.name);
                t && (t._$SetActive$_(s.active), this._$_effectParams$_[t._$GetIndex$_()] = ww._$EffectList$_._$LoadFxParamsFromJson$_(s.params));
            }
            this._$UpdateActiveEffects$_(), this._$_UpdateAllEffectParamBuffers$_();
        }
    };
}

{
    const Sw = self._$C3$_;
    Sw._$EffectType$_ = class extends Sw._$DefendedBase$_ {
        constructor(t, s, i) {
            super(), this._$_effectList$_ = t, this._$_id$_ = s[0], this._$_name$_ = s[1], this._$_index$_ = i, 
            this._$_shaderProgram$_ = null, this._$_isActive$_ = !0;
        }
        _$Release$_() {
            this._$_effectList$_ = null, this._$_shaderProgram$_ = null;
        }
        _$Clone$_(t) {
            const s = Sw._$New$_(Sw._$EffectType$_, t, [ this._$_id$_, this._$_name$_ ], -1);
            return s._$_shaderProgram$_ = this._$_shaderProgram$_, s._$_isActive$_ = this._$_isActive$_, 
            s;
        }
        _$_InitRenderer$_(t) {
            const s = t._$GetShaderProgramByName$_(this._$_id$_);
            if (!s) throw new Error("failed to find shader program '" + this._$_id$_ + "'");
            this._$_shaderProgram$_ = s;
        }
        _$GetEffectList$_() {
            return this._$_effectList$_;
        }
        _$GetName$_() {
            return this._$_name$_;
        }
        _$_SetIndex$_(t) {
            this._$_index$_ = t;
        }
        _$GetIndex$_() {
            return this._$_index$_;
        }
        _$GetOwner$_() {
            return this._$_effectList$_._$GetOwner$_();
        }
        _$GetRuntime$_() {
            return this._$_effectList$_._$GetRuntime$_();
        }
        _$SetActive$_(t) {
            this._$_isActive$_ = !!t;
        }
        _$IsActive$_() {
            return this._$_isActive$_;
        }
        _$GetShaderProgram$_() {
            return this._$_shaderProgram$_;
        }
        _$GetDefaultParameterValues$_() {
            const t = [];
            for (let s = 0, i = this._$_shaderProgram$_._$GetParameterCount$_(); s < i; ++s) {
                const i = this._$_shaderProgram$_._$GetParameterType$_(s);
                if ("float" === i || "percent" === i) t.push(0); else {
                    if ("color" !== i) throw new TypeError("unknown effect parameter type");
                    t.push(Sw._$New$_(Sw._$Color$_, 1, 1, 1, 1));
                }
            }
            return t;
        }
    };
}

{
    const bw = self._$C3$_;
    bw._$InstanceEffectList$_ = class extends bw._$DefendedBase$_ {
        constructor(t, s) {
            super(), this._$_inst$_ = t, this._$_wi$_ = s, this._$_effectList$_ = t._$GetObjectClass$_()._$GetEffectList$_(), 
            this._$_needsRebuildSteps$_ = !0, this._$_wasDefaultColor$_ = !0, this._$_was3D$_ = !1, 
            this._$_wasRotatedOrNegativeSize$_ = !1, this._$_wasTexRotated$_ = !1, this._$_wasMustPreDraw$_ = !1, 
            this._$_effectChain$_ = bw._$New$_(bw._$Gfx$_._$EffectChain$_, t._$GetRuntime$_()._$GetCanvasManager$_()._$GetEffectChainManager$_(), {
                _$drawContent$_: (t, s) => {
                    const i = s._$GetContentObject$_(), e = i._$GetWorldInfo$_();
                    t._$SetColor$_(e._$GetPremultipliedColor$_()), t._$SetCurrentZ$_(e._$GetTotalZElevation$_()), 
                    i._$Draw$_(t), t._$SetCurrentZ$_(0);
                },
                _$getSourceTextureInfo$_: t => {
                    const s = t._$GetCurrentTexRect$_(), [i, e] = t._$GetCurrentSurfaceSize$_();
                    return {
                        _$srcTexRect$_: s,
                        _$srcWidth$_: i,
                        _$srcHeight$_: e
                    };
                },
                _$getShaderParameters$_: t => this._$_GetEffectChainShaderParametersForIndex$_(t)
            }), this._$_activeEffectFlags$_ = [], this._$_activeEffectTypes$_ = [], this._$_preservesOpaqueness$_ = !0, 
            this._$_effectParams$_ = [], this._$_effectParamBuffers$_ = [], this._$_InitRenderer$_(t._$GetRuntime$_()._$GetRenderer$_());
            for (let t = 0, s = this._$_effectList$_._$GetAllEffectTypes$_().length; t < s; ++t) this._$_activeEffectFlags$_.push(!0);
            this._$UpdateActiveEffects$_(), this._$_effectList$_._$_AddInstanceEffectList$_(this);
        }
        _$Release$_() {
            this._$_effectList$_._$_RemoveInstanceEffectList$_(this);
            for (const t of this._$_effectParamBuffers$_) t && t._$Release$_();
            bw._$clearArray$_(this._$_effectParamBuffers$_), this._$_effectChain$_._$Release$_(), 
            this._$_effectChain$_ = null, bw._$clearArray$_(this._$_activeEffectFlags$_), bw._$clearArray$_(this._$_activeEffectTypes$_), 
            bw._$clearArray$_(this._$_effectParams$_), this._$_inst$_ = null, this._$_effectList$_ = null;
        }
        _$_InitRenderer$_(t) {
            t._$IsWebGPU$_() && (this._$_effectParamBuffers$_ = this._$_effectList$_._$GetAllEffectTypes$_().map((t => {
                const s = t._$GetShaderProgram$_();
                return s._$GetCustomParametersByteSize$_() > 0 ? bw._$New$_(bw._$Gfx$_._$WebGPUEffectCustomParamsBuffer$_, s) : null;
            })));
        }
        _$_LoadEffectParameters$_(t) {
            let s = 0;
            for (const i of t) this._$_effectParams$_.push(this._$_LoadSingleEffectParameters$_(s, i)), 
            ++s;
            this._$_UpdateAllEffectParamBuffers$_(), this._$UpdateActiveEffects$_();
        }
        _$_LoadSingleEffectParameters$_(t, s) {
            this._$_activeEffectFlags$_[t] = s[0];
            const i = s.slice(1);
            for (let t = 0, s = i.length; t < s; ++t) {
                const s = i[t];
                if (Array.isArray(s)) {
                    const e = bw._$New$_(bw._$Color$_);
                    e._$setFromJSON$_(s), i[t] = e;
                }
            }
            return i;
        }
        _$LoadDefaultEffectParameters$_() {
            for (const t of this._$_effectList$_._$GetAllEffectTypes$_()) this._$_effectParams$_.push(t._$GetDefaultParameterValues$_());
            this._$_UpdateAllEffectParamBuffers$_();
        }
        _$GetOwner$_() {
            return this._$_owner$_;
        }
        _$GetEffectList$_() {
            return this._$_effectList$_;
        }
        _$GetEffectChain$_() {
            return this._$_MaybeRebuildEffectChainSteps$_(), this._$_effectChain$_;
        }
        _$GetRuntime$_() {
            return this._$_inst$_._$GetRuntime$_();
        }
        _$UpdateActiveEffects$_() {
            bw._$clearArray$_(this._$_activeEffectTypes$_);
            const t = this._$_wi$_, s = this._$_effectList$_._$GetAllEffectTypes$_(), i = this._$_activeEffectTypes$_, e = this._$_activeEffectFlags$_;
            let n = !0;
            for (let t = 0, h = s.length; t < h; ++t) if (e[t]) {
                const e = s[t];
                i.push(e), e._$GetShaderProgram$_()._$PreservesOpaqueness$_() || (n = !1);
            }
            this._$_preservesOpaqueness$_ = n, t._$_SetHasAnyActiveEffect$_(!!i.length), this._$_needsRebuildSteps$_ = !0;
        }
        _$_MaybeRebuildEffectChainSteps$_() {
            const t = this._$_inst$_, s = this._$_wi$_, i = s._$HasDefaultColor$_(), e = t._$GetPlugin$_()._$Is3D$_(), n = 0 !== s._$GetAngle$_() || 0 !== s._$GetLayer$_()._$GetAngle$_() || s._$GetWidth$_() < 0 || s._$GetHeight$_() < 0, h = t._$IsCurrentTexRotated$_(), r = t._$MustPreDraw$_();
            (this._$_needsRebuildSteps$_ || i !== this._$_wasDefaultColor$_ || e !== this._$_was3D$_ || n !== this._$_wasRotatedOrNegativeSize$_ || h !== this._$_wasTexRotated$_ || r !== this._$_wasMustPreDraw$_ || this._$_effectChain$_._$NeedsRebuild$_()) && (this._$_effectChain$_._$BuildSteps$_(this._$_activeEffectTypes$_.map((t => t._$GetShaderProgram$_())), {
                _$indexMap$_: this._$_activeEffectTypes$_.map((t => t._$GetIndex$_())),
                _$forcePreDraw$_: !i || r,
                _$is3D$_: e,
                _$isSourceTextureRotated$_: h,
                _$isRotatedOrNegativeSizeInstance$_: n
            }), this._$_needsRebuildSteps$_ = !1, this._$_wasDefaultColor$_ = i, this._$_was3D$_ = e, 
            this._$_wasRotatedOrNegativeSize$_ = n, this._$_wasTexRotated$_ = h, this._$_wasMustPreDraw$_ = r);
        }
        _$GetActiveEffectTypes$_() {
            return this._$_activeEffectTypes$_;
        }
        _$GetEffectParametersForIndex$_(t) {
            return this._$_effectParams$_[t];
        }
        _$_GetEffectChainShaderParametersForIndex$_(t) {
            return t < this._$_effectParamBuffers$_.length ? this._$_effectParamBuffers$_[t] : this._$_effectParams$_[t];
        }
        _$GetEffectParameter$_(t, s) {
            if (t < 0 || t >= this._$_effectParams$_.length) return null;
            const i = this._$_effectParams$_[t];
            return s < 0 || s >= i.length ? null : i[s];
        }
        _$SetEffectParameter$_(t, s, i) {
            if (t < 0 || t >= this._$_effectParams$_.length) return !1;
            const e = this._$_effectParams$_[t];
            if (s < 0 || s >= e.length) return !1;
            const n = e[s];
            if (n instanceof bw._$Color$_) {
                if (n._$equalsIgnoringAlpha$_(i)) return !1;
                n._$copyRgb$_(i);
            } else {
                if (n === i) return !1;
                e[s] = i;
            }
            return t < this._$_effectParamBuffers$_.length && this._$_effectParamBuffers$_[t]._$SetParameterValue$_(s, i), 
            !0;
        }
        _$_UpdateAllEffectParamBuffers$_() {
            const t = this._$_effectParams$_, s = this._$_effectParamBuffers$_;
            for (let i = 0, e = s.length; i < e; ++i) {
                const e = s[i], n = t[i];
                for (let t = 0, s = n.length; t < s; ++t) e._$SetParameterValue$_(t, n[t]);
            }
        }
        _$PreservesOpaqueness$_() {
            return this._$_preservesOpaqueness$_;
        }
        _$HasAnyActiveBackgroundBlendingEffect$_() {
            return this._$_activeEffectTypes$_.some((t => t._$GetShaderProgram$_()._$BlendsBackground$_()));
        }
        _$IsEffectIndexActive$_(t) {
            return this._$_activeEffectFlags$_[t];
        }
        _$SetEffectIndexActive$_(t, s) {
            this._$_activeEffectFlags$_[t] = !!s;
        }
        _$GetAllEffectTypes$_() {
            return this._$_effectList$_._$GetAllEffectTypes$_();
        }
        _$_SaveToJson$_() {
            return this._$_effectList$_._$GetAllEffectTypes$_().map((t => ({
                name: t._$GetName$_(),
                active: this._$_activeEffectFlags$_[t._$GetIndex$_()],
                params: bw._$EffectList$_._$SaveFxParamsToJson$_(this._$_effectParams$_[t._$GetIndex$_()])
            })));
        }
        _$_LoadFromJson$_(t) {
            for (const s of t) {
                const t = this._$_effectList$_._$GetEffectTypeByName$_(s.name);
                t && (this._$_activeEffectFlags$_[t._$GetIndex$_()] = s.active, this._$_effectParams$_[t._$GetIndex$_()] = bw._$EffectList$_._$LoadFxParamsFromJson$_(s.params));
            }
            this._$UpdateActiveEffects$_(), this._$_UpdateAllEffectParamBuffers$_();
        }
    };
}

{
    const Tw = self._$C3$_, vw = [], xw = [], Iw = [], Gw = Tw._$New$_(Tw._$CollisionPoly$_), Cw = Tw._$New$_(Tw._$CollisionPoly$_), _w = Tw._$New$_(Tw._$Quad$_), Ew = Tw._$New$_(Tw.Rect), Dw = Tw._$New$_(Tw.Rect);
    let Aw = null, Nw = null, Lw = null;
    Tw._$CollisionEngine$_ = class extends Tw._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_runtime$_ = t, this._$_collisionCellWidth$_ = 0, this._$_collisionCellHeight$_ = 0, 
            this._$_registeredCollisions$_ = [], this._$_collisionCheckCount$_ = 0, this._$_collisionCheckSec$_ = 0, 
            this._$_polyCheckCount$_ = 0, this._$_polyCheckSec$_ = 0, this._$_iCollisionEngine$_ = new self._$ICollisionEngine$_(this);
        }
        _$Release$_() {
            this._$_runtime$_ = null;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetICollisionEngine$_() {
            return this._$_iCollisionEngine$_;
        }
        _$_Update1sStats$_() {
            this._$_collisionCheckSec$_ = this._$_collisionCheckCount$_, this._$_collisionCheckCount$_ = 0, 
            this._$_polyCheckSec$_ = this._$_polyCheckCount$_, this._$_polyCheckCount$_ = 0;
        }
        _$Get1secCollisionChecks$_() {
            return this._$_collisionCheckSec$_;
        }
        _$Get1secPolyChecks$_() {
            return this._$_polyCheckSec$_;
        }
        _$RegisterCollision$_(t, s) {
            const i = t._$GetWorldInfo$_(), e = s._$GetWorldInfo$_();
            i && e && i._$IsCollisionEnabled$_() && e._$IsCollisionEnabled$_() && this._$_registeredCollisions$_.push([ t, s ]);
        }
        _$AddRegisteredCollisionCandidates$_(t, s, i) {
            for (const [e, n] of this._$_registeredCollisions$_) {
                let h = null;
                if (t === e) h = n; else {
                    if (t !== n) continue;
                    h = e;
                }
                h._$BelongsToObjectClass$_(s) && (i.includes(h) || i.push(h));
            }
        }
        _$CheckRegisteredCollision$_(t, s) {
            if (!this._$_registeredCollisions$_.length) return !1;
            for (const [i, e] of this._$_registeredCollisions$_) if (t === i && s === e || t === e && s === i) return !0;
            return !1;
        }
        _$ClearRegisteredCollisions$_() {
            Tw._$clearArray$_(this._$_registeredCollisions$_);
        }
        _$TestOverlap$_(t, s) {
            if (!t || !s || t === s) return !1;
            const i = t._$GetWorldInfo$_(), e = s._$GetWorldInfo$_();
            if (!i._$IsCollisionEnabled$_() || !e._$IsCollisionEnabled$_()) return !1;
            this._$_collisionCheckCount$_++;
            const n = i._$GetLayer$_(), h = e._$GetLayer$_();
            return n._$IsTransformCompatibleWith$_(h) ? this._$_TestOverlap_SameLayers$_(i, e) : this._$_TestOverlap_DifferentLayers$_(i, e);
        }
        _$_TestOverlap_SameLayers$_(t, s) {
            if (!t._$GetBoundingBox$_()._$intersectsRect$_(s._$GetBoundingBox$_())) return !1;
            if (this._$_polyCheckCount$_++, !t._$GetBoundingQuad$_()._$intersectsQuad$_(s._$GetBoundingQuad$_())) return !1;
            if (t._$HasTilemap$_() && s._$HasTilemap$_()) return !1;
            if (t._$HasTilemap$_()) return this._$TestTilemapOverlap$_(t, s);
            if (s._$HasTilemap$_()) return this._$TestTilemapOverlap$_(s, t);
            if (!t._$HasOwnCollisionPoly$_() && !s._$HasOwnCollisionPoly$_()) return !0;
            const i = t._$GetTransformedCollisionPoly$_(), e = s._$GetTransformedCollisionPoly$_();
            return i._$intersectsPoly$_(e, s._$GetX$_() - t._$GetX$_(), s._$GetY$_() - t._$GetY$_());
        }
        _$_TestOverlap_DifferentLayers$_(t, s) {
            const i = t._$HasTilemap$_(), e = s._$HasTilemap$_();
            if (i && !e) return this._$TestTilemapOverlapDifferentLayers$_(t, s);
            if (e && !i) return this._$TestTilemapOverlapDifferentLayers$_(s, t);
            if (e || i) return !1;
            {
                const i = t._$GetLayer$_(), e = s._$GetLayer$_();
                Gw._$copy$_(t._$GetTransformedCollisionPoly$_()), Cw._$copy$_(s._$GetTransformedCollisionPoly$_());
                const n = Gw._$pointsArr$_();
                for (let s = 0, e = n.length; s < e; s += 2) {
                    const e = s + 1, h = n[s], r = n[e], [o, a] = i._$LayerToCanvasCss$_(h + t._$GetX$_(), r + t._$GetY$_());
                    n[s] = o, n[e] = a;
                }
                const h = Cw._$pointsArr$_();
                for (let t = 0, i = h.length; t < i; t += 2) {
                    const i = t + 1, n = h[t], r = h[i], [o, a] = e._$LayerToCanvasCss$_(n + s._$GetX$_(), r + s._$GetY$_());
                    h[t] = o, h[i] = a;
                }
                return Gw._$setBboxChanged$_(), Cw._$setBboxChanged$_(), this._$_polyCheckCount$_++, 
                Gw._$intersectsPoly$_(Cw, 0, 0);
            }
        }
        _$TestTilemapOverlapDifferentLayers$_(t, s) {
            const i = t._$GetLayer$_(), e = s._$GetLayer$_();
            Aw || (Aw = Tw._$New$_(Tw._$CollisionPoly$_)), Nw || (Nw = Tw._$New$_(Tw.Rect)), 
            Lw || (Lw = Tw._$New$_(Tw._$Quad$_));
            const n = s._$GetX$_(), h = s._$GetY$_(), [r, o] = e._$LayerToCanvasCss$_(n, h), [a, u] = i._$CanvasCssToLayer$_(r, o), l = a - n, c = u - h;
            if (Nw._$copy$_(s._$GetBoundingBox$_()), Nw.offset(l, c), !t._$GetBoundingBox$_()._$intersectsRect$_(Nw)) return !1;
            if (Lw._$copy$_(s._$GetBoundingQuad$_()), Lw.offset(l, c), this._$_polyCheckCount$_++, 
            !t._$GetBoundingQuad$_()._$intersectsQuad$_(Lw)) return !1;
            Aw._$copy$_(s._$GetTransformedCollisionPoly$_());
            const f = Aw._$pointsArr$_();
            for (let t = 0, s = f.length; t < s; t += 2) {
                const s = t + 1;
                f[t] += l, f[s] += c;
            }
            return Aw._$setBboxChanged$_(), this._$TestTilemapOverlap$_(t, s, a, u, Aw, Nw, Lw);
        }
        _$TestTilemapOverlap$_(t, s, i, e, n, h, r) {
            const o = void 0 !== h ? h : s._$GetBoundingBox$_(), a = t._$GetX$_(), u = t._$GetY$_(), l = t._$GetInstance$_()._$GetSdkInstance$_(), c = void 0 !== i ? i : s._$GetX$_(), f = void 0 !== e ? e : s._$GetY$_(), d = s._$HasOwnCollisionPoly$_(), p = void 0 !== r ? r : s._$GetBoundingQuad$_(), m = xw;
            l._$GetCollisionRectCandidates$_(o, m);
            for (let t = 0, i = m.length; t < i; ++t) {
                const i = m[t], e = i._$GetRect$_();
                if (this._$_collisionCheckCount$_++, o._$intersectsRectOffset$_(e, a, u) && (_w._$setFromRect$_(e), 
                _w.offset(a, u), _w._$intersectsQuad$_(p))) if (d) {
                    const t = void 0 !== n ? n : s._$GetTransformedCollisionPoly$_();
                    let h = c, r = f;
                    void 0 !== n && (h = s._$GetX$_(), r = s._$GetY$_());
                    const o = i._$GetPoly$_();
                    if (o) {
                        if (this._$_polyCheckCount$_++, o._$intersectsPoly$_(t, h - (a + e._$getLeft$_()), r - (u + e._$getTop$_()))) return Tw._$clearArray$_(m), 
                        !0;
                    } else if (Gw._$setFromQuad$_(_w, 0, 0), Gw._$intersectsPoly$_(t, h, r)) return Tw._$clearArray$_(m), 
                    !0;
                } else {
                    const t = i._$GetPoly$_();
                    if (!t) return Tw._$clearArray$_(m), !0;
                    if (Gw._$setFromQuad$_(p, 0, 0), t._$intersectsPoly$_(Gw, -(a + e._$getLeft$_()), -(u + e._$getTop$_()))) return Tw._$clearArray$_(m), 
                    !0;
                }
            }
            return Tw._$clearArray$_(m), !1;
        }
        _$TestAndSelectCanvasPointOverlap$_(t, s, i) {
            const e = t._$GetCurrentSol$_(), n = this._$_runtime$_._$GetCurrentEvent$_();
            if (!n) throw new Error("cannot call outside event");
            const h = n._$IsOrBlock$_(), r = new Tw._$LayerStateCache$_;
            if (e._$IsSelectAll$_()) {
                i || (e._$_SetSelectAll$_(!1), Tw._$clearArray$_(e._$_GetOwnInstances$_())), h && Tw._$clearArray$_(e._$_GetOwnElseInstances$_());
                for (const n of t._$GetInstances$_()) {
                    const t = n._$GetWorldInfo$_(), o = t._$GetLayer$_();
                    let a = !1;
                    if (r._$IsInteractive$_(o) && t._$IsInViewport2$_() && (a = s.some((([s, i]) => {
                        const [e, n] = r._$CanvasCssToLayer$_(o, s, i, t._$GetTotalZElevation$_());
                        return t._$ContainsPoint$_(e, n);
                    }))), a) {
                        if (i) return !1;
                        e._$_PushInstance$_(n);
                    } else h && e._$_PushElseInstance$_(n);
                }
            } else {
                let t, o = !1;
                h && !n._$IsFirstConditionOfType$_(this._$_runtime$_._$GetCurrentCondition$_()) ? this._$_runtime$_._$IsCurrentConditionFirst$_() && !e._$_GetOwnElseInstances$_().length && e._$_GetOwnInstances$_().length ? t = e._$_GetOwnInstances$_() : (t = e._$_GetOwnElseInstances$_(), 
                o = !0) : t = e._$_GetOwnInstances$_();
                let a = 0;
                for (let n = 0, u = t.length; n < u; ++n) {
                    const u = t[n], l = u._$GetWorldInfo$_(), c = l._$GetLayer$_();
                    let f = !1;
                    if (r._$IsInteractive$_(c) && l._$IsInViewport2$_() && (f = s.some((([t, s]) => {
                        const [i, e] = r._$CanvasCssToLayer$_(c, t, s, l._$GetTotalZElevation$_());
                        return l._$ContainsPoint$_(i, e);
                    }))), f) {
                        if (i) return !1;
                        o ? e._$_PushInstance$_(u) : t[a++] = u;
                    } else o ? t[a++] = u : h && e._$_PushElseInstance$_(u);
                }
                i || (t.length = a);
            }
            return t._$ApplySolToContainer$_(), r._$Release$_(), !!i || e._$HasAnyInstances$_();
        }
        _$_ObjectClassCanUseCollisionCells$_(t, s) {
            if (!t) return !0;
            for (const i of s._$layersHasInstancesOn$_()) if (!t._$IsTransformCompatibleWith$_(i)) return !1;
            return !0;
        }
        _$GetCollisionCandidates$_(t, s, i, e) {
            if (s._$IsFamily$_()) for (const n of s._$GetFamilyMembers$_()) this._$_ObjectClassCanUseCollisionCells$_(t, n) ? (n._$_UpdateAllCollisionCells$_(), 
            n._$_GetCollisionCellGrid$_()._$QueryRange$_(i, e)) : Tw._$appendArray$_(e, n._$GetInstances$_()); else this._$_ObjectClassCanUseCollisionCells$_(t, s) ? (s._$_UpdateAllCollisionCells$_(), 
            s._$_GetCollisionCellGrid$_()._$QueryRange$_(i, e)) : Tw._$appendArray$_(e, s._$GetInstances$_());
        }
        _$GetObjectClassesCollisionCandidates$_(t, s, i, e) {
            for (const n of s) this._$GetCollisionCandidates$_(t, n, i, e);
        }
        _$GetSolidCollisionCandidates$_(t, s, i) {
            const e = this._$_runtime$_._$GetSolidBehavior$_();
            e && this._$GetObjectClassesCollisionCandidates$_(t, e._$GetObjectClasses$_(), s, i);
        }
        _$GetJumpthruCollisionCandidates$_(t, s, i) {
            const e = this._$_runtime$_._$GetJumpthruBehavior$_();
            e && this._$GetObjectClassesCollisionCandidates$_(t, e._$GetObjectClasses$_(), s, i);
        }
        _$IsSolidCollisionAllowed$_(t, s) {
            return t._$_IsSolidEnabled$_() && (!s || s._$GetWorldInfo$_()._$IsSolidCollisionAllowed$_(t._$GetSavedDataMap$_().get("solidTags")));
        }
        _$TestOverlapSolid$_(t) {
            const s = t._$GetWorldInfo$_();
            this._$GetSolidCollisionCandidates$_(s._$GetLayer$_(), s._$GetBoundingBox$_(), vw);
            for (const s of vw) if (this._$IsSolidCollisionAllowed$_(s, t) && this._$TestOverlap$_(t, s)) return Tw._$clearArray$_(vw), 
            s;
            return Tw._$clearArray$_(vw), null;
        }
        _$TestRectOverlapSolid$_(t, s) {
            this._$GetSolidCollisionCandidates$_(null, t, vw);
            for (const i of vw) if (this._$IsSolidCollisionAllowed$_(i, s) && this._$TestRectOverlap$_(t, i)) return Tw._$clearArray$_(vw), 
            i;
            return Tw._$clearArray$_(vw), null;
        }
        _$TestOverlapJumpthru$_(t, s) {
            let i = null;
            s && (i = Iw, Tw._$clearArray$_(i));
            const e = t._$GetWorldInfo$_();
            this._$GetJumpthruCollisionCandidates$_(e._$GetLayer$_(), e._$GetBoundingBox$_(), vw);
            for (const e of vw) if (e._$_IsJumpthruEnabled$_() && this._$TestOverlap$_(t, e)) {
                if (!s) return Tw._$clearArray$_(vw), e;
                i.push(e);
            }
            return Tw._$clearArray$_(vw), i;
        }
        _$PushOut$_(t, s, i, e, n) {
            e = e || 50;
            const h = t._$GetWorldInfo$_(), r = h._$GetX$_(), o = h._$GetY$_();
            for (let a = 0; a < e; ++a) if (h._$SetXY$_(r + s * a, o + i * a), h._$SetBboxChanged$_(), 
            !this._$TestOverlap$_(t, n)) return !0;
            return h._$SetXY$_(r, o), h._$SetBboxChanged$_(), !1;
        }
        _$PushOutSolid$_(t, s, i, e, n, h) {
            e = e || 50;
            const r = t._$GetWorldInfo$_(), o = r._$GetX$_(), a = r._$GetY$_();
            let u = null, l = null;
            for (let c = 0; c < e; ++c) if (r._$SetXY$_(o + s * c, a + i * c), r._$SetBboxChanged$_(), 
            !this._$TestOverlap$_(t, u)) if (u = this._$TestOverlapSolid$_(t), u) l = u; else if (n && (u = h ? this._$TestOverlap$_(t, h) ? h : null : this._$TestOverlapJumpthru$_(t), 
            u && (l = u)), !u) return l && this._$PushInFractional$_(t, s, i, l, 16, !0), !0;
            return r._$SetXY$_(o, a), r._$SetBboxChanged$_(), !1;
        }
        _$PushOutSolidAxis$_(t, s, i, e) {
            e = e || 50;
            const n = t._$GetWorldInfo$_(), h = n._$GetX$_(), r = n._$GetY$_();
            let o = null, a = null;
            for (let u = 0; u < e; ++u) for (let e = 0; e < 2; ++e) {
                const l = 2 * e - 1;
                if (n._$SetXY$_(h + s * u * l, r + i * u * l), n._$SetBboxChanged$_(), !this._$TestOverlap$_(t, o)) {
                    if (o = this._$TestOverlapSolid$_(t), !o) return a && this._$PushInFractional$_(t, s * l, i * l, a, 16, !0), 
                    !0;
                    a = o;
                }
            }
            return n._$SetXY$_(h, r), n._$SetBboxChanged$_(), !1;
        }
        _$PushInFractional$_(t, s, i, e, n, h) {
            let r = 2, o = !1, a = !1;
            const u = t._$GetWorldInfo$_();
            let l = u._$GetX$_(), c = u._$GetY$_();
            for (;r <= n; ) {
                const n = 1 / r;
                r *= 2, u._$OffsetXY$_(s * n * (o ? 1 : -1), i * n * (o ? 1 : -1)), u._$SetBboxChanged$_(), 
                this._$TestOverlap$_(t, e) || h && this._$TestOverlapSolid$_(t) ? (o = !0, a = !0) : (o = !1, 
                a = !1, l = u._$GetX$_(), c = u._$GetY$_());
            }
            a && (u._$SetXY$_(l, c), u._$SetBboxChanged$_());
        }
        _$PushOutSolidNearest$_(t, s = 100) {
            let i = 0;
            const e = t._$GetWorldInfo$_(), n = e._$GetX$_(), h = e._$GetY$_();
            let r = 0, o = this._$TestOverlapSolid$_(t);
            if (!o) return !0;
            for (;i <= s; ) {
                let s = 0, a = 0;
                switch (r) {
                  case 0:
                    s = 0, a = -1, i++;
                    break;

                  case 1:
                    s = 1, a = -1;
                    break;

                  case 2:
                    s = 1, a = 0;
                    break;

                  case 3:
                    s = 1, a = 1;
                    break;

                  case 4:
                    s = 0, a = 1;
                    break;

                  case 5:
                    s = -1, a = 1;
                    break;

                  case 6:
                    s = -1, a = 0;
                    break;

                  case 7:
                    s = -1, a = -1;
                }
                if (r = (r + 1) % 8, e._$SetXY$_(Math.floor(n + s * i), Math.floor(h + a * i)), 
                e._$SetBboxChanged$_(), !this._$TestOverlap$_(t, o) && (o = this._$TestOverlapSolid$_(t), 
                !o)) return !0;
            }
            return e._$SetXY$_(n, h), e._$SetBboxChanged$_(), !1;
        }
        _$CalculateBounceAngle$_(t, s, i, e) {
            const n = t._$GetWorldInfo$_(), h = n._$GetX$_(), r = n._$GetY$_(), o = Math.max(10, Tw._$distanceTo$_(s, i, h, r)), a = Tw._$angleTo$_(s, i, h, r), u = e || this._$TestOverlapSolid$_(t);
            if (!u) return Tw._$clampAngle$_(a + Math.PI);
            let l = u, c = 0, f = 0;
            const d = Tw._$toRadians$_(5);
            let p;
            for (p = 1; p < 36; ++p) {
                const h = a - p * d;
                if (n._$SetXY$_(s + Math.cos(h) * o, i + Math.sin(h) * o), n._$SetBboxChanged$_(), 
                !this._$TestOverlap$_(t, l) && (l = e ? null : this._$TestOverlapSolid$_(t), !l)) {
                    c = h;
                    break;
                }
            }
            for (36 === p && (c = Tw._$clampAngle$_(a + Math.PI)), l = u, p = 1; p < 36; ++p) {
                const h = a + p * d;
                if (n._$SetXY$_(s + Math.cos(h) * o, i + Math.sin(h) * o), n._$SetBboxChanged$_(), 
                !this._$TestOverlap$_(t, l) && (l = e ? null : this._$TestOverlapSolid$_(t), !l)) {
                    f = h;
                    break;
                }
            }
            if (36 === p && (f = Tw._$clampAngle$_(a + Math.PI)), n._$SetXY$_(h, r), n._$SetBboxChanged$_(), 
            f === c) return f;
            const m = Tw._$angleDiff$_(f, c) / 2;
            let g;
            g = Tw._$angleClockwise$_(f, c) ? Tw._$clampAngle$_(c + m + Math.PI) : Tw._$clampAngle$_(f + m);
            const y = Math.cos(a), M = Math.sin(a), w = Math.cos(g), S = Math.sin(g), b = y * w + M * S, T = y - 2 * b * w, v = M - 2 * b * S;
            return Tw._$angleTo$_(0, 0, T, v);
        }
        _$TestSegmentOverlap$_(t, s, i, e, n) {
            if (!n) return !1;
            const h = n._$GetWorldInfo$_();
            return !!h._$IsCollisionEnabled$_() && (this._$_collisionCheckCount$_++, Ew.set(Math.min(t, i), Math.min(s, e), Math.max(t, i), Math.max(s, e)), 
            !!h._$GetBoundingBox$_()._$intersectsRect$_(Ew) && (n._$HasTilemap$_() ? this._$_TestSegmentOverlapTilemap$_(t, s, i, e, n, h) : (this._$_polyCheckCount$_++, 
            !!h._$GetBoundingQuad$_()._$intersectsSegment$_(t, s, i, e) && (!h._$HasOwnCollisionPoly$_() || h._$GetTransformedCollisionPoly$_()._$intersectsSegment$_(h._$GetX$_(), h._$GetY$_(), t, s, i, e)))));
        }
        _$_TestSegmentOverlapTilemap$_(t, s, i, e, n, h) {
            const r = h._$GetX$_(), o = h._$GetY$_(), a = n._$GetSdkInstance$_(), u = xw;
            Dw.set(t, s, i, e), Dw.normalize(), a._$GetCollisionRectCandidates$_(Dw, u);
            for (let n = 0, h = u.length; n < h; ++n) {
                const h = u[n], a = h._$GetRect$_();
                if (this._$_collisionCheckCount$_++, Ew._$intersectsRectOffset$_(a, r, o) && (_w._$setFromRect$_(a), 
                _w.offset(r, o), _w._$intersectsSegment$_(t, s, i, e))) {
                    const n = h._$GetPoly$_();
                    if (!n) return Tw._$clearArray$_(u), !0;
                    if (this._$_polyCheckCount$_++, n._$intersectsSegment$_(r + a._$getLeft$_(), o + a._$getTop$_(), t, s, i, e)) return Tw._$clearArray$_(u), 
                    !0;
                }
            }
            return Tw._$clearArray$_(u), !1;
        }
        _$TestRectOverlap$_(t, s) {
            if (!s) return !1;
            const i = s._$GetWorldInfo$_();
            if (!i._$IsCollisionEnabled$_()) return !1;
            if (this._$_collisionCheckCount$_++, !i._$GetBoundingBox$_()._$intersectsRect$_(t)) return !1;
            if (s._$HasTilemap$_()) return this._$_TestRectOverlapTilemap$_(t, s, i);
            if (this._$_polyCheckCount$_++, _w._$setFromRect$_(t), !i._$GetBoundingQuad$_()._$intersectsQuad$_(_w)) return !1;
            if (!i._$HasOwnCollisionPoly$_()) return !0;
            const e = Gw;
            e._$setFromRect$_(t, i._$GetX$_(), i._$GetY$_());
            const n = i._$GetTransformedCollisionPoly$_();
            return e._$intersectsPoly$_(n, 0, 0);
        }
        _$_TestRectOverlapTilemap$_(t, s, i) {
            const e = i._$GetX$_(), n = i._$GetY$_(), h = s._$GetSdkInstance$_(), r = xw;
            h._$GetCollisionRectCandidates$_(t, r);
            for (let s = 0, i = r.length; s < i; ++s) {
                const i = r[s], h = i._$GetRect$_();
                if (this._$_collisionCheckCount$_++, t._$intersectsRectOffset$_(h, e, n)) {
                    const s = i._$GetPoly$_();
                    if (!s) return Tw._$clearArray$_(r), !0;
                    if (this._$_polyCheckCount$_++, Gw._$setFromRect$_(t, 0, 0), s._$intersectsPoly$_(Gw, -(e + h._$getLeft$_()), -(n + h._$getTop$_()))) return Tw._$clearArray$_(r), 
                    !0;
                }
            }
            return Tw._$clearArray$_(r), !1;
        }
        _$TestRayIntersectsInstance$_(t, s) {
            if (!t) return;
            const i = t._$GetWorldInfo$_();
            i._$IsCollisionEnabled$_() && (this._$_collisionCheckCount$_++, i._$GetBoundingBox$_()._$intersectsRect$_(s.rect) && (t._$HasTilemap$_() ? this._$_TestRayIntersectsTilemap$_(t, i, s) : (this._$_polyCheckCount$_++, 
            i._$HasOwnCollisionPoly$_() ? s._$TestInstancePoly$_(t, i._$GetX$_(), i._$GetY$_(), i._$GetTransformedCollisionPoly$_()) : s._$TestInstanceQuad$_(t, i._$GetBoundingQuad$_()))));
        }
        _$_TestRayIntersectsTilemap$_(t, s, i) {
            const e = s._$GetX$_(), n = s._$GetY$_(), h = xw;
            t._$GetSdkInstance$_()._$GetCollisionRectCandidates$_(i.rect, h);
            for (let r = 0, o = h.length; r < o; r++) {
                const o = h[r], a = o._$GetRect$_();
                if (this._$_collisionCheckCount$_++, i.rect._$intersectsRectOffset$_(a, e, n)) {
                    const h = o._$GetPoly$_();
                    this._$_polyCheckCount$_++, h ? i._$TestInstancePoly$_(t, e + a._$getLeft$_(), n + a._$getTop$_(), h) : i._$TestInstanceRect$_(t, s._$GetX$_(), s._$GetY$_(), a);
                }
            }
            Tw._$clearArray$_(h);
        }
        _$SetCollisionCellSize$_(t, s) {
            if (t === this._$_collisionCellWidth$_ && s === this._$_collisionCellHeight$_) return;
            this._$_collisionCellWidth$_ = t, this._$_collisionCellHeight$_ = s;
            const i = this._$_runtime$_._$GetAllObjectClasses$_();
            for (const e of i) if (e._$IsWorldType$_()) {
                for (const t of e._$instancesIncludingPendingCreate$_()) t._$GetWorldInfo$_()._$_RemoveFromCollisionCells$_();
                e._$_GetCollisionCellGrid$_()._$SetCellSize$_(t, s), e._$_SetAnyCollisionCellChanged$_();
                for (const t of e._$instancesIncludingPendingCreate$_()) {
                    const s = t._$GetWorldInfo$_();
                    s._$_SetCollisionCellChanged$_(), s._$_UpdateCollisionCell$_();
                }
            }
        }
        _$GetCollisionCellSize$_() {
            return [ this._$_collisionCellWidth$_, this._$_collisionCellHeight$_ ];
        }
        _$_InitCollisionCellSize$_(t, s) {
            this._$_collisionCellWidth$_ = t, this._$_collisionCellHeight$_ = s;
        }
    };
}

{
    const Ow = self._$C3$_;
    Ow._$SparseGrid$_ = class extends Ow._$DefendedBase$_ {
        constructor(t, s) {
            super(), this._$_cellWidth$_ = t, this._$_cellHeight$_ = s, this._$_cells$_ = Ow._$New$_(Ow._$PairMap$_);
        }
        _$Release$_() {
            this._$_cells$_._$Release$_(), this._$_cells$_ = null;
        }
        _$SetCellSize$_(t, s) {
            if (!this._$_cells$_._$IsEmpty$_()) throw new Error("grid not empty");
            this._$_cellWidth$_ = t, this._$_cellHeight$_ = s;
        }
        _$GetCell$_(t, s, i) {
            let e = this._$_cells$_._$Get$_(t, s);
            return e || (i ? (e = Ow._$New$_(Ow._$GridCell$_, this, t, s), this._$_cells$_.Set(t, s, e), 
            e) : null);
        }
        _$XToCell$_(t) {
            const s = Math.floor(t / this._$_cellWidth$_);
            return isFinite(s) ? s : 0;
        }
        _$YToCell$_(t) {
            const s = Math.floor(t / this._$_cellHeight$_);
            return isFinite(s) ? s : 0;
        }
        _$Update$_(t, s, i) {
            if (s) for (let e = s._$getLeft$_(), n = s._$getRight$_(); e <= n; ++e) for (let n = s._$getTop$_(), h = s._$getBottom$_(); n <= h; ++n) {
                if (i && i._$containsPoint$_(e, n)) continue;
                const s = this._$GetCell$_(e, n, !1);
                s && (s._$Remove$_(t), s._$IsEmpty$_() && this._$_cells$_._$Delete$_(e, n));
            }
            if (i) for (let e = i._$getLeft$_(), n = i._$getRight$_(); e <= n; ++e) for (let n = i._$getTop$_(), h = i._$getBottom$_(); n <= h; ++n) s && s._$containsPoint$_(e, n) || this._$GetCell$_(e, n, !0)._$Insert$_(t);
        }
        _$QueryRange$_(t, s) {
            let i = this._$XToCell$_(t._$getLeft$_());
            const e = this._$YToCell$_(t._$getTop$_()), n = this._$XToCell$_(t._$getRight$_()), h = this._$YToCell$_(t._$getBottom$_());
            if (isFinite(n) && isFinite(h)) for (;i <= n; ++i) for (let t = e; t <= h; ++t) {
                const e = this._$GetCell$_(i, t, !1);
                e && e._$Dump$_(s);
            }
        }
    };
}

{
    const Rw = self._$C3$_;
    Rw._$GridCell$_ = class extends Rw._$DefendedBase$_ {
        constructor(t, s, i) {
            super(), this._$_grid$_ = t, this._$_x$_ = s, this._$_y$_ = i, this._$_instances$_ = Rw._$New$_(Rw._$ArraySet$_);
        }
        _$Release$_() {
            this._$_instances$_._$Release$_(), this._$_instances$_ = null, this._$_grid$_ = null;
        }
        _$IsEmpty$_() {
            return this._$_instances$_._$IsEmpty$_();
        }
        _$Insert$_(t) {
            this._$_instances$_._$Add$_(t);
        }
        _$Remove$_(t) {
            this._$_instances$_._$Delete$_(t);
        }
        _$Dump$_(t) {
            Rw._$appendArray$_(t, this._$_instances$_._$GetArray$_());
        }
    };
}

{
    const Pw = self._$C3$_, kw = 1e-6;
    Pw._$Ray$_ = class {
        constructor() {
            this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.dx = 0, this.dy = 0, this.rect = new Pw.Rect, 
            this._$hitFraction$_ = 2, this._$hitUid$_ = null, this._$hitNormal$_ = 0, this._$hitNormalDx$_ = 0, 
            this._$hitNormalDy$_ = 0, this._$hitX$_ = 0, this._$hitY$_ = 0, this._$distance$_ = 0, 
            this._$normalX$_ = 1, this._$normalY$_ = 0, this._$reflectionX$_ = 1, this._$reflectionY$_ = 0;
        }
        _$DidCollide$_() {
            return this._$hitFraction$_ < 1.000001;
        }
        _$Reset$_() {
            this._$hitFraction$_ = 2;
        }
        Set(t, s, i, e) {
            return this.x1 = t, this.y1 = s, this.x2 = i, this.y2 = e, this.dx = i - t, this.dy = e - s, 
            this.rect.set(t, s, i, e), this.rect.normalize(), this._$hitFraction$_ = 2, this._$hitUid$_ = null, 
            this._$hitNormal$_ = 0, this._$hitNormalDx$_ = 0, this._$hitNormalDy$_ = 0, this._$hitX$_ = 0, 
            this._$hitY$_ = 0, this._$distance$_ = 0, this._$normalX$_ = 1, this._$normalY$_ = 0, 
            this._$reflectionX$_ = 1, this._$reflectionY$_ = 0, this;
        }
        _$Complete$_() {
            if (!1 === this._$DidCollide$_()) return;
            const t = this.dx * this._$hitFraction$_, s = this.dy * this._$hitFraction$_, i = Pw._$hypot2DFast$_(t, s), e = t / i, n = s / i;
            this._$distance$_ = i - kw, this._$hitX$_ = this.x1 + e * this._$distance$_, this._$hitY$_ = this.y1 + n * this._$distance$_, 
            this._$hitNormal$_ = Math.atan2(this._$hitNormalDy$_, this._$hitNormalDx$_) + Math.PI / 2, 
            this._$normalX$_ = Math.cos(this._$hitNormal$_), this._$normalY$_ = Math.sin(this._$hitNormal$_);
            const h = e * this._$normalX$_ + n * this._$normalY$_;
            if (this._$reflectionX$_ = e - 2 * this._$normalX$_ * h, this._$reflectionY$_ = n - 2 * this._$normalY$_ * h, 
            h > 0) {
                const t = Math.PI;
                this._$hitNormal$_ = Pw._$clampAngle$_(this._$hitNormal$_ + t), this._$normalX$_ = -this._$normalX$_, 
                this._$normalY$_ = -this._$normalY$_;
            }
        }
        _$TestInstanceSegment$_(t, s, i, e, n) {
            const h = Pw._$rayIntersect$_(this.x1, this.y1, this.x2, this.y2, s, i, e, n);
            h >= 0 && h < this._$hitFraction$_ && (this._$hitFraction$_ = h, this._$hitUid$_ = t._$GetUID$_(), 
            this._$hitNormalDx$_ = s - e, this._$hitNormalDy$_ = i - n);
        }
        _$TestInstanceRect$_(t, s, i, e) {
            const n = s + e._$getLeft$_(), h = s + e._$getRight$_(), r = i + e._$getTop$_(), o = i + e._$getBottom$_();
            this._$TestInstanceSegment$_(t, n, r, h, r), this._$TestInstanceSegment$_(t, h, r, h, o), 
            this._$TestInstanceSegment$_(t, h, o, n, o), this._$TestInstanceSegment$_(t, n, o, n, r);
        }
        _$TestInstanceQuad$_(t, s) {
            const i = s._$getTlx$_(), e = s._$getTly$_(), n = s._$getTrx$_(), h = s._$getTry$_(), r = s._$getBrx$_(), o = s._$getBry$_(), a = s._$getBlx$_(), u = s._$getBly$_();
            this._$TestInstanceSegment$_(t, i, e, n, h), this._$TestInstanceSegment$_(t, n, h, r, o), 
            this._$TestInstanceSegment$_(t, r, o, a, u), this._$TestInstanceSegment$_(t, a, u, i, e);
        }
        _$TestInstancePoly$_(t, s, i, e) {
            const n = e._$pointsArr$_();
            for (let e = 0, h = n.length; e < h; e += 2) {
                const r = (e + 2) % h, o = n[e] + s, a = n[e + 1] + i, u = n[r] + s, l = n[r + 1] + i;
                this._$TestInstanceSegment$_(t, o, a, u, l);
            }
        }
    };
}

{
    const Fw = self._$C3$_;
    Fw._$LayerStateCache$_ = class {
        constructor() {
            this._$_layerCache$_ = new Map;
        }
        _$Release$_() {
            for (const t of this._$_layerCache$_.values()) t._$layerPts$_._$Clear$_();
            this._$_layerCache$_.clear();
        }
        _$_GetLayerCache$_(t) {
            let s = this._$_layerCache$_.get(t);
            return void 0 === s && (s = {
                _$isInteractive$_: null,
                _$layerPts$_: new Fw._$PairMap$_
            }, this._$_layerCache$_.set(t, s)), s;
        }
        _$IsInteractive$_(t) {
            const s = this._$_GetLayerCache$_(t);
            return null === s._$isInteractive$_ && (s._$isInteractive$_ = t._$IsSelfAndParentsInteractive$_()), 
            s._$isInteractive$_;
        }
        _$CanvasCssToLayer$_(t, s, i, e) {
            if (0 !== e) return t._$CanvasCssToLayer$_(s, i, e);
            const n = this._$_GetLayerCache$_(t);
            let h = n._$layerPts$_._$Get$_(s, i);
            return void 0 === h && (h = t._$CanvasCssToLayer$_(s, i, e), n._$layerPts$_.Set(s, i, h)), 
            h;
        }
    };
}

{
    const jw = self._$C3$_, Bw = new Set([ "off", "crop", "scale-inner", "scale-outer", "letterbox-scale", "letterbox-integer-scale" ]), zw = new Set([ "high", "low" ]), Uw = self._$glMatrix$_, Ww = Uw._$mat4$_, Jw = (Uw._$vec3$_, 
    Ww.create()), Qw = jw._$New$_(jw._$Quad$_), Yw = jw._$New$_(jw.Rect);
    jw._$CanvasManager$_ = class extends jw._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_runtime$_ = t, this._$_canvasLayers$_ = [], this._$_isWebGPUEnabled$_ = !1, 
            this._$_webglRenderer$_ = null, this._$_webgpuRenderer$_ = null, this._$_iRenderer$_ = null, 
            this._$_gpuPreference$_ = "high-performance", this._$_isLimitedToWebGL1$_ = !1, 
            this._$_multitexturingMode$_ = "auto", this._$_windowInnerWidth$_ = 0, this._$_windowInnerHeight$_ = 0, 
            this._$_cssDisplayMode$_ = "", this._$_canvasCssWidth$_ = 0, this._$_canvasCssHeight$_ = 0, 
            this._$_canvasDeviceWidth$_ = 0, this._$_canvasDeviceHeight$_ = 0, this._$_canvasCssOffsetX$_ = 0, 
            this._$_canvasCssOffsetY$_ = 0, this._$_zAxisScale$_ = "normalized", this._$_initFieldOfView$_ = 0, 
            this._$_zNear$_ = 1, this._$_zFar$_ = 1e4, this._$_enableMipmaps$_ = !0, this._$_textureAnisotropy$_ = 0, 
            this._$_drawWidth$_ = 0, this._$_drawHeight$_ = 0, this._$_fullscreenMode$_ = "letterbox-scale", 
            this._$_documentFullscreenMode$_ = "letterbox-scale", this._$_deviceTransformOffX$_ = 0, 
            this._$_deviceTransformOffY$_ = 0, this._$_defaultProjectionMatrix$_ = Ww.create(), 
            this._$_wantFullscreenScalingQuality$_ = "high", this._$_fullscreenScalingQuality$_ = this._$_wantFullscreenScalingQuality$_, 
            this._$_isDocumentFullscreen$_ = !1, this._$_availableAdditionalRenderTargets$_ = [], 
            this._$_usedAdditionalRenderTargets$_ = new Set, this._$_shaderData$_ = self.C3_Shaders, 
            this._$_effectChainManager$_ = jw._$New$_(jw._$Gfx$_._$EffectChainManager$_, {
                _$getDrawSize$_: () => [ this._$GetDrawWidth$_(), this._$GetDrawHeight$_() ],
                _$getRenderTarget$_: () => this._$GetEffectCompositorRenderTarget$_(),
                _$releaseRenderTarget$_: t => this._$ReleaseEffectCompositorRenderTarget$_(t),
                getTime: () => this._$GetRuntime$_()._$GetGameTime$_(),
                _$redraw$_: () => this._$GetRuntime$_()._$UpdateRender$_()
            }), this._$_gpuTimeStartFrame$_ = 0, this._$_gpuTimeEndFrame$_ = 0, this._$_gpuLastUtilisation$_ = NaN, 
            this._$_gpuFrameTimingsBuffer$_ = null, this._$_layersGpuProfile$_ = new Map, this._$_gpuCurUtilisation$_ = NaN, 
            this._$_webgpuFrameTimings$_ = new Map, this._$_snapshotFormat$_ = "", this._$_snapshotQuality$_ = 1, 
            this._$_snapshotArea$_ = jw._$New$_(jw.Rect), this._$_snapshotUrl$_ = "", this._$_snapshotPromise$_ = null, 
            this._$_snapshotResolve$_ = null, this._$_isPastingToDrawingCanvas$_ = 0, this._$_loaderStartTime$_ = 0, 
            this._$_rafId$_ = -1, this._$_loadingProgress$_ = 0, this._$_loadingprogress_handler$_ = t => this._$_loadingProgress$_ = t.progress, 
            this._$_percentText$_ = null, this._$_splashTextures$_ = {
                _$logo$_: null,
                _$powered$_: null,
                _$website$_: null
            }, this._$_splashFrameNumber$_ = 0, this._$_splashFadeInFinishTime$_ = 0, this._$_splashFadeOutStartTime$_ = 0, 
            this._$_splashState$_ = "fade-in", this._$_splashDoneResolve$_ = null, this._$_splashDonePromise$_ = new Promise((t => this._$_splashDoneResolve$_ = t));
        }
        _$_SetGPUPowerPreference$_(t) {
            this._$_gpuPreference$_ = t;
        }
        _$_SetWebGPUEnabled$_(t) {
            this._$_isWebGPUEnabled$_ = !!t;
        }
        _$_SetZAxisScale$_(t) {
            this._$_zAxisScale$_ = t;
        }
        _$GetZAxisScale$_() {
            return this._$_zAxisScale$_;
        }
        _$_SetInitFieldOfView$_(t) {
            this._$_initFieldOfView$_ = t;
        }
        _$_SetZDistances$_(t, s) {
            this._$_zNear$_ = t, this._$_zFar$_ = s;
        }
        _$_SetLimitedToWebGL1$_(t) {
            this._$_isLimitedToWebGL1$_ = !!t;
        }
        _$_SetMultitexturingMode$_(t) {
            this._$_multitexturingMode$_ = t;
        }
        async _$CreateCanvas$_(t) {
            let s = t.canvas;
            this._$_canvasLayers$_.push({
                canvas: s,
                _$ctx$_: null
            }), this._$_runtime$_._$AddDOMComponentMessageHandler$_("runtime", "window-resize", (t => this._$_OnWindowResize$_(t))), 
            this._$_runtime$_._$AddDOMComponentMessageHandler$_("runtime", "fullscreenchange", (t => this._$_OnFullscreenChange$_(t))), 
            this._$_runtime$_._$AddDOMComponentMessageHandler$_("runtime", "fullscreenerror", (t => this._$_OnFullscreenError$_(t))), 
            s.addEventListener("webglcontextlost", (t => this._$_OnWebGLContextLost$_(t))), 
            s.addEventListener("webglcontextrestored", (t => this._$_OnWebGLContextRestored$_(t))), 
            this._$_isDocumentFullscreen$_ = !!t.isFullscreen, this._$_cssDisplayMode$_ = t.cssDisplayMode;
            const i = navigator.gpu && this._$_isWebGPUEnabled$_;
            let e = !1;
            if (i) try {
                await this._$_InitWebGPUContext$_(!0);
            } catch (t) {
                this._$_MaybeLogRendererError$_("WebGPU", t), this._$_webgpuRenderer$_ = null;
            }
            if (!this._$GetRenderer$_()) try {
                await this._$_InitWebGLContext$_(!0);
            } catch (t) {
                this._$_MaybeLogRendererError$_("WebGL", t), this._$_webglRenderer$_ = null;
            }
            if (this._$GetRenderer$_() || (e = !0), !this._$GetRenderer$_() && i) try {
                await this._$_InitWebGPUContext$_(!1);
            } catch (t) {
                this._$_MaybeLogRendererError$_("WebGPU", t), this._$_webgpuRenderer$_ = null;
            }
            if (!this._$GetRenderer$_()) try {
                await this._$_InitWebGLContext$_(!1);
            } catch (t) {
                this._$_MaybeLogRendererError$_("WebGL", t), this._$_webglRenderer$_ = null;
            }
            const n = this._$GetRenderer$_();
            if (!n) throw new Error("failed to acquire a renderer - check WebGL or WebGPU is supported");
            n._$SetHasMajorPerformanceCaveat$_(e), this._$_webgpuRenderer$_ && (this._$_webgpuRenderer$_._$ondevicelost$_ = () => this._$_OnWebGPUDeviceLost$_(), 
            this._$_webgpuRenderer$_._$ondevicerestored$_ = () => this._$_OnWebGPUDeviceRestored$_()), 
            "normalized" === this._$_zAxisScale$_ ? n._$SetZAxisScaleNormalized$_() : (n._$SetZAxisScaleRegular$_(), 
            n._$SetFovY$_(this._$_initFieldOfView$_)), this._$SetSize$_(t.windowInnerWidth, t.windowInnerHeight, !0), 
            await this._$_InitRenderer$_();
        }
        _$_MaybeLogRendererError$_(t, s) {
            s && "string" == typeof s.message && s.message.startsWith("renderer-unavailable") || console.error(`Error creating ${t} renderer: `, s);
        }
        async _$_InitWebGPUContext$_(t) {
            const s = {
                _$nearZ$_: this._$_zNear$_,
                _$farZ$_: this._$_zFar$_
            };
            let i = !0;
            "no" === this._$_multitexturingMode$_ ? i = !1 : "auto" === this._$_multitexturingMode$_ && (i = jw._$Platform$_._$IsDesktop$_);
            const e = {
                powerPreference: this._$_gpuPreference$_,
                depth: this._$_runtime$_._$Uses3DFeatures$_(),
                failIfMajorPerformanceCaveat: t,
                _$usesBackgroundBlending$_: this._$_runtime$_._$UsesAnyBackgroundBlending$_(),
                _$canSampleBackbuffer$_: this._$_runtime$_._$UsesAnyCrossSampling$_(),
                _$canSampleDepth$_: this._$_runtime$_._$UsesAnyDepthSampling$_(),
                _$isMultiTexturingAllowed$_: i
            };
            this._$_webgpuRenderer$_ = jw._$New$_(jw._$Gfx$_._$WebGPURenderer$_, s), await this._$_webgpuRenderer$_._$Create$_(this._$_canvasLayers$_[0].canvas, e);
        }
        async _$_InitWebGLContext$_(t) {
            const s = {
                alpha: !0,
                powerPreference: this._$_gpuPreference$_,
                _$enableGpuProfiling$_: "xbox-uwp-webview2" !== this._$_runtime$_._$GetExportType$_(),
                depth: this._$_runtime$_._$Uses3DFeatures$_(),
                _$canSampleDepth$_: this._$_runtime$_._$UsesAnyDepthSampling$_(),
                failIfMajorPerformanceCaveat: t,
                _$nearZ$_: this._$_zNear$_,
                _$farZ$_: this._$_zFar$_
            };
            this._$_isLimitedToWebGL1$_ && (s._$maxWebGLVersion$_ = 1), this._$_webglRenderer$_ = jw._$New$_(jw._$Gfx$_._$WebGLRenderer$_, this._$_canvasLayers$_[0].canvas, s), 
            await this._$_webglRenderer$_._$InitState$_();
        }
        async _$_InitWebGPU$_() {
            if (this._$_shaderData$_) {
                const t = [];
                for (const [s, i] of Object.entries(this._$_shaderData$_)) {
                    i.src = i._$wgsl$_;
                    const e = jw._$Gfx$_._$WebGPUShaderProgram$_._$GetDefaultVertexShaderSource$_();
                    t.push(this._$_webgpuRenderer$_._$CreateShaderProgram$_(Object.assign({
                        _$vertexSrc$_: e,
                        name: s
                    }, i)));
                }
                await Promise.all(t);
            }
        }
        async _$_InitWebGL$_() {
            if (this._$_shaderData$_) {
                const t = [];
                for (const [s, i] of Object.entries(this._$_shaderData$_)) {
                    let e;
                    if (i._$glslWebGL2$_ && this._$_webglRenderer$_._$GetWebGLVersionNumber$_() >= 2) i.src = i._$glslWebGL2$_, 
                    e = jw._$Gfx$_._$WebGLShaderProgram$_._$GetDefaultVertexShaderSource_WebGL2$_(); else {
                        if (!i._$glsl$_) throw new Error(`shader '${s}' does not support WebGL 1`);
                        i.src = i._$glsl$_, e = jw._$Gfx$_._$WebGLShaderProgram$_._$GetDefaultVertexShaderSource$_();
                    }
                    t.push(this._$_webglRenderer$_._$CreateShaderProgram$_(Object.assign({
                        _$vertexSrc$_: e,
                        name: s
                    }, i)));
                }
                await Promise.all(t), this._$_webglRenderer$_._$ResetLastProgram$_(), this._$_webglRenderer$_._$SetTextureFillMode$_();
            }
            this._$_webglRenderer$_._$SupportsGPUProfiling$_() && (this._$_gpuFrameTimingsBuffer$_ = jw._$New$_(jw._$Gfx$_._$WebGLQueryResultBuffer$_, this._$_webglRenderer$_));
        }
        async _$_InitRenderer$_() {
            this._$_webgpuRenderer$_ ? await this._$_InitWebGPU$_() : this._$_webglRenderer$_ && await this._$_InitWebGL$_();
            const t = this._$GetRenderer$_();
            t._$SetMipmapsEnabled$_(this._$_enableMipmaps$_), t._$SupportsGPUProfiling$_() && (this._$_gpuLastUtilisation$_ = 0);
            for (const s of this._$_runtime$_._$_GetAllEffectLists$_()) {
                for (const i of s._$GetAllEffectTypes$_()) i._$_InitRenderer$_(t);
                s._$_InitRenderer$_(t), s._$UpdateActiveEffects$_();
            }
            this._$_iRenderer$_ = new self._$IRenderer$_(this._$_runtime$_, t);
        }
        _$Release$_() {
            this._$_runtime$_ = null, this._$_webglRenderer$_ = null, this._$_canvasLayers$_.length = 0;
        }
        _$IsInWorker$_() {
            return this._$_runtime$_._$IsInWorker$_();
        }
        _$_OnWindowResize$_(t) {
            const s = this._$_runtime$_;
            if (s._$IsExportToVideo$_()) return;
            const i = t.devicePixelRatio;
            this._$IsInWorker$_() && (self.devicePixelRatio = i), s._$_SetDevicePixelRatio$_(i), 
            this._$_isDocumentFullscreen$_ = !!t.isFullscreen, this._$_cssDisplayMode$_ = t.cssDisplayMode, 
            this._$SetSize$_(t.innerWidth, t.innerHeight), s._$UpdateRender$_();
            const e = new jw.Event("window-resize");
            e.data = t, s._$Dispatcher$_()._$dispatchEventAndWaitAsyncSequential$_(e);
            const n = new jw.Event("resize");
            n._$cssWidth$_ = this._$GetCssWidth$_(), n._$cssHeight$_ = this._$GetCssHeight$_(), 
            n._$deviceWidth$_ = this._$GetDeviceWidth$_(), n._$deviceHeight$_ = this._$GetDeviceHeight$_(), 
            s._$DispatchUserScriptEvent$_(n), s._$IsDebug$_() && (s._$HitBreakpoint$_() || self._$C3Debugger$_._$IsDebuggerPaused$_()) && s._$Render$_();
        }
        _$_OnFullscreenChange$_(t) {
            this._$_isDocumentFullscreen$_ = !!t.isFullscreen, this._$SetSize$_(t.innerWidth, t.innerHeight, !0), 
            this._$_runtime$_._$UpdateRender$_();
        }
        _$_OnFullscreenError$_(t) {
            this._$_isDocumentFullscreen$_ = !!t.isFullscreen, this._$SetSize$_(t.innerWidth, t.innerHeight, !0), 
            this._$_runtime$_._$UpdateRender$_();
        }
        _$SetSize$_(t, s, i = !1) {
            if (t = Math.floor(t), s = Math.floor(s), t <= 0 || s <= 0) throw new Error("invalid size");
            if (this._$_windowInnerWidth$_ === t && this._$_windowInnerHeight$_ === s && !i) return;
            this._$_windowInnerWidth$_ = t, this._$_windowInnerHeight$_ = s;
            const e = this._$GetCurrentFullscreenMode$_();
            "letterbox-scale" === e ? this._$_CalculateLetterboxScale$_(t, s) : "letterbox-integer-scale" === e ? this._$_CalculateLetterboxIntegerScale$_(t, s) : "off" === e ? this._$_CalculateFixedSizeCanvas$_(t, s) : this._$_CalculateFullsizeCanvas$_(t, s), 
            this._$_UpdateFullscreenScalingQuality$_(e);
            for (const {canvas: t} of this._$_canvasLayers$_) t.width = this._$_canvasDeviceWidth$_, 
            t.height = this._$_canvasDeviceHeight$_;
            this._$_runtime$_._$PostComponentMessageToDOM$_("canvas", "update-size", {
                marginLeft: this._$_canvasCssOffsetX$_,
                marginTop: this._$_canvasCssOffsetY$_,
                styleWidth: this._$_canvasCssWidth$_,
                styleHeight: this._$_canvasCssHeight$_,
                displayScale: this._$GetDisplayScale$_()
            });
            const n = this._$GetRenderer$_();
            n._$SetSize$_(this._$_canvasDeviceWidth$_, this._$_canvasDeviceHeight$_, !0);
            for (const t of this._$_availableAdditionalRenderTargets$_) n._$DeleteRenderTarget$_(t);
            jw._$clearArray$_(this._$_availableAdditionalRenderTargets$_), this._$UpdateDefaultProjectionMatrix$_();
            const h = this._$_runtime$_._$GetLayoutManager$_();
            h._$SetAllLayerProjectionChanged$_(), h._$SetAllLayerMVChanged$_();
        }
        _$UpdateDefaultProjectionMatrix$_() {
            this._$GetRenderer$_()._$CalculatePerspectiveMatrix$_(this._$_defaultProjectionMatrix$_, this._$GetDrawWidth$_() / this._$GetDrawHeight$_());
        }
        _$GetDefaultProjectionMatrix$_() {
            return this._$_defaultProjectionMatrix$_;
        }
        _$_CalculateLetterboxScale$_(t, s) {
            const i = this._$_runtime$_._$GetDevicePixelRatio$_(), e = this._$_runtime$_._$GetOriginalViewportWidth$_(), n = this._$_runtime$_._$GetOriginalViewportHeight$_(), h = e / n;
            if (t / s > h) {
                const i = s * h;
                this._$_canvasCssWidth$_ = Math.round(i), this._$_canvasCssHeight$_ = s, this._$_canvasCssOffsetX$_ = Math.floor((t - this._$_canvasCssWidth$_) / 2), 
                this._$_canvasCssOffsetY$_ = 0;
            } else {
                const i = t / h;
                this._$_canvasCssWidth$_ = t, this._$_canvasCssHeight$_ = Math.round(i), this._$_canvasCssOffsetX$_ = 0, 
                this._$_canvasCssOffsetY$_ = Math.floor((s - this._$_canvasCssHeight$_) / 2);
            }
            this._$_canvasDeviceWidth$_ = Math.round(this._$_canvasCssWidth$_ * i), this._$_canvasDeviceHeight$_ = Math.round(this._$_canvasCssHeight$_ * i), 
            this._$_runtime$_._$SetViewportSize$_(e, n);
        }
        _$_CalculateLetterboxIntegerScale$_(t, s) {
            const i = this._$_runtime$_._$GetDevicePixelRatio$_();
            1 !== i && (t += 1, s += 1);
            const e = this._$_runtime$_._$GetOriginalViewportWidth$_(), n = this._$_runtime$_._$GetOriginalViewportHeight$_(), h = e / n;
            let r;
            r = t / s > h ? s * h * i / e : t / h * i / n, r > 1 ? r = Math.floor(r) : r < 1 && (r = 1 / Math.ceil(1 / r)), 
            this._$_canvasDeviceWidth$_ = Math.round(e * r), this._$_canvasDeviceHeight$_ = Math.round(n * r), 
            this._$_canvasCssWidth$_ = this._$_canvasDeviceWidth$_ / i, this._$_canvasCssHeight$_ = this._$_canvasDeviceHeight$_ / i, 
            this._$_canvasCssOffsetX$_ = Math.max(Math.floor((t - this._$_canvasCssWidth$_) / 2), 0), 
            this._$_canvasCssOffsetY$_ = Math.max(Math.floor((s - this._$_canvasCssHeight$_) / 2), 0), 
            this._$_runtime$_._$SetViewportSize$_(e, n);
        }
        _$_CalculateFullsizeCanvas$_(t, s) {
            const i = this._$_runtime$_._$GetDevicePixelRatio$_();
            this._$_canvasCssWidth$_ = t, this._$_canvasCssHeight$_ = s, this._$_canvasDeviceWidth$_ = Math.round(this._$_canvasCssWidth$_ * i), 
            this._$_canvasDeviceHeight$_ = Math.round(this._$_canvasCssHeight$_ * i), this._$_canvasCssOffsetX$_ = 0, 
            this._$_canvasCssOffsetY$_ = 0;
            const e = this._$GetDisplayScale$_();
            this._$_runtime$_._$SetViewportSize$_(this._$_canvasCssWidth$_ / e, this._$_canvasCssHeight$_ / e);
        }
        _$_CalculateFixedSizeCanvas$_(t, s) {
            const i = this._$_runtime$_._$GetDevicePixelRatio$_();
            this._$_canvasCssWidth$_ = this._$_runtime$_._$GetViewportWidth$_(), this._$_canvasCssHeight$_ = this._$_runtime$_._$GetViewportHeight$_(), 
            this._$_canvasDeviceWidth$_ = Math.round(this._$_canvasCssWidth$_ * i), this._$_canvasDeviceHeight$_ = Math.round(this._$_canvasCssHeight$_ * i), 
            this._$IsDocumentFullscreen$_() ? (this._$_canvasCssOffsetX$_ = Math.floor((t - this._$_canvasCssWidth$_) / 2), 
            this._$_canvasCssOffsetY$_ = Math.floor((s - this._$_canvasCssHeight$_) / 2)) : (this._$_canvasCssOffsetX$_ = 0, 
            this._$_canvasCssOffsetY$_ = 0), this._$_runtime$_._$SetViewportSize$_(this._$_runtime$_._$GetViewportWidth$_(), this._$_runtime$_._$GetViewportHeight$_());
        }
        _$_UpdateFullscreenScalingQuality$_(t) {
            if ("high" === this._$_wantFullscreenScalingQuality$_) this._$_drawWidth$_ = this._$_canvasDeviceWidth$_, 
            this._$_drawHeight$_ = this._$_canvasDeviceHeight$_, this._$_fullscreenScalingQuality$_ = "high"; else {
                let s, i;
                if ("off" === this._$GetCurrentFullscreenMode$_() ? (s = this._$_runtime$_._$GetViewportWidth$_(), 
                i = this._$_runtime$_._$GetViewportHeight$_()) : (s = this._$_runtime$_._$GetOriginalViewportWidth$_(), 
                i = this._$_runtime$_._$GetOriginalViewportHeight$_()), this._$_canvasDeviceWidth$_ < s || this._$_canvasDeviceHeight$_ < i) this._$_drawWidth$_ = this._$_canvasDeviceWidth$_, 
                this._$_drawHeight$_ = this._$_canvasDeviceHeight$_, this._$_fullscreenScalingQuality$_ = "high"; else if (this._$_drawWidth$_ = s, 
                this._$_drawHeight$_ = i, this._$_fullscreenScalingQuality$_ = "low", "scale-inner" === t) {
                    const t = s / i, e = this._$_windowInnerWidth$_ / this._$_windowInnerHeight$_;
                    e < t ? this._$_drawWidth$_ = this._$_drawHeight$_ * e : e > t && (this._$_drawHeight$_ = this._$_drawWidth$_ / e);
                } else if ("scale-outer" === t) {
                    const t = s / i, e = this._$_windowInnerWidth$_ / this._$_windowInnerHeight$_;
                    e > t ? this._$_drawWidth$_ = this._$_drawHeight$_ * e : e < t && (this._$_drawHeight$_ = this._$_drawWidth$_ / e);
                }
            }
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetMainCanvas$_() {
            return this._$_canvasLayers$_[0].canvas;
        }
        _$GetEffectChainManager$_() {
            return this._$_effectChainManager$_;
        }
        _$IsDocumentFullscreen$_() {
            return this._$_isDocumentFullscreen$_;
        }
        _$GetCssDisplayMode$_() {
            return this._$_cssDisplayMode$_;
        }
        _$SetFullscreenMode$_(t) {
            if (!Bw.has(t)) throw new Error("invalid fullscreen mode");
            this._$_fullscreenMode$_ = t;
            const s = this._$_runtime$_._$GetLayoutManager$_();
            s._$SetAllLayerProjectionChanged$_(), s._$SetAllLayerMVChanged$_();
        }
        _$GetFullscreenMode$_() {
            return this._$_fullscreenMode$_;
        }
        _$SetDocumentFullscreenMode$_(t) {
            if (!Bw.has(t)) throw new Error("invalid fullscreen mode");
            this._$_documentFullscreenMode$_ = t;
            const s = this._$_runtime$_._$GetLayoutManager$_();
            s._$SetAllLayerProjectionChanged$_(), s._$SetAllLayerMVChanged$_();
        }
        _$GetDocumentFullscreenMode$_() {
            return this._$_documentFullscreenMode$_;
        }
        _$GetCurrentFullscreenMode$_() {
            return this._$IsDocumentFullscreen$_() ? this._$GetDocumentFullscreenMode$_() : this._$GetFullscreenMode$_();
        }
        _$SetFullscreenScalingQuality$_(t) {
            if (!zw.has(t)) throw new Error("invalid fullscreen scaling quality");
            this._$_wantFullscreenScalingQuality$_ = t, this._$_runtime$_._$GetLayoutManager$_()._$SetAllLayerProjectionChanged$_();
        }
        _$GetSetFullscreenScalingQuality$_() {
            return this._$_wantFullscreenScalingQuality$_;
        }
        _$GetCurrentFullscreenScalingQuality$_() {
            return this._$_fullscreenScalingQuality$_;
        }
        static _$_FullscreenModeNumberToString$_(t) {
            switch (t) {
              case 0:
                return "off";

              case 1:
                return "crop";

              case 2:
                return "scale-inner";

              case 3:
                return "scale-outer";

              case 4:
                return "letterbox-scale";

              case 5:
                return "letterbox-integer-scale";

              default:
                throw new Error("invalid fullscreen mode");
            }
        }
        _$GetLastWidth$_() {
            return this._$_windowInnerWidth$_;
        }
        _$GetLastHeight$_() {
            return this._$_windowInnerHeight$_;
        }
        _$GetDrawWidth$_() {
            return this._$_drawWidth$_;
        }
        _$GetDrawHeight$_() {
            return this._$_drawHeight$_;
        }
        _$SetMipmapsEnabled$_(t) {
            this._$_enableMipmaps$_ = !!t;
        }
        _$_SetTextureAnisotropy$_(t) {
            this._$_textureAnisotropy$_ = t;
        }
        _$GetTextureAnisotropy$_() {
            return this._$_textureAnisotropy$_;
        }
        _$IsRendererContextLost$_() {
            return this._$GetRenderer$_()._$IsContextLost$_();
        }
        _$_OnWebGLContextLost$_(t) {
            console.log("[Construct] WebGL context lost"), t.preventDefault(), this._$_availableAdditionalRenderTargets$_ = [], 
            this._$_usedAdditionalRenderTargets$_.clear(), this._$_effectChainManager$_._$OnContextLost$_(), 
            this._$_webglRenderer$_._$OnContextLost$_(), this._$_runtime$_._$_OnRendererContextLost$_();
        }
        _$_OnWebGPUDeviceLost$_() {
            console.log("[Construct] WebGPU device lost"), this._$_availableAdditionalRenderTargets$_ = [], 
            this._$_usedAdditionalRenderTargets$_.clear(), this._$_effectChainManager$_._$OnContextLost$_(), 
            this._$_runtime$_._$_OnRendererContextLost$_();
        }
        async _$_OnWebGLContextRestored$_(t) {
            await this._$_webglRenderer$_._$OnContextRestored$_(), await this._$_InitRenderer$_(), 
            await this._$_runtime$_._$_OnRendererContextRestored$_(), console.log("[Construct] WebGL context restored");
        }
        async _$_OnWebGPUDeviceRestored$_() {
            await this._$_InitRenderer$_(), await this._$_runtime$_._$_OnRendererContextRestored$_(), 
            console.log("[Construct] WebGPU device restored");
        }
        _$GetWebGLRenderer$_() {
            return this._$_webglRenderer$_;
        }
        _$GetWebGPURenderer$_() {
            return this._$_webgpuRenderer$_;
        }
        _$GetRenderer$_() {
            return this._$_webgpuRenderer$_ || this._$_webglRenderer$_;
        }
        _$GetIRenderer$_() {
            return this._$_iRenderer$_;
        }
        _$GetRendererString$_() {
            let t = "";
            return t = this._$_runtime$_._$GetWebGPURenderer$_() ? "webgpu" : "webgl" + this._$_runtime$_._$GetWebGLRenderer$_()._$GetWebGLVersionNumber$_(), 
            this._$_runtime$_._$GetRenderer$_()._$HasMajorPerformanceCaveat$_() && (t += "-software"), 
            t;
        }
        _$GetRendererDetailString$_() {
            return this._$_runtime$_._$GetWebGPURenderer$_() ? this._$_runtime$_._$GetWebGPURenderer$_()._$GetAdapterInfoString$_() : this._$_runtime$_._$GetWebGLRenderer$_()._$GetUnmaskedRenderer$_();
        }
        _$GetRenderScale$_() {
            return "low" === this._$_fullscreenScalingQuality$_ ? 1 / this._$_runtime$_._$GetDevicePixelRatio$_() : this._$GetDisplayScale$_();
        }
        _$GetDisplayScale$_() {
            const t = this._$GetCurrentFullscreenMode$_();
            if ("off" === t || "crop" === t) return 1;
            const s = this._$_runtime$_._$GetOriginalViewportWidth$_(), i = this._$_runtime$_._$GetOriginalViewportHeight$_(), e = s / i, n = this._$_canvasDeviceWidth$_ / this._$_canvasDeviceHeight$_;
            return "scale-inner" !== t && n > e || "scale-inner" === t && n < e ? this._$_canvasCssHeight$_ / i : this._$_canvasCssWidth$_ / s;
        }
        _$GetEffectLayerScaleParam$_() {
            return "low" === this._$GetCurrentFullscreenScalingQuality$_() ? 1 : this._$GetDisplayScale$_();
        }
        _$GetEffectDevicePixelRatioParam$_() {
            return "low" === this._$GetCurrentFullscreenScalingQuality$_() ? 1 : this._$_runtime$_._$GetDevicePixelRatio$_();
        }
        _$SetDeviceTransformOffset$_(t, s) {
            this._$_deviceTransformOffX$_ = t, this._$_deviceTransformOffY$_ = s;
        }
        _$SetDeviceTransform$_(t, s, i, e = !0) {
            s = s || this._$_drawWidth$_, i = i || this._$_drawHeight$_;
            const n = s / 2 + this._$_deviceTransformOffX$_, h = i / 2 + this._$_deviceTransformOffY$_;
            if (e) {
                let e = this._$GetDefaultProjectionMatrix$_();
                s === this._$_drawWidth$_ && i === this._$_drawHeight$_ || (t._$CalculatePerspectiveMatrix$_(Jw, s / i), 
                e = Jw), t._$SetProjectionMatrix$_(e);
            }
            const r = t._$CalculateLookAtModelView2$_(n, h, t._$GetDefaultCameraZ$_(i), n, h, 0, i);
            t._$SetModelViewMatrix$_(r);
        }
        _$SetCssTransform$_(t, s = !0) {
            const i = this._$GetCssWidth$_(), e = this._$GetCssHeight$_(), n = i / 2, h = e / 2;
            s && t._$SetProjectionMatrix$_(this._$GetDefaultProjectionMatrix$_());
            const r = t._$CalculateLookAtModelView2$_(n, h, t._$GetDefaultCameraZ$_(e), n, h, 0, e);
            t._$SetModelViewMatrix$_(r);
        }
        _$GetDeviceWidth$_() {
            return this._$_canvasDeviceWidth$_;
        }
        _$GetDeviceHeight$_() {
            return this._$_canvasDeviceHeight$_;
        }
        _$GetCssWidth$_() {
            return this._$_canvasCssWidth$_;
        }
        _$GetCssHeight$_() {
            return this._$_canvasCssHeight$_;
        }
        _$GetCanvasClientX$_() {
            return this._$_canvasCssOffsetX$_;
        }
        _$GetCanvasClientY$_() {
            return this._$_canvasCssOffsetY$_;
        }
        _$GetHTMLLayerCount$_() {
            return this._$_canvasLayers$_.length;
        }
        _$_CanUseImageBitmapRenderingContext$_() {
            return "undefined" != typeof OffscreenCanvas && this._$GetMainCanvas$_() instanceof OffscreenCanvas && ("Chromium" !== jw._$Platform$_._$BrowserEngine$_ || jw._$Platform$_._$BrowserVersionNumber$_ >= 124);
        }
        async _$SetHTMLLayerCount$_(t, s = !1) {
            if (t < 1) throw new Error("invalid HTML layer count");
            if (this._$_canvasLayers$_.length === t) return;
            const i = {
                count: t,
                layersDomState: this._$_runtime$_._$GetLayoutManager$_()._$GetMainRunningLayout$_()._$_GetRootLayers$_().filter((t => t._$IsHTMLElementsLayer$_())).map((t => t._$_GetHTMLLayerDOMState$_())),
                immediate: s,
                marginLeft: this._$_canvasCssOffsetX$_,
                marginTop: this._$_canvasCssOffsetY$_,
                styleWidth: this._$_canvasCssWidth$_,
                styleHeight: this._$_canvasCssHeight$_
            };
            let e;
            if (e = this._$IsInWorker$_() ? await this._$_runtime$_._$PostComponentMessageToDOMAsync$_("canvas", "set-html-layer-count", i) : self.c3_runtimeInterface._OnSetHTMLLayerCount(i), 
            t < this._$_canvasLayers$_.length) this._$_canvasLayers$_.length = t; else for (const t of e.addedCanvases) {
                t.width = this._$_canvasDeviceWidth$_, t.height = this._$_canvasDeviceHeight$_;
                const s = this._$_CanUseImageBitmapRenderingContext$_() ? "bitmaprenderer" : "2d", i = t.getContext(s);
                if (!i) throw new Error(`failed to acquire '${s}' canvas context`);
                this._$_canvasLayers$_.push({
                    canvas: t,
                    _$ctx$_: i
                });
            }
            this._$_runtime$_._$UpdateRender$_();
        }
        _$BlitMainCanvasToHTMLLayerCanvas$_(t) {
            if (t >= this._$_canvasLayers$_.length) return;
            const s = this._$GetMainCanvas$_(), i = this._$_canvasLayers$_[t]._$ctx$_;
            this._$_CanUseImageBitmapRenderingContext$_() ? i.transferFromImageBitmap(s.transferToImageBitmap()) : (i.globalCompositeOperation = "copy", 
            i.drawImage(s, 0, 0));
        }
        _$GetAdditionalRenderTarget$_(t) {
            t.depth = this._$_runtime$_._$Uses3DFeatures$_();
            const s = this._$_availableAdditionalRenderTargets$_, i = s.findIndex((s => s._$IsCompatibleWithOptions$_(t)));
            let e;
            return -1 !== i ? (e = s[i], s.splice(i, 1)) : e = this._$GetRenderer$_()._$CreateRenderTarget$_(t), 
            this._$_usedAdditionalRenderTargets$_.add(e), e;
        }
        _$ReleaseAdditionalRenderTarget$_(t) {
            if (!this._$_usedAdditionalRenderTargets$_.has(t)) throw new Error("render target not in use");
            this._$_usedAdditionalRenderTargets$_.delete(t), this._$_availableAdditionalRenderTargets$_.push(t);
        }
        _$GetEffectCompositorRenderTarget$_() {
            const t = {
                _$sampling$_: this._$_runtime$_._$GetSampling$_()
            };
            return "low" === this._$GetCurrentFullscreenScalingQuality$_() && (t.width = this._$GetDrawWidth$_(), 
            t.height = this._$GetDrawHeight$_()), this._$GetAdditionalRenderTarget$_(t);
        }
        _$ReleaseEffectCompositorRenderTarget$_(t) {
            this._$ReleaseAdditionalRenderTarget$_(t);
        }
        * _$activeLayersGpuProfiles$_() {
            for (const t of this._$_runtime$_._$GetLayoutManager$_()._$runningLayouts$_()) for (const s of t._$GetLayers$_()) {
                const t = this._$_layersGpuProfile$_.get(s);
                t && (yield t);
            }
        }
        _$GetLayerTimingsBuffer$_(t) {
            if (!this._$GetRenderer$_()._$SupportsGPUProfiling$_()) return null;
            let s = this._$_layersGpuProfile$_.get(t);
            return s || (s = {
                _$layer$_: t,
                name: t._$GetName$_(),
                _$timingsBuffer$_: jw._$New$_(jw._$Gfx$_._$WebGLQueryResultBuffer$_, this._$_webglRenderer$_),
                _$curUtilisation$_: 0,
                _$lastTotalUtilisation$_: 0,
                _$lastSelfUtilisation$_: 0
            }, this._$_layersGpuProfile$_.set(t, s)), s._$timingsBuffer$_;
        }
        _$_Update1sFrameRange$_() {
            const t = this._$GetRenderer$_();
            if (t._$SupportsGPUProfiling$_() && 0 === this._$_gpuTimeEndFrame$_) {
                this._$_gpuTimeEndFrame$_ = t._$GetFrameNumber$_(), this._$_gpuCurUtilisation$_ = NaN;
                for (const t of this._$activeLayersGpuProfiles$_()) t._$curUtilisation$_ = NaN;
            }
        }
        _$_UpdateTick$_() {
            this._$_webglRenderer$_ && this._$_webglRenderer$_._$SupportsGPUProfiling$_() && this._$_UpdateTick_WebGL$_(), 
            this._$_webgpuRenderer$_ && this._$_webgpuRenderer$_._$SupportsGPUProfiling$_() && this._$_UpdateTick_WebGPU$_();
        }
        _$_UpdateTick_WebGL$_() {
            if (isNaN(this._$_gpuCurUtilisation$_) && (this._$_gpuCurUtilisation$_ = this._$_gpuFrameTimingsBuffer$_._$GetFrameRangeResultSum$_(this._$_gpuTimeStartFrame$_, this._$_gpuTimeEndFrame$_), 
            !isNaN(this._$_gpuCurUtilisation$_))) {
                if (this._$_runtime$_._$IsDebug$_()) for (const t of this._$activeLayersGpuProfiles$_()) if (t._$curUtilisation$_ = t._$timingsBuffer$_._$GetFrameRangeResultSum$_(this._$_gpuTimeStartFrame$_, this._$_gpuTimeEndFrame$_), 
                isNaN(t._$curUtilisation$_)) return;
                if (this._$_gpuFrameTimingsBuffer$_._$DeleteAllBeforeFrameNumber$_(this._$_gpuTimeEndFrame$_), 
                this._$_gpuLastUtilisation$_ = Math.min(this._$_gpuCurUtilisation$_, 1), this._$_runtime$_._$IsDebug$_()) {
                    const t = new Map;
                    for (const s of this._$activeLayersGpuProfiles$_()) s._$timingsBuffer$_._$DeleteAllBeforeFrameNumber$_(this._$_gpuTimeEndFrame$_), 
                    s._$lastTotalUtilisation$_ = Math.min(s._$curUtilisation$_, 1), t.set(s._$layer$_, s._$lastTotalUtilisation$_);
                    for (const s of this._$activeLayersGpuProfiles$_()) {
                        const i = s._$layer$_, e = (t.get(i) || 0) - i._$GetSubLayers$_().reduce(((s, i) => s + (t.get(i) || 0)), 0);
                        s._$lastSelfUtilisation$_ = jw._$clamp$_(e, 0, 1);
                    }
                    const s = this._$_runtime$_._$GetMainRunningLayout$_(), i = this._$_gpuLastUtilisation$_ - s._$_GetRootLayers$_().reduce(((s, i) => s + (t.get(i) || 0)), 0);
                    self._$C3Debugger$_._$UpdateGPUProfile$_(jw._$clamp$_(i, 0, 1), this._$_gpuLastUtilisation$_, [ ...this._$activeLayersGpuProfiles$_() ]);
                }
                this._$_gpuTimeStartFrame$_ = this._$_gpuTimeEndFrame$_, this._$_gpuTimeEndFrame$_ = 0;
            }
        }
        _$GetGPUFrameTimingsBuffer$_() {
            return this._$_gpuFrameTimingsBuffer$_;
        }
        _$_UpdateTick_WebGPU$_() {
            if (0 === this._$_gpuTimeEndFrame$_) return;
            for (let t = this._$_gpuTimeStartFrame$_; t < this._$_gpuTimeEndFrame$_; ++t) {
                const s = this._$_webgpuFrameTimings$_.get(t);
                if (s && !s._$HasResult$_()) return;
            }
            const t = this._$_runtime$_._$GetMainRunningLayout$_(), s = jw._$MakeFilledArray$_(t._$GetLayerCount$_() + 1, 0);
            let i = 0;
            for (let t = this._$_gpuTimeStartFrame$_; t < this._$_gpuTimeEndFrame$_; ++t) {
                const e = this._$_webgpuFrameTimings$_.get(t);
                if (!e) continue;
                const n = e._$GetResult$_();
                let h = BigInt(0), r = BigInt(0);
                const o = BigInt(0);
                for (let t = 0, i = Math.min(s.length, n.length / 2); t < i; ++t) {
                    const i = n[2 * t], e = n[2 * t + 1];
                    i !== o && (h === o || i < h) && (h = i), e > r && (r = e);
                    const a = Number(e - i) / 1e9;
                    s[t] += a;
                }
                i += Number(r - h) / 1e9;
            }
            if (this._$_gpuLastUtilisation$_ = jw._$clamp$_(i, 0, 1), this._$_runtime$_._$IsDebug$_()) {
                const i = t._$GetLayers$_(), e = new Map;
                for (let t = 0, n = Math.min(i.length, s.length - 1); t < n; ++t) {
                    const n = s[t + 1];
                    e.set(i[t], n);
                }
                const n = [], h = new Map;
                for (const [t, s] of e) {
                    const i = [ ...t._$selfAndAllSubLayers$_() ].reduce(((t, s) => t + (e.get(s) || 0)), 0);
                    h.set(t, i), n.push({
                        name: t._$GetName$_(),
                        _$lastSelfUtilisation$_: jw._$clamp$_(s, 0, 1),
                        _$lastTotalUtilisation$_: jw._$clamp$_(i, 0, 1)
                    });
                }
                const r = this._$_gpuLastUtilisation$_ - t._$_GetRootLayers$_().reduce(((t, s) => t + (h.get(s) || 0)), 0);
                self._$C3Debugger$_._$UpdateGPUProfile$_(jw._$clamp$_(r, 0, 1), this._$_gpuLastUtilisation$_, n);
            }
            for (let t = this._$_gpuTimeStartFrame$_; t < this._$_gpuTimeEndFrame$_; ++t) this._$_webgpuFrameTimings$_.delete(t);
            this._$_gpuTimeStartFrame$_ = this._$_gpuTimeEndFrame$_, this._$_gpuTimeEndFrame$_ = 0;
        }
        _$_AddWebGPUFrameTiming$_(t) {
            this._$_webgpuFrameTimings$_.set(this._$_webgpuRenderer$_._$GetFrameNumber$_(), t);
        }
        _$GetGPUUtilisation$_() {
            return this._$_gpuLastUtilisation$_;
        }
        _$SnapshotCanvas$_(t, s, i, e, n, h) {
            return this._$_snapshotFormat$_ = t, this._$_snapshotQuality$_ = s, this._$_snapshotArea$_._$setWH$_(i, e, n, h), 
            this._$_snapshotPromise$_ || (this._$_snapshotPromise$_ = new Promise((t => {
                this._$_snapshotResolve$_ = t;
            }))), this._$_snapshotPromise$_;
        }
        _$_MaybeTakeSnapshot$_() {
            if (!this._$_snapshotFormat$_) return;
            let t = this._$GetMainCanvas$_();
            const s = this._$_snapshotArea$_, i = jw._$clamp$_(Math.floor(s._$getLeft$_()), 0, t.width), e = jw._$clamp$_(Math.floor(s._$getTop$_()), 0, t.height);
            let n = s.width();
            n = 0 === n ? t.width - i : jw._$clamp$_(Math.floor(n), 0, t.width - i);
            let h = s.height();
            if (h = 0 === h ? t.height - e : jw._$clamp$_(Math.floor(h), 0, t.height - e), (0 !== i || 0 !== e || n !== t.width || h !== t.height) && n > 0 && h > 0) {
                const s = jw._$CreateCanvas$_(n, h);
                s.getContext("2d").drawImage(t, i, e, n, h, 0, 0, n, h), t = s;
            }
            jw._$CanvasToBlob$_(t, this._$_snapshotFormat$_, this._$_snapshotQuality$_).then((t => {
                this._$_snapshotUrl$_ && URL.revokeObjectURL(this._$_snapshotUrl$_), this._$_snapshotUrl$_ = URL.createObjectURL(t), 
                this._$_snapshotPromise$_ = null, this._$_snapshotResolve$_(t);
            })), this._$_snapshotFormat$_ = "", this._$_snapshotQuality$_ = 1;
        }
        _$GetCanvasSnapshotUrl$_() {
            return this._$_snapshotUrl$_;
        }
        _$SetIsPastingToDrawingCanvas$_(t) {
            t ? this._$_isPastingToDrawingCanvas$_++ : this._$_isPastingToDrawingCanvas$_--;
        }
        _$IsPastingToDrawingCanvas$_() {
            return this._$_isPastingToDrawingCanvas$_ > 0;
        }
        _$InitLoadingScreen$_(t) {
            const s = this._$GetRenderer$_();
            if (2 === t) this._$_percentText$_ = jw._$New$_(jw._$Gfx$_._$RendererText$_, this._$GetRenderer$_()), 
            this._$_percentText$_._$SetFontName$_("Arial"), this._$_percentText$_._$SetFontSize$_(16), 
            this._$_percentText$_._$SetHorizontalAlignment$_("center"), this._$_percentText$_._$SetVerticalAlignment$_("center"), 
            this._$_percentText$_._$SetSize$_(300, 200); else if (0 === t) {
                const t = this._$_runtime$_._$GetLoadingLogoAsset$_();
                t && t._$LoadStaticTexture$_(s).catch((t => console.warn("[C3 runtime] Failed to create texture for loading logo: ", t)));
            } else 4 === t && (this._$_LoadSvgSplashImage$_("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAxNi4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+DQo8c3ZnIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiDQoJIHdpZHRoPSIxNzAwLjc5MDA0cHgiIGhlaWdodD0iMTcwMC43OTAwNHB4IiB2aWV3Qm94PSIyODcgMzE3IDExMjUgMTEyNSINCgkgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMTcwMC43OTAwNCAxNzAwLjc5MDA0IiB4bWw6c3BhY2U9InByZXNlcnZlIj4NCjxnIGlkPSJsb2dvIj4NCgk8Zz4NCgkJPGc+DQoJCQk8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZmlsbD0iI0ZGRkZGRiIgZD0iTTM1NC45Nzc1NCwxMTk1LjYyMzA1DQoJCQkJYzExLjM4NDc3LDAsMjIuMDEyNywzLjIzNzMsMzEuMDE3NTgsOC44Mzc4OWMxLjk0NjI5LDEuMjEwOTQsMi41ODQ5NiwzLjc0OTAyLDEuNDM4NDgsNS43MzQzOGwtNC45MzI2Miw4LjU0MTk5DQoJCQkJYy0zLjI3ODMyLDUuNjc5NjktMTAuMDMzMiw4LjM3Njk1LTE2LjMxNzM4LDYuNTAwOThjLTIuNzY0NjUtMC44MjUyLTUuNjkzMzYtMS4yNjg1NS04LjcyNjU2LTEuMjY4NTUNCgkJCQljLTE2LjgyOTEsMC0zMC40NzI2NiwxMy42NDM1NS0zMC40NzI2NiwzMC40NzI2NmMwLDE2LjgyODEzLDEzLjY0MzU1LDMwLjQ3MjY2LDMwLjQ3MjY2LDMwLjQ3MjY2DQoJCQkJYzMuMDMzMiwwLDUuOTYxOTEtMC40NDMzNiw4LjcyNjU2LTEuMjY4NTVjNi4yOTQ5Mi0xLjg3OTg4LDEzLjAzMzIsMC44MTE1MiwxNi4zMTczOCw2LjUwMDk4bDQuOTMxNjQsOC41NDE5OQ0KCQkJCWMxLjE0NzQ2LDEuOTg4MjgsMC41MTA3NCw0LjUyMzQ0LTEuNDM4NDgsNS43MzQzOGMtOS4wMDM5MSw1LjYwMTU2LTE5LjYzMTg0LDguODM3ODktMzEuMDE2Niw4LjgzNzg5DQoJCQkJYy0zMi40ODUzNSwwLTU4LjgxOTM0LTI2LjMzNDk2LTU4LjgxOTM0LTU4LjgxOTM0QzI5Ni4xNTgyLDEyMjEuOTU3MDMsMzIyLjQ5MjE5LDExOTUuNjIzMDUsMzU0Ljk3NzU0LDExOTUuNjIzMDUNCgkJCQlMMzU0Ljk3NzU0LDExOTUuNjIzMDV6IE03MDMuMjE0ODQsMTI1OS4xNzU3OGMtMTQuNTU5NTctOS44MTczOC0yMC4yMDMxMy0yMC4wMzIyMy0yMC4yMDMxMy0zMy4wODAwOA0KCQkJCWMwLTE4LjQ4OTI2LDE1LjcxNDg0LTI5Ljc2MzY3LDM4LjI2NjYtMjkuNzYzNjdjOS42NTcyMywwLDE4LjcyMTY4LDIuNTQyOTcsMjYuNTU5NTcsNi45OTQxNA0KCQkJCWMyLjA0OTgsMS4xNjQwNiwyLjc2MTcyLDMuNzgzMiwxLjU4MzAxLDUuODI0MjJsLTMuNDE3OTcsNS45MTk5MmMtMy4yNDcwNyw1LjYyNDAyLTkuOTA4Miw4LjMzMTA1LTE2LjE1MzMyLDYuNTQ4ODMNCgkJCQljLTIuNzIzNjMtMC43NzYzNy01LjU5ODYzLTEuMTkyMzgtOC41NzEyOS0xLjE5MjM4Yy0xMC40OTAyMywwLTExLjU5ODYzLDkuNTc2MTctNC44NTc0MiwxNC4xMjMwNWwyMy42ODY1MiwxNS45NzY1Ng0KCQkJCWM5Ljk5MDIzLDYuNzM4MjgsMTUuODk1NTEsMTcuMDY2NDEsMTUuODk1NTEsMjguNzE4NzVjMCwxOC43ODYxMy0xNS4wMDY4NCwzMy4zMDc2Mi0zOC4yNjc1OCwzMy4zMDc2Mg0KCQkJCWMtOS41MjI0NiwwLTE4LjU4Nzg5LTEuOTU3MDMtMjYuODE1NDMtNS40OTAyM2MtNy43ODEyNS0zLjMzOTg0LTEwLjkzMzU5LTEyLjc4MjIzLTYuNjk3MjctMjAuMTE4MTZsMy40ODczLTYuMDQxOTkNCgkJCQljMS4yMTM4Ny0yLjA5OTYxLDMuOTMxNjQtMi43NTk3Nyw1Ljk3NDYxLTEuNDU2MDVjNi44NTkzOCw0LjM4MjgxLDE2LjQ5MDIzLDcuNTk0NzMsMjQuNzU4NzksNy41OTQ3Mw0KCQkJCWMxMC41NDU5LDAsMTEuMzI4MTMtOS45NTg5OCwzLjc2NzU4LTE1LjA1NzYyTDcwMy4yMTQ4NCwxMjU5LjE3NTc4TDcwMy4yMTQ4NCwxMjU5LjE3NTc4eiBNOTg0LjYzMDg2LDEyMDIuMDAwOTgNCgkJCQljMC0yLjM0NzY2LDEuOTAzMzItNC4yNTE5NSw0LjI1MTk1LTQuMjUxOTVoOS45MjE4OGM3LjgyNzE1LDAsMTQuMTcyODUsNi4zNDU3LDE0LjE3Mjg1LDE0LjE3MzgzdjU3LjQwMTM3DQoJCQkJYzAsOC42MTAzNSw2Ljk4MDQ3LDE1LjU5MDgyLDE1LjU5MDgyLDE1LjU5MDgyczE1LjU5MDgyLTYuOTgwNDcsMTUuNTkwODItMTUuNTkwODJ2LTU3LjQwMTM3DQoJCQkJYzAtNy44MjgxMyw2LjM0NTctMTQuMTczODMsMTQuMTcyODUtMTQuMTczODNoOS45MjA5YzIuMzQ4NjMsMCw0LjI1MTk1LDEuOTA0Myw0LjI1MTk1LDQuMjUxOTV2NjcuMzIzMjQNCgkJCQljMCwyNC4yNjU2My0xOS42NzA5LDQzLjkzNzUtNDMuOTM2NTIsNDMuOTM3NXMtNDMuOTM3NS0xOS42NzE4OC00My45Mzc1LTQzLjkzNzVWMTIwMi4wMDA5OEw5ODQuNjMwODYsMTIwMi4wMDA5OHoNCgkJCQkgTTQ2Ni44NjkxNCwxMTk1LjYyMzA1YzMyLjQ4NDM4LDAsNTguODE4MzYsMjYuMzMzOTgsNTguODE4MzYsNTguODE5MzRjMCwzMi40ODQzOC0yNi4zMzM5OCw1OC44MTkzNC01OC44MTgzNiw1OC44MTkzNA0KCQkJCWMtMzIuNDg2MzMsMC01OC44MTkzNC0yNi4zMzQ5Ni01OC44MTkzNC01OC44MTkzNEM0MDguMDQ5OCwxMjIxLjk1NzAzLDQzNC4zODI4MSwxMTk1LjYyMzA1LDQ2Ni44NjkxNCwxMTk1LjYyMzA1DQoJCQkJTDQ2Ni44NjkxNCwxMTk1LjYyMzA1eiBNNDY2Ljg2OTE0LDEyMjUuMDMzMmMtMTYuMjQzMTYsMC0yOS40MTAxNiwxMy4xNjY5OS0yOS40MTAxNiwyOS40MDkxOA0KCQkJCXMxMy4xNjY5OSwyOS40MDgyLDI5LjQxMDE2LDI5LjQwODJjMTYuMjQxMjEsMCwyOS40MDgyLTEzLjE2NjAyLDI5LjQwODItMjkuNDA4MlM0ODMuMTEwMzUsMTIyNS4wMzMyLDQ2Ni44NjkxNCwxMjI1LjAzMzINCgkJCQlMNDY2Ljg2OTE0LDEyMjUuMDMzMnogTTU1Ni43MzI0MiwxMzExLjEzNDc3Yy0yLjM0NzY2LDAtNC4yNTE5NS0xLjkwMjM0LTQuMjUxOTUtNC4yNXYtOTQuOTYxOTENCgkJCQljMC03LjgyODEzLDYuMzQ1Ny0xNC4xNzM4MywxNC4xNzM4My0xNC4xNzM4M2gzLjk1ODk4YzQuNjI1LDAsOC45NTg5OCwyLjI1Njg0LDExLjYxMTMzLDYuMDQ1OWw0MS4xMjIwNyw1OC43NDcwN3YtNTAuNjE5MTQNCgkJCQljMC03LjgyODEzLDYuMzQ1Ny0xNC4xNzM4MywxNC4xNzI4NS0xNC4xNzM4M2g5LjkyMTg4YzIuMzQ3NjYsMCw0LjI1MTk1LDEuOTA0Myw0LjI1MTk1LDQuMjUxOTV2OTQuOTYwOTQNCgkJCQljMCw3LjgyOTEtNi4zNDU3LDE0LjE3Mjg1LTE0LjE3MzgzLDE0LjE3Mjg1aC0zLjk1ODk4Yy00LjYyNSwwLTguOTU4OTgtMi4yNTU4Ni0xMS42MTEzMy02LjA0NDkybC00MS4xMjIwNy01OC43NDYwOXY1MC42MTgxNg0KCQkJCWMwLDcuODI5MS02LjM0NTcsMTQuMTcyODUtMTQuMTcyODUsMTQuMTcyODVINTU2LjczMjQyTDU1Ni43MzI0MiwxMzExLjEzNDc3eiBNMTIxNS4wMjA1MSwxMjExLjkyMjg1DQoJCQkJYzAtNy44MjgxMyw2LjM0NTctMTQuMTczODMsMTQuMTcyODUtMTQuMTczODNoNTAuMzE1NDNjMi4zNDg2MywwLDQuMjUxOTUsMS45MDQzLDQuMjUxOTUsNC4yNTE5NXY1LjY2OTkyDQoJCQkJYzAsNy44MjcxNS02LjM0NTcsMTQuMTcyODUtMTQuMTcyODUsMTQuMTcyODVoLTYuMDI0NDF2NzUuMTE4MTZjMCw3LjgyOTEtNi4zNDU3LDE0LjE3Mjg1LTE0LjE3Mjg1LDE0LjE3Mjg1aC05LjkyMTg4DQoJCQkJYy0yLjM0ODYzLDAtNC4yNTE5NS0xLjkwMjM0LTQuMjUxOTUtNC4yNXYtODUuMDQxMDJoLTE1Ljk0NDM0Yy0yLjM0ODYzLDAtNC4yNTE5NS0xLjkwMzMyLTQuMjUxOTUtNC4yNTE5NVYxMjExLjkyMjg1DQoJCQkJTDEyMTUuMDIwNTEsMTIxMS45MjI4NXogTTc3Ni40NDkyMiwxMjExLjkyMjg1YzAtNy44MjgxMyw2LjM0NTctMTQuMTczODMsMTQuMTczODMtMTQuMTczODNoNTAuMzE0NDUNCgkJCQljMi4zNDk2MSwwLDQuMjUxOTUsMS45MDQzLDQuMjUxOTUsNC4yNTE5NXY1LjY2OTkyYzAsNy44MjcxNS02LjM0NTcsMTQuMTcyODUtMTQuMTcxODgsMTQuMTcyODVoLTYuMDI1Mzl2NzUuMTE4MTYNCgkJCQljMCw3LjgyOTEtNi4zNDU3LDE0LjE3Mjg1LTE0LjE3Mjg1LDE0LjE3Mjg1aC05LjkyMDljLTIuMzQ5NjEsMC00LjI1MTk1LTEuOTAyMzQtNC4yNTE5NS00LjI1di04NS4wNDEwMmgtMTUuOTQ1MzENCgkJCQljLTIuMzQ3NjYsMC00LjI1MTk1LTEuOTAzMzItNC4yNTE5NS00LjI1MTk1VjEyMTEuOTIyODVMNzc2LjQ0OTIyLDEyMTEuOTIyODV6IE05MjkuNjA0NDksMTI3Mi4wMjI0NmwyNi45NTgwMSwzMi4xMjc5Mw0KCQkJCWMyLjMxNDQ1LDIuNzU3ODEsMC4zNDM3NSw2Ljk4NDM4LTMuMjU2ODQsNi45ODQzOGgtMTkuNzA1MDhjLTQuMTg5NDUsMC04LjE2NTA0LTEuODUxNTYtMTAuODU3NDItNS4wNjA1NWwtMjIuNjgxNjQtMjcuMDMxMjUNCgkJCQl2MjcuODQxOGMwLDIuMzQ3NjYtMS45MDMzMiw0LjI1LTQuMjUxOTUsNC4yNWgtOS45MjA5Yy03LjgyNzE1LDAtMTQuMTcyODUtNi4zNDM3NS0xNC4xNzI4NS0xNC4xNzI4NXYtODUuMDM5MDYNCgkJCQljMC03LjgyODEzLDYuMzQ1Ny0xNC4xNzM4MywxNC4xNzI4NS0xNC4xNzM4M2gyOS43NjM2N2MyMi43MDAyLDAsNDEuMTAyNTQsMTcuMTMzNzksNDEuMTAyNTQsMzguMjY4NTUNCgkJCQlDOTU2Ljc1NDg4LDEyNTIuNTkwODIsOTQ1LjQzNjUyLDEyNjYuNzAyMTUsOTI5LjYwNDQ5LDEyNzIuMDIyNDZMOTI5LjYwNDQ5LDEyNzIuMDIyNDZ6IE05MDAuMDYxNTIsMTIyMS44NDM3NXYzMi41OTg2M2g4LjUwMzkxDQoJCQkJYzEwLjk1ODk4LDAsMTkuODQyNzctNy4yOTc4NSwxOS44NDI3Ny0xNi4yOTg4M2MwLTkuMDAxOTUtOC44ODM3OS0xNi4yOTk4LTE5Ljg0Mjc3LTE2LjI5OThIOTAwLjA2MTUyTDkwMC4wNjE1MiwxMjIxLjg0Mzc1eg0KCQkJCSBNMTE1OC4zNTkzOCwxMTk1LjYyMzA1YzExLjM4NDc3LDAsMjIuMDEyNywzLjIzNzMsMzEuMDE3NTgsOC44Mzc4OWMxLjk0NzI3LDEuMjEwOTQsMi41ODQ5NiwzLjc0OTAyLDEuNDM4NDgsNS43MzQzOA0KCQkJCWwtNC45MzI2Miw4LjU0MTk5Yy0zLjI3ODMyLDUuNjc5NjktMTAuMDMzMiw4LjM3Njk1LTE2LjMxNzM4LDYuNTAwOThjLTIuNzY0NjUtMC44MjUyLTUuNjkzMzYtMS4yNjg1NS04LjcyNTU5LTEuMjY4NTUNCgkJCQljLTE2LjgyOTEsMC0zMC40NzI2NiwxMy42NDM1NS0zMC40NzI2NiwzMC40NzI2NmMwLDE2LjgyODEzLDEzLjY0MzU1LDMwLjQ3MjY2LDMwLjQ3MjY2LDMwLjQ3MjY2DQoJCQkJYzMuMDMyMjMsMCw1Ljk2MDk0LTAuNDQzMzYsOC43MjU1OS0xLjI2ODU1YzYuMjk1OS0xLjg3OTg4LDEzLjAzMzIsMC44MTE1MiwxNi4zMTgzNiw2LjUwMDk4bDQuOTMwNjYsOC41NDE5OQ0KCQkJCWMxLjE0NzQ2LDEuOTg4MjgsMC41MTA3NCw0LjUyMzQ0LTEuNDM3NSw1LjczNDM4Yy05LjAwNDg4LDUuNjAxNTYtMTkuNjMyODEsOC44Mzc4OS0zMS4wMTc1OCw4LjgzNzg5DQoJCQkJYy0zMi40ODUzNSwwLTU4LjgxOTM0LTI2LjMzNDk2LTU4LjgxOTM0LTU4LjgxOTM0QzEwOTkuNTQwMDQsMTIyMS45NTcwMywxMTI1Ljg3NDAyLDExOTUuNjIzMDUsMTE1OC4zNTkzOCwxMTk1LjYyMzA1eiIvPg0KCQkJPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGZpbGw9IiMwMEZGREEiIGQ9Ik0xMzE4LjE5NzI3LDEyMDYuMDMyMjMNCgkJCQljMC03LjgyODEzLDYuMzQ1Ny0xNC4xNzM4MywxNC4xNzI4NS0xNC4xNzM4M2MyMC42NTYyNSwwLDQxLjMxMjUsMCw2MS45Njg3NSwwYzMuNDI5NjksMCw1LjQ1MDIsMy44ODA4NiwzLjQ4MzQsNi42OTA0Mw0KCQkJCWwtMTkuMjk2ODgsMjcuNTY3MzhjMTUuNTQyOTcsOC4zNzU5OCwyNi4xMDY0NSwyNC44MDA3OCwyNi4xMDY0NSw0My42OTUzMWMwLDI3LjM5NzQ2LTIyLjIwODk4LDQ5LjYwNjQ1LTQ5LjYwNjQ1LDQ5LjYwNjQ1DQoJCQkJYy0xNi42ODg0OCwwLTMxLjQ1MTE3LTguMjQwMjMtNDAuNDQzMzYtMjAuODc1OThjLTEuNDUwMi0yLjAzOTA2LTAuODMxMDUtNC44OTk0MSwxLjMzNTk0LTYuMTUyMzRsMTAuOTc3NTQtNi4zMzc4OQ0KCQkJCWM0Ljg4MTg0LTIuODE4MzYsMTAuOTc5NDktMi40NzU1OSwxNS41MTQ2NSwwLjg3MzA1YzMuNTI4MzIsMi42MDU0Nyw3Ljg5MTYsNC4xNDY0OCwxMi42MTUyMyw0LjE0NjQ4DQoJCQkJYzExLjc0MjE5LDAsMjEuMjU5NzctOS41MTg1NSwyMS4yNTk3Ny0yMS4yNTk3N3MtOS41MTc1OC0yMS4yNTk3Ny0yMS4yNTk3Ny0yMS4yNTk3N2gtMTUuMjE3NzcNCgkJCQljLTMuNDI5NjksMC01LjQ1MDItMy44ODA4Ni0zLjQ4NDM4LTYuNjkwNDNsMTguMTM1NzQtMjUuOTA4MmgtMzIuMDA5NzdjLTIuMzQ4NjMsMC00LjI1MTk1LTEuOTAzMzItNC4yNTE5NS00LjI1MTk1VjEyMDYuMDMyMjN6DQoJCQkJIi8+DQoJCTwvZz4NCgkJPGc+DQoJCQk8Zz4NCgkJCQk8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZmlsbD0iI0RBRThGNyIgZD0iTTg1MC4zOTU1MSw4NTcuNTkxOA0KCQkJCQljLTUwLjM1NjQ1LDAtOTQuMzI1Mi0yNy4zNTY0NS0xMTcuODUyNTQtNjguMDIwNTFsLTgwLjAzMDI3LDQ2LjIwNDFjLTQuNjU1MjcsMi42ODk0NS02LjEzMTg0LDguNzE4NzUtMy4yNDkwMiwxMy4yNTU4Ng0KCQkJCQljNDIuMjM3Myw2Ni40ODYzMywxMTYuNTMzMiwxMTAuNjA3NDIsMjAxLjEzMTg0LDExMC42MDc0MmM4OC4xMjU5OCwwLDE2NS4wNzEyOS00Ny44NzUsMjA2LjI0MzE2LTExOS4wMzYxM2wtODAuNDg3My00Ni40Njk3Mw0KCQkJCQljLTQuMzEzNDgtMi40OTAyMy05LjgwMTc2LTEuMjA1MDgtMTIuNTcwMzEsMi45MzU1NUM5MzkuMTc1NzgsODMzLjU2MjUsODk3LjU5MTgsODU3LjU5MTgsODUwLjM5NTUxLDg1Ny41OTE4DQoJCQkJCUw4NTAuMzk1NTEsODU3LjU5MTh6IE0xMTM2LjcyMTY4LDU1Ni4yMTc3N2M0LjYxNDI2LTIuNjYzMDksNi4xMTAzNS04LjYxOTE0LDMuMzEyNS0xMy4xNTEzNw0KCQkJCQljLTU5LjkxNTA0LTk3LjAzMDI3LTE2Ny4yMjQ2MS0xNjEuNjk0MzQtMjg5LjYzODY3LTE2MS42OTQzNGMtMTI1Ljg5MzU1LDAtMjM1LjgxMzQ4LDY4LjM5MjU4LTI5NC42MzM3OSwxNzAuMDQ5OA0KCQkJCQlsODAuMzc2OTUsNDYuNDA2MjVjNC4zOTc0NiwyLjUzOTA2LDEwLjAwMTk1LDEuMTQ5NDEsMTIuNzEwOTQtMy4xNDU1MQ0KCQkJCQljNDIuMTY0MDYtNjYuODUxNTYsMTE2LjY2ODk1LTExMS4yNjM2NywyMDEuNTQ1OS0xMTEuMjYzNjdjODguMTI1OTgsMCwxNjUuMDcxMjksNDcuODc1OTgsMjA2LjI0MzE2LDExOS4wMzYxMw0KCQkJCQlMMTEzNi43MjE2OCw1NTYuMjE3Nzd6Ii8+DQoJCQkJPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGZpbGw9IiNBNUJBQzgiIGQ9Ik04NTAuMzk1NTEsOTU5LjYzODY3DQoJCQkJCWMtODQuNTk4NjMsMC0xNTguODk0NTMtNDQuMTIxMDktMjAxLjEzMTg0LTExMC42MDc0MmMtMi44NzY5NS00LjUzMDI3LTEuMzk5NDEtMTAuNTcwMzEsMy4yNDkwMi0xMy4yNTU4Nmw4MC4wMzAyNy00Ni4yMDQxDQoJCQkJCWMtMTEuNTgxMDUtMjAuMDE2Ni0xOC4yMDk5Ni00My4yNTQ4OC0xOC4yMDk5Ni02OC4wNDE5OWMwLTc0Ljc4NTE2LDYwLjU1NzYyLTEzNi4wNjI1LDEzNi4wNjI1LTEzNi4wNjI1DQoJCQkJCWM0Ny4xOTYyOSwwLDg4Ljc4MDI3LDI0LjAyOTMsMTEzLjE4NTU1LDYwLjUyMjQ2YzIuNzY0NjUsNC4xMzM3OSw4LjI2MzY3LDUuNDIxODgsMTIuNTcwMzEsMi45MzU1NWw4MC40ODczLTQ2LjQ2OTczDQoJCQkJCWMtNDEuMTcxODgtNzEuMTYwMTYtMTE4LjExNzE5LTExOS4wMzYxMy0yMDYuMjQzMTYtMTE5LjAzNjEzYy04NC44NzY5NSwwLTE1OS4zODE4NCw0NC40MTIxMS0yMDEuNTQ1OSwxMTEuMjYzNjcNCgkJCQkJYy0yLjcwNjA1LDQuMjkxMDItOC4zMTgzNiw1LjY4MTY0LTEyLjcxMDk0LDMuMTQ1NTFsLTgwLjM3Njk1LTQ2LjQwNjI1DQoJCQkJCWMtMjguOTUyMTUsNTAuMDQwMDQtNDUuNTIzNDQsMTA4LjEzOTY1LTQ1LjUyMzQ0LDE3MC4xMDc0MmMwLDE4Ni45NjM4NywxNTEuMzk0NTMsMzQwLjE1NzIzLDM0MC4xNTcyMywzNDAuMTU3MjMNCgkJCQkJYzEyMi40MTQwNiwwLDIyOS43MjM2My02NC42NjQwNiwyODkuNjM4NjctMTYxLjY5NTMxYzIuNzk0OTItNC41MjYzNywxLjI5NDkyLTEwLjQ5MDIzLTMuMzEyNS0xMy4xNTEzN2wtODAuMDgzMDEtNDYuMjM3Mw0KCQkJCQlDMTAxNS40NjY4LDkxMS43NjM2Nyw5MzguNTIxNDgsOTU5LjYzODY3LDg1MC4zOTU1MSw5NTkuNjM4Njd6Ii8+DQoJCQk8L2c+DQoJCQk8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZmlsbD0iIzAwRkZEQSIgZD0iTTExMzcuMTg1NTUsNzU4LjExMzI4di03My4xNjc5N2wtNjMuMzY1MjMsMzYuNTgzOTgNCgkJCQlMMTEzNy4xODU1NSw3NTguMTEzMjhMMTEzNy4xODU1NSw3NTguMTEzMjh6IE0xMDI2LjU3NjE3LDcwNS4xNjQwNmwxMjAuMDU4NTktNjkuMzE2NDENCgkJCQljMTIuNTY4MzYtNy4yNTU4NiwyOC4zNDQ3MywxLjg1MjU0LDI4LjM0NTcsMTYuMzY2MjF2MTM4LjYzMDg2Yy0wLjAwMDk4LDE0LjUxMjctMTUuNzc3MzQsMjMuNjIyMDctMjguMzQ1NywxNi4zNjYyMQ0KCQkJCWwtMTIwLjA1ODU5LTY5LjMxNjQxQzEwMTQuMDI4MzIsNzMwLjY0OTQxLDEwMTQuMDI4MzIsNzEyLjQwOTE4LDEwMjYuNTc2MTcsNzA1LjE2NDA2eiIvPg0KCQk8L2c+DQoJPC9nPg0KPC9nPg0KPC9zdmc+DQo=").then((t => {
                "done" === this._$_splashState$_ ? s._$DeleteTexture$_(t) : this._$_splashTextures$_._$logo$_ = t;
            })).catch((t => console.warn("Failed to load splash image: ", t))), this._$_LoadBitmapSplashImage$_("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAABABAMAAACekdKMAAAAMFBMVEUAAAByfYZyfYZyfYZyfYZyfYZyfYZyfYZyfYZyfYZyfYZyfYZyfYZyfYZyfYZyfYYgo7vbAAAAD3RSTlMAmd137hFVqjO7zCKIRGZ881JRAAAFZklEQVR42u2aO68SQRTHR3leQeI3wMRo7CDGZyyg0MTEYlFbEylMLC+JsQYfvTZWFpgYKwuImlhqYiyNfgOsbRBYefn4O+ecGdgF0caEMbv/5N6BYRY4vzNzzplZVKxYsWLFihUrViwHVcIBJdoDqAjqvwGwF6LJ6YgDAI5EHQBuRR3AvBZNAENu73pAI8oAVB74GWkA6gOG0QawF2hFGkACKEcaQA7yna804Z9UG5U6A9ys2SfH8Y2vaWNyQrfm8aC8AiBdgX9aOSkGIBIAl6Qq4pcm3L8r6SELfNQmF6E1oI4iDu4CP+w1xuIEtPx6CEC2A61HSvX1lSwPB5UbCgIgQ/d7YDXIFN9Ex/PUyNM7YD1jAEfAALIlqSO6SqsN0igEoAfSsKWS5i3303JzQ6tLoAfRjF3eEm+NqclgovsMn2GNAJwTAPcgOsyjjIIAFq/ngbrJuS3lhpYA0uSVnAecVYU28EZbzm7Kmhl/jeqEl8ATlauweUXtdD1AX0PtCxlWoQGpYysARl11g17Pmu69mCtHtASwA9Tp30P9uMCeLeKBeMuXUPBVqSZbmSvhGwN4w1NDrHoOdFXKM/EhBGBGQbNPMaSDKvXdx0g5oiWAXbKzZ1zTx9CYrPZB5u0HPFb7Tb38kswsmiDZkzbnaZsTZkAmBOApxxDqqshyqmiAjmgBoADyStt8swy56xrG7K0Se7qDsu72a4uAWDRjmzpIilVVTcvvcn70ggA+Smmgx72WCdLRMB2RBfCiQ0EqZR2Xo+m9g+9s13VtGb3U0kiox8THIr6wrSA+TGqq/wabCiH2/g4vp5w7SSC4HfZbKs2z3fooweuh42cwpRjp06KY2jxetgDSNqInMdIDxhsAyMIv8AckgJpyRAEARzng1ezW6KvK0rMUBmnye57+VfDF2vdGALA19q2+6wFfNwJIYmCm2A5myhUtAYx46duQ2Cdfd1DX9o1T3pxi4ZiDu9UBBiAGWg10X3UjgH1kdhNVyaiuyAKYnZRUaPNzj/LgBw4EVdXk5X+eYuQ6gJ0wgIMbAIjfZY309TxxRTYILr5jEMAuqtrwhm7LtCMIAXiwDkBf3PwzAFkHelRDuaI/Akhiqr1V1xAe69lQ/juAv8+APHzKkXXligIA1mNABiPtrZpuv6kOutp1gfxtAWQCZe0fY8Bes8Gop+E7kwRCAFazgCpgkvIm1I5SmHNvdQWA+NTqb1lAXtijHzijMIBCoA44SDWOn8ZPamdpUxRN1wAkAju7v9UBUi8m9SBnFAaQC1aCjOE2u7SJq5iKDWsAssGyTkrFzZWgUq8x7qGqnFEYgN0L2AK+guN4wO1nVHm03w0BEFsvKqt98Gub9wJVDoUDyq7OaAVA30S0Xem+Dw9ldmwbDZnuEgWfl5cAKuaa3CG1YTd42O4GufFLmogzWgGwD3go9f1Y4hbQZbdJcEiV5OAr7U2WAC4Dz6i9job2vKyBZhCAXNOXt0oB+iPdURiAPRFqGkfmgbnxHmoyJfD9o0q0MWwtAGQBvFfqDO8m+r8/EWrJiZCw0YzcURhA6ExQZsKIl7TtKMDogswAVn+5nbQ7gxCAIUSHzerCVLmjMIDQqbAYPjXBcWTznD3hFQCCSXRUHEwatQMAZkJ12DXlgDunIWEAolfBX0tI6RcsAHJi4DvJAqFrvtcWc8SvFwMABnJf4JZ57tBpyBqAtTtDFZOxXi9uZKROaVPLwTQo1+CtfdyhO0MhAKE7Q/spGEZZWXeOxLejvDtH4ttR0qHTkK2ojwcq0urgk4qyEi6dhmxB6Wa0YyAAZ34asRUB8F35ZcBWxDuGKKuIJypWrFixYsX6B/oFRYsi2zOzWJcAAAAASUVORK5CYII=").then((t => {
                "done" === this._$_splashState$_ ? s._$DeleteTexture$_(t) : this._$_splashTextures$_._$powered$_ = t;
            })).catch((t => console.warn("Failed to load splash image: ", t))), this._$_LoadBitmapSplashImage$_("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAABABAMAAACekdKMAAAAMFBMVEUAAAByfYZyfYZyfYZyfYZyfYZyfYZyfYZyfYZyfYZyfYZyfYZyfYZyfYZyfYZyfYYgo7vbAAAAD3RSTlMAdxHdu4hmVZnuRMwzqiLYE4y2AAAFw0lEQVR42u2Yy+9LQRTHp6Xq0VIkXkFvwkYslAWJiGJj2a6sJJe/oF3YWGElEQmxkYi4ErFWNpatWFmIx9Lm1sJCLKgqraqv82h726l6hOuRzDf53TtnOr+ZOZ+ZOffca5ycnJycnJycnJycnJycnJz+pi7g2G9osxjvzX8qB8ABcAAcgH8XwDa85dspNOiaRDuAR4U0PnHtDuyy7IJRJS6gvVmL6TywVkp4ZxIhulUxFvlaXQTrgEHbnMDH5XRjlXCdb+uAnc2ojWgFFTYBZ8e9tzcaswAk6v/3K4sPfPNRFj87IXj+KXQUS9m2jXoH1lMuLq2DtEcAtNMBT9PjanFq7ySAhbABVEAaeDaAwkk2D7GRqctAMQJIq2sBauLnB/VxCfqKpWrbRhSC1W5SMQ9RTgBUwKpF1ccmAIQ2gCxE+20Au9nSESvDgeIDkJSBMpA9vgyXdsj0H0GORL3n2fbwPOKoSQS4Q2cBOGzSJbQYAHDbZEI+rEuBcyZRlF71fIP/x0wBuIBOw6xH3xu2GQFAP2cegmvSwHkeqBZjECzB46UXD3bg8UKJCT6QYzgDY9uiU7hC11doERq6MAZ2CPJ7ipEulOrteDcB4KOZBpBG7zrV1JGzATzmIdnrl/go3bRiBJBHlZc+6ItjuQQ+yFLz8Gka2LZFRVTFGdoQJQ0LPodHnXkS8AjlRWkBLwKQswAs0PDzGpcsAAMNuG+5WgdqxwjgEcp8qcBjN5oZdPhEvOfhU/hsbJuVloWV6WWgp2IBLxXQNEwLDfKqoMXrEQBjATiFA3qePlgAZJRl+EStdaAQjfgALOC1zfeX8ALV+7S69JdALWjxHGqztmxyMnTD6OOBWvAdGDkn60c6vrI5H4CPnOJsWQDe8G0hIU0MB8ojFx+AFAeqeitLy5FkL3w0yNNcSOx3oDxjjxaH9XxldZluY5NBfwrAQvQbRjQXAO8UqVq5dh6A7HCgWzgdFwBdgOX4lMZbTndkWWkDN07Bk+zItllLdHm1+FkLwBSADNDf8B0AnGOp5gFYgJEexwcgGQx4iyeD9ybFkWsbDZbv0+2Y8XvGtqMpWsUimpMAzA1AUrj5ALjm2wCoONKB+ACYsEeDlU04MMs4imeJQqljslSuD4xl/zgAsx6ku/8DgDwaO9AwFU56qhzOPiXpKCzCpSSdb8v+CQDmXshb99cARAPFCOA1chWaFXlP55yn2FqEgiFvOSzYtmiJzisKB7MxQPS8iO63YsD3AHDv8QPgjR92eKuf9vts1wdZjvZhN4XajD35FNDiR7ln0LYBaILY+OZT4DsA+BkTP4AUrgXkxSJcDFps+72X7EGlx6mBbU/lAbdQjvKA7hSAlSuHxdw0gORsHrAUnXkAUuj+AQAZdHGRp9bShX2ECz1JRSk4zNhRJqj5SZQJfpgCUNS2eRsAP/usTDAxPxFKA834AZgAOM1z6qGgxxpdmUDQNjP25LtAsojxu0AehSkAF6RLXWR/EkAdVYEevQtswVtpMwuAB1JGh2jbxQcgBKrig/qSxTD6o2Nm7fttSY6uUnErV+jb4CJyaArAI5luJkCDOy5HAPISSB5A3wYbhJERahvtPALAAw2EI9Vzsh2TTuk23qEceN9d4vVVv227hNroe0CRi/o9IKTZTQFIAc/M8jwGEiouG2/042u8u25uAuPvAavRH7XhzqcBpICdRpssRa+aNLFoh2JeyBzU08fih/ht20WZXghW34s+/ZQnAKhzojsSH4CC/sjARPKamLXacOfTAIwfNSkCbROLluG9Tm2gdl3PY178tu2SBIpFQ6fHH//2GAvAogCkjtGDEAFQYPsu6DdBqw11bgFIF8dNHsQGIEFRSDOe0RS9YYJk23JMrw+/Cr9bFX0VXmNsACbhA088qXhBrMYAlq8Gjhh//FX4YNSGO7cASO9n9B99AuHk5OTk5OTk5OTk5OTk5OTk5OT0VX0B7+fX+9cwWYYAAAAASUVORK5CYII=").then((t => {
                "done" === this._$_splashState$_ ? s._$DeleteTexture$_(t) : this._$_splashTextures$_._$website$_ = t;
            })).catch((t => console.warn("Failed to load splash image: ", t))));
        }
        async _$_LoadSvgSplashImage$_(t) {
            t = new URL(t, this._$_runtime$_._$GetRuntimeBaseURL$_()).toString();
            const s = await jw._$FetchBlob$_(t), i = await this._$_runtime$_._$RasterSvgImage$_(s, 2048, 2048);
            return await this._$GetRenderer$_()._$CreateStaticTextureAsync$_(i, {
                _$mipMapQuality$_: "high"
            });
        }
        async _$_LoadBitmapSplashImage$_(t) {
            t = new URL(t, this._$_runtime$_._$GetRuntimeBaseURL$_()).toString();
            const s = await jw._$FetchBlob$_(t);
            return await this._$GetRenderer$_()._$CreateStaticTextureAsync$_(s, {
                _$mipMapQuality$_: "high"
            });
        }
        _$HideCordovaSplashScreen$_() {
            this._$_runtime$_._$PostComponentMessageToDOM$_("runtime", "hide-cordova-splash");
        }
        _$StartLoadingScreen$_() {
            this._$_loaderStartTime$_ = Date.now(), this._$_runtime$_._$Dispatcher$_().addEventListener("loadingprogress", this._$_loadingprogress_handler$_), 
            this._$_rafId$_ = requestAnimationFrame((() => this._$_DrawLoadingScreen$_())), 
            3 !== this._$_runtime$_._$GetLoaderStyle$_() && this._$HideCordovaSplashScreen$_();
        }
        async _$EndLoadingScreen$_() {
            const t = this._$GetRenderer$_();
            this._$_loadingProgress$_ = 1;
            const s = this._$_runtime$_._$GetLoaderStyle$_();
            4 === s && await this._$_splashDonePromise$_, this._$_splashDoneResolve$_ = null, 
            this._$_splashDonePromise$_ = null, -1 !== this._$_rafId$_ && (cancelAnimationFrame(this._$_rafId$_), 
            this._$_rafId$_ = -1), this._$_runtime$_._$Dispatcher$_().removeEventListener("loadingprogress", this._$_loadingprogress_handler$_), 
            this._$_loadingprogress_handler$_ = null, this._$_percentText$_ && (this._$_percentText$_._$Release$_(), 
            this._$_percentText$_ = null), this._$_runtime$_._$ReleaseLoadingLogoAsset$_(), 
            t._$Start$_(), this._$_splashTextures$_._$logo$_ && (t._$DeleteTexture$_(this._$_splashTextures$_._$logo$_), 
            this._$_splashTextures$_._$logo$_ = null), this._$_splashTextures$_._$powered$_ && (t._$DeleteTexture$_(this._$_splashTextures$_._$powered$_), 
            this._$_splashTextures$_._$powered$_ = null), this._$_splashTextures$_._$website$_ && (t._$DeleteTexture$_(this._$_splashTextures$_._$website$_), 
            this._$_splashTextures$_._$website$_ = null), t._$ClearRgba$_(0, 0, 0, 0), t._$Finish$_(), 
            this._$_splashState$_ = "done", this._$_gpuTimeStartFrame$_ = t._$GetFrameNumber$_(), 
            3 === s && this._$HideCordovaSplashScreen$_();
        }
        _$_DrawLoadingScreen$_() {
            if (-1 === this._$_rafId$_) return;
            const t = this._$GetRenderer$_();
            t._$Start$_(), this._$_rafId$_ = -1;
            const s = this._$_runtime$_._$GetAssetManager$_()._$HasHadErrorLoading$_(), i = this._$_runtime$_._$GetLoaderStyle$_();
            if (3 !== i && (this._$SetCssTransform$_(t), t._$ClearRgba$_(0, 0, 0, 0), t._$ResetColor$_(), 
            t._$SetTextureFillMode$_(), t._$SetTexture$_(null)), 0 === i) this._$_DrawProgressBarAndLogoLoadingScreen$_(s); else if (1 === i) this._$_DrawProgressBarLoadingScreen$_(s, 120, 0); else if (2 === i) this._$_DrawPercentTextLoadingScreen$_(s); else if (3 === i) jw._$noop$_(); else {
                if (4 !== i) throw new Error("invalid loader style");
                this._$_DrawSplashLoadingScreen$_(s);
            }
            t._$Finish$_(), this._$_rafId$_ = requestAnimationFrame((() => this._$_DrawLoadingScreen$_()));
        }
        _$_DrawPercentTextLoadingScreen$_(t) {
            t ? this._$_percentText$_._$SetColorRgb$_(1, 0, 0) : this._$_percentText$_._$SetColorRgb$_(.6, .6, .6), 
            this._$_percentText$_._$SetText$_(Math.round(100 * this._$_loadingProgress$_) + "%");
            const s = this._$_canvasCssWidth$_ / 2, i = this._$_canvasCssHeight$_ / 2;
            Qw._$setRect$_(s - 150, i - 100, s + 150, i + 100);
            const e = this._$GetRenderer$_();
            e._$SetTexture$_(this._$_percentText$_._$GetTexture$_()), e._$Quad3$_(Qw, this._$_percentText$_._$GetTexRect$_());
        }
        _$_DrawProgressBarLoadingScreen$_(t, s, i) {
            const e = this._$GetRenderer$_();
            e._$SetColorFillMode$_(), t ? e._$SetColorRgba$_(1, 0, 0, 1) : e._$SetColorRgba$_(.118, .565, 1, 1);
            const n = this._$_canvasCssWidth$_ / 2, h = this._$_canvasCssHeight$_ / 2, r = s / 2;
            Yw._$setWH$_(n - r, h - 4 + i, Math.floor(s * this._$_loadingProgress$_), 8), e.Rect(Yw), 
            Yw._$setWH$_(n - r, h - 4 + i, s, 8), Yw.offset(-.5, -.5), Yw._$inflate$_(.5, .5), 
            e._$SetColorRgba$_(0, 0, 0, 1), e._$LineRect2$_(Yw), Yw._$inflate$_(1, 1), e._$SetColorRgba$_(1, 1, 1, 1), 
            e._$LineRect2$_(Yw);
        }
        _$_DrawProgressBarAndLogoLoadingScreen$_(t) {
            const s = this._$GetRenderer$_(), i = this._$_runtime$_._$GetLoadingLogoAsset$_();
            if (!i) return void this._$_DrawProgressBarLoadingScreen$_(t, 120, 0);
            const e = i._$GetTexture$_();
            if (!e) return void this._$_DrawProgressBarLoadingScreen$_(t, 120, 0);
            const n = e._$GetWidth$_(), h = e._$GetHeight$_(), r = this._$_canvasCssWidth$_ / 2, o = this._$_canvasCssHeight$_ / 2, a = n / 2, u = h / 2;
            Qw._$setRect$_(r - a, o - u, r + a, o + u), s._$SetTexture$_(e), s._$Quad$_(Qw), 
            this._$_DrawProgressBarLoadingScreen$_(t, n, u + 16);
        }
        _$_DrawSplashLoadingScreen$_(t) {
            const s = this._$GetRenderer$_(), i = this._$_splashTextures$_._$logo$_, e = this._$_splashTextures$_._$powered$_, n = this._$_splashTextures$_._$website$_, h = Date.now();
            0 === this._$_splashFrameNumber$_ && (this._$_loaderStartTime$_ = h);
            const r = this._$_runtime$_._$IsPreview$_() || this._$_runtime$_._$IsFBInstantAvailable$_() && !this._$_runtime$_._$IsCordova$_(), o = r ? 0 : 200, a = r ? 0 : 3e3;
            let u = 1;
            "fade-in" === this._$_splashState$_ ? u = Math.min((h - this._$_loaderStartTime$_) / 300, 1) : "fade-out" === this._$_splashState$_ && (u = Math.max(1 - (h - this._$_splashFadeOutStartTime$_) / 300, 0)), 
            s._$SetColorFillMode$_(), s._$SetColorRgba$_(.231 * u, .251 * u, .271 * u, u), Yw.set(0, 0, this._$_canvasCssWidth$_, this._$_canvasCssHeight$_), 
            s.Rect(Yw);
            const l = Math.ceil(this._$_canvasCssWidth$_), c = Math.ceil(this._$_canvasCssHeight$_);
            let f, d;
            this._$_canvasCssHeight$_ > 256 ? (s._$SetColorRgba$_(.302 * u, .334 * u, .365 * u, u), 
            f = l, d = Math.max(.005 * c, 2), Yw._$setWH$_(0, .8 * c - d / 2, f, d), s.Rect(Yw), 
            t ? s._$SetColorRgba$_(u, 0, 0, u) : s._$SetColorRgba$_(.161 * u, .953 * u, .816 * u, u), 
            f = l * this._$_loadingProgress$_, Yw._$setWH$_(.5 * l - f / 2, .8 * c - d / 2, f, d), 
            s.Rect(Yw), s._$SetColorRgba$_(u, u, u, u), s._$SetTextureFillMode$_(), e && (f = 1.5 * jw._$clamp$_(.22 * c, 105, .6 * l), 
            d = f / 8, Yw._$setWH$_(.5 * l - f / 2, .2 * c - d / 2, f, d), s._$SetTexture$_(e), 
            s.Rect(Yw)), i && (f = Math.min(.395 * c, .95 * l), d = f, Yw._$setWH$_(.5 * l - f / 2, .485 * c - d / 2, f, d), 
            s._$SetTexture$_(i), s.Rect(Yw)), n && (f = 1.5 * jw._$clamp$_(.22 * c, 105, .6 * l), 
            d = f / 8, Yw._$setWH$_(.5 * l - f / 2, .868 * c - d / 2, f, d), s._$SetTexture$_(n), 
            s.Rect(Yw))) : (s._$SetColorRgba$_(.302 * u, .334 * u, .365 * u, u), f = l, d = Math.max(.005 * c, 2), 
            Yw._$setWH$_(0, .85 * c - d / 2, f, d), s.Rect(Yw), t ? s._$SetColorRgba$_(u, 0, 0, u) : s._$SetColorRgba$_(.161 * u, .953 * u, .816 * u, u), 
            f = l * this._$_loadingProgress$_, Yw._$setWH$_(.5 * l - f / 2, .85 * c - d / 2, f, d), 
            s.Rect(Yw), s._$SetColorRgba$_(u, u, u, u), s._$SetTextureFillMode$_(), i && (f = .55 * c, 
            d = f, Yw._$setWH$_(.5 * l - f / 2, .45 * c - d / 2, f, d), s._$SetTexture$_(i), 
            s.Rect(Yw))), this._$_splashFrameNumber$_++, "fade-in" === this._$_splashState$_ && h - this._$_loaderStartTime$_ >= 300 && this._$_splashFrameNumber$_ >= 2 && (this._$_splashState$_ = "wait", 
            this._$_splashFadeInFinishTime$_ = h), "wait" === this._$_splashState$_ && h - this._$_splashFadeInFinishTime$_ >= a && this._$_loadingProgress$_ >= 1 && (this._$_splashState$_ = "fade-out", 
            this._$_splashFadeOutStartTime$_ = h), ("fade-out" === this._$_splashState$_ && h - this._$_splashFadeOutStartTime$_ >= 300 + o || r && this._$_loadingProgress$_ >= 1 && h - this._$_loaderStartTime$_ < 500) && this._$_splashDoneResolve$_();
        }
    };
}

{
    const Vw = self._$C3$_, Hw = self._$C3Debugger$_, qw = (self.assert, self._$ISDKBehaviorInstanceBase$_), Xw = {
        messagePort: null,
        runtimeBaseUrl: "",
        headless: !1,
        hasDom: !0,
        isInWorker: !1,
        useAudio: !0,
        exportType: ""
    };
    let Zw = !0;
    Vw._$Runtime$_ = class extends Vw._$DefendedBase$_ {
        constructor(t) {
            t = Object.assign({}, Xw, t), super(), this._$_messagePort$_ = t.messagePort, this._$_runtimeBaseUrl$_ = t.runtimeBaseUrl, 
            this._$_previewUrl$_ = t.previewUrl, this._$_isHeadless$_ = !!t.headless, this._$_hasDom$_ = !!t.hasDom, 
            this._$_isInWorker$_ = !!t.isInWorker, Zw = t.ife, this._$_useAudio$_ = !!t.useAudio, 
            this._$_exportType$_ = t.exportType, this._$_isNWjs$_ = t.isNWjs, this._$_isiOSCordova$_ = !!t.isiOSCordova, 
            this._$_isiOSWebView$_ = !!t.isiOSWebView, this._$_isWindowsWebView2$_ = !!t.isWindowsWebView2, 
            this._$_isAnyWebView2Wrapper$_ = !!t.isAnyWebView2Wrapper, this._$_isFBInstantAvailable$_ = !!t.isFBInstantAvailable, 
            this._$_isDebug$_ = !("preview" !== this._$_exportType$_ || !t.isDebug), this._$_breakpointsEnabled$_ = this._$_isDebug$_, 
            this._$_isDebugging$_ = this._$_isDebug$_, this._$_debuggingDisabled$_ = 0, this._$_additionalLoadPromises$_ = [], 
            this._$_additionalCreatePromises$_ = [], this._$_isUsingCreatePromises$_ = !1, this._$_projectName$_ = "", 
            this._$_projectVersion$_ = "", this._$_projectUniqueId$_ = "", this._$_appId$_ = "", 
            this._$_exportTimestamp$_ = 0, this._$_originalViewportWidth$_ = 0, this._$_originalViewportHeight$_ = 0, 
            this._$_devicePixelRatio$_ = self.devicePixelRatio, this._$_parallaxXorigin$_ = 0, 
            this._$_parallaxYorigin$_ = 0, this._$_viewportWidth$_ = 0, this._$_viewportHeight$_ = 0, 
            this._$_loaderStyle$_ = 0, this._$_usesLoaderLayout$_ = !1, this._$_isLoading$_ = !0, 
            this._$_usesAnyBackgroundBlending$_ = !1, this._$_usesAnyCrossSampling$_ = !1, this._$_usesAnyDepthSampling$_ = !1, 
            this._$_loadingLogoAsset$_ = null, this._$_assetManager$_ = Vw._$New$_(Vw._$AssetManager$_, this, t), 
            this._$_layoutManager$_ = Vw._$New$_(Vw._$LayoutManager$_, this), this._$_eventSheetManager$_ = Vw._$New$_(Vw._$EventSheetManager$_, this), 
            this._$_addonManager$_ = Vw._$New$_(Vw._$AddonManager$_, this, t.wrapperComponentIds), 
            this._$_collisionEngine$_ = Vw._$New$_(Vw._$CollisionEngine$_, this), this._$_timelineManager$_ = Vw._$New$_(Vw._$TimelineManager$_, this), 
            this._$_transitionManager$_ = Vw._$New$_(Vw._$TransitionManager$_, this), this._$_templateManager$_ = Vw._$New$_(Vw._$TemplateManager$_, this), 
            this._$_flowchartManager$_ = Vw._$New$_(Vw._$FlowchartManager$_, this), this._$_textIconManager$_ = Vw._$New$_(Vw._$TextIconManager$_, {
                _$getIconSetMeta$_: t => this._$_GetTextIconSetMeta$_(t),
                _$getIconSetContent$_: t => this._$_GetTextIconSetContent$_(t)
            }), this._$_iconChangeHandlers$_ = new Map, this._$_allObjectClasses$_ = [], this._$_objectClassesByName$_ = new Map, 
            this._$_objectClassesBySid$_ = new Map, this._$_familyCount$_ = 0, this._$_allContainers$_ = [], 
            this._$_allEffectLists$_ = new Set, this._$_currentLayoutStack$_ = [], this._$_instancesPendingCreate$_ = [], 
            this._$_instancesPendingDestroy$_ = new Map, this._$_hasPendingInstances$_ = !1, 
            this._$_isFlushingPendingInstances$_ = !1, this._$_objectCount$_ = 0, this._$_nextUid$_ = 0, 
            this._$_instancesByUid$_ = new Map, this._$_instancesPendingRelease$_ = new Set, 
            this._$_instancesPendingReleaseAffectedObjectClasses$_ = new Set, this._$_objectReferenceTable$_ = [], 
            this._$_jsPropNameTable$_ = [], this._$_canvasManager$_ = null, this._$_uses3dFeatures$_ = !1, 
            this._$_framerateMode$_ = "vsync", this._$_sampling$_ = "trilinear", this._$_isPixelRoundingEnabled$_ = !1, 
            this._$_needRender$_ = !0, this._$_pauseOnBlur$_ = !1, this._$_isPausedOnBlur$_ = !1, 
            this._$_exportToVideo$_ = null, this._$_tickCallbacks$_ = {
                _$normal$_: t => {
                    this._$_rafId$_ = -1, this._$_ruafId$_ = -1, this._$Tick$_(t);
                },
                _$tickOnly$_: t => {
                    this._$_ruafId$_ = -1, this._$Tick$_(t, !1, "skip-render");
                },
                _$renderOnly$_: () => {
                    this._$_rafId$_ = -1, this._$Render$_();
                }
            }, this._$_rafId$_ = -1, this._$_ruafId$_ = -1, this._$_tickCount$_ = 0, this._$_tickCountNoSave$_ = 0, 
            this._$_hasStarted$_ = !1, this._$_isInTick$_ = !1, this._$_hasStartedTicking$_ = !1, 
            this._$_isLayoutFirstTick$_ = !0, this._$_isAutoSuspendEnabled$_ = !0, this._$_isPageVisibilitySuspended$_ = !1, 
            this._$_suspendCount$_ = 0, this._$_scheduleTriggersThrottle$_ = new Vw._$PromiseThrottle$_(1), 
            this._$_randomNumberCallback$_ = () => Math.random(), this._$_startTime$_ = 0, this._$_lastTickTime$_ = 0, 
            this._$_dtRaw$_ = 0, this._$_dt1$_ = 0, this._$_dt$_ = 0, this._$_timeScale$_ = 1, 
            this._$_maxDt$_ = 1 / 30, this._$_minDt$_ = 0, this._$_gameTime$_ = Vw._$New$_(Vw._$KahanSum$_), 
            this._$_gameTimeRaw$_ = Vw._$New$_(Vw._$KahanSum$_), this._$_wallTime$_ = Vw._$New$_(Vw._$KahanSum$_), 
            this._$_instanceTimes$_ = new Map, this._$_fpsFrameCount$_ = -1, this._$_fpsLastTime$_ = 0, 
            this._$_fps$_ = 0, this._$_tpsTickCount$_ = -1, this._$_tps$_ = 0, this._$_mainThreadTimeCounter$_ = 0, 
            this._$_mainThreadTime$_ = 0, this._$_isLoadingState$_ = !1, this._$_saveToSlotName$_ = "", 
            this._$_saveToJsonString$_ = !1, this._$_loadFromSlotName$_ = "", this._$_loadFromJson$_ = null, 
            this._$_lastSaveJson$_ = "", this._$_projectStorage$_ = null, this._$_savegamesStorage$_ = null, 
            this._$_dispatcher$_ = Vw._$New$_(Vw.Event._$Dispatcher$_), this._$_domEventHandlers$_ = new Map, 
            this._$_pendingResponsePromises$_ = new Map, this._$_nextDomResponseId$_ = 0, this._$_didRequestDeviceOrientationEvent$_ = !1, 
            this._$_didRequestDeviceMotionEvent$_ = !1, this._$_isReadyToHandleEvents$_ = !1, 
            this._$_waitingToHandleEvents$_ = [], this._$_eventObjects$_ = {
                pretick: Vw._$New$_(Vw.Event, "pretick", !1),
                tick: Vw._$New$_(Vw.Event, "tick", !1),
                tick2: Vw._$New$_(Vw.Event, "tick2", !1),
                instancecreate: Vw._$New$_(Vw.Event, "instancecreate", !1),
                instancedestroy: Vw._$New$_(Vw.Event, "instancedestroy", !1),
                beforelayoutchange: Vw._$New$_(Vw.Event, "beforelayoutchange", !1),
                layoutchange: Vw._$New$_(Vw.Event, "layoutchange", !1)
            }, this._$_eventObjects$_.instancecreate._$instance$_ = null, this._$_eventObjects$_.instancedestroy._$instance$_ = null, 
            this._$_userScriptDispatcher$_ = Vw._$New$_(Vw.Event._$Dispatcher$_), this._$_userScriptEventObjects$_ = null;
            const s = (t, s) => Vw._$BehaviorInstance$_._$SortByTickSequence$_(this, t, s);
            this._$_behInstsToTick$_ = Vw._$New$_(Vw._$RedBlackSet$_, s), this._$_behInstsToPostTick$_ = Vw._$New$_(Vw._$RedBlackSet$_, s), 
            this._$_behInstsToTick2$_ = Vw._$New$_(Vw._$RedBlackSet$_, s), this._$_jobScheduler$_ = Vw._$New$_(Vw._$JobSchedulerRuntime$_, this, t.jobScheduler), 
            t.canvas && (this._$_canvasManager$_ = Vw._$New$_(Vw._$CanvasManager$_, this)), 
            this._$_messagePort$_.onmessage = t => this._OnMessageFromDOM(t.data), this._$AddDOMComponentMessageHandler$_("runtime", "visibilitychange", (t => this._$_OnVisibilityChange$_(t))), 
            this._$AddDOMComponentMessageHandler$_("runtime", "wrapper-extension-message", (t => this._$_OnWrapperExtensionMessage$_(t))), 
            this._$AddDOMComponentMessageHandler$_("runtime", "get-remote-preview-status-info", (() => this._$_GetRemotePreviewStatusInfo$_())), 
            this._$AddDOMComponentMessageHandler$_("runtime", "js-invoke-function", (t => this._$_InvokeFunctionFromJS$_(t))), 
            this._$AddDOMComponentMessageHandler$_("runtime", "go-to-last-error-script", self.goToLastErrorScript), 
            this._$AddDOMComponentMessageHandler$_("runtime", "offline-audio-render-completed", (t => this._$_OnOfflineAudioRenderCompleted$_(t))), 
            this._$_dispatcher$_.addEventListener("window-blur", (t => this._$_OnWindowBlur$_(t))), 
            this._$_dispatcher$_.addEventListener("window-focus", (() => this._$_OnWindowFocus$_())), 
            this._$_timelineManager$_._$AddRuntimeListeners$_(), this._$_templateManager$_._$AddRuntimeListeners$_(), 
            this._$_iRuntime$_ = null, this._$_interfaceMap$_ = new WeakMap, this._$_commonScriptInterfaces$_ = {
                keyboard: null,
                _$mouse$_: null,
                _$touch$_: null,
                _$timelineController$_: null
            }, this._$_instancesNeedingAfterLoadMap$_ = new WeakMap, this._$_instancesNeedingAfterLoadArray$_ = [];
        }
        static _$Create$_(t) {
            return Vw._$New$_(Vw._$Runtime$_, t);
        }
        _$Release$_() {
            Vw._$clearArray$_(this._$_allObjectClasses$_), this._$_objectClassesByName$_.clear(), 
            this._$_objectClassesBySid$_.clear(), this._$_layoutManager$_._$Release$_(), this._$_layoutManager$_ = null, 
            this._$_eventSheetManager$_._$Release$_(), this._$_eventSheetManager$_ = null, this._$_addonManager$_._$Release$_(), 
            this._$_addonManager$_ = null, this._$_assetManager$_._$Release$_(), this._$_assetManager$_ = null, 
            this._$_collisionEngine$_._$Release$_(), this._$_collisionEngine$_ = null, this._$_timelineManager$_._$Release$_(), 
            this._$_timelineManager$_ = null, this._$_transitionManager$_._$Release$_(), this._$_transitionManager$_ = null, 
            this._$_templateManager$_._$Release$_(), this._$_templateManager$_ = null, this._$_flowchartManager$_._$Release$_(), 
            this._$_flowchartManager$_ = null, this._$_textIconManager$_._$Release$_(), this._$_textIconManager$_ = null, 
            this._$_canvasManager$_ && (this._$_canvasManager$_._$Release$_(), this._$_canvasManager$_ = null), 
            this._$_dispatcher$_._$Release$_(), this._$_dispatcher$_ = null, this._$_tickEvent$_ = null;
        }
        _OnMessageFromDOM(t) {
            const s = t.type;
            if ("event" === s) this._$_OnEventFromDOM$_(t); else {
                if ("result" !== s) throw new Error(`unknown message '${s}'`);
                this._$_OnResultFromDOM$_(t);
            }
        }
        _$_OnEventFromDOM$_(t) {
            if (!this._$_isReadyToHandleEvents$_) return void this._$_waitingToHandleEvents$_.push(t);
            const s = t.component, i = t.handler, e = t.data, n = t.dispatchOpts, h = !(!n || !n.dispatchRuntimeEvent), r = !(!n || !n.dispatchUserScriptEvent), o = t.responseId;
            if ("runtime" === s) {
                if (h) {
                    const t = new Vw.Event(i);
                    t.data = e, this._$_dispatcher$_._$dispatchEventAndWaitAsyncSequential$_(t);
                }
                if (r) {
                    const t = new Vw.Event(i, !0);
                    for (const [s, i] of Object.entries(e)) t[s] = i;
                    this._$DispatchUserScriptEvent$_(t);
                }
            }
            const a = this._$_domEventHandlers$_.get(s);
            if (!a) return void (h || r || console.warn(`[Runtime] No DOM event handlers for component '${s}'`));
            const u = a.get(i);
            if (!u) return void (h || r || console.warn(`[Runtime] No DOM handler '${i}' for component '${s}'`));
            let l = null;
            try {
                l = u(e);
            } catch (t) {
                return console.error(`Exception in '${s}' handler '${i}':`, t), void (null !== o && this._$_PostResultToDOM$_(o, !1, "" + t));
            }
            null !== o && (l && l.then ? l.then((t => this._$_PostResultToDOM$_(o, !0, t))).catch((t => {
                console.error(`Rejection from '${s}' handler '${i}':`, t), this._$_PostResultToDOM$_(o, !1, "" + t);
            })) : this._$_PostResultToDOM$_(o, !0, l));
        }
        _$_PostResultToDOM$_(t, s, i) {
            this._$_messagePort$_.postMessage({
                type: "result",
                responseId: t,
                isOk: s,
                result: i
            });
        }
        _$_OnResultFromDOM$_(t) {
            const s = t.responseId, i = t.isOk, e = t.result, n = this._$_pendingResponsePromises$_.get(s);
            i ? n.resolve(e) : n.reject(e), this._$_pendingResponsePromises$_.delete(s);
        }
        _$AddDOMComponentMessageHandler$_(t, s, i) {
            let e = this._$_domEventHandlers$_.get(t);
            if (e || (e = new Map, this._$_domEventHandlers$_.set(t, e)), e.has(s)) throw new Error(`[Runtime] Component '${t}' already has handler '${s}'`);
            e.set(s, i);
        }
        _$PostComponentMessageToDOM$_(t, s, i, e) {
            this._$_messagePort$_.postMessage({
                type: "event",
                component: t,
                handler: s,
                data: i,
                responseId: null
            }, e);
        }
        _$PostComponentMessageToDOMAsync$_(t, s, i, e) {
            const n = this._$_nextDomResponseId$_++, h = new Promise(((t, s) => {
                this._$_pendingResponsePromises$_.set(n, {
                    resolve: t,
                    reject: s
                });
            }));
            return this._$_messagePort$_.postMessage({
                type: "event",
                component: t,
                handler: s,
                data: i,
                responseId: n
            }, e), h;
        }
        _$SendWrapperExtensionMessage$_(t, s, i, e = -1) {
            this._$PostComponentMessageToDOM$_("runtime", "send-wrapper-extension-message", {
                componentId: t,
                messageId: s,
                params: i,
                asyncId: e
            });
        }
        _$SendWrapperExtensionMessageAsync$_(t, s, i) {
            const e = this._$_nextDomResponseId$_++, n = new Promise(((t, s) => {
                this._$_pendingResponsePromises$_.set(e, {
                    resolve: t,
                    reject: s
                });
            }));
            return this._$SendWrapperExtensionMessage$_(t, s, i, e), n;
        }
        _$_OnWrapperExtensionMessage$_(t) {
            if (-1 !== t.asyncId) {
                const s = t.asyncId;
                this._$_pendingResponsePromises$_.get(s).resolve(t.params), this._$_pendingResponsePromises$_.delete(s);
            } else this._$_OnEventFromDOM$_({
                component: "wrapper-extension:" + t.componentId,
                handler: t.messageId,
                data: t.params,
                responseId: null
            });
        }
        _$AddWrapperExtensionMessageHandler$_(t, s, i) {
            this._$AddDOMComponentMessageHandler$_("wrapper-extension:" + t, s, i);
        }
        _$HasWrapperComponentId$_(t) {
            return this._$_addonManager$_._$HasWrapperComponentId$_(t);
        }
        _$PostToDebugger$_(t) {
            if (!this._$IsDebug$_()) throw new Error("not in debug mode");
            this._$PostComponentMessageToDOM$_("runtime", "post-to-debugger", t);
        }
        async _$Init$_(t) {
            Vw._$CommonACES_SetRuntime$_(this), this._$IsDebug$_() ? await Hw._$Init$_(this) : self._$C3Debugger$_ && self._$C3Debugger$_._$InitPreview$_(this);
            const s = await this._$_assetManager$_._$FetchJson$_("data.json");
            if (await this._$_LoadDataJson$_(s), await this._$_InitialiseCanvas$_(t), this._$IsPreview$_() || console.info("%cMade with Construct, the game and animation creation tool. Visit: https://www.construct.net", "font-weight: bold"), 
            this._$GetWebGLRenderer$_()) {
                const t = this._$GetWebGLRenderer$_();
                console.info(`[C3 runtime] Hosted in ${this._$IsInWorker$_() ? "worker" : "DOM"}, rendering with WebGL ${t._$GetWebGLVersionNumber$_()} [${t._$GetUnmaskedRenderer$_()}]`);
            } else this._$GetWebGPURenderer$_() && console.info(`[C3 runtime] Hosted in ${this._$IsInWorker$_() ? "worker" : "DOM"}, rendering with WebGPU [${this._$GetWebGPURenderer$_()._$GetAdapterInfoString$_()}]`);
            this._$GetRenderer$_()._$HasMajorPerformanceCaveat$_() && console.warn("[C3 runtime] The renderer indicates a major performance caveat. Software rendering may be in use. This can result in significantly degraded performance."), 
            this._$_isReadyToHandleEvents$_ = !0;
            for (const t of this._$_waitingToHandleEvents$_) this._$_OnEventFromDOM$_(t);
            Vw._$clearArray$_(this._$_waitingToHandleEvents$_), this._$_canvasManager$_ && this._$_canvasManager$_._$StartLoadingScreen$_();
            for (const s of t.runOnStartupFunctions) this._$_additionalLoadPromises$_.push(this._$_RunOnStartupFunction$_(s));
            if (await Promise.all([ this._$_assetManager$_._$WaitForAllToLoad$_(), ...this._$_additionalLoadPromises$_ ]), 
            Vw._$clearArray$_(this._$_additionalLoadPromises$_), !this._$_assetManager$_._$HasHadErrorLoading$_()) return this._$_canvasManager$_ && await this._$_canvasManager$_._$EndLoadingScreen$_(), 
            await this._$_dispatcher$_._$dispatchEventAndWaitAsync$_(new Vw.Event("beforeruntimestart")), 
            await this._$Start$_(), this._$_messagePort$_.postMessage({
                type: "runtime-ready"
            }), this;
            this._$_canvasManager$_ && this._$_canvasManager$_._$HideCordovaSplashScreen$_();
        }
        async _$_RunOnStartupFunction$_(t) {
            try {
                await t(this._$_iRuntime$_);
            } catch (t) {
                console.error("[C3 runtime] Error in runOnStartup function: ", t);
            }
        }
        async _$_LoadDataJson$_(t) {
            const s = t.project;
            this._$_projectName$_ = s[0], this._$_projectVersion$_ = s[16], this._$_projectUniqueId$_ = s[31], 
            this._$_appId$_ = s[38], this._$_exportTimestamp$_ = s[36];
            const i = s[39] || "loading-logo.png";
            this._$_isPixelRoundingEnabled$_ = !!s[9], this._$_originalViewportWidth$_ = this._$_viewportWidth$_ = s[10], 
            this._$_originalViewportHeight$_ = this._$_viewportHeight$_ = s[11], this._$_collisionEngine$_._$_InitCollisionCellSize$_(this._$_originalViewportWidth$_, this._$_originalViewportHeight$_), 
            this._$_parallaxXorigin$_ = this._$_originalViewportWidth$_ / 2, this._$_parallaxYorigin$_ = this._$_originalViewportHeight$_ / 2, 
            this._$_framerateMode$_ = s[37], this._$_uses3dFeatures$_ = !!s[40], this._$_sampling$_ = s[14], 
            this._$_usesAnyBackgroundBlending$_ = s[15], this._$_usesAnyCrossSampling$_ = s[42], 
            this._$_usesAnyDepthSampling$_ = s[17], this._$_usesLoaderLayout$_ = !!s[18], this._$_loaderStyle$_ = s[19], 
            this._$_nextUid$_ = s[21], this._$_pauseOnBlur$_ = s[22];
            const e = this._$_assetManager$_;
            if (e._$_SetFileStructure$_(s[45]), e._$_SetAudioFiles$_(s[7], s[25]), e._$_SetMediaSubfolder$_(s[8]), 
            e._$_SetFontsSubfolder$_(s[32]), e._$_SetIconsSubfolder$_(s[28]), e._$_SetWebFonts$_(s[29]), 
            0 === this._$_loaderStyle$_) {
                let t = "";
                t = "flat" === e._$GetFileStructure$_() ? e._$GetIconsSubfolder$_() + i : i, t && (this._$_loadingLogoAsset$_ = e._$LoadImage$_({
                    url: t
                }));
            }
            this._$_canvasManager$_ && (this._$_canvasManager$_._$SetFullscreenMode$_(Vw._$CanvasManager$_._$_FullscreenModeNumberToString$_(s[12])), 
            this._$_canvasManager$_._$SetFullscreenScalingQuality$_(s[23] ? "high" : "low"), 
            this._$_canvasManager$_._$SetMipmapsEnabled$_(0 !== s[24]), this._$_canvasManager$_._$_SetGPUPowerPreference$_(s[34]), 
            this._$_canvasManager$_._$_SetTextureAnisotropy$_(s[41]), this._$_canvasManager$_._$_SetWebGPUEnabled$_(s[13]), 
            this._$_canvasManager$_._$_SetZAxisScale$_(s[30]), this._$_canvasManager$_._$_SetZDistances$_(s[46], s[47]), 
            this._$_canvasManager$_._$_SetInitFieldOfView$_(s[26]), this._$_canvasManager$_._$_SetLimitedToWebGL1$_(s[48]), 
            this._$_canvasManager$_._$_SetMultitexturingMode$_(s[50]));
            const n = s[43];
            n && await this._$_LoadExportToVideoData$_(n), this._$_InitScriptInterfaces$_(), 
            this._$_addonManager$_._$CreateSystemPlugin$_(), this._$_objectReferenceTable$_ = self._$C3_GetObjectRefTable$_();
            const h = s[2];
            for (const t of h[1]) this._$_addonManager$_._$CreateBehavior$_(t);
            for (const t of h[0]) this._$_addonManager$_._$CreatePlugin$_(t);
            this._$_objectReferenceTable$_ = self._$C3_GetObjectRefTable$_(), this._$_LoadJsPropNameTable$_(), 
            this._$_addonManager$_._$_InitAddonScriptInterfaces$_();
            for (const t of s[3]) {
                const s = Vw._$ObjectClass$_._$Create$_(this, this._$_allObjectClasses$_.length, t);
                this._$_allObjectClasses$_.push(s), this._$_objectClassesByName$_.set(s._$GetName$_().toLowerCase(), s), 
                this._$_objectClassesBySid$_.set(s._$GetSID$_(), s);
            }
            for (const t of s[4]) this._$_allObjectClasses$_[t[0]]._$_LoadFamily$_(t);
            for (const t of s[27]) {
                const s = t.map((t => this._$_allObjectClasses$_[t]));
                this._$_allContainers$_.push(Vw._$New$_(Vw._$Container$_, this, s));
            }
            this._$_InitObjectsScriptInterface$_();
            for (const t of this._$_allObjectClasses$_) t._$_OnAfterCreate$_();
            for (const t of s[5]) this._$_layoutManager$_._$Create$_(t);
            const r = s[1];
            if (r) {
                const t = this._$_layoutManager$_._$GetLayoutByName$_(r);
                t && this._$_layoutManager$_._$SetFirstLayout$_(t);
            }
            for (const t of s[35]) this._$_transitionManager$_._$Create$_(t);
            for (const t of s[33]) this._$_timelineManager$_._$Create$_(t);
            for (const t of s[44]) this._$_templateManager$_._$Create$_(t);
            this._$_templateManager$_._$HasTemplates$_() || (this._$_templateManager$_._$Release$_(), 
            this._$_templateManager$_ = null);
            for (const t of s[49]) this._$_flowchartManager$_._$Create$_(t);
            this._$_flowchartManager$_._$HasFlowcharts$_() || (this._$_flowchartManager$_._$Release$_(), 
            this._$_flowchartManager$_ = null);
            for (const t of s[6]) this._$_eventSheetManager$_._$Create$_(t);
            this._$_eventSheetManager$_._$_PostInit$_(), this._$_InitGlobalVariableScriptInterface$_(), 
            Vw._$clearArray$_(this._$_objectReferenceTable$_), this._$FlushPendingInstances$_();
            let o = "any";
            const a = s[20];
            1 === a ? o = "portrait" : 2 === a && (o = "landscape"), this._$PostComponentMessageToDOM$_("runtime", "set-target-orientation", {
                targetOrientation: o
            });
        }
        async _$_LoadExportToVideoData$_(t) {
            const s = t.format;
            "image-sequence" === s ? this._$_exportToVideo$_ = new self._$C3ExportToImageSequence$_(this, t) : "image-sequence-gif" === s ? this._$_exportToVideo$_ = new self._$C3ExportToGIF$_(this, t) : "webm" === s ? this._$_exportToVideo$_ = new self._$C3ExportToWebMVideo$_(this, t) : "mp4" === s && (this._$_exportToVideo$_ = new self._$C3ExportToMP4Video$_(this, t)), 
            this._$_framerateMode$_ = "unlimited-frame", this._$_canvasManager$_._$SetFullscreenMode$_("off"), 
            this._$_devicePixelRatio$_ = 1, self.devicePixelRatio = 1, await this._$PostComponentMessageToDOMAsync$_("runtime", "set-exporting-to-video", {
                message: this._$_exportToVideo$_._$GetExportingMessageForPercent$_(0),
                duration: this._$_exportToVideo$_._$GetDuration$_()
            });
        }
        _$GetLoaderStyle$_() {
            return this._$_loaderStyle$_;
        }
        _$IsExportToVideo$_() {
            return null !== this._$_exportToVideo$_;
        }
        _$GetExportVideoDuration$_() {
            return this._$_exportToVideo$_._$GetDuration$_();
        }
        _$GetExportVideoFramerate$_() {
            return this._$_exportToVideo$_._$GetFramerate$_();
        }
        _$_InitExportToVideo$_() {
            return this._$_exportToVideo$_._$Init$_({
                width: this._$_canvasManager$_._$GetDeviceWidth$_(),
                height: this._$_canvasManager$_._$GetDeviceHeight$_()
            });
        }
        _$_ExportToVideoAddFrame$_() {
            const t = this._$_tickCount$_ / this._$GetExportVideoFramerate$_();
            return this._$_exportToVideo$_._$AddFrame$_(this._$_canvasManager$_._$GetMainCanvas$_(), t);
        }
        _$_ExportToVideoAddKeyframe$_() {
            this._$_exportToVideo$_ && this._$_exportToVideo$_._$AddKeyframe$_();
        }
        _$_OnOfflineAudioRenderCompleted$_(t) {
            this._$_exportToVideo$_._$OnOfflineAudioRenderCompleted$_(t);
        }
        _$_ExportToVideoFinish$_() {
            return this._$_exportToVideo$_._$Finish$_();
        }
        _$IsFBInstantAvailable$_() {
            return this._$_isFBInstantAvailable$_;
        }
        _$IsLoading$_() {
            return this._$_isLoading$_;
        }
        _$AddLoadPromise$_(t) {
            this._$_additionalLoadPromises$_.push(t);
        }
        _$SetUsingCreatePromises$_(t) {
            this._$_isUsingCreatePromises$_ = !!t;
        }
        _$AddCreatePromise$_(t) {
            this._$_isUsingCreatePromises$_ && this._$_additionalCreatePromises$_.push(t);
        }
        _$GetCreatePromises$_() {
            return this._$_additionalCreatePromises$_;
        }
        _$_GetNextFamilyIndex$_() {
            return this._$_familyCount$_++;
        }
        _$GetFamilyCount$_() {
            return this._$_familyCount$_;
        }
        _$_AddEffectList$_(t) {
            this._$_allEffectLists$_.add(t);
        }
        _$_RemoveEffectList$_(t) {
            this._$_allEffectLists$_.delete(t);
        }
        _$_GetAllEffectLists$_() {
            return this._$_allEffectLists$_;
        }
        async _$_InitialiseCanvas$_(t) {
            this._$_canvasManager$_ && (await this._$_canvasManager$_._$CreateCanvas$_(t), this._$_canvasManager$_._$InitLoadingScreen$_(this._$_loaderStyle$_));
        }
        async _$Start$_() {
            this._$_hasStarted$_ = !0, this._$_startTime$_ = Date.now();
            let t = null;
            const s = new Promise((s => t = s));
            if (this._$_usesLoaderLayout$_) {
                for (const t of this._$_allObjectClasses$_) t._$IsFamily$_() || t._$IsOnLoaderLayout$_() || !t._$IsWorldType$_() || t._$OnCreate$_();
                (async () => {
                    await this._$_assetManager$_._$WaitForAllToLoad$_(), await s, this._$_isLoading$_ = !1, 
                    this._$_OnLoadFinished$_();
                })();
            } else this._$_isLoading$_ = !1;
            this._$_assetManager$_._$SetInitialLoadFinished$_(), this._$IsDebug$_() && Hw._$RuntimeInit$_(Zw);
            for (const t of this._$_layoutManager$_._$GetAllLayouts$_()) t._$_CreateGlobalNonWorlds$_();
            this._$IsExportToVideo$_() && await this._$_InitExportToVideo$_();
            const i = this._$_layoutManager$_._$GetFirstLayout$_();
            await i._$_Load$_(null, this._$GetRenderer$_()), await i._$_StartRunning$_(!0), 
            this._$_fpsLastTime$_ = performance.now(), t(), this._$_usesLoaderLayout$_ || this._$_OnLoadFinished$_(), 
            (await this._$PostComponentMessageToDOMAsync$_("runtime", "before-start-ticking")).isSuspended && !this._$IsExportToVideo$_() ? (this._$_suspendCount$_++, 
            this._$_isPageVisibilitySuspended$_ = !0) : this._$Tick$_();
        }
        _$_OnLoadFinished$_() {
            this._$Trigger$_(Vw._$Plugins$_._$System$_._$Cnds$_._$OnLoadFinished$_, null, null), 
            this._$PostComponentMessageToDOM$_("runtime", "register-sw");
        }
        _$GetObjectReference$_(t) {
            t = Math.floor(t);
            const s = this._$_objectReferenceTable$_;
            if (t < 0 || t >= s.length) throw new Error("invalid object reference");
            return s[t];
        }
        _$_LoadJsPropNameTable$_() {
            for (const t of self._$C3_JsPropNameTable$_) {
                const s = Vw._$first$_(Object.keys(t));
                this._$_jsPropNameTable$_.push(s);
            }
        }
        _$GetJsPropName$_(t) {
            t = Math.floor(t);
            const s = this._$_jsPropNameTable$_;
            if (t < 0 || t >= s.length) throw new Error("invalid prop reference");
            return s[t];
        }
        _$HasDOM$_() {
            return this._$_hasDom$_;
        }
        _$IsHeadless$_() {
            return this._$_isHeadless$_;
        }
        _$IsInWorker$_() {
            return this._$_isInWorker$_;
        }
        _$GetRuntimeBaseURL$_() {
            return this._$_runtimeBaseUrl$_;
        }
        _$GetPreviewURL$_() {
            return this._$_previewUrl$_;
        }
        _$GetEventSheetManager$_() {
            return this._$_eventSheetManager$_;
        }
        _$GetEventStack$_() {
            return this._$_eventSheetManager$_._$GetEventStack$_();
        }
        _$GetCurrentEventStackFrame$_() {
            return this._$_eventSheetManager$_._$GetCurrentEventStackFrame$_();
        }
        _$GetCurrentEvent$_() {
            return this._$_eventSheetManager$_._$GetCurrentEvent$_();
        }
        _$GetCurrentCondition$_() {
            return this._$_eventSheetManager$_._$GetCurrentCondition$_();
        }
        _$IsCurrentConditionFirst$_() {
            return 0 === this._$GetCurrentEventStackFrame$_()._$GetConditionIndex$_();
        }
        _$GetCurrentAction$_() {
            return this._$_eventSheetManager$_._$GetCurrentAction$_();
        }
        _$GetAddonManager$_() {
            return this._$_addonManager$_;
        }
        _$GetSystemPlugin$_() {
            return this._$_addonManager$_._$GetSystemPlugin$_();
        }
        _$GetObjectClassByIndex$_(t) {
            if ((t = Math.floor(t)) < 0 || t >= this._$_allObjectClasses$_.length) throw new RangeError("invalid index");
            return this._$_allObjectClasses$_[t];
        }
        _$GetObjectClassByName$_(t) {
            return this._$_objectClassesByName$_.get(t.toLowerCase()) || null;
        }
        _$GetObjectClassBySID$_(t) {
            return this._$_objectClassesBySid$_.get(t) || null;
        }
        _$GetSingleGlobalObjectClassByCtor$_(t) {
            const s = Vw._$AddonManager$_._$GetPluginByConstructorFunction$_(t);
            return s ? s._$GetSingleGlobalObjectClass$_() : null;
        }
        _$GetAllObjectClasses$_() {
            return this._$_allObjectClasses$_;
        }
        * _$allInstances$_() {
            for (const t of this._$_allObjectClasses$_) t._$IsFamily$_() || (yield* t._$instances$_());
        }
        _$Dispatcher$_() {
            return this._$_dispatcher$_;
        }
        _$UserScriptDispatcher$_() {
            return this._$_userScriptDispatcher$_;
        }
        _$DispatchUserScriptEvent$_(t) {
            t.runtime = this._$GetIRuntime$_();
            const s = this._$IsDebug$_() && !this._$_eventSheetManager$_._$IsInEventEngine$_();
            s && Hw._$StartMeasuringScriptTime$_(), this._$_userScriptDispatcher$_.dispatchEvent(t), 
            s && Hw._$AddScriptTime$_();
        }
        _$DispatchUserScriptEventAsyncWait$_(t) {
            return t.runtime = this._$GetIRuntime$_(), this._$_userScriptDispatcher$_._$dispatchEventAndWaitAsync$_(t);
        }
        _$GetOriginalViewportWidth$_() {
            return this._$_originalViewportWidth$_;
        }
        _$GetOriginalViewportHeight$_() {
            return this._$_originalViewportHeight$_;
        }
        _$SetOriginalViewportSize$_(t, s) {
            if (this._$_originalViewportWidth$_ === t && this._$_originalViewportHeight$_ === s) return;
            this._$_originalViewportWidth$_ = t, this._$_originalViewportHeight$_ = s;
            const i = this._$GetLayoutManager$_();
            i._$SetAllLayerProjectionChanged$_(), i._$SetAllLayerMVChanged$_();
        }
        _$GetViewportWidth$_() {
            return this._$_viewportWidth$_;
        }
        _$GetViewportHeight$_() {
            return this._$_viewportHeight$_;
        }
        _$SetViewportSize$_(t, s) {
            if (this._$_viewportWidth$_ === t && this._$_viewportHeight$_ === s) return;
            this._$_viewportWidth$_ = t, this._$_viewportHeight$_ = s;
            const i = this._$GetLayoutManager$_();
            i._$SetAllLayerProjectionChanged$_(), i._$SetAllLayerMVChanged$_();
        }
        _$_SetDevicePixelRatio$_(t) {
            this._$IsExportToVideo$_() || (this._$_devicePixelRatio$_ = t);
        }
        _$GetDevicePixelRatio$_() {
            return this._$_devicePixelRatio$_;
        }
        _$GetParallaxXOrigin$_() {
            return this._$_parallaxXorigin$_;
        }
        _$GetParallaxYOrigin$_() {
            return this._$_parallaxYorigin$_;
        }
        _$GetCanvasManager$_() {
            return this._$_canvasManager$_;
        }
        _$GetDrawWidth$_() {
            return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetDrawWidth$_() : this._$_viewportWidth$_;
        }
        _$GetDrawHeight$_() {
            return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetDrawHeight$_() : this._$_viewportHeight$_;
        }
        _$GetRenderScale$_() {
            return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetRenderScale$_() : 1;
        }
        _$GetDisplayScale$_() {
            return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetDisplayScale$_() : 1;
        }
        _$GetEffectLayerScaleParam$_() {
            return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetEffectLayerScaleParam$_() : 1;
        }
        _$GetEffectDevicePixelRatioParam$_() {
            return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetEffectDevicePixelRatioParam$_() : 1;
        }
        _$GetCanvasClientX$_() {
            return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetCanvasClientX$_() : 0;
        }
        _$GetCanvasClientY$_() {
            return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetCanvasClientY$_() : 0;
        }
        _$GetCanvasCssWidth$_() {
            return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetCssWidth$_() : 0;
        }
        _$GetCanvasCssHeight$_() {
            return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetCssHeight$_() : 0;
        }
        _$GetFullscreenMode$_() {
            return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetFullscreenMode$_() : "off";
        }
        _$GetAdditionalRenderTarget$_(t) {
            return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetAdditionalRenderTarget$_(t) : null;
        }
        _$ReleaseAdditionalRenderTarget$_(t) {
            this._$_canvasManager$_ && this._$_canvasManager$_._$ReleaseAdditionalRenderTarget$_(t);
        }
        _$UsesAnyBackgroundBlending$_() {
            return this._$_usesAnyBackgroundBlending$_;
        }
        _$UsesAnyCrossSampling$_() {
            return this._$_usesAnyCrossSampling$_;
        }
        _$UsesAnyDepthSampling$_() {
            return this._$_usesAnyDepthSampling$_;
        }
        _$GetGPUUtilisation$_() {
            return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetGPUUtilisation$_() : NaN;
        }
        _$IsLinearSampling$_() {
            return "nearest" !== this._$GetSampling$_();
        }
        _$GetFramerateMode$_() {
            return this._$_framerateMode$_;
        }
        _$_SetFramerateMode$_(t) {
            this._$_framerateMode$_ !== t && (this._$_framerateMode$_ = t, -1 === this._$_rafId$_ && -1 === this._$_ruafId$_ || (this._$_CancelAnimationFrame$_(), 
            this._$_RequestAnimationFrame$_()));
        }
        _$GetSampling$_() {
            return this._$_sampling$_;
        }
        _$UsesLoaderLayout$_() {
            return this._$_usesLoaderLayout$_;
        }
        _$GetLoadingLogoAsset$_() {
            return this._$_loadingLogoAsset$_;
        }
        _$ReleaseLoadingLogoAsset$_() {
            this._$_loadingLogoAsset$_ && (this._$_loadingLogoAsset$_._$ReleaseTexture$_(), 
            this._$_loadingLogoAsset$_._$Release$_(), this._$_loadingLogoAsset$_ = null);
        }
        _$GetLayoutManager$_() {
            return this._$_layoutManager$_;
        }
        _$GetMainRunningLayout$_() {
            return this._$_layoutManager$_._$GetMainRunningLayout$_();
        }
        _$GetTimelineManager$_() {
            return this._$_timelineManager$_;
        }
        _$GetTransitionManager$_() {
            return this._$_transitionManager$_;
        }
        _$GetTemplateManager$_() {
            return this._$_templateManager$_;
        }
        _$GetFlowchartManager$_() {
            return this._$_flowchartManager$_;
        }
        _$GetAssetManager$_() {
            return this._$_assetManager$_;
        }
        _$LoadImage$_(t) {
            return this._$_assetManager$_._$LoadImage$_(t);
        }
        _$CreateInstance$_(t, s, i, e, n, h) {
            if (h && this._$_templateManager$_) {
                if (t instanceof Vw._$ObjectClass$_ && t._$IsFamily$_()) {
                    const r = t._$GetFamilyMembers$_(), o = Math.floor(this._$Random$_() * r.length);
                    return this._$CreateInstance$_(r[o], s, i, e, n, h);
                }
                const r = this._$_templateManager$_._$GetTemplateData$_(t, h);
                if (r) {
                    const t = this._$CreateInstanceFromData$_(r, s, !1, i, e, !1, n, void 0, n);
                    return this._$_templateManager$_._$MapInstanceToTemplateName$_(t, h), t;
                }
            }
            return this._$CreateInstanceFromData$_(t, s, !1, i, e, !1, n, void 0, n);
        }
        _$CreateInstanceFromData$_(t, s, i, e, n, h, r, o, a) {
            let u = null, l = null;
            if (t instanceof Vw._$ObjectClass$_) {
                if (l = t, l._$IsFamily$_()) {
                    const t = l._$GetFamilyMembers$_();
                    l = t[Math.floor(this._$Random$_() * t.length)];
                }
                u = l._$GetDefaultInstanceData$_();
            } else u = t, l = this._$GetObjectClassByIndex$_(u[1]);
            const c = l._$GetPlugin$_()._$IsWorldType$_();
            if (this._$_isLoading$_ && c && !l._$IsOnLoaderLayout$_()) return null;
            const f = s;
            let d;
            c || (s = null), d = i && !h && u && !this._$_instancesByUid$_.has(u[2]) ? u[2] : this._$_nextUid$_++;
            const p = u ? u[0] : null, m = Vw._$New$_(Vw.Instance, {
                runtime: this,
                objectType: l,
                _$layer$_: s,
                _$worldData$_: p,
                _$instVarData$_: u ? u[3] : null,
                uid: d,
                tags: u ? u[6] : null
            });
            this._$_instancesByUid$_.set(d, m);
            let g = null;
            if (c && (g = m._$GetWorldInfo$_(), void 0 !== e && void 0 !== n && (g._$SetX$_(e), 
            g._$SetY$_(n)), l._$_SetAnyCollisionCellChanged$_(!0)), s && (a || s._$_AddInstance$_(m, !0), 
            s._$GetLayout$_()._$MaybeLoadTexturesFor$_(l)), this._$_objectCount$_++, l._$IsInContainer$_() && !i && !h) {
                const t = new Set;
                for (const s of l._$GetContainer$_()._$objectTypes$_()) {
                    if (s === l) continue;
                    const i = this._$_MaybeGetChildInstanceForObjectTypeData$_(s, g, t);
                    if (i) {
                        const t = this._$CreateInstanceFromData$_(i, f, !1, g ? g._$GetX$_() : e, g ? g._$GetY$_() : n, !0, !1, void 0, a);
                        m._$_AddSibling$_(t);
                    } else {
                        const t = this._$CreateInstanceFromData$_(s, f, !1, g ? g._$GetX$_() : e, g ? g._$GetY$_() : n, !0, !1, void 0, a);
                        m._$_AddSibling$_(t);
                    }
                }
                for (const t of m._$siblings$_()) {
                    t._$_AddSibling$_(m);
                    for (const s of m._$siblings$_()) t !== s && t._$_AddSibling$_(s);
                }
            }
            if (c && !i && r && this._$_CreateChildInstancesFromData$_(m, p, g, s, e, n, a), 
            l._$IsInContainer$_() && !i && !h && r) for (const t of m._$siblings$_()) {
                const i = t._$GetWorldInfo$_();
                if (!i) continue;
                const e = t._$GetPlugin$_(), n = t._$GetObjectClass$_()._$GetDefaultInstanceData$_()[0];
                e._$IsWorldType$_() ? this._$_CreateChildInstancesFromData$_(t, n, i, s, i._$GetX$_(), i._$GetY$_(), a) : this._$_CreateChildInstancesFromData$_(t, n, i, s, void 0, void 0, a);
            }
            if (!h && r) {
                void 0 === e && (e = p[0]), void 0 === n && (n = p[1]);
                const t = g._$GetTopParent$_(), s = e - g._$GetX$_() + t._$GetX$_(), i = n - g._$GetY$_() + t._$GetY$_();
                t._$SetXY$_(s, i);
            }
            l._$_SetIIDsStale$_();
            const y = u ? Vw._$cloneArray$_(u[5]) : null, M = u ? u[4].map((t => Vw._$cloneArray$_(t))) : null, w = c && p && p[13];
            if (w && m._$_SetHasTilemap$_(), m._$_CreateSdkInstance$_(y, M), w) {
                const t = p[13];
                m._$GetSdkInstance$_()._$LoadTilemapData$_(t[2], t[0], t[1]);
            }
            this._$_instancesPendingCreate$_.push(m), this._$_hasPendingInstances$_ = !0, this._$IsDebug$_() && Hw._$InstanceCreated$_(m);
            const S = this._$_eventObjects$_.instancecreate;
            return S._$instance$_ = m, this._$_dispatcher$_.dispatchEvent(S), m;
        }
        _$_GetInstanceData$_(t) {
            const s = t[0], i = t[1], e = t[2], n = t[6];
            return n || this._$_layoutManager$_._$GetLayoutBySID$_(s)._$GetLayer$_(i)._$GetInitialInstanceData$_(e);
        }
        _$_MaybeGetChildInstanceForObjectTypeData$_(t, s, i) {
            const e = s?._$GetSceneGraphChildrenExportData$_() ?? [];
            for (const s of e) {
                const e = this._$_GetInstanceData$_(s), n = !!s[4], h = this._$GetObjectClassByIndex$_(e[1]);
                if (!i.has(e) && t === h && n) return i.add(e), e;
            }
        }
        _$_CreateChildInstancesFromData$_(t, s, i, e, n, h, r) {
            const o = i._$GetSceneGraphZIndexExportData$_(), a = i._$GetSceneGraphChildrenExportData$_();
            if (t._$GetWorldInfo$_()._$SetSceneGraphZIndex$_(o), !a) return;
            void 0 === n && (n = s[0]), void 0 === h && (h = s[1]);
            const u = new Set, l = s[0], c = s[1];
            for (const s of a) {
                const i = s[0], o = s[1], a = s[2], f = s[3], d = !!s[4], p = s[5], m = s[6];
                let g;
                g = m || this._$_layoutManager$_._$GetLayoutBySID$_(i)._$GetLayer$_(o)._$GetInitialInstanceData$_(a);
                const y = this._$GetObjectClassByIndex$_(g[1]), M = t._$HasSibling$_(y), w = u.has(y);
                if (M && !w && d) {
                    const s = t._$GetSibling$_(y);
                    s._$GetWorldInfo$_()._$Init$_(g[0]);
                    const i = n + g[0][0] - l, e = h + g[0][1] - c;
                    s._$GetWorldInfo$_()._$SetXY$_(i, e), s._$GetWorldInfo$_()._$SetSceneGraphZIndex$_(p), 
                    t._$AddChild$_(s, {
                        _$transformX$_: !!(1 & f),
                        _$transformY$_: !!(f >> 1 & 1),
                        _$transformWidth$_: !!(f >> 2 & 1),
                        _$transformHeight$_: !!(f >> 3 & 1),
                        _$transformAngle$_: !!(f >> 4 & 1),
                        _$destroyWithParent$_: !!(f >> 5 & 1),
                        _$transformZElevation$_: !!(f >> 6 & 1),
                        _$transformOpacity$_: !!(f >> 7 & 1),
                        _$transformVisibility$_: !!(f >> 8 & 1)
                    }), u.add(y);
                } else {
                    const s = n + g[0][0] - l, i = h + g[0][1] - c, o = this._$CreateInstanceFromData$_(g, e, !1, s, i, !1, !0, t, r);
                    o._$GetWorldInfo$_()._$SetSceneGraphZIndex$_(p), t._$AddChild$_(o, {
                        _$transformX$_: !!(1 & f),
                        _$transformY$_: !!(f >> 1 & 1),
                        _$transformWidth$_: !!(f >> 2 & 1),
                        _$transformHeight$_: !!(f >> 3 & 1),
                        _$transformAngle$_: !!(f >> 4 & 1),
                        _$destroyWithParent$_: !!(f >> 5 & 1),
                        _$transformZElevation$_: !!(f >> 6 & 1),
                        _$transformOpacity$_: !!(f >> 7 & 1),
                        _$transformVisibility$_: !!(f >> 8 & 1)
                    });
                }
            }
        }
        _$DestroyInstance$_(t) {
            if (this._$_instancesPendingRelease$_.has(t)) return;
            const s = t._$GetObjectClass$_();
            let i = this._$_instancesPendingDestroy$_.get(s);
            if (i) {
                if (i.has(t)) return;
                i.add(t);
            } else i = new Set, i.add(t), this._$_instancesPendingDestroy$_.set(s, i);
            if (this._$IsDebug$_() && Hw._$InstanceDestroyed$_(t), t._$_MarkDestroyed$_(), this._$_hasPendingInstances$_ = !0, 
            t._$IsInContainer$_()) for (const s of t._$siblings$_()) this._$DestroyInstance$_(s);
            for (const s of t.children()) s._$GetDestroyWithParent$_() && this._$DestroyInstance$_(s);
            if (!this._$_layoutManager$_._$IsEndingLayout$_() && !this._$_isLoadingState$_) {
                const s = this._$GetEventSheetManager$_();
                s._$BlockFlushingInstances$_(!0), t._$_TriggerOnDestroyed$_(), s._$BlockFlushingInstances$_(!1);
            }
            t._$_FireDestroyedScriptEvents$_(this._$_layoutManager$_._$IsEndingLayout$_());
        }
        _$FlushPendingInstances$_() {
            this._$_hasPendingInstances$_ && (this._$_isFlushingPendingInstances$_ = !0, this._$_FlushInstancesPendingCreate$_(), 
            this._$_FlushInstancesPendingDestroy$_(), this._$_isFlushingPendingInstances$_ = !1, 
            this._$_hasPendingInstances$_ = !1, this._$UpdateRender$_());
        }
        _$_FlushInstancesPendingCreate$_() {
            for (const t of this._$_instancesPendingCreate$_) {
                const s = t._$GetObjectClass$_();
                s._$_AddInstance$_(t);
                for (const i of s._$GetFamilies$_()) i._$_AddInstance$_(t), i._$_SetIIDsStale$_();
            }
            Vw._$clearArray$_(this._$_instancesPendingCreate$_);
        }
        _$_FlushInstancesPendingDestroy$_() {
            this._$_dispatcher$_._$SetDelayRemoveEventsEnabled$_(!0);
            for (const [t, s] of this._$_instancesPendingDestroy$_.entries()) this._$_FlushInstancesPendingDestroyForObjectClass$_(t, s), 
            s.clear();
            this._$_instancesPendingDestroy$_.clear(), this._$_dispatcher$_._$SetDelayRemoveEventsEnabled$_(!1);
        }
        _$_FlushInstancesPendingDestroyForObjectClass$_(t, s) {
            for (const t of s) {
                const s = this._$_eventObjects$_.instancedestroy;
                s._$instance$_ = t, this._$_dispatcher$_.dispatchEvent(s), this._$_instancesByUid$_.delete(t._$GetUID$_()), 
                this._$_instanceTimes$_.delete(t);
                const i = t._$GetWorldInfo$_();
                i && (i._$_RemoveFromCollisionCells$_(), i._$_RemoveFromRenderCells$_(), i._$_MarkDestroyed$_()), 
                this._$_instancesPendingRelease$_.add(t), this._$_objectCount$_--;
            }
            Vw._$arrayRemoveAllInSet$_(t._$GetInstances$_(), s), t._$_SetIIDsStale$_(), this._$_instancesPendingReleaseAffectedObjectClasses$_.add(t);
            for (const i of t._$GetFamilies$_()) Vw._$arrayRemoveAllInSet$_(i._$GetInstances$_(), s), 
            i._$_SetIIDsStale$_(), this._$_instancesPendingReleaseAffectedObjectClasses$_.add(i);
            if (t._$GetPlugin$_()._$IsWorldType$_()) {
                const t = new Set([ ...s ].map((t => t._$GetWorldInfo$_()._$GetLayer$_())));
                for (const i of t) i._$_RemoveAllInstancesInSet$_(s);
            }
        }
        _$_GetInstancesPendingCreate$_() {
            return this._$_instancesPendingCreate$_;
        }
        * _$instancesPendingCreateForObjectClass$_(t) {
            for (const s of this._$_GetInstancesPendingCreate$_()) t._$IsFamily$_() ? s._$GetObjectClass$_()._$BelongsToFamily$_(t) && (yield s) : s._$GetObjectClass$_() === t && (yield s);
        }
        _$_GetNewUID$_() {
            return this._$_nextUid$_++;
        }
        _$_MapInstanceByUID$_(t, s) {
            this._$_instancesByUid$_.set(t, s);
        }
        _$_SetAutoSuspendEnabled$_(t) {
            t = !!t, this._$_isAutoSuspendEnabled$_ !== t && (this._$_isAutoSuspendEnabled$_ = !!t, 
            this._$_isAutoSuspendEnabled$_ && this._$_isPageVisibilitySuspended$_ && (this._$SetSuspended$_(!1), 
            this._$_isPageVisibilitySuspended$_ = !1));
        }
        _$_IsAutoSuspendEnabled$_() {
            return this._$_isAutoSuspendEnabled$_;
        }
        _$_OnRendererContextLost$_() {
            this._$_dispatcher$_.dispatchEvent(Vw._$New$_(Vw.Event, "renderercontextlost")), 
            this._$SetSuspended$_(!0);
            for (const t of this._$_allObjectClasses$_) !t._$IsFamily$_() && t._$HasLoadedTextures$_() && t._$ReleaseTextures$_();
            const t = this._$GetMainRunningLayout$_();
            t && t._$_OnRendererContextLost$_(), Vw._$ImageInfo$_._$OnRendererContextLost$_(), 
            Vw._$ImageAsset$_._$OnRendererContextLost$_();
        }
        async _$_OnRendererContextRestored$_() {
            await this._$GetMainRunningLayout$_()._$_Load$_(null, this._$GetRenderer$_()), this._$_dispatcher$_.dispatchEvent(Vw._$New$_(Vw.Event, "renderercontextrestored")), 
            this._$SetSuspended$_(!1), this._$UpdateRender$_();
        }
        _$_OnVisibilityChange$_(t) {
            if (!this._$_isAutoSuspendEnabled$_) return;
            const s = t.hidden;
            this._$SetSuspended$_(s), this._$_isPageVisibilitySuspended$_ = s, s || this._$UpdateRender$_();
        }
        _$_OnWindowBlur$_(t) {
            this._$IsPreview$_() && this._$_pauseOnBlur$_ && !Vw._$Platform$_._$IsMobile$_ && (t.data.parentHasFocus || (this._$SetSuspended$_(!0), 
            this._$_isPausedOnBlur$_ = !0));
        }
        _$_OnWindowFocus$_() {
            this._$_isPausedOnBlur$_ && (this._$SetSuspended$_(!1), this._$_isPausedOnBlur$_ = !1);
        }
        _$_RequestAnimationFrame$_() {
            const t = this._$_tickCallbacks$_;
            "vsync" === this._$_framerateMode$_ ? -1 === this._$_rafId$_ && (this._$_rafId$_ = self.requestAnimationFrame(t._$normal$_)) : "unlimited-tick" === this._$_framerateMode$_ ? (-1 === this._$_ruafId$_ && (this._$_ruafId$_ = Vw._$RequestUnlimitedAnimationFrame$_(t._$tickOnly$_)), 
            -1 === this._$_rafId$_ && (this._$_rafId$_ = self.requestAnimationFrame(t._$renderOnly$_))) : -1 === this._$_ruafId$_ && (this._$_ruafId$_ = Vw._$RequestUnlimitedAnimationFrame$_(t._$normal$_));
        }
        _$_CancelAnimationFrame$_() {
            -1 !== this._$_rafId$_ && (self.cancelAnimationFrame(this._$_rafId$_), this._$_rafId$_ = -1), 
            -1 !== this._$_ruafId$_ && (Vw._$CancelUnlimitedAnimationFrame$_(this._$_ruafId$_), 
            this._$_ruafId$_ = -1);
        }
        _$IsSuspended$_() {
            return this._$_suspendCount$_ > 0;
        }
        _$SetSuspended$_(t) {
            if (this._$IsExportToVideo$_()) return;
            const s = this._$IsSuspended$_();
            this._$_suspendCount$_ += t ? 1 : -1, this._$_suspendCount$_ < 0 && (this._$_suspendCount$_ = 0);
            const i = this._$IsSuspended$_();
            if (!s && i) console.log("[Construct] Suspending"), this._$_CancelAnimationFrame$_(), 
            this._$_dispatcher$_.dispatchEvent(Vw._$New$_(Vw.Event, "suspend")), this._$DispatchUserScriptEvent$_(Vw._$New$_(Vw.Event, "suspend")), 
            this._$Trigger$_(Vw._$Plugins$_._$System$_._$Cnds$_._$OnSuspend$_, null, null); else if (s && !i) {
                console.log("[Construct] Resuming");
                const t = performance.now();
                this._$_lastTickTime$_ = t, this._$_fpsLastTime$_ = t, this._$_fpsFrameCount$_ = 0, 
                this._$_fps$_ = 0, this._$_tpsTickCount$_ = 0, this._$_tps$_ = 0, this._$_mainThreadTime$_ = 0, 
                this._$_mainThreadTimeCounter$_ = 0, this._$_dispatcher$_.dispatchEvent(Vw._$New$_(Vw.Event, "resume")), 
                this._$DispatchUserScriptEvent$_(Vw._$New$_(Vw.Event, "resume")), this._$Trigger$_(Vw._$Plugins$_._$System$_._$Cnds$_._$OnResume$_, null, null), 
                this._$HitBreakpoint$_() || this._$Tick$_(t);
            }
        }
        _$_AddBehInstToTick$_(t) {
            this._$_behInstsToTick$_._$Add$_(t);
        }
        _$_AddBehInstToPostTick$_(t) {
            this._$_behInstsToPostTick$_._$Add$_(t);
        }
        _$_AddBehInstToTick2$_(t) {
            this._$_behInstsToTick2$_._$Add$_(t);
        }
        _$_RemoveBehInstToTick$_(t) {
            this._$_behInstsToTick$_._$Remove$_(t);
        }
        _$_RemoveBehInstToPostTick$_(t) {
            this._$_behInstsToPostTick$_._$Remove$_(t);
        }
        _$_RemoveBehInstToTick2$_(t) {
            this._$_behInstsToTick2$_._$Remove$_(t);
        }
        _$_CallBehaviorTickMethod$_(t, s) {
            const i = s ? performance.now() : 0;
            let e;
            return t instanceof qw ? (e = t._$_tick$_(), s && Hw._$AddIndividualBehaviorTickTime$_(t.behavior, performance.now() - i)) : (e = t._$Tick$_(), 
            s && Hw._$AddIndividualBehaviorTickTime$_(t._$GetBehavior$_(), performance.now() - i)), 
            e;
        }
        _$_BehaviorTick$_() {
            const t = this._$IsDebug$_();
            this._$_behInstsToTick$_._$SetQueueingEnabled$_(!0);
            for (const s of this._$_behInstsToTick$_) this._$_CallBehaviorTickMethod$_(s, t);
            this._$_behInstsToTick$_._$SetQueueingEnabled$_(!1);
        }
        _$_CallBehaviorPostTickMethod$_(t, s) {
            const i = s ? performance.now() : 0;
            let e;
            return t instanceof qw ? (e = t._$_postTick$_(), s && Hw._$AddIndividualBehaviorTickTime$_(t.behavior, performance.now() - i)) : (e = t._$PostTick$_(), 
            s && Hw._$AddIndividualBehaviorTickTime$_(t._$GetBehavior$_(), performance.now() - i)), 
            e;
        }
        _$_BehaviorPostTick$_() {
            const t = this._$IsDebug$_();
            this._$_behInstsToPostTick$_._$SetQueueingEnabled$_(!0);
            for (const s of this._$_behInstsToPostTick$_) this._$_CallBehaviorPostTickMethod$_(s, t);
            this._$_behInstsToPostTick$_._$SetQueueingEnabled$_(!1);
        }
        _$_CallBehaviorTick2Method$_(t, s) {
            const i = s ? performance.now() : 0;
            let e;
            return t instanceof qw ? (e = t._$_tick2$_(), s && Hw._$AddIndividualBehaviorTickTime$_(t.behavior, performance.now() - i)) : (e = t._$Tick2$_(), 
            s && Hw._$AddIndividualBehaviorTickTime$_(t._$GetBehavior$_(), performance.now() - i)), 
            e;
        }
        _$_BehaviorTick2$_() {
            const t = this._$IsDebug$_();
            this._$_behInstsToTick2$_._$SetQueueingEnabled$_(!0);
            for (const s of this._$_behInstsToTick2$_) this._$_CallBehaviorTick2Method$_(s, t);
            this._$_behInstsToTick2$_._$SetQueueingEnabled$_(!1);
        }
        * _$_DebugBehaviorTick$_() {
            const t = this._$IsDebug$_();
            this._$_behInstsToTick$_._$SetQueueingEnabled$_(!0);
            for (const s of this._$_behInstsToTick$_) {
                const i = this._$_CallBehaviorTickMethod$_(s, t);
                Vw._$IsIterator$_(i) && (yield* i);
            }
            this._$_behInstsToTick$_._$SetQueueingEnabled$_(!1);
        }
        * _$_DebugBehaviorPostTick$_() {
            const t = this._$IsDebug$_();
            this._$_behInstsToPostTick$_._$SetQueueingEnabled$_(!0);
            for (const s of this._$_behInstsToPostTick$_) {
                const i = this._$_CallBehaviorPostTickMethod$_(s, t);
                Vw._$IsIterator$_(i) && (yield* i);
            }
            this._$_behInstsToPostTick$_._$SetQueueingEnabled$_(!1);
        }
        * _$_DebugBehaviorTick2$_() {
            const t = this._$IsDebug$_();
            this._$_behInstsToTick2$_._$SetQueueingEnabled$_(!0);
            for (const s of this._$_behInstsToTick2$_) {
                const i = this._$_CallBehaviorTick2Method$_(s, t);
                Vw._$IsIterator$_(i) && (yield* i);
            }
            this._$_behInstsToTick2$_._$SetQueueingEnabled$_(!1);
        }
        async _$Tick$_(t, s, i) {
            this._$_hasStartedTicking$_ = !0;
            const e = "background-wake" === i, n = "background-wake" !== i && "skip-render" !== i, h = this._$GetLayoutManager$_(), r = this._$GetCanvasManager$_();
            if (!this._$_hasStarted$_ || this._$IsSuspended$_() && !s && !e) return;
            const o = performance.now();
            this._$_isInTick$_ = !0, this._$_MeasureDt$_(t || 0), this._$_tpsTickCount$_++, 
            this._$_ReleasePendingInstances$_();
            const a = this._$Step_BeforePreTick$_();
            this._$IsDebugging$_() && await a;
            const u = this._$_dispatcher$_._$dispatchEventAndWait_AsyncOptional$_(this._$_eventObjects$_.pretick);
            u instanceof Promise && await u, this._$DispatchUserScriptEvent$_(this._$_userScriptEventObjects$_.pretick);
            const l = this._$Step_AfterPreTick$_();
            this._$IsDebugging$_() && await l, this._$_NeedsHandleSaveOrLoad$_() && await this._$_HandleSaveOrLoad$_(), 
            h._$IsPendingChangeMainLayout$_() && await this._$_MaybeChangeLayout$_();
            const c = this._$Step_RunEventsEtc$_();
            this._$IsDebugging$_() && await c;
            const f = h._$GetMainRunningLayout$_(), d = f._$_GetPendingSetHTMLLayerCount$_();
            let p = !1;
            if (-1 !== d && (f._$_ResetPendingHTMLLayerCount$_(), r._$GetHTMLLayerCount$_() !== d)) {
                const t = this._$GetCanvasManager$_()._$SetHTMLLayerCount$_(d);
                this._$IsInWorker$_() && (p = !0, await t);
            }
            this._$PostComponentMessageToDOM$_("canvas", "update-html-layer-dom-state", {
                layersDomState: f._$_GetRootLayers$_().filter((t => t._$IsHTMLElementsLayer$_())).map((t => t._$_GetHTMLLayerDOMState$_()))
            }), n && this._$Render$_(), p && this._$PostComponentMessageToDOM$_("canvas", "cleanup-html-layers"), 
            this._$IsExportToVideo$_() && (await this._$_ExportToVideoAddFrame$_(), this._$GetGameTime$_() >= this._$GetExportVideoDuration$_()) ? this._$_ExportToVideoFinish$_() : (this._$IsSuspended$_() || e || this._$_RequestAnimationFrame$_(), 
            this._$_tickCount$_++, this._$_tickCountNoSave$_++, this._$_isInTick$_ = !1, this._$_mainThreadTimeCounter$_ += performance.now() - o);
        }
        async _$Step_BeforePreTick$_() {
            const t = this._$_eventSheetManager$_, s = this._$IsDebug$_();
            this._$FlushPendingInstances$_(), t._$BlockFlushingInstances$_(!0), this._$PushCurrentLayout$_(this._$GetMainRunningLayout$_()), 
            s && Hw._$StartMeasuringTime$_(), this._$IsDebugging$_() ? await t._$DebugRunScheduledWaits$_() : t._$RunScheduledWaits$_(), 
            s && Hw._$AddEventsTime$_(), this._$PopCurrentLayout$_(), t._$BlockFlushingInstances$_(!1), 
            this._$FlushPendingInstances$_(), t._$BlockFlushingInstances$_(!0);
        }
        async _$Step_AfterPreTick$_() {
            const t = this._$_eventSheetManager$_, s = this._$IsDebug$_(), i = this._$IsDebugging$_(), e = this._$_dispatcher$_, n = this._$_eventObjects$_, h = this._$_userScriptEventObjects$_;
            s && Hw._$StartMeasuringTime$_(), i ? await this._$DebugIterateAndBreak$_(this._$_DebugBehaviorTick$_()) : this._$_BehaviorTick$_(), 
            i ? await this._$DebugIterateAndBreak$_(this._$_DebugBehaviorPostTick$_()) : this._$_BehaviorPostTick$_(), 
            s && Hw._$AddBehaviorTotalTickTime$_(), s && Hw._$StartMeasuringTime$_(), i ? await this._$DebugFireGeneratorEventAndBreak$_(n.tick) : e.dispatchEvent(n.tick), 
            s && Hw._$AddPluginTotalTickTime$_(), t._$BlockFlushingInstances$_(!1), this._$DispatchUserScriptEvent$_(h.tick);
        }
        async _$Step_RunEventsEtc$_() {
            const t = this._$_eventSheetManager$_, s = this._$_dispatcher$_, i = this._$_eventObjects$_, e = this._$_userScriptEventObjects$_, n = this._$IsDebug$_(), h = this._$IsDebugging$_();
            n && Hw._$StartMeasuringTime$_(), h ? await t._$DebugRunEvents$_(this._$_layoutManager$_) : t._$RunEvents$_(this._$_layoutManager$_), 
            n && Hw._$AddEventsTime$_(), this._$_collisionEngine$_._$ClearRegisteredCollisions$_(), 
            this._$_ReleasePendingInstances$_(), this._$_isLayoutFirstTick$_ = !1, t._$BlockFlushingInstances$_(!0), 
            n && Hw._$StartMeasuringTime$_(), h ? await this._$DebugIterateAndBreak$_(this._$_DebugBehaviorTick2$_()) : this._$_BehaviorTick2$_(), 
            n && Hw._$AddBehaviorTotalTickTime$_(), n && Hw._$StartMeasuringTime$_(), h ? await this._$DebugFireGeneratorEventAndBreak$_(i.tick2) : s.dispatchEvent(i.tick2), 
            n && Hw._$AddPluginTotalTickTime$_(), t._$BlockFlushingInstances$_(!1), this._$DispatchUserScriptEvent$_(e.tick2), 
            h && await t._$RunQueuedDebugTriggersAsync$_(), this._$FlushPendingInstances$_(), 
            this._$_ReleasePendingInstances$_();
        }
        _$_ReleasePendingInstances$_() {
            if (0 === this._$_instancesPendingRelease$_.size) return;
            const t = this._$_dispatcher$_;
            t._$SetDelayRemoveEventsEnabled$_(!0);
            for (const t of this._$_instancesPendingReleaseAffectedObjectClasses$_) t._$GetSolStack$_()._$RemoveInstances$_(this._$_instancesPendingRelease$_);
            this._$_instancesPendingReleaseAffectedObjectClasses$_.clear(), this._$_eventSheetManager$_._$_OnInstancesReleased$_(this._$_instancesPendingRelease$_);
            for (const t of this._$_instancesPendingRelease$_) t._$Release$_();
            this._$_instancesPendingRelease$_.clear(), t._$SetDelayRemoveEventsEnabled$_(!1);
        }
        async _$_MaybeChangeLayout$_() {
            const t = this._$GetLayoutManager$_();
            let s = 0;
            for (;t._$IsPendingChangeMainLayout$_() && s++ < 10; ) await this._$_DoChangeLayout$_(t._$GetPendingChangeMainLayout$_());
        }
        _$_MeasureDt$_(t) {
            let s = 0;
            this._$IsExportToVideo$_() ? (s = 1 / this._$GetExportVideoFramerate$_(), this._$_dtRaw$_ = s, 
            this._$_dt1$_ = s) : 0 !== this._$_lastTickTime$_ && (s = Math.max(t - this._$_lastTickTime$_, 0) / 1e3, 
            s > .5 && (s = 0), this._$_dtRaw$_ = s, this._$_dt1$_ = Vw._$clamp$_(s, this._$_minDt$_, this._$_maxDt$_)), 
            this._$_lastTickTime$_ = t, this._$_dt$_ = this._$_dt1$_ * this._$_timeScale$_, 
            this._$_gameTime$_._$Add$_(this._$_dt$_), this._$_gameTimeRaw$_._$Add$_(s * this._$_timeScale$_), 
            this._$_wallTime$_._$Add$_(this._$_dt1$_);
            for (const [t, s] of this._$_instanceTimes$_) s._$Add$_(this._$_dt1$_ * t._$GetTimeScale$_());
            this._$_canvasManager$_ && this._$_canvasManager$_._$_UpdateTick$_(), t - this._$_fpsLastTime$_ >= 1e3 && (this._$_fpsLastTime$_ += 1e3, 
            t - this._$_fpsLastTime$_ >= 1e3 && (this._$_fpsLastTime$_ = t), this._$_fps$_ = this._$_fpsFrameCount$_, 
            this._$_fpsFrameCount$_ = 0, this._$_tps$_ = this._$_tpsTickCount$_, this._$_tpsTickCount$_ = 0, 
            this._$_mainThreadTime$_ = Math.min(this._$_mainThreadTimeCounter$_ / 1e3, 1), this._$_mainThreadTimeCounter$_ = 0, 
            this._$_canvasManager$_ && this._$_canvasManager$_._$_Update1sFrameRange$_(), this._$_collisionEngine$_._$_Update1sStats$_(), 
            this._$IsDebug$_() && Hw._$Update1sPerfStats$_());
        }
        _$_SetTrackingInstanceTime$_(t, s) {
            if (s) {
                if (!this._$_instanceTimes$_.has(t)) {
                    const s = Vw._$New$_(Vw._$KahanSum$_);
                    s._$Copy$_(this._$_gameTime$_), this._$_instanceTimes$_.set(t, s);
                }
            } else this._$_instanceTimes$_.delete(t);
        }
        _$_GetInstanceGameTime$_(t) {
            const s = this._$_instanceTimes$_.get(t);
            return s ? s._$Get$_() : this._$GetGameTime$_();
        }
        async _$_DoChangeLayout$_(t) {
            const s = this._$_dispatcher$_, i = this._$GetLayoutManager$_()._$GetMainRunningLayout$_();
            await i._$_StopRunning$_(), i._$_Unload$_(t, this._$GetRenderer$_()), i === t && this._$_eventSheetManager$_._$ClearAllScheduledWaits$_(), 
            this._$_collisionEngine$_._$ClearRegisteredCollisions$_(), this._$_ReleasePendingInstances$_(), 
            s.dispatchEvent(this._$_eventObjects$_.beforelayoutchange), Vw._$Asyncify$_._$SetHighThroughputMode$_(!0), 
            await t._$_Load$_(i, this._$GetRenderer$_()), Vw._$Asyncify$_._$SetHighThroughputMode$_(!1), 
            await t._$_StartRunning$_(!1), s.dispatchEvent(this._$_eventObjects$_.layoutchange), 
            this._$UpdateRender$_(), this._$_isLayoutFirstTick$_ = !0, this._$FlushPendingInstances$_(), 
            this._$_ExportToVideoAddKeyframe$_();
        }
        _$UpdateRender$_() {
            this._$_needRender$_ = !0;
        }
        _$GetWebGLRenderer$_() {
            return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetWebGLRenderer$_() : null;
        }
        _$GetWebGPURenderer$_() {
            return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetWebGPURenderer$_() : null;
        }
        _$GetRenderer$_() {
            return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetRenderer$_() : null;
        }
        _$Render$_() {
            const t = this._$_canvasManager$_;
            if (!t || t._$IsRendererContextLost$_()) return;
            const s = this._$GetRenderer$_(), i = s._$SupportsGPUProfiling$_(), e = i && s._$IsWebGL$_(), n = i && s._$IsWebGPU$_();
            if (e && s._$CheckForQueryResults$_(), !this._$_needRender$_ && !this._$IsExportToVideo$_()) return void s._$IncrementFrameNumber$_();
            const h = this._$_layoutManager$_._$GetMainRunningLayout$_();
            this._$_fpsFrameCount$_++, s._$Start$_();
            const r = this._$IsDebug$_();
            r && Hw._$StartMeasuringTime$_(), this._$_needRender$_ = !1;
            let o = null;
            e && (o = t._$GetGPUFrameTimingsBuffer$_()._$AddTimeElapsedQuery$_(), s._$StartQuery$_(o));
            let a = null;
            n && (a = s._$StartFrameTiming$_(2 * (1 + h._$GetLayerCount$_())), s._$StartMeasuringRenderPassTime$_(0, 1)), 
            this._$Uses3DFeatures$_() && "low" === t._$GetCurrentFullscreenScalingQuality$_() ? s._$SetFixedSizeDepthBuffer$_(t._$GetDrawWidth$_(), t._$GetDrawHeight$_()) : s._$SetAutoSizeDepthBuffer$_(), 
            this._$_Render$_(this._$GetRenderer$_(), h), o && s._$EndQuery$_(o), n && (s._$StopMeasuringRenderPassTime$_(), 
            this._$_canvasManager$_._$_AddWebGPUFrameTiming$_(a)), s._$Finish$_(), r && (Hw._$AddDrawCallsTime$_(), 
            Hw._$UpdateInspectHighlight$_()), t && t._$_MaybeTakeSnapshot$_();
        }
        _$_NeedsHTMLLayerCompositing$_(t) {
            return "low" === this._$GetCanvasManager$_()._$GetCurrentFullscreenScalingQuality$_() || t._$IsWebGL$_() && (this._$UsesAnyBackgroundBlending$_() || this._$Uses3DFeatures$_());
        }
        _$_Render$_(t, s) {
            t._$SetTextureFillMode$_(), t._$SetAlphaBlend$_(), t._$SetColorRgba$_(1, 1, 1, 1), 
            t._$SetRenderTarget$_(null), t._$SetTexture$_(null), t._$SetDepthEnabled$_(this._$Uses3DFeatures$_()), 
            this._$_NeedsHTMLLayerCompositing$_(t) && s._$_MaybeStartDrawToOwnTexture$_(t);
            const i = s._$GetHTMLLayerCount$_();
            for (let e = 1; e < i; ++e) s._$DrawForHTMLLayerIndex$_(t, e), t._$IsWebGPU$_() && t._$Restart$_();
            this._$_NeedsHTMLLayerCompositing$_(t) || s._$_MaybeStartDrawToOwnTexture$_(t), 
            s._$DrawMain$_(t);
        }
        _$Trigger$_(t, s, i) {
            if (!this._$_hasStarted$_) return !1;
            const e = !this._$_isInTick$_ && !this._$_eventSheetManager$_._$IsInTrigger$_();
            let n = 0;
            e && (n = performance.now());
            const h = this._$IsDebug$_();
            h && this._$SetDebuggingEnabled$_(!1);
            const r = this._$_eventSheetManager$_._$_Trigger$_(this._$_layoutManager$_, t, s, i);
            if (e) {
                const t = performance.now() - n;
                this._$_mainThreadTimeCounter$_ += t, h && Hw._$AddTriggersTime$_(t);
            }
            return h && this._$SetDebuggingEnabled$_(!0), r;
        }
        _$DebugTrigger$_(t, s, i) {
            if (!this._$IsDebugging$_()) return this._$Trigger$_(t, s, i);
            if (this._$HitBreakpoint$_()) throw new Error("called DebugTrigger() while stopped on breakpoint");
            if (!this._$_isInTick$_ && !this._$_eventSheetManager$_._$IsInTrigger$_()) throw new Error("called DebugTrigger() outside of event code - use TriggerAsync() instead");
            return this._$_eventSheetManager$_._$_DebugTrigger$_(this._$_layoutManager$_, t, s, i);
        }
        async _$TriggerAsync$_(t, s, i) {
            if (!this._$IsDebugging$_()) return this._$Trigger$_(t, s, i);
            if (!this._$_hasStarted$_) return !1;
            if (this._$HitBreakpoint$_()) return this._$_eventSheetManager$_._$QueueDebugTrigger$_(t, s, i);
            if (!this._$GetMainRunningLayout$_()) return this._$_eventSheetManager$_._$QueueTrigger$_(t, s, i);
            const e = performance.now(), n = this._$_eventSheetManager$_._$_DebugTrigger$_(this._$_layoutManager$_, t, s, i);
            let h = n.next();
            for (;!h.done; ) await this._$DebugBreak$_(h.value), h = n.next();
            return this._$IsSuspended$_() || this._$_eventSheetManager$_._$IsInTrigger$_() || (await this._$_eventSheetManager$_._$RunQueuedDebugTriggersAsync$_(), 
            this._$_hasStartedTicking$_ && !this._$_isInTick$_ && this._$_RequestAnimationFrame$_()), 
            this._$_mainThreadTimeCounter$_ += performance.now() - e, h.value;
        }
        _$FastTrigger$_(t, s, i) {
            const e = this._$IsDebug$_();
            e && this._$SetDebuggingEnabled$_(!1);
            const n = this._$_eventSheetManager$_._$_FastTrigger$_(this._$_layoutManager$_, t, s, i);
            return e && this._$SetDebuggingEnabled$_(!0), n;
        }
        _$DebugFastTrigger$_(t, s, i) {
            return this._$_eventSheetManager$_._$_DebugFastTrigger$_(this._$_layoutManager$_, t, s, i);
        }
        _$ScheduleTriggers$_(t) {
            return this._$_scheduleTriggersThrottle$_._$Add$_(t);
        }
        _$PushCurrentLayout$_(t) {
            this._$_currentLayoutStack$_.push(t);
        }
        _$PopCurrentLayout$_() {
            if (!this._$_currentLayoutStack$_.length) throw new Error("layout stack empty");
            this._$_currentLayoutStack$_.pop();
        }
        _$GetCurrentLayout$_() {
            return this._$_currentLayoutStack$_.length ? this._$_currentLayoutStack$_.at(-1) : this._$GetMainRunningLayout$_();
        }
        _$GetDt$_(t) {
            return t && -1 !== t._$GetTimeScale$_() ? this._$_dt1$_ * t._$GetTimeScale$_() : this._$_dt$_;
        }
        _$_GetDtFast$_() {
            return this._$_dt$_;
        }
        _$GetDt1$_() {
            return this._$_dt1$_;
        }
        _$GetDtRaw$_() {
            return this._$_dtRaw$_;
        }
        _$GetTimeScale$_() {
            return this._$_timeScale$_;
        }
        _$SetTimeScale$_(t) {
            (isNaN(t) || t < 0) && (t = 0), this._$_timeScale$_ = t;
        }
        _$SetMinDt$_(t) {
            this._$_minDt$_ = Math.max(t, 0);
        }
        _$GetMinDt$_() {
            return this._$_minDt$_;
        }
        _$SetMaxDt$_(t) {
            this._$_maxDt$_ = Math.max(t, 0);
        }
        _$GetMaxDt$_() {
            return this._$_maxDt$_;
        }
        _$GetFramesPerSecond$_() {
            return this._$_fps$_;
        }
        _$GetTicksPerSecond$_() {
            return this._$_tps$_;
        }
        _$GetMainThreadTime$_() {
            return this._$_mainThreadTime$_;
        }
        _$GetStartTime$_() {
            return this._$_startTime$_;
        }
        _$GetGameTime$_() {
            return this._$_gameTime$_._$Get$_();
        }
        _$GetGameTimeRaw$_() {
            return this._$_gameTimeRaw$_._$Get$_();
        }
        _$GetWallTime$_() {
            return this._$_wallTime$_._$Get$_();
        }
        _$GetTickCount$_() {
            return this._$_tickCount$_;
        }
        _$GetTickCountNoSave$_() {
            return this._$_tickCountNoSave$_;
        }
        _$GetObjectCount$_() {
            return this._$_objectCount$_;
        }
        _$GetProjectName$_() {
            return this._$_projectName$_;
        }
        _$GetProjectVersion$_() {
            return this._$_projectVersion$_;
        }
        _$GetProjectUniqueId$_() {
            return this._$_projectUniqueId$_;
        }
        _$GetAppId$_() {
            return this._$_appId$_;
        }
        _$GetExportTimestamp$_() {
            return this._$_exportTimestamp$_;
        }
        _$GetInstanceByUID$_(t) {
            if (this._$_isLoadingState$_) throw new Error("cannot call while loading state - wait until afterload event");
            return this._$_instancesByUid$_.get(t) || null;
        }
        _$_RemoveInstanceFromUIDMap$_(t) {
            if (this._$_isLoadingState$_) throw new Error("cannot call while loading state - wait until afterload event");
            this._$_instancesByUid$_.delete(t);
        }
        _$_RefreshUidMap$_() {
            this._$_instancesByUid$_.clear();
            for (const t of this._$_allObjectClasses$_) if (!t._$IsFamily$_()) for (const s of t._$GetInstances$_()) this._$_instancesByUid$_.set(s._$GetUID$_(), s);
        }
        _$IsPreview$_() {
            return "preview" === this._$_exportType$_;
        }
        _$IsDebug$_() {
            return this._$_isDebug$_;
        }
        _$GetExportType$_() {
            return this._$_exportType$_;
        }
        _$IsNWjs$_() {
            return "nwjs" === this._$GetExportType$_() || this._$_isNWjs$_;
        }
        _$IsCordova$_() {
            return "cordova" === this._$_exportType$_;
        }
        _$IsAndroidWebView$_() {
            return "Android" === Vw._$Platform$_._$OS$_ && ("cordova" === this._$_exportType$_ || "playable-ad-single-file" === this._$_exportType$_ || "playable-ad-zip" === this._$_exportType$_ || "instant-games" === this._$_exportType$_);
        }
        _$IsiOSCordova$_() {
            return this._$_isiOSCordova$_;
        }
        _$IsiOSWebView$_() {
            return this._$_isiOSWebView$_;
        }
        _$IsWindowsWebView2$_() {
            return this._$_isWindowsWebView2$_;
        }
        _$IsAnyWebView2Wrapper$_() {
            return this._$_isAnyWebView2Wrapper$_;
        }
        _$GetCollisionEngine$_() {
            return this._$_collisionEngine$_;
        }
        _$GetSolidBehavior$_() {
            return this._$_addonManager$_._$GetSolidBehavior$_();
        }
        _$GetJumpthruBehavior$_() {
            return this._$_addonManager$_._$GetJumpthruBehavior$_();
        }
        _$Uses3DFeatures$_() {
            return this._$_uses3dFeatures$_;
        }
        _$GetZScaleFactor$_() {
            return this._$GetRenderer$_()._$GetZAxisScaleFactor$_(this._$GetViewportHeight$_());
        }
        _$GetDefaultCameraZ$_(t) {
            return this._$GetRenderer$_()._$GetDefaultCameraZ$_(t || this._$GetViewportHeight$_());
        }
        _$IsLayoutFirstTick$_() {
            return this._$_isLayoutFirstTick$_;
        }
        _$SetPixelRoundingEnabled$_(t) {
            t = !!t, this._$_isPixelRoundingEnabled$_ !== t && (this._$_isPixelRoundingEnabled$_ = t, 
            this._$GetLayoutManager$_()._$SetAllLayerMVChanged$_(), this._$UpdateRender$_());
        }
        _$IsPixelRoundingEnabled$_() {
            return this._$_isPixelRoundingEnabled$_;
        }
        _$GetTextIconSet$_(t) {
            if (!this._$_iconChangeHandlers$_.has(t)) {
                const s = () => this._$DeleteTextIconSet$_(t);
                this._$_iconChangeHandlers$_.set(t, s), t._$Dispatcher$_().addEventListener("animationframeimagechange", s);
            }
            const s = this._$_textIconManager$_._$GetIconSet$_(t);
            return s._$HasLoaded$_() || s._$LoadContent$_().then((() => this._$UpdateRender$_())), 
            s;
        }
        _$DeleteTextIconSet$_(t) {
            this._$_textIconManager$_._$DeleteIconSet$_(t);
        }
        _$_GetTextIconSetMeta$_(t) {
            const s = [];
            for (const i of t._$GetAnimations$_()) for (const t of i._$GetFrames$_()) {
                const i = t._$GetImageInfo$_();
                s.push({
                    source: t,
                    width: i._$GetWidth$_(),
                    height: i._$GetHeight$_(),
                    tag: t._$GetTag$_()
                });
            }
            return {
                _$icons$_: s
            };
        }
        async _$_GetTextIconSetContent$_(t) {
            const s = Vw._$New$_(Vw._$PromiseThrottle$_), i = [], e = new Map;
            for (const n of t._$GetAnimations$_()) for (const t of n._$GetFrames$_()) {
                const n = t._$GetImageInfo$_()._$GetImageAsset$_();
                e.has(n) || (e.set(n, null), i.push(s._$Add$_((async () => {
                    const t = await n._$LoadToDrawable$_();
                    e.set(n, t);
                }))));
            }
            await Promise.all(i);
            const n = [];
            for (const i of t._$GetAnimations$_()) for (const t of i._$GetFrames$_()) n.push(s._$Add$_((async () => {
                const s = t._$GetImageInfo$_(), i = e.get(s._$GetImageAsset$_()), n = await s._$ExtractImageToCanvas$_(i);
                return {
                    _$drawable$_: await createImageBitmap(n)
                };
            })));
            const h = await Promise.all(n);
            for (const t of e.values()) t instanceof ImageBitmap && t.close && t.close();
            return {
                _$icons$_: h
            };
        }
        _$SaveToSlot$_(t) {
            this._$_saveToSlotName$_ = t, this._$_saveToJsonString$_ = !1;
        }
        _$SaveToJsonString$_() {
            this._$_saveToSlotName$_ = "", this._$_saveToJsonString$_ = !0;
        }
        _$LoadFromSlot$_(t) {
            this._$_loadFromSlotName$_ = t;
        }
        _$LoadFromJsonString$_(t) {
            this._$_loadFromJson$_ = t;
        }
        _$GetLastSaveJsonString$_() {
            return this._$_lastSaveJson$_;
        }
        _$_NeedsHandleSaveOrLoad$_() {
            return !!(this._$_saveToSlotName$_ || this._$_saveToJsonString$_ || this._$_loadFromSlotName$_ || null !== this._$_loadFromJson$_);
        }
        async _$_HandleSaveOrLoad$_() {
            if (this._$_saveToSlotName$_ && (this._$FlushPendingInstances$_(), await this._$_DoSaveToSlot$_(this._$_saveToSlotName$_), 
            this._$_ClearSaveOrLoad$_()), this._$_loadFromSlotName$_ && (await this._$_DoLoadFromSlot$_(this._$_loadFromSlotName$_), 
            this._$_ClearSaveOrLoad$_(), this._$IsDebug$_() && Hw._$StepIfPausedInDebugger$_()), 
            this._$_saveToJsonString$_) {
                const t = await this._$_SaveToJsonString$_();
                this._$_lastSaveJson$_ = t, await this._$TriggerAsync$_(Vw._$Plugins$_._$System$_._$Cnds$_._$OnSaveComplete$_, null), 
                this._$_lastSaveJson$_ = "", this._$_ClearSaveOrLoad$_();
            }
            if (null !== this._$_loadFromJson$_) {
                this._$FlushPendingInstances$_();
                try {
                    await this._$_DoLoadFromJsonString$_(this._$_loadFromJson$_), this._$_lastSaveJson$_ = this._$_loadFromJson$_, 
                    await this._$TriggerAsync$_(Vw._$Plugins$_._$System$_._$Cnds$_._$OnLoadComplete$_, null), 
                    this._$_lastSaveJson$_ = "";
                } catch (t) {
                    console.error("[Construct] Failed to load state from JSON string: ", t), await this._$TriggerAsync$_(Vw._$Plugins$_._$System$_._$Cnds$_._$OnLoadFailed$_, null);
                }
                this._$_ClearSaveOrLoad$_();
            }
        }
        _$_ClearSaveOrLoad$_() {
            this._$_saveToSlotName$_ = "", this._$_saveToJsonString$_ = !1, this._$_loadFromSlotName$_ = "", 
            this._$_loadFromJson$_ = null;
        }
        _$_GetProjectStorage$_() {
            return this._$_projectStorage$_ || (this._$_projectStorage$_ = localforage._$createInstance$_({
                name: "c3-localstorage-" + this._$GetProjectUniqueId$_(),
                description: this._$GetProjectName$_()
            })), this._$_projectStorage$_;
        }
        _$_GetSavegamesStorage$_() {
            return this._$_savegamesStorage$_ || (this._$_savegamesStorage$_ = localforage._$createInstance$_({
                name: "c3-savegames-" + this._$GetProjectUniqueId$_(),
                description: this._$GetProjectName$_()
            })), this._$_savegamesStorage$_;
        }
        async _$_DoSaveToSlot$_(t) {
            const s = await this._$_SaveToJsonString$_();
            try {
                await this._$_GetSavegamesStorage$_().setItem(t, s), console.log("[Construct] Saved state to storage (" + s.length + " chars)"), 
                this._$_lastSaveJson$_ = s, await this._$TriggerAsync$_(Vw._$Plugins$_._$System$_._$Cnds$_._$OnSaveComplete$_, null), 
                this._$_lastSaveJson$_ = "";
            } catch (t) {
                console.error("[Construct] Failed to save state to storage: ", t), await this._$TriggerAsync$_(Vw._$Plugins$_._$System$_._$Cnds$_._$OnSaveFailed$_, null);
            }
        }
        async _$_DoLoadFromSlot$_(t) {
            try {
                const s = await this._$_GetSavegamesStorage$_().getItem(t);
                if (!s) throw new Error("empty slot");
                console.log("[Construct] Loaded state from storage (" + s.length + " chars)"), await this._$_DoLoadFromJsonString$_(s), 
                this._$_lastSaveJson$_ = s, await this._$TriggerAsync$_(Vw._$Plugins$_._$System$_._$Cnds$_._$OnLoadComplete$_, null), 
                this._$_lastSaveJson$_ = "";
            } catch (t) {
                console.error("[Construct] Failed to load state from storage: ", t), await this._$TriggerAsync$_(Vw._$Plugins$_._$System$_._$Cnds$_._$OnLoadFailed$_, null);
            }
        }
        async _$_SaveToJsonString$_() {
            const t = {
                c3save: !0,
                version: 1,
                rt: {
                    time: this._$GetGameTime$_(),
                    timeRaw: this._$GetGameTimeRaw$_(),
                    walltime: this._$GetWallTime$_(),
                    timescale: this._$GetTimeScale$_(),
                    tickcount: this._$GetTickCount$_(),
                    next_uid: this._$_nextUid$_,
                    running_layout: this._$GetMainRunningLayout$_()._$GetSID$_(),
                    start_time_offset: Date.now() - this._$_startTime$_
                },
                types: {},
                layouts: {},
                events: this._$_eventSheetManager$_._$_SaveToJson$_(),
                timelines: this._$_timelineManager$_._$_SaveToJson$_(),
                user_script_data: null
            };
            for (const s of this._$_allObjectClasses$_) s._$IsFamily$_() || s._$HasNoSaveBehavior$_() || (t.types[s._$GetSID$_().toString()] = s._$_SaveToJson$_());
            for (const s of this._$_layoutManager$_._$GetAllLayouts$_()) t.layouts[s._$GetSID$_().toString()] = s._$_SaveToJson$_();
            const s = this._$_CreateUserScriptEvent$_("save");
            return s.saveData = null, await this._$DispatchUserScriptEventAsyncWait$_(s), t.user_script_data = s.saveData, 
            JSON.stringify(t);
        }
        _$IsLoadingState$_() {
            return this._$_isLoadingState$_;
        }
        async _$_DoLoadFromJsonString$_(t) {
            const s = this._$GetLayoutManager$_(), i = JSON.parse(t);
            if (i.c2save) throw new Error("C2 saves are incompatible with C3 runtime");
            if (!i.c3save) throw new Error("not valid C3 save data");
            if (i.version > 1) throw new Error("C3 save data from future version");
            this._$ClearIntancesNeedingAfterLoad$_(), this._$_dispatcher$_.dispatchEvent(Vw._$New$_(Vw.Event, "beforeload"));
            for (const t of this._$allInstances$_()) t._$GetObjectClass$_()._$HasNoSaveBehavior$_() || t._$_OnBeforeLoad$_();
            const e = i.rt;
            this._$_gameTime$_.Set(e.time), e.hasOwnProperty("timeRaw") && this._$_gameTimeRaw$_.Set(e.timeRaw), 
            this._$_wallTime$_.Set(e.walltime), this._$_timeScale$_ = e.timescale, this._$_tickCount$_ = e.tickcount, 
            this._$_startTime$_ = Date.now() - e.start_time_offset;
            const n = e.running_layout;
            this._$_isLoadingState$_ = !0;
            let h = !1;
            if (n !== this._$GetMainRunningLayout$_()._$GetSID$_()) {
                const t = s._$GetLayoutBySID$_(n);
                if (!t) return;
                await this._$_DoChangeLayout$_(t), h = !0;
            }
            for (const [t, e] of Object.entries(i.layouts)) {
                const i = parseInt(t, 10), n = s._$GetLayoutBySID$_(i);
                n && n._$_LoadFromJson$_(e);
            }
            const r = new Set;
            for (const [t, s] of Object.entries(i.types)) {
                const i = parseInt(t, 10), e = this._$GetObjectClassBySID$_(i);
                !e || e._$IsFamily$_() || e._$HasNoSaveBehavior$_() || e._$_LoadFromJson$_(s, r);
            }
            for (const t of this._$_layoutManager$_._$GetAllLayouts$_()) for (const s of t._$allLayers$_()) s._$_LoadFromJsonAfterInstances$_();
            if (this._$FlushPendingInstances$_(), this._$_RefreshUidMap$_(), this._$_isLoadingState$_ = !1, 
            h) {
                for (const t of this._$allInstances$_()) t._$SetupInitialSceneGraphConnections$_();
                for (const [t, s] of Object.entries(i.types)) {
                    const i = parseInt(t, 10), e = this._$GetObjectClassBySID$_(i);
                    !e || e._$IsFamily$_() || e._$HasNoSaveBehavior$_() || e._$_SetupSceneGraphConnectionsOnChangeOfLayout$_(s);
                }
            }
            this._$_nextUid$_ = e.next_uid, this._$_eventSheetManager$_._$_LoadFromJson$_(i.events);
            for (const t of this._$_allObjectClasses$_) if (!t._$IsFamily$_() && t._$IsInContainer$_()) for (const s of t._$GetInstances$_()) {
                const i = s._$GetIID$_();
                s._$_ClearSiblings$_();
                for (const e of t._$GetContainer$_()._$objectTypes$_()) {
                    if (e === t) continue;
                    const n = e._$GetInstances$_();
                    if (i < 0 || i >= n.length) throw new Error("missing sibling instance");
                    s._$_AddSibling$_(n[i]);
                }
            }
            this._$_timelineManager$_._$_LoadFromJson$_(i.timelines), s._$SetAllLayerProjectionChanged$_(), 
            s._$SetAllLayerMVChanged$_();
            for (const t of r) t._$_OnCreatedForLoadingSavegame$_();
            this._$DoAfterLoad$_(), this._$_dispatcher$_.dispatchEvent(Vw._$New$_(Vw.Event, "afterload")), 
            this._$DispatchUserScriptEvent$_(this._$_CreateUserScriptEvent$_("afterload"));
            for (const [t, s] of Object.entries(i.types)) {
                const s = parseInt(t, 10), i = this._$GetObjectClassBySID$_(s);
                i && i._$_ClearLoadInstancesJson$_();
            }
            const o = this._$_CreateUserScriptEvent$_("load");
            o.saveData = i.user_script_data, await this._$DispatchUserScriptEventAsyncWait$_(o), 
            this._$UpdateRender$_();
        }
        _$SortOnTmpHierarchyPosition$_(t, s) {
            return s._$GetWorldInfo$_()._$GetTmpHierarchyPosition$_() - t._$GetWorldInfo$_()._$GetTmpHierarchyPosition$_();
        }
        _$AddInstanceNeedingAfterLoad$_(t, s) {
            t._$GetWorldInfo$_() && (this._$_instancesNeedingAfterLoadMap$_.has(t) || (this._$_instancesNeedingAfterLoadMap$_.set(t, s), 
            this._$_instancesNeedingAfterLoadArray$_.push(t)));
        }
        _$ClearIntancesNeedingAfterLoad$_() {
            this._$_instancesNeedingAfterLoadMap$_ = new WeakMap, Vw._$clearArray$_(this._$_instancesNeedingAfterLoadArray$_);
        }
        _$DoAfterLoad$_(t = "full", s = null) {
            this._$_instancesNeedingAfterLoadArray$_.sort(this._$SortOnTmpHierarchyPosition$_);
            const i = this._$_instancesNeedingAfterLoadArray$_.length;
            for (const i of this._$_instancesNeedingAfterLoadArray$_) i._$_OnAfterLoad$_(this._$_instancesNeedingAfterLoadMap$_.get(i), t, s);
            for (const i of this._$_instancesNeedingAfterLoadArray$_) i._$_OnAfterLoad2$_(this._$_instancesNeedingAfterLoadMap$_.get(i), t, s);
            if (this._$ClearIntancesNeedingAfterLoad$_(), i) {
                this._$FlushPendingInstances$_(), this._$_RefreshUidMap$_();
                for (const t of this._$_layoutManager$_._$GetAllLayouts$_()) for (const s of t._$allLayers$_()) s._$_SortInstancesByLastCachedZIndex$_(), 
                s._$SetZIndicesChanged$_();
            }
        }
        async _$AddJobWorkerScripts$_(t) {
            const s = await Promise.all(t.map((async t => {
                if (this._$IsCordova$_() && this._$_assetManager$_._$IsFileProtocol$_() || "playable-ad-single-file" === this._$GetExportType$_()) {
                    const s = await this._$_assetManager$_._$FetchBlob$_(t);
                    return URL.createObjectURL(s);
                }
                return new URL(t, location.href).toString();
            })));
            this._$_jobScheduler$_._$ImportScriptsToJobWorkers$_(s);
        }
        _$AddJobWorkerBlob$_(t, s) {
            this._$_jobScheduler$_._$SendBlobToJobWorkers$_(t, s);
        }
        _$AddJobWorkerBuffer$_(t, s) {
            this._$_jobScheduler$_._$SendBufferToJobWorkers$_(t, s);
        }
        _$AddJob$_(t, s, i, e) {
            return this._$_jobScheduler$_._$AddJob$_(t, s, i, null, null, e);
        }
        _$BroadcastJob$_(t, s, i, e) {
            return this._$_jobScheduler$_._$BroadcastJob$_(t, s, i, e);
        }
        _$GetMaxNumJobWorkers$_() {
            return this._$_jobScheduler$_._$GetMaxNumWorkers$_();
        }
        _$InvokeDownload$_(t, s) {
            this._$PostComponentMessageToDOM$_("runtime", "invoke-download", {
                url: t,
                filename: s
            });
        }
        async _$RasterSvgImage$_(t, s, i, e, n, h) {
            if (e = e || s, n = n || i, this._$IsInWorker$_()) return (await this._$PostComponentMessageToDOMAsync$_("runtime", "raster-svg-image", {
                blob: t,
                imageWidth: s,
                imageHeight: i,
                surfaceWidth: e,
                surfaceHeight: n,
                imageBitmapOpts: h
            })).imageBitmap;
            {
                const r = await self.C3_RasterSvgImageBlob(t, s, i, e, n);
                return h ? await self.createImageBitmap(r, h) : r;
            }
        }
        async _$GetSvgImageSize$_(t) {
            return this._$IsInWorker$_() ? await this._$PostComponentMessageToDOMAsync$_("runtime", "get-svg-image-size", {
                blob: t
            }) : await self.C3_GetSvgImageSize(t);
        }
        _$RequestDeviceOrientationEvent$_() {
            this._$_didRequestDeviceOrientationEvent$_ || (this._$_didRequestDeviceOrientationEvent$_ = !0, 
            this._$PostComponentMessageToDOM$_("runtime", "enable-device-orientation"));
        }
        _$RequestDeviceMotionEvent$_() {
            this._$_didRequestDeviceMotionEvent$_ || (this._$_didRequestDeviceMotionEvent$_ = !0, 
            this._$PostComponentMessageToDOM$_("runtime", "enable-device-motion"));
        }
        _$Random$_() {
            return this._$_randomNumberCallback$_();
        }
        _$SetRandomNumberGeneratorCallback$_(t) {
            this._$_randomNumberCallback$_ = t;
        }
        _$_GetRemotePreviewStatusInfo$_() {
            const t = this._$GetRenderer$_();
            return {
                fps: this._$GetFramesPerSecond$_(),
                tps: this._$GetTicksPerSecond$_(),
                cpu: this._$GetMainThreadTime$_(),
                gpu: this._$GetGPUUtilisation$_(),
                layout: this._$GetMainRunningLayout$_() ? this._$GetMainRunningLayout$_()._$GetName$_() : "",
                renderer: t._$IsWebGL$_() ? t._$GetUnmaskedRenderer$_() : t._$GetAdapterInfoString$_()
            };
        }
        _$HitBreakpoint$_() {
            return !!this._$IsDebug$_() && Hw._$HitBreakpoint$_();
        }
        _$DebugBreak$_(t) {
            return this._$IsDebugging$_() ? Hw._$DebugBreak$_(t) : Promise.resolve();
        }
        _$DebugBreakNext$_() {
            return !!this._$IsDebugging$_() && Hw._$BreakNext$_();
        }
        _$SetDebugBreakpointsEnabled$_(t) {
            this._$_breakpointsEnabled$_ = !!t, this._$_UpdateDebuggingFlag$_();
        }
        _$AreDebugBreakpointsEnabled$_() {
            return this._$_breakpointsEnabled$_;
        }
        _$IsDebugging$_() {
            return this._$_isDebugging$_;
        }
        _$SetDebuggingEnabled$_(t) {
            t ? this._$_debuggingDisabled$_-- : this._$_debuggingDisabled$_++, this._$_UpdateDebuggingFlag$_();
        }
        _$_UpdateDebuggingFlag$_() {
            this._$_isDebugging$_ = this._$IsDebug$_() && this._$_breakpointsEnabled$_ && 0 === this._$_debuggingDisabled$_;
        }
        _$IsCPUProfiling$_() {
            return this._$IsDebug$_() && Hw._$IsCPUProfiling$_();
        }
        _$IsGPUProfiling$_() {
            return this._$IsDebug$_() && this._$GetRenderer$_()._$SupportsGPUProfiling$_() && Hw._$IsGPUProfiling$_();
        }
        async _$DebugIterateAndBreak$_(t) {
            if (t) for (const s of t) await this._$DebugBreak$_(s);
        }
        _$DebugFireGeneratorEventAndBreak$_(t) {
            return this._$DebugIterateAndBreak$_(this._$_dispatcher$_._$dispatchGeneratorEvent$_(t));
        }
        _$_InvokeFunctionFromJS$_(t) {
            return this._$_eventSheetManager$_._$_InvokeFunctionFromJS$_(t.name, t.params);
        }
        _$_GetHTMLLayerWrapElement$_(t) {
            if (this._$IsInWorker$_()) throw new Error("not supported in worker mode");
            return self.c3_runtimeInterface._GetHTMLWrapElement(t);
        }
        _$GetIRuntime$_() {
            return this._$_iRuntime$_;
        }
        _$_CreateUserScriptEvent$_(t) {
            const s = Vw._$New$_(Vw.Event, t, !1);
            return s.runtime = this._$_iRuntime$_, s;
        }
        _$_InitScriptInterfaces$_() {
            this._$_iRuntime$_ = new self._$IRuntime$_(this), this._$_userScriptEventObjects$_ = {
                pretick: this._$_CreateUserScriptEvent$_("pretick"),
                tick: this._$_CreateUserScriptEvent$_("tick"),
                tick2: this._$_CreateUserScriptEvent$_("tick2")
            };
        }
        _$_InitObjectsScriptInterface$_() {
            const t = {};
            for (const s of this._$_allObjectClasses$_) t[s._$GetJsPropName$_()] = {
                value: s._$GetIObjectClass$_(),
                enumerable: !0,
                writable: !1
            };
            this._$_iRuntime$_._$_InitObjects$_(t);
        }
        _$_InitGlobalVariableScriptInterface$_() {
            const t = {};
            for (const s of this._$GetEventSheetManager$_()._$GetAllGlobalVariables$_()) t[s._$GetJsPropName$_()] = s._$_GetScriptInterfaceDescriptor$_();
            this._$_iRuntime$_._$_InitGlobalVars$_(t);
        }
        _$_GetCommonScriptInterfaces$_() {
            return this._$_commonScriptInterfaces$_;
        }
        _$_MapScriptInterface$_(t, s) {
            this._$_interfaceMap$_.set(t, s);
        }
        _$_UnwrapScriptInterface$_(t) {
            return this._$_interfaceMap$_.get(t);
        }
        _$_UnwrapIObjectClass$_(t) {
            if (!(t instanceof self._$IObjectClass$_)) throw new TypeError("expected IObjectClass");
            const s = this._$_UnwrapScriptInterface$_(t);
            if (!(s && s instanceof Vw._$ObjectClass$_)) throw new Error("invalid IObjectClass");
            return s;
        }
        _$_UnwrapIInstance$_(t) {
            if (!(t instanceof self._$IInstance$_)) throw new TypeError("expected IInstance");
            const s = this._$_UnwrapScriptInterface$_(t);
            if (!(s && s instanceof Vw.Instance)) throw new Error("invalid IInstance");
            return s;
        }
        _$_UnwrapIWorldInstance$_(t) {
            if (!(t instanceof self._$IWorldInstance$_)) throw new TypeError("expected IWorldInstance");
            const s = this._$_UnwrapScriptInterface$_(t);
            if (!(s && s instanceof Vw.Instance)) throw new Error("invalid IInstance");
            return s;
        }
    }, self.C3_CreateRuntime = Vw._$Runtime$_._$Create$_, self.C3_InitRuntime = (t, s) => t._$Init$_(s);
}

{
    const Kw = self._$C3$_;
    Kw._$JobSchedulerRuntime$_ = class extends Kw._$DefendedBase$_ {
        constructor(t, s) {
            super(), this._$_runtime$_ = t, this._$_jobPromises$_ = new Map, this._$_nextJobId$_ = 0, 
            this._$_inputPort$_ = s.inputPort, s.outputPort.onmessage = t => this._$_OnJobWorkerMessage$_(t), 
            this._$_maxNumWorkers$_ = s.maxNumWorkers, this._$_jobWorkerCount$_ = 1, this._$_isCreatingWorker$_ = !1, 
            this._$_hadErrorCreatingWorker$_ = !1;
        }
        _$GetMaxNumWorkers$_() {
            return this._$_maxNumWorkers$_;
        }
        _$ImportScriptsToJobWorkers$_(t) {
            this._$_inputPort$_.postMessage({
                type: "_import_scripts",
                scripts: t
            });
        }
        _$SendBlobToJobWorkers$_(t, s) {
            this._$_inputPort$_.postMessage({
                type: "_send_blob",
                blob: t,
                id: s
            });
        }
        _$SendBufferToJobWorkers$_(t, s) {
            this._$_inputPort$_.postMessage({
                type: "_send_buffer",
                buffer: t,
                id: s
            }, [ t ]);
        }
        _$AddJob$_(t, s, i, e, n, h) {
            if (i || (i = []), "number" == typeof h && (h = Math.floor(h)) <= 0) throw new Error("invalid maxWorkerNum");
            const r = this._$_nextJobId$_++, o = {
                type: t,
                isBroadcast: !1,
                maxWorkerNum: h,
                jobId: r,
                params: s,
                transferables: i
            }, a = new Promise(((t, s) => {
                this._$_jobPromises$_.set(r, {
                    resolve: t,
                    progress: e,
                    reject: s,
                    _$cancelled$_: !1,
                    _$maxWorkerNum$_: h
                });
            }));
            return n && n._$SetAction$_((() => this._$_CancelJob$_(r))), this._$_inputPort$_.postMessage(o, i), 
            this._$_MaybeCreateExtraWorker$_(), a;
        }
        _$BroadcastJob$_(t, s, i, e) {
            if (i || (i = []), "number" == typeof e && (e = Math.floor(e)) <= 0) throw new Error("invalid maxWorkerNum");
            const n = {
                type: t,
                isBroadcast: !0,
                maxWorkerNum: e,
                jobId: this._$_nextJobId$_++,
                params: s,
                transferables: i
            };
            this._$_inputPort$_.postMessage(n, i);
        }
        _$_CancelJob$_(t) {
            const s = this._$_jobPromises$_.get(t);
            s && (s._$cancelled$_ = !0, s.resolve = null, s.progress = null, s.reject = null, 
            this._$_inputPort$_.postMessage({
                type: "_cancel",
                jobId: t
            }));
        }
        _$_OnJobWorkerMessage$_(t) {
            const s = t.data, i = s.type, e = s.jobId;
            switch (i) {
              case "result":
                this._$_OnJobResult$_(e, s.result);
                break;

              case "progress":
                this._$_OnJobProgress$_(e, s.progress);
                break;

              case "error":
                this._$_OnJobError$_(e, s.error);
                break;

              case "ready":
                this._$_OnJobWorkerReady$_();
                break;

              default:
                throw new Error(`unknown message from worker '${i}'`);
            }
        }
        _$_OnJobResult$_(t, s) {
            const i = this._$_jobPromises$_.get(t);
            if (!i) throw new Error("invalid job ID");
            i._$cancelled$_ || i.resolve(s), this._$_jobPromises$_.delete(t);
        }
        _$_OnJobProgress$_(t, s) {
            const i = this._$_jobPromises$_.get(t);
            if (!i) throw new Error("invalid job ID");
            !i._$cancelled$_ && i.progress && i.progress(s);
        }
        _$_OnJobError$_(t, s) {
            const i = this._$_jobPromises$_.get(t);
            if (!i) throw new Error("invalid job ID");
            i._$cancelled$_ || i.reject(s), this._$_jobPromises$_.delete(t);
        }
        _$_OnJobWorkerReady$_() {
            this._$_isCreatingWorker$_ && (this._$_isCreatingWorker$_ = !1, this._$_jobWorkerCount$_++, 
            this._$_jobWorkerCount$_ < this._$_maxNumWorkers$_ ? this._$_MaybeCreateExtraWorker$_() : this._$_inputPort$_.postMessage({
                type: "_no_more_workers"
            }));
        }
        _$_GetWorkerCountNeededForPendingJobs$_() {
            let t = 0;
            const s = [ ...this._$_jobPromises$_.values() ].sort(((t, s) => (t._$maxWorkerNum$_ || 1 / 0) - (s._$maxWorkerNum$_ || 1 / 0)));
            for (const i of s) t < (i._$maxWorkerNum$_ || 1 / 0) && t++;
            return t;
        }
        async _$_MaybeCreateExtraWorker$_() {
            if (!(this._$_jobWorkerCount$_ >= this._$_maxNumWorkers$_ || this._$_isCreatingWorker$_ || this._$_hadErrorCreatingWorker$_ || this._$_GetWorkerCountNeededForPendingJobs$_() <= this._$_jobWorkerCount$_)) try {
                this._$_isCreatingWorker$_ = !0, (await this._$_runtime$_._$PostComponentMessageToDOMAsync$_("runtime", "create-job-worker")).outputPort.onmessage = t => this._$_OnJobWorkerMessage$_(t);
            } catch (t) {
                this._$_hadErrorCreatingWorker$_ = !0, this._$_isCreatingWorker$_ = !1, console.error(`[Construct] Failed to create job worker; stopping creating any more (created ${this._$_jobWorkerCount$_} so far)`, t);
            }
        }
    };
}

self.C3_Shaders = {};

{
    let $w = function(t, s) {
        const i = t[1], e = s[1];
        if ("number" == typeof i && "number" == typeof e) return i - e;
        {
            const t = "" + i, s = "" + e;
            return t < s ? -1 : t > s ? 1 : 0;
        }
    };
    0;
    const tS = self._$C3$_;
    let sS = null, iS = "", eS = "", nS = [], hS = "", rS = "", oS = "";
    const aS = tS._$New$_(tS._$ArrayStack$_);
    tS._$Plugins$_._$System$_ = class extends tS._$SDKPluginBase$_ {
        constructor(t) {
            super(t), this._$_loopStack$_ = this._$_runtime$_._$GetEventSheetManager$_()._$GetLoopStack$_(), 
            this._$_eventStack$_ = this._$_runtime$_._$GetEventSheetManager$_()._$GetEventStack$_(), 
            this._$_imagesLoadingTotal$_ = 0, this._$_imagesLoadingComplete$_ = 0, this._$_functionMaps$_ = new Map;
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$UpdateRender$_() {
            this._$_runtime$_._$UpdateRender$_();
        }
        _$Trigger$_(t) {
            this._$_runtime$_._$Trigger$_(t, null, null);
        }
        _$GetRegex$_(t, s) {
            return sS && t === iS && s === eS || (sS = new RegExp(t, s), iS = t, eS = s), sS.lastIndex = 0, 
            sS;
        }
        _$GetRegexMatches$_(t, s, i) {
            if (t === hS && s === rS && i === oS) return nS;
            const e = this._$GetRegex$_(s, i);
            return nS = t.match(e), hS = t, rS = s, oS = i, nS;
        }
        async _$_LoadTexturesForObjectClasses$_(t, s) {
            if (!s.length) return;
            this._$_imagesLoadingTotal$_ += s.length;
            const i = [];
            for (const e of s) i.push(t._$MaybeLoadTexturesFor$_(e));
            await tS._$PromiseAllWithProgress$_(i, (() => {
                this._$_imagesLoadingComplete$_++;
            })), this._$_imagesLoadingComplete$_++, this._$_imagesLoadingComplete$_ === this._$_imagesLoadingTotal$_ && (this._$_imagesLoadingComplete$_ = 0, 
            this._$_imagesLoadingTotal$_ = 0, this._$_runtime$_._$Trigger$_(tS._$Plugins$_._$System$_._$Cnds$_._$OnImageLoadingComplete$_, null, null));
        }
        _$GetImageLoadingProgress$_() {
            return 0 === this._$_imagesLoadingTotal$_ ? 1 : this._$_imagesLoadingComplete$_ / this._$_imagesLoadingTotal$_;
        }
        _$_UnloadTexturesForObjectClasses$_(t, s) {
            for (const i of s) 0 === i._$GetInstanceCount$_() && t._$MaybeUnloadTexturesFor$_(i);
        }
        _$_GetForEachStack$_() {
            return aS;
        }
        _$_Repeat$_(t) {
            const s = this._$_runtime$_._$GetEventSheetManager$_(), i = s._$GetEventStack$_(), e = i._$GetCurrentStackFrame$_(), n = e._$GetCurrentEvent$_(), h = n._$GetSolModifiers$_(), r = e._$IsSolModifierAfterCnds$_(), o = i._$Push$_(n), a = s._$GetLoopStack$_(), u = a._$Push$_();
            if (u._$SetEnd$_(t), r) for (let i = 0; i < t && !u._$IsStopped$_(); ++i) s._$PushCopySol$_(h), 
            u._$SetIndex$_(i), n._$Retrigger$_(e, o), s._$PopSol$_(h); else for (let s = 0; s < t && !u._$IsStopped$_(); ++s) u._$SetIndex$_(s), 
            n._$Retrigger$_(e, o);
            return i._$Pop$_(), a._$Pop$_(), !1;
        }
        * _$_DebugRepeat$_(t) {
            const s = this._$_runtime$_._$GetEventSheetManager$_(), i = s._$GetEventStack$_(), e = i._$GetCurrentStackFrame$_(), n = e._$GetCurrentEvent$_(), h = n._$GetSolModifiers$_(), r = e._$IsSolModifierAfterCnds$_(), o = i._$Push$_(n), a = s._$GetLoopStack$_(), u = a._$Push$_();
            if (u._$SetEnd$_(t), r) for (let i = 0; i < t && !u._$IsStopped$_(); ++i) s._$PushCopySol$_(h), 
            u._$SetIndex$_(i), yield* n._$DebugRetrigger$_(e, o), s._$PopSol$_(h); else for (let s = 0; s < t && !u._$IsStopped$_(); ++s) u._$SetIndex$_(s), 
            yield* n._$DebugRetrigger$_(e, o);
            return i._$Pop$_(), a._$Pop$_(), !1;
        }
        _$_While$_() {
            const t = this._$_runtime$_._$GetEventSheetManager$_(), s = t._$GetEventStack$_(), i = s._$GetCurrentStackFrame$_(), e = i._$GetCurrentEvent$_(), n = e._$GetSolModifiers$_(), h = i._$IsSolModifierAfterCnds$_(), r = s._$Push$_(e), o = t._$GetLoopStack$_(), a = o._$Push$_();
            if (h) for (let s = 0; !a._$IsStopped$_(); ++s) t._$PushCopySol$_(n), a._$SetIndex$_(s), 
            e._$Retrigger$_(i, r) || a._$Stop$_(), t._$PopSol$_(n); else for (let t = 0; !a._$IsStopped$_(); ++t) a._$SetIndex$_(t), 
            e._$Retrigger$_(i, r) || a._$Stop$_();
            return s._$Pop$_(), o._$Pop$_(), !1;
        }
        * _$_DebugWhile$_() {
            const t = this._$_runtime$_._$GetEventSheetManager$_(), s = t._$GetEventStack$_(), i = s._$GetCurrentStackFrame$_(), e = i._$GetCurrentEvent$_(), n = e._$GetSolModifiers$_(), h = i._$IsSolModifierAfterCnds$_(), r = s._$Push$_(e), o = t._$GetLoopStack$_(), a = o._$Push$_();
            if (h) for (let s = 0; !a._$IsStopped$_(); ++s) t._$PushCopySol$_(n), a._$SetIndex$_(s), 
            (yield* e._$DebugRetrigger$_(i, r)) || a._$Stop$_(), t._$PopSol$_(n); else for (let t = 0; !a._$IsStopped$_(); ++t) a._$SetIndex$_(t), 
            (yield* e._$DebugRetrigger$_(i, r)) || a._$Stop$_();
            return s._$Pop$_(), o._$Pop$_(), !1;
        }
        _$_For$_(t, s, i) {
            const e = this._$_runtime$_._$GetEventSheetManager$_(), n = e._$GetEventStack$_(), h = n._$GetCurrentStackFrame$_(), r = h._$GetCurrentEvent$_(), o = r._$GetSolModifiers$_(), a = h._$IsSolModifierAfterCnds$_(), u = n._$Push$_(r), l = e._$GetLoopStack$_(), c = l._$Push$_();
            if (c._$SetName$_(t), c._$SetEnd$_(i), i < s) if (a) for (let t = s; t >= i && !c._$IsStopped$_(); --t) e._$PushCopySol$_(o), 
            c._$SetIndex$_(t), r._$Retrigger$_(h, u), e._$PopSol$_(o); else for (let t = s; t >= i && !c._$IsStopped$_(); --t) c._$SetIndex$_(t), 
            r._$Retrigger$_(h, u); else if (a) for (let t = s; t <= i && !c._$IsStopped$_(); ++t) e._$PushCopySol$_(o), 
            c._$SetIndex$_(t), r._$Retrigger$_(h, u), e._$PopSol$_(o); else for (let t = s; t <= i && !c._$IsStopped$_(); ++t) c._$SetIndex$_(t), 
            r._$Retrigger$_(h, u);
            return n._$Pop$_(), l._$Pop$_(), !1;
        }
        * _$_DebugFor$_(t, s, i) {
            const e = this._$_runtime$_._$GetEventSheetManager$_(), n = e._$GetEventStack$_(), h = n._$GetCurrentStackFrame$_(), r = h._$GetCurrentEvent$_(), o = r._$GetSolModifiers$_(), a = h._$IsSolModifierAfterCnds$_(), u = n._$Push$_(r), l = e._$GetLoopStack$_(), c = l._$Push$_();
            if (c._$SetName$_(t), c._$SetEnd$_(i), i < s) if (a) for (let t = s; t >= i && !c._$IsStopped$_(); --t) e._$PushCopySol$_(o), 
            c._$SetIndex$_(t), yield* r._$DebugRetrigger$_(h, u), e._$PopSol$_(o); else for (let t = s; t >= i && !c._$IsStopped$_(); --t) c._$SetIndex$_(t), 
            yield* r._$DebugRetrigger$_(h, u); else if (a) for (let t = s; t <= i && !c._$IsStopped$_(); ++t) e._$PushCopySol$_(o), 
            c._$SetIndex$_(t), yield* r._$DebugRetrigger$_(h, u), e._$PopSol$_(o); else for (let t = s; t <= i && !c._$IsStopped$_(); ++t) c._$SetIndex$_(t), 
            yield* r._$DebugRetrigger$_(h, u);
            return n._$Pop$_(), l._$Pop$_(), !1;
        }
        _$_ForEach$_(t) {
            const s = t._$GetCurrentSol$_(), i = s._$GetInstances$_();
            if (0 === i.length) return !1;
            const e = this._$_runtime$_._$GetEventSheetManager$_(), n = e._$GetEventStack$_(), h = n._$GetCurrentStackFrame$_(), r = h._$GetCurrentEvent$_(), o = r._$GetSolModifiers$_(), a = h._$IsSolModifierAfterCnds$_(), u = n._$Push$_(r), l = e._$GetLoopStack$_(), c = l._$Push$_(), f = t._$IsInContainer$_(), d = aS._$Push$_();
            if (tS._$shallowAssignArray$_(d, i), c._$SetEnd$_(d.length), a) for (let s = 0, i = d.length; s < i && !c._$IsStopped$_(); ++s) {
                e._$PushCopySol$_(o);
                const i = d[s];
                t._$GetCurrentSol$_()._$SetSinglePicked$_(i), f && i._$SetSiblingsSinglePicked$_(), 
                c._$SetIndex$_(s), r._$Retrigger$_(h, u), e._$PopSol$_(o);
            } else {
                s._$_SetSelectAll$_(!1);
                const t = s._$_GetOwnInstances$_();
                tS._$clearArray$_(t), t.push(null);
                for (let s = 0, i = d.length; s < i && !c._$IsStopped$_(); ++s) {
                    const i = d[s];
                    t[0] = i, f && i._$SetSiblingsSinglePicked$_(), c._$SetIndex$_(s), r._$Retrigger$_(h, u);
                }
            }
            return n._$Pop$_(), l._$Pop$_(), tS._$clearArray$_(d), aS._$Pop$_(), !1;
        }
        * _$_DebugForEach$_(t) {
            const s = t._$GetCurrentSol$_(), i = s._$GetInstances$_();
            if (0 === i.length) return !1;
            const e = this._$_runtime$_._$GetEventSheetManager$_(), n = e._$GetEventStack$_(), h = n._$GetCurrentStackFrame$_(), r = h._$GetCurrentEvent$_(), o = r._$GetSolModifiers$_(), a = h._$IsSolModifierAfterCnds$_(), u = n._$Push$_(r), l = e._$GetLoopStack$_(), c = l._$Push$_(), f = t._$IsInContainer$_(), d = aS._$Push$_();
            if (tS._$shallowAssignArray$_(d, i), c._$SetEnd$_(d.length), a) for (let s = 0, i = d.length; s < i && !c._$IsStopped$_(); ++s) {
                e._$PushCopySol$_(o);
                const i = d[s];
                t._$GetCurrentSol$_()._$SetSinglePicked$_(i), f && i._$SetSiblingsSinglePicked$_(), 
                c._$SetIndex$_(s), yield* r._$DebugRetrigger$_(h, u), e._$PopSol$_(o);
            } else {
                s._$_SetSelectAll$_(!1);
                const t = s._$_GetOwnInstances$_();
                tS._$clearArray$_(t), t.push(null);
                for (let s = 0, i = d.length; s < i && !c._$IsStopped$_(); ++s) {
                    const i = d[s];
                    t[0] = i, f && i._$SetSiblingsSinglePicked$_(), c._$SetIndex$_(s), yield* r._$DebugRetrigger$_(h, u);
                }
            }
            return n._$Pop$_(), l._$Pop$_(), tS._$clearArray$_(d), aS._$Pop$_(), !1;
        }
        _$_ForEachOrdered$_(t, s) {
            const i = t._$GetCurrentSol$_(), e = i._$GetInstances$_();
            if (0 === e.length) return !1;
            const n = this._$_runtime$_._$GetEventSheetManager$_(), h = n._$GetEventStack$_(), r = n._$GetCurrentCondition$_(), o = h._$GetCurrentStackFrame$_(), a = o._$GetCurrentEvent$_(), u = a._$GetSolModifiers$_(), l = o._$IsSolModifierAfterCnds$_(), c = h._$Push$_(a), f = n._$GetLoopStack$_(), d = f._$Push$_(), p = t._$IsInContainer$_(), m = aS._$Push$_();
            tS._$clearArray$_(m), d._$SetEnd$_(e.length);
            for (let t = 0, s = e.length; t < s; ++t) m.push([ e[t], r._$ReevaluateParameter$_(1, t) ]);
            if (m.sort($w), 1 === s && m.reverse(), l) for (let s = 0, i = m.length; s < i && !d._$IsStopped$_(); ++s) {
                n._$PushCopySol$_(u);
                const i = m[s][0];
                t._$GetCurrentSol$_()._$SetSinglePicked$_(i), p && i._$SetSiblingsSinglePicked$_(), 
                d._$SetIndex$_(s), a._$Retrigger$_(o, c), n._$PopSol$_(u);
            } else {
                i._$_SetSelectAll$_(!1);
                const t = i._$_GetOwnInstances$_();
                tS._$clearArray$_(t), t.push(null);
                for (let s = 0, i = m.length; s < i && !d._$IsStopped$_(); ++s) {
                    const i = m[s][0];
                    t[0] = i, p && i._$SetSiblingsSinglePicked$_(), d._$SetIndex$_(s), a._$Retrigger$_(o, c);
                }
            }
            return h._$Pop$_(), f._$Pop$_(), tS._$clearArray$_(m), aS._$Pop$_(), !1;
        }
        * _$_DebugForEachOrdered$_(t, s) {
            const i = t._$GetCurrentSol$_(), e = i._$GetInstances$_();
            if (0 === e.length) return !1;
            const n = this._$_runtime$_._$GetEventSheetManager$_(), h = n._$GetEventStack$_(), r = n._$GetCurrentCondition$_(), o = h._$GetCurrentStackFrame$_(), a = o._$GetCurrentEvent$_(), u = a._$GetSolModifiers$_(), l = o._$IsSolModifierAfterCnds$_(), c = h._$Push$_(a), f = n._$GetLoopStack$_(), d = f._$Push$_(), p = t._$IsInContainer$_(), m = aS._$Push$_();
            tS._$clearArray$_(m), d._$SetEnd$_(e.length);
            for (let t = 0, s = e.length; t < s; ++t) m.push([ e[t], r._$ReevaluateParameter$_(1, t) ]);
            if (m.sort($w), 1 === s && m.reverse(), l) for (let s = 0, i = m.length; s < i && !d._$IsStopped$_(); ++s) {
                n._$PushCopySol$_(u);
                const i = m[s][0];
                t._$GetCurrentSol$_()._$SetSinglePicked$_(i), p && i._$SetSiblingsSinglePicked$_(), 
                d._$SetIndex$_(s), yield* a._$DebugRetrigger$_(o, c), n._$PopSol$_(u);
            } else {
                i._$_SetSelectAll$_(!1);
                const t = i._$_GetOwnInstances$_();
                tS._$clearArray$_(t), t.push(null);
                for (let s = 0, i = m.length; s < i && !d._$IsStopped$_(); ++s) {
                    const i = m[s][0];
                    t[0] = i, p && i._$SetSiblingsSinglePicked$_(), d._$SetIndex$_(s), yield* a._$DebugRetrigger$_(o, c);
                }
            }
            return h._$Pop$_(), f._$Pop$_(), tS._$clearArray$_(m), aS._$Pop$_(), !1;
        }
        _$_GetFunctionMap$_(t, s) {
            let i = this._$_functionMaps$_.get(t);
            return i || (s ? (i = {
                _$defaultFunc$_: null,
                _$strMap$_: new Map
            }, this._$_functionMaps$_.set(t, i), i) : null);
        }
        _$_DoCallMappedFunction$_(t, s, i, e, n) {
            s._$GetEventBlock$_()._$RunAsMappedFunctionCall$_(i, s._$IsCopyPicked$_()), e && t._$PopSol$_(n);
        }
        * _$_DebugDoCallMappedFunction$_(t, s, i, e, n) {
            yield* s._$GetEventBlock$_()._$DebugRunAsMappedFunctionCall$_(i, s._$IsCopyPicked$_()), 
            e && t._$PopSol$_(n);
        }
    };
}

{
    const uS = self._$C3$_;
    uS._$Plugins$_._$System$_._$Type$_ = class extends uS._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_objectClass$_ = t, this._$_runtime$_ = t._$GetRuntime$_(), this._$_plugin$_ = t._$GetPlugin$_();
        }
        _$OnCreate$_() {}
        _$Release$_() {
            this._$_objectClass$_ = null, this._$_runtime$_ = null, this._$_plugin$_ = null;
        }
    };
}

{
    const lS = self._$C3$_;
    lS._$Plugins$_._$System$_.Instance = class extends lS._$DefendedBase$_ {
        constructor(t, s) {
            super(), this._$_inst$_ = t, this._$_objectClass$_ = this._$_inst$_._$GetObjectClass$_(), 
            this._$_sdkType$_ = this._$_objectClass$_._$GetSdkType$_(), this._$_runtime$_ = this._$_inst$_._$GetRuntime$_();
        }
        _$Release$_() {
            this._$_inst$_ = null, this._$_objectClass$_ = null, this._$_sdkType$_ = null, this._$_runtime$_ = null;
        }
    };
}

{
    const cS = self._$C3$_, fS = [];
    cS._$Plugins$_._$System$_._$Cnds$_ = {
        _$EveryTick$_: () => !0,
        _$OnLayoutStart$_: () => !0,
        _$OnLayoutEnd$_: () => !0,
        _$OnSuspend$_: () => !0,
        _$OnResume$_: () => !0,
        _$IsSuspended$_() {
            return this._$_runtime$_._$IsSuspended$_();
        },
        _$Else$_() {
            const t = this._$_runtime$_._$GetCurrentEventStackFrame$_();
            return !t._$GetElseBranchRan$_() && !t._$GetLastEventTrue$_();
        },
        _$TriggerOnce$_() {
            const t = this._$_runtime$_._$GetCurrentCondition$_()._$GetSavedDataMap$_();
            let s = t.get("TriggerOnce_lastTick");
            void 0 === s && (s = -1, t.set("TriggerOnce_lastTick", -1));
            const i = this._$_runtime$_._$GetTickCount$_();
            return t.set("TriggerOnce_lastTick", i), this._$_runtime$_._$IsLayoutFirstTick$_() || s !== i - 1;
        },
        _$Every$_(t) {
            const s = this._$_runtime$_._$GetCurrentCondition$_()._$GetSavedDataMap$_(), i = s.get("Every_lastTime") || 0, e = this._$_runtime$_._$GetGameTime$_();
            s.has("Every_seconds") || s.set("Every_seconds", t);
            const n = s.get("Every_seconds");
            return e >= i + n ? (s.set("Every_lastTime", i + n), e >= s.get("Every_lastTime") + .04 && s.set("Every_lastTime", e), 
            s.set("Every_seconds", t), !0) : (e < i - .1 && s.set("Every_lastTime", e), !1);
        },
        _$IsGroupActive$_(t) {
            const s = this._$_runtime$_._$GetEventSheetManager$_()._$GetEventGroupByName$_(t);
            return s && s._$IsGroupActive$_();
        },
        _$IsPreview$_() {
            return this._$_runtime$_._$IsPreview$_();
        },
        _$IsMobile$_: () => cS._$Platform$_._$IsMobile$_,
        _$OnLoadFinished$_: () => !0,
        _$OnCanvasSnapshot$_: () => !0,
        _$EffectsSupported$_: () => !0,
        _$OnSaveComplete$_: () => !0,
        _$OnSaveFailed$_: () => !0,
        _$OnLoadComplete$_: () => !0,
        _$OnLoadFailed$_: () => !0,
        _$ObjectUIDExists$_(t) {
            return !!this._$_runtime$_._$GetInstanceByUID$_(t);
        },
        _$IsOnPlatform$_(t) {
            switch (t) {
              case 0:
                return "browser" === cS._$Platform$_._$Context$_;

              case 1:
                return "iOS" === cS._$Platform$_._$OS$_;

              case 2:
                return "Android" === cS._$Platform$_._$OS$_;

              case 8:
                return "cordova" === cS._$Platform$_._$Context$_;

              case 9:
                return "scirra-arcade" === this._$_runtime$_._$GetExportType$_();

              case 10:
                return "nwjs" === cS._$Platform$_._$Context$_;

              case 13:
                return "windows-uwp" === this._$_runtime$_._$GetExportType$_();

              default:
                return !1;
            }
        },
        _$RegexTest$_(t, s, i) {
            return this._$GetRegex$_(s, i).test(t);
        },
        _$Compare$_: (t, s, i) => cS.compare(t, s, i),
        _$CompareBetween$_: (t, s, i) => t >= s && t <= i,
        _$CompareVar$_: (t, s, i) => cS.compare(t._$GetValue$_(), s, i),
        _$CompareBoolVar$_: t => !!t._$GetValue$_(),
        _$CompareTime$_(t, s) {
            const i = this._$_runtime$_._$GetGameTime$_();
            if (0 === t) {
                const t = this._$_runtime$_._$GetCurrentCondition$_()._$GetSavedDataMap$_();
                return !t.get("CompareTime_executed") && i >= s && (t.set("CompareTime_executed", !0), 
                !0);
            }
            return cS.compare(i, t, s);
        },
        _$IsNaN$_: t => isNaN(t),
        _$AngleWithin$_: (t, s, i) => cS._$angleDiff$_(cS._$toRadians$_(t), cS._$toRadians$_(i)) <= cS._$toRadians$_(s),
        _$IsClockwiseFrom$_: (t, s) => cS._$angleClockwise$_(cS._$toRadians$_(t), cS._$toRadians$_(s)),
        _$IsBetweenAngles$_(t, s, i) {
            let e = cS._$toRadians$_(t), n = cS._$toRadians$_(s), h = cS._$toRadians$_(i);
            return cS._$angleClockwise$_(h, n) ? cS._$angleClockwise$_(e, n) && !cS._$angleClockwise$_(e, h) : !(!cS._$angleClockwise$_(e, n) && cS._$angleClockwise$_(e, h));
        },
        _$IsValueType$_: (t, s) => "number" == typeof t ? 0 === s : 1 === s,
        _$EvaluateExpression$_: t => !!t,
        _$OnSignal$_(t) {
            return t.toLowerCase() === this._$_runtime$_._$GetEventSheetManager$_()._$GetCurrentSignalTag$_();
        },
        _$PickByComparison$_(t, s, i, e) {
            if (!t) return !1;
            const n = this._$_GetForEachStack$_(), h = n._$Push$_(), r = t._$GetCurrentSol$_();
            cS._$shallowAssignArray$_(h, r._$GetInstances$_()), r._$IsSelectAll$_() && cS._$clearArray$_(r._$_GetOwnElseInstances$_());
            const o = this._$_runtime$_._$GetCurrentCondition$_();
            let a = 0;
            for (let t = 0, n = h.length; t < n; ++t) {
                const n = h[t];
                h[a] = n, s = o._$ReevaluateParameter$_(1, t), e = o._$ReevaluateParameter$_(3, t), 
                cS.compare(s, i, e) ? ++a : r._$_PushElseInstance$_(n);
            }
            cS._$truncateArray$_(h, a), r._$SetArrayPicked$_(h);
            const u = !!h.length;
            return cS._$clearArray$_(h), n._$Pop$_(), t._$ApplySolToContainer$_(), u;
        },
        _$PickByEvaluate$_(t, s) {
            if (!t) return !1;
            const i = this._$_GetForEachStack$_(), e = i._$Push$_(), n = t._$GetCurrentSol$_();
            cS._$shallowAssignArray$_(e, n._$GetInstances$_()), n._$IsSelectAll$_() && cS._$clearArray$_(n._$_GetOwnElseInstances$_());
            const h = this._$_runtime$_._$GetCurrentCondition$_();
            let r = 0;
            for (let t = 0, s = e.length; t < s; ++t) {
                const s = e[t];
                e[r] = s, h._$ReevaluateParameter$_(1, t) ? ++r : n._$_PushElseInstance$_(s);
            }
            cS._$truncateArray$_(e, r), n._$SetArrayPicked$_(e);
            const o = !!e.length;
            return cS._$clearArray$_(e), i._$Pop$_(), t._$ApplySolToContainer$_(), o;
        },
        _$PickByHighestLowestValue$_(t, s, i) {
            if (!t) return !1;
            const e = t._$GetCurrentSol$_(), n = e._$GetInstances$_();
            if (0 === n.length) return !1;
            const h = this._$_runtime$_._$GetCurrentCondition$_();
            let r = null, o = 0;
            for (let t = 0, e = n.length; t < e; ++t) {
                const e = n[t];
                i = h._$ReevaluateParameter$_(2, t), (null === r || 0 === s && i < o || 1 === s && i > o) && (o = i, 
                r = e);
            }
            return e._$PickOne$_(r), t._$ApplySolToContainer$_(), !0;
        },
        _$PickNth$_(t, s) {
            if (!t) return !1;
            const i = t._$GetCurrentSol$_(), e = i._$GetInstances$_();
            if ((s = Math.floor(s)) >= e.length) return !1;
            const n = e[s];
            return i._$PickOne$_(n), t._$ApplySolToContainer$_(), !0;
        },
        _$PickRandom$_(t) {
            if (!t) return !1;
            const s = t._$GetCurrentSol$_(), i = s._$GetInstances$_(), e = Math.floor(this._$_runtime$_._$Random$_() * i.length);
            if (e >= i.length) return !1;
            const n = i[e];
            return s._$PickOne$_(n), t._$ApplySolToContainer$_(), !0;
        },
        _$PickAll$_: t => !!t && (!!t._$GetInstanceCount$_() && (t._$GetCurrentSol$_()._$_SetSelectAll$_(!0), 
        t._$ApplySolToContainer$_(), !0)),
        _$PickOverlappingPoint$_(t, s, i) {
            if (!t) return !1;
            const e = t._$GetCurrentSol$_(), n = e._$GetInstances$_(), h = this._$_runtime$_._$GetCurrentEvent$_()._$IsOrBlock$_(), r = this._$_runtime$_._$GetCurrentCondition$_()._$IsInverted$_();
            e._$IsSelectAll$_() ? (cS._$shallowAssignArray$_(fS, n), e._$ClearArrays$_(), e._$_SetSelectAll$_(!1)) : h ? (cS._$shallowAssignArray$_(fS, e._$_GetOwnElseInstances$_()), 
            cS._$clearArray$_(e._$_GetOwnElseInstances$_())) : (cS._$shallowAssignArray$_(fS, e._$_GetOwnInstances$_()), 
            cS._$clearArray$_(e._$_GetOwnInstances$_()));
            for (let t = 0, n = fS.length; t < n; ++t) {
                const n = fS[t];
                cS.xor(n._$GetWorldInfo$_()._$ContainsPoint$_(s, i), r) ? e._$_PushInstance$_(n) : e._$_PushElseInstance$_(n);
            }
            return t._$ApplySolToContainer$_(), cS.xor(!!e._$_GetOwnInstances$_().length, r);
        },
        _$PickLastCreated$_(t) {
            if (!t) return !1;
            const s = t._$IsFamily$_();
            let i = null;
            const e = this._$_runtime$_._$_GetInstancesPendingCreate$_();
            for (let n = e.length - 1; n >= 0; --n) {
                const h = e[n];
                if (s) {
                    if (h._$GetObjectClass$_()._$BelongsToFamily$_(t)) {
                        i = h;
                        break;
                    }
                } else if (h._$GetObjectClass$_() === t) {
                    i = h;
                    break;
                }
            }
            if (!i) {
                const s = t._$GetInstances$_();
                s.length && (i = s.at(-1));
            }
            return !!i && (t._$GetCurrentSol$_()._$PickOne$_(i), t._$ApplySolToContainer$_(), 
            !0);
        },
        _$Repeat$_(t) {
            return this._$_runtime$_._$IsDebugging$_() ? this._$_DebugRepeat$_(t) : this._$_Repeat$_(t);
        },
        _$While$_() {
            return this._$_runtime$_._$IsDebugging$_() ? this._$_DebugWhile$_() : this._$_While$_();
        },
        _$For$_(t, s, i) {
            return this._$_runtime$_._$IsDebugging$_() ? this._$_DebugFor$_(t, s, i) : this._$_For$_(t, s, i);
        },
        _$ForEach$_(t) {
            return this._$_runtime$_._$IsDebugging$_() ? this._$_DebugForEach$_(t) : this._$_ForEach$_(t);
        },
        _$ForEachOrdered$_(t, s, i) {
            return this._$_runtime$_._$IsDebugging$_() ? this._$_DebugForEachOrdered$_(t, i) : this._$_ForEachOrdered$_(t, i);
        },
        _$LayerVisible$_: t => !!t && t._$IsVisible$_(),
        _$LayerInteractive$_: t => !!t && t._$IsSelfAndParentsInteractive$_(),
        _$LayerIsHTML$_: t => !!t && t._$IsHTMLElementsLayer$_(),
        _$LayerEmpty$_: t => !!t && !t._$GetInstanceCount$_(),
        _$LayerCmpOpacity$_: (t, s, i) => !!t && cS.compare(100 * t._$GetOpacity$_(), s, i),
        _$LayerNameExists$_(t) {
            const s = this._$_runtime$_._$GetMainRunningLayout$_();
            return !!s && s._$HasLayerByName$_(t);
        },
        _$OnImageLoadingComplete$_: () => !0,
        _$IsLoadingImages$_() {
            return this._$_imagesLoadingTotal$_ > 0;
        },
        _$TemplateExists$_(t, s) {
            const i = this._$_runtime$_._$GetTemplateManager$_();
            return !!i && !!s && !!i._$GetTemplateData$_(t, s);
        }
    };
}

{
    let dS = function(t, s) {
        const i = t[0] - s[0];
        return 0 !== i ? i : t[1] - s[1];
    }, pS = function(t, s) {
        return t[1] - s[1];
    };
    0;
    const mS = self._$C3$_, gS = [], yS = [], MS = mS._$New$_(mS.Rect), wS = mS._$New$_(mS._$Color$_), SS = [];
    mS._$Plugins$_._$System$_._$Acts$_ = {
        _$SetVar$_(t, s) {
            t._$SetValue$_(s);
        },
        _$AddVar$_(t, s) {
            t._$IsNumber$_() && "number" != typeof s && (s = parseFloat(s)), t._$SetValue$_(t._$GetValue$_() + s);
        },
        _$SubVar$_(t, s) {
            t._$IsNumber$_() && t._$SetValue$_(t._$GetValue$_() - s);
        },
        _$SetBoolVar$_(t, s) {
            t._$SetValue$_(!!s);
        },
        _$ToggleBoolVar$_(t) {
            t._$SetValue$_(!t._$GetValue$_());
        },
        _$ResetEventVar$_(t) {
            t._$SetValue$_(t._$GetInitialValue$_());
        },
        _$ResetGlobals$_(t) {
            this._$_runtime$_._$GetEventSheetManager$_()._$ResetAllGlobalsToInitialValue$_(t);
        },
        _$CreateObject$_(t, s, i, e, n, h) {
            if (!t || !s) return;
            const r = this._$_runtime$_._$CreateInstance$_(t, s, i, e, n, h);
            if (!r) return;
            n && s._$SortAndAddInstancesByZIndex$_(r);
            const o = this._$_runtime$_._$GetEventSheetManager$_();
            o._$BlockFlushingInstances$_(!0), r._$_TriggerOnCreatedOnSelfAndRelated$_(), o._$BlockFlushingInstances$_(!1);
            const a = new Map;
            r._$CollectInstancesToPick$_(a, t, n);
            for (const [t, s] of a) t._$GetCurrentSol$_()._$SetSetPicked$_(s);
        },
        _$CreateObjectByName$_(t, s, i, e, n, h) {
            if (!t || !s) return;
            const r = this._$_runtime$_._$GetObjectClassByName$_(t);
            r && mS._$Plugins$_._$System$_._$Acts$_._$CreateObject$_.call(this, r, s, i, e, n, h);
        },
        _$RecreateInitialObjects$_(t, s, i, e, n, h, r, o, a, u, l) {
            if (!t) return;
            const c = this._$_runtime$_._$GetCurrentLayout$_();
            let f = c;
            if (h) {
                const t = this._$_runtime$_._$GetLayoutManager$_()._$GetLayoutByName$_(h);
                if (!t) return;
                f = t;
            }
            let d = null;
            if (("number" != typeof r || r >= 0) && (d = f._$GetLayer$_(r), !d)) return;
            let p = null;
            if (("number" != typeof o || o >= 0) && (p = c._$GetLayer$_(o), !p)) return;
            MS.set(s, i, e, n);
            const m = f._$RecreateInitialObjects$_(t, MS, d, p, a, u, l);
            t._$GetCurrentSol$_()._$SetArrayPicked$_(m), t._$ApplySolToContainer$_();
        },
        _$StopLoop$_() {
            const t = this._$_loopStack$_;
            t._$IsInLoop$_() && t._$GetCurrent$_()._$Stop$_();
        },
        _$SetGroupActive$_(t, s) {
            const i = this._$_runtime$_._$GetEventSheetManager$_()._$GetEventGroupByName$_(t);
            i && (0 === s ? i._$SetGroupActive$_(!1) : 1 === s ? i._$SetGroupActive$_(!0) : i._$SetGroupActive$_(!i._$IsGroupActive$_()));
        },
        _$SetTimescale$_(t) {
            this._$_runtime$_._$SetTimeScale$_(t);
        },
        _$SetObjectTimescale$_(t, s) {
            if (s < 0 && (s = 0), !t) return;
            const i = t._$GetCurrentSol$_()._$GetInstances$_();
            for (const t of i) t._$SetTimeScale$_(s);
        },
        _$RestoreObjectTimescale$_(t) {
            if (!t) return;
            const s = t._$GetCurrentSol$_()._$GetInstances$_();
            for (const t of s) t._$RestoreTimeScale$_();
        },
        _$Wait$_(t, s) {
            if (t < 0) return;
            const i = this._$_runtime$_._$GetEventSheetManager$_()._$AddScheduledWait$_();
            return s ? i._$InitTimer$_(t) : i._$InitWallTimer$_(t), !0;
        },
        _$WaitForSignal$_(t) {
            return this._$_runtime$_._$GetEventSheetManager$_()._$AddScheduledWait$_()._$InitSignal$_(t), 
            !0;
        },
        _$WaitForPreviousActions$_() {
            const t = this._$_runtime$_._$GetEventSheetManager$_();
            return t._$AddScheduledWait$_()._$InitPromise$_(t._$GetPromiseForAllAsyncActions$_()), 
            !0;
        },
        _$Signal$_(t) {
            this._$_runtime$_._$GetEventSheetManager$_()._$Signal$_(t);
        },
        async _$SnapshotCanvas$_(t, s, i, e, n, h) {
            const r = this._$_runtime$_._$GetCanvasManager$_();
            r && (this._$UpdateRender$_(), await r._$SnapshotCanvas$_(0 === t ? "image/png" : "image/jpeg", s / 100, i, e, n, h), 
            await this._$_runtime$_._$TriggerAsync$_(mS._$Plugins$_._$System$_._$Cnds$_._$OnCanvasSnapshot$_, null));
        },
        _$SetCanvasSize$_(t, s) {
            if (t <= 0 || s <= 0) return;
            this._$_runtime$_._$SetViewportSize$_(t, s), this._$_runtime$_._$GetCurrentLayout$_()._$BoundScrolling$_();
            const i = this._$_runtime$_._$GetCanvasManager$_();
            i && ("off" === i._$GetCurrentFullscreenMode$_() || this._$_runtime$_._$SetOriginalViewportSize$_(t, s), 
            i._$SetSize$_(i._$GetLastWidth$_(), i._$GetLastHeight$_(), !0), this._$_runtime$_._$UpdateRender$_());
        },
        _$SetFullscreenQuality$_(t) {
            const s = this._$_runtime$_._$GetCanvasManager$_();
            s && "off" !== s._$GetCurrentFullscreenMode$_() && (s._$SetFullscreenScalingQuality$_(0 !== t ? "high" : "low"), 
            s._$SetSize$_(s._$GetLastWidth$_(), s._$GetLastHeight$_(), !0));
        },
        _$SaveState$_(t) {
            this._$_runtime$_._$SaveToSlot$_(t);
        },
        _$SaveStateJSON$_() {
            this._$_runtime$_._$SaveToJsonString$_();
        },
        _$LoadState$_(t) {
            this._$_runtime$_._$LoadFromSlot$_(t);
        },
        _$LoadStateJSON$_(t) {
            this._$_runtime$_._$LoadFromJsonString$_(t);
        },
        _$SetHalfFramerateMode$_(t) {},
        _$ResetPersisted$_() {
            for (const t of this._$_runtime$_._$GetLayoutManager$_()._$GetAllLayouts$_()) t._$ResetPersistData$_();
        },
        _$SetPixelRounding$_(t) {
            this._$_runtime$_._$SetPixelRoundingEnabled$_(0 !== t);
        },
        _$SetFramerateMinMax$_(t, s) {
            this._$_runtime$_._$SetMaxDt$_(1 / t), this._$_runtime$_._$SetMinDt$_(1 / s);
        },
        _$SetDeltaTimeMinMax$_(t, s) {
            this._$_runtime$_._$SetMinDt$_(t), this._$_runtime$_._$SetMaxDt$_(s);
        },
        _$SetFramerateMode$_(t) {
            this._$_runtime$_._$_SetFramerateMode$_([ "vsync", "unlimited-tick", "unlimited-frame" ][t]);
        },
        _$SortZOrderByInstVar$_(t, s) {
            if (!t) return;
            const i = t._$GetCurrentSol$_()._$GetInstances$_(), e = gS, n = yS, h = this._$_runtime$_._$GetCurrentLayout$_(), r = t._$IsFamily$_(), o = t._$GetFamilyIndex$_();
            for (let t = 0, h = i.length; t < h; ++t) {
                const h = i[t], a = h._$GetWorldInfo$_();
                if (!a) continue;
                let u;
                u = r ? h._$GetInstanceVariableValue$_(s + h._$GetObjectClass$_()._$GetFamilyInstanceVariableOffset$_(o)) : h._$GetInstanceVariableValue$_(s), 
                e.push([ a._$GetLayer$_()._$GetIndex$_(), a._$GetZIndex$_() ]), n.push([ h, u ]);
            }
            if (!e.length) return;
            e.sort(dS), n.sort(pS);
            let a = !1;
            for (let t = 0, s = e.length; t < s; ++t) {
                const s = n[t][0], i = h._$GetLayerByIndex$_(e[t][0]), r = e[t][1], o = i._$_GetInstances$_();
                o[r] !== s && (o[r] = s, s._$GetWorldInfo$_()._$_SetLayer$_(i, !0), i._$SetZIndicesChanged$_(s), 
                a = !0);
            }
            a && this._$_runtime$_._$UpdateRender$_(), mS._$clearArray$_(gS), mS._$clearArray$_(yS);
        },
        _$SetCollisionCellSize$_(t, s) {
            t = Math.floor(t), s = Math.floor(s), t <= 0 || s <= 0 || !Number.isFinite(t) || !Number.isFinite(s) || this._$_runtime$_._$GetCollisionEngine$_()._$SetCollisionCellSize$_(t, s);
        },
        _$GoToLayout$_(t) {
            if (this._$_runtime$_._$IsLoading$_()) return;
            const s = this._$_runtime$_._$GetLayoutManager$_();
            s._$IsPendingChangeMainLayout$_() || s._$ChangeMainLayout$_(t);
        },
        _$GoToLayoutByName$_(t) {
            if (this._$_runtime$_._$IsLoading$_()) return;
            const s = this._$_runtime$_._$GetLayoutManager$_();
            if (s._$IsPendingChangeMainLayout$_()) return;
            const i = s._$GetLayoutByName$_(t);
            i && s._$ChangeMainLayout$_(i);
        },
        _$NextPrevLayout$_(t) {
            if (this._$_runtime$_._$IsLoading$_()) return;
            const s = this._$_runtime$_._$GetLayoutManager$_();
            if (s._$IsPendingChangeMainLayout$_()) return;
            const i = s._$GetAllLayouts$_(), e = i.indexOf(s._$GetMainRunningLayout$_());
            if (t && 0 === e) return;
            if (!t && e === i.length - 1) return;
            const n = i[e + (t ? -1 : 1)];
            s._$ChangeMainLayout$_(n);
        },
        _$RestartLayout$_() {
            if (this._$_runtime$_._$IsLoading$_()) return;
            const t = this._$_runtime$_._$GetLayoutManager$_();
            t._$IsPendingChangeMainLayout$_() || (t._$ChangeMainLayout$_(t._$GetMainRunningLayout$_()), 
            this._$_runtime$_._$GetEventSheetManager$_()._$ResetAllGroupsInitialActivation$_());
        },
        _$SetLayerVisible$_(t, s) {
            t && t._$SetVisible$_(s);
        },
        _$SetLayerInteractive$_(t, s) {
            t && t._$SetInteractive$_(s);
        },
        _$SetLayerHTML$_(t, s) {
            t && t._$SetIsHTMLElementsLayer$_(s);
        },
        _$SetLayerOpacity$_(t, s) {
            t && t._$SetOpacity$_(s / 100);
        },
        _$SetLayerScale$_(t, s) {
            t && t._$SetOwnScale$_(s);
        },
        _$SetLayerScaleRate$_(t, s) {
            t && t._$SetScaleRate$_(s);
        },
        _$SetLayerAngle$_(t, s) {
            t && t._$SetAngle$_(mS._$toRadians$_(+s));
        },
        _$SetLayerScroll$_(t, s, i) {
            t && (t._$SetOwnScrollPositionEnabled$_(!0), t._$SetScrollX$_(s), t._$SetScrollY$_(i));
        },
        _$RestoreLayerScroll$_(t) {
            t && t._$SetOwnScrollPositionEnabled$_(!1);
        },
        _$SetLayerParallax$_(t, s, i) {
            t && t._$SetParallax$_(s / 100, i / 100);
        },
        _$SetLayerZElevation$_(t, s) {
            t && t._$SetZElevation$_(+s);
        },
        _$SetLayerRenderingMode$_(t, s) {
            t && t._$SetRenderAs3D$_(1 === s);
        },
        _$SetLayerBackground$_(t, s) {
            if (!t) return;
            wS._$setFromRgbValue$_(s), wS._$clamp$_();
            const i = t._$GetBackgroundColor$_();
            i._$equalsIgnoringAlpha$_(wS) || (i._$copyRgb$_(wS), this._$UpdateRender$_());
        },
        _$SetLayerTransparent$_(t, s) {
            t && t._$SetTransparent$_(s);
        },
        _$SetLayerBlendMode$_(t, s) {
            t && t._$SetBlendMode$_(s);
        },
        _$SetLayerEffectEnabled$_(t, s, i) {
            if (!t) return;
            const e = t._$GetEffectList$_()._$GetEffectTypeByName$_(i);
            if (!e) return;
            const n = 1 === s;
            e._$IsActive$_() !== n && (e._$SetActive$_(n), t._$UpdateActiveEffects$_(), this._$_runtime$_._$UpdateRender$_());
        },
        _$SetLayerEffectParam$_(t, s, i, e) {
            if (!t) return;
            const n = t._$GetEffectList$_(), h = n._$GetEffectTypeByName$_(s);
            if (!h) return;
            i = Math.floor(i);
            const r = h._$GetShaderProgram$_()._$GetParameterType$_(i);
            r && ("color" === r ? (wS._$setFromRgbValue$_(e), e = wS) : "percent" === r && (e /= 100), 
            n._$SetEffectParameter$_(h._$GetIndex$_(), i, e) && h._$IsActive$_() && this._$_runtime$_._$UpdateRender$_());
        },
        _$SetLayerForceOwnTexture$_(t, s) {
            t && t._$SetForceOwnTexture$_(s);
        },
        _$SetLayoutScale$_(t) {
            this._$_runtime$_._$GetCurrentLayout$_()._$SetScale$_(+t);
        },
        _$SetLayoutAngle$_(t) {
            this._$_runtime$_._$GetCurrentLayout$_()._$SetAngle$_(mS._$toRadians$_(+t));
        },
        _$SetLayoutEffectEnabled$_(t, s) {
            const i = this._$_runtime$_._$GetCurrentLayout$_(), e = i._$GetEffectList$_()._$GetEffectTypeByName$_(s);
            if (!e) return;
            const n = 1 === t;
            e._$IsActive$_() !== n && (e._$SetActive$_(n), i._$UpdateActiveEffects$_(), this._$_runtime$_._$UpdateRender$_());
        },
        _$SetLayoutEffectParam$_(t, s, i) {
            const e = this._$_runtime$_._$GetCurrentLayout$_()._$GetEffectList$_(), n = e._$GetEffectTypeByName$_(t);
            if (!n) return;
            s = Math.floor(s);
            const h = n._$GetShaderProgram$_()._$GetParameterType$_(s);
            h && ("color" === h ? (wS._$setFromRgbValue$_(i), i = wS) : "percent" === h && (i /= 100), 
            e._$SetEffectParameter$_(n._$GetIndex$_(), s, i) && n._$IsActive$_() && this._$_runtime$_._$UpdateRender$_());
        },
        _$SetLayoutVanishingPoint$_(t, s) {
            this._$_runtime$_._$GetCurrentLayout$_()._$SetVanishingPointXY$_(t / 100, s / 100);
        },
        _$SetLayoutProjection$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_();
            0 === t ? s._$SetPerspectiveProjection$_() : s._$SetOrthographicProjection$_();
        },
        _$ScrollX$_(t) {
            this._$_runtime$_._$GetCurrentLayout$_()._$SetScrollX$_(t);
        },
        _$ScrollY$_(t) {
            this._$_runtime$_._$GetCurrentLayout$_()._$SetScrollY$_(t);
        },
        _$Scroll$_(t, s) {
            const i = this._$_runtime$_._$GetCurrentLayout$_();
            i._$SetScrollX$_(t), i._$SetScrollY$_(s);
        },
        _$ScrollToObject$_(t) {
            if (!t) return;
            const s = t._$GetFirstPicked$_();
            if (!s) return;
            const i = s._$GetWorldInfo$_();
            if (!i) return;
            const e = this._$_runtime$_._$GetCurrentLayout$_();
            e._$SetScrollX$_(i._$GetX$_()), e._$SetScrollY$_(i._$GetY$_());
        },
        _$AddLayer$_(t, s, i) {
            const e = this._$_runtime$_._$GetCurrentLayout$_();
            try {
                e._$AddLayer$_(t, s, i);
            } catch (t) {
                console.warn("[Construct] Cannot add layer: ", t);
            }
        },
        _$MoveLayer$_(t, s, i) {
            if (!t) return;
            const e = this._$_runtime$_._$GetCurrentLayout$_();
            try {
                e._$MoveLayer$_(t, s, i);
            } catch (t) {
                console.warn("[Construct] Cannot move layer: ", t);
            }
        },
        _$RemoveLayer$_(t) {
            t && this._$_runtime$_._$GetCurrentLayout$_()._$RemoveLayer$_(t);
        },
        _$RemoveAllDynamicLayers$_() {
            this._$_runtime$_._$GetCurrentLayout$_()._$RemoveAllDynamicLayers$_();
        },
        async _$LoadObjectTextures$_(t) {
            const s = this._$_runtime$_._$GetMainRunningLayout$_();
            if (!s || !t || this._$_runtime$_._$IsLoading$_()) return;
            const i = t._$IsFamily$_() ? t._$GetFamilyMembers$_() : [ t ];
            await this._$_LoadTexturesForObjectClasses$_(s, i);
        },
        async _$LoadObjectTexturesByName$_(t) {
            await mS._$Plugins$_._$System$_._$Acts$_._$LoadObjectTextures$_.call(this, this._$_runtime$_._$GetObjectClassByName$_(t));
        },
        _$UnloadObjectTextures$_(t) {
            const s = this._$_runtime$_._$GetMainRunningLayout$_();
            if (!s || !t) return;
            const i = t._$IsFamily$_() ? t._$GetFamilyMembers$_() : [ t ];
            this._$_UnloadTexturesForObjectClasses$_(s, i);
        },
        _$UnloadObjectTexturesByName$_(t) {
            mS._$Plugins$_._$System$_._$Acts$_._$UnloadObjectTextures$_.call(this, this._$_runtime$_._$GetObjectClassByName$_(t));
        },
        _$UnloadUnusedTextures$_() {
            const t = this._$_runtime$_._$GetMainRunningLayout$_();
            if (!t) return;
            const s = t._$_GetTextureLoadedObjectTypes$_();
            this._$_UnloadTexturesForObjectClasses$_(t, s);
        },
        async _$LoadLayoutTextures$_(t) {
            const s = this._$_runtime$_._$GetMainRunningLayout$_();
            t && s && !this._$_runtime$_._$IsLoading$_() && await this._$_LoadTexturesForObjectClasses$_(s, t._$_GetInitialObjectClasses$_());
        },
        async _$LoadLayoutTexturesByName$_(t) {
            const s = this._$_runtime$_._$GetMainRunningLayout$_(), i = this._$_runtime$_._$GetLayoutManager$_()._$GetLayoutByName$_(t);
            i && s && !this._$_runtime$_._$IsLoading$_() && await this._$_LoadTexturesForObjectClasses$_(s, i._$_GetInitialObjectClasses$_());
        },
        _$SetFunctionReturnValue$_(t) {
            const s = this._$_eventStack$_._$GetCurrentExpFuncStackFrame$_();
            if (s) switch (s._$GetFunctionReturnType$_()) {
              case 1:
                "number" == typeof t && s._$SetFunctionReturnValue$_(t);
                break;

              case 2:
                "string" == typeof t && s._$SetFunctionReturnValue$_(t);
                break;

              case 3:
                s._$SetFunctionReturnValue$_(t);
            }
        },
        _$MapFunction$_(t, s, i) {
            const e = this._$_GetFunctionMap$_(t.toLowerCase(), !0), n = e._$strMap$_, h = s.toLowerCase();
            n.has(h) && console.warn(`[Construct] Function map '${t}' string '${s}' already in map; overwriting entry`);
            const r = mS._$first$_(n.values()) || e._$defaultFunc$_;
            r && 0 !== r._$GetReturnType$_() != (0 !== i._$GetReturnType$_()) ? console.error(`[Construct] Function map '${t}' string '${s}' function return type not compatible with other functions in the map; entry ignored`) : n.set(h, i);
        },
        _$MapFunctionDefault$_(t, s) {
            const i = this._$_GetFunctionMap$_(t.toLowerCase(), !0);
            i._$defaultFunc$_ && console.warn(`[Construct] Function map '${t}' already has a default; overwriting entry`);
            const e = mS._$first$_(i._$strMap$_.values()) || i._$defaultFunc$_;
            e && 0 !== e._$GetReturnType$_() != (0 !== s._$GetReturnType$_()) ? console.error(`[Construct] Function map '${t}' default: function return type not compatible with other functions in the map; entry ignored`) : i._$defaultFunc$_ = s;
        },
        _$CallMappedFunction$_(t, s, i) {
            const e = this._$_runtime$_, n = e._$IsDebugging$_() ? SS : null;
            i = Math.floor(i);
            const h = this._$_GetFunctionMap$_(t.toLowerCase(), !1);
            if (!h) return console.warn(`[Construct] Call mapped function: map name '${t}' not found; call ignored`), 
            n;
            let r = h._$strMap$_.get(s.toLowerCase());
            if (!r) {
                if (!h._$defaultFunc$_) return console.warn(`[Construct] Call mapped function: no function associated with map '${t}' string '${s}'; call ignored (consider setting a default)`), 
                n;
                r = h._$defaultFunc$_, i = 0;
            }
            if (!r._$IsEnabled$_()) return n;
            if (0 !== r._$GetReturnType$_()) return console.warn(`[Construct] Call mapped function: map '${t}' string '${s}' has a return type so cannot be called`), 
            n;
            const o = e._$GetEventSheetManager$_(), a = o._$GetCurrentEvent$_(), u = a._$GetSolModifiersIncludingParents$_(), l = u.length > 0;
            l && (r._$IsCopyPicked$_() ? o._$PushCopySol$_(u) : o._$PushCleanSol$_(u));
            const c = [], f = o._$FindFirstFunctionBlockParent$_(a);
            if (f) {
                const t = f._$GetFunctionParameters$_();
                for (let s = i, e = t.length; s < e; ++s) c.push(t[s]._$GetValue$_());
            }
            const d = r._$GetFunctionParameters$_();
            for (let t = c.length, s = d.length; t < s; ++t) c.push(d[t]._$GetInitialValue$_());
            return e._$IsDebugging$_() ? this._$_DebugDoCallMappedFunction$_(o, r, c, l, u) : this._$_DoCallMappedFunction$_(o, r, c, l, u);
        }
    };
}

{
    const bS = self._$C3$_;
    bS._$Plugins$_._$System$_._$Exps$_ = {
        _$int$_: function(t) {
            return "string" == typeof t && (t = parseInt(t, 10), isNaN(t) && (t = 0)), Math.floor(t);
        },
        float: function(t) {
            return "string" == typeof t && (t = parseFloat(t), isNaN(t) && (t = 0)), t;
        },
        _$str$_: t => t.toString(),
        _$len$_: t => "string" == typeof t ? t.length : 0,
        random(t, s) {
            return void 0 === s ? this._$_runtime$_._$Random$_() * t : this._$_runtime$_._$Random$_() * (s - t) + t;
        },
        _$choose$_(...t) {
            return t[Math.floor(this._$_runtime$_._$Random$_() * t.length)];
        },
        _$chooseindex$_: (t, ...s) => ("number" != typeof t && (t = 0), s[t = bS._$clamp$_(Math.floor(t), 0, s.length - 1)]),
        _$pi$_: () => Math.PI,
        _$infinity$_: () => 1 / 0,
        sqrt: t => Math.sqrt(t),
        abs: t => Math.abs(t),
        round: t => Math.round(t),
        _$roundtodp$_(t, s) {
            s = Math.max(Math.floor(s), 0);
            const i = Math.pow(10, s);
            return Math.round((t + Number.EPSILON) * i) / i;
        },
        floor: t => Math.floor(t),
        ceil: t => Math.ceil(t),
        sign: t => Math.sign(t),
        sin: t => Math.sin(bS._$toRadians$_(t)),
        cos: t => Math.cos(bS._$toRadians$_(t)),
        tan: t => Math.tan(bS._$toRadians$_(t)),
        asin: t => bS._$toDegrees$_(Math.asin(t)),
        acos: t => bS._$toDegrees$_(Math.acos(t)),
        atan: t => bS._$toDegrees$_(Math.atan(t)),
        exp: t => Math.exp(t),
        _$ln$_: t => Math.log(t),
        log10: t => Math.log10(t),
        max(...t) {
            let s = t[0];
            "number" != typeof s && (s = 0);
            for (let i = 1, e = t.length; i < e; ++i) {
                let e = t[i];
                "number" == typeof e && s < e && (s = e);
            }
            return s;
        },
        min(...t) {
            let s = t[0];
            "number" != typeof s && (s = 0);
            for (let i = 1, e = t.length; i < e; ++i) {
                let e = t[i];
                "number" == typeof e && s > e && (s = e);
            }
            return s;
        },
        _$clamp$_: (t, s, i) => bS._$clamp$_(t, s, i),
        _$distance$_: (t, s, i, e) => bS._$distanceTo$_(t, s, i, e),
        angle: (t, s, i, e) => bS._$toDegrees$_(bS._$angleTo$_(t, s, i, e)),
        _$lerp$_: (t, s, i) => bS._$lerp$_(t, s, i),
        _$unlerp$_: (t, s, i) => bS._$unlerp$_(t, s, i),
        _$qarp$_: (t, s, i, e) => bS._$qarp$_(t, s, i, e),
        _$cubic$_: (t, s, i, e, n) => bS._$cubic$_(t, s, i, e, n),
        _$cosp$_: (t, s, i) => bS._$cosp$_(t, s, i),
        _$anglediff$_: (t, s) => bS._$toDegrees$_(bS._$angleDiff$_(bS._$toRadians$_(t), bS._$toRadians$_(s))),
        _$anglelerp$_: (t, s, i) => bS._$toDegrees$_(bS._$angleLerp$_(bS._$toRadians$_(t), bS._$toRadians$_(s), i)),
        _$anglerotate$_: (t, s, i) => bS._$toDegrees$_(bS._$angleRotate$_(bS._$toRadians$_(t), bS._$toRadians$_(s), bS._$toRadians$_(i))),
        _$setbit$_: (t, s, i) => (t |= 0) & ~(1 << (s |= 0)) | (i = 0 !== i ? 1 : 0) << s,
        _$togglebit$_: (t, s) => (t |= 0) ^ 1 << s,
        _$getbit$_: (t, s) => (t |= 0) & 1 << (s |= 0) ? 1 : 0,
        _$newline$_: () => "\n",
        _$uppercase$_: t => "string" == typeof t ? t.toUpperCase() : "",
        _$lowercase$_: t => "string" == typeof t ? t.toLowerCase() : "",
        left: (t, s) => "string" == typeof t ? t.substr(0, s) : "",
        mid: (t, s, i) => "string" != typeof t ? "" : i < 0 ? t.substr(s) : t.substr(s, i),
        right: (t, s) => "string" == typeof t ? t.substr(Math.max(t.length - s, 0)) : "",
        trim: t => "string" == typeof t ? t.trim() : "",
        _$tokenat$_(t, s, i) {
            if ("string" != typeof t || "string" != typeof i) return "";
            let e = t.split(i);
            return (s = Math.floor(s)) < 0 || s >= e.length ? "" : e[s];
        },
        _$tokencount$_: (t, s) => "string" == typeof t && "string" == typeof s && t.length ? t.split(s).length : 0,
        find: (t, s) => "string" == typeof t && "string" == typeof s ? t.search(new RegExp(bS._$EscapeRegex$_(s), "i")) : -1,
        _$findcase$_: (t, s) => "string" == typeof t && "string" == typeof s ? t.search(new RegExp(bS._$EscapeRegex$_(s), "")) : -1,
        replace: (t, s, i) => "string" == typeof t && "string" == typeof s && "string" == typeof i ? t.replace(new RegExp(bS._$EscapeRegex$_(s), "gi"), i) : "string" == typeof t ? t : "",
        _$stringsub$_(t, ...s) {
            let i = t;
            for (let t = 0, e = s.length; t < e; ++t) i = i.replaceAll(`{${t}}`, s[t].toString());
            return i;
        },
        _$regexsearch$_(t, s, i) {
            const e = this._$GetRegex$_(s, i);
            return t ? t.search(e) : -1;
        },
        _$regexreplace$_(t, s, i, e) {
            const n = this._$GetRegex$_(s, i);
            return t ? t.replace(n, e) : "";
        },
        _$regexmatchcount$_(t, s, i) {
            const e = this._$GetRegexMatches$_(t.toString(), s, i);
            return e ? e.length : 0;
        },
        _$regexmatchat$_(t, s, i, e) {
            e = Math.floor(e);
            const n = this._$GetRegexMatches$_(t.toString(), s, i);
            return !n || e < 0 || e >= n.length ? "" : n[e];
        },
        _$zeropad$_(t, s) {
            let i = t < 0 ? "-" : "";
            t < 0 && (t = -t);
            const e = s - t.toString().length;
            return i += "0".repeat(Math.max(e, 0)), i + t.toString();
        },
        _$urlencode$_: t => encodeURIComponent(t),
        _$urldecode$_: t => decodeURIComponent(t),
        _$dt$_() {
            return this._$_runtime$_._$_GetDtFast$_();
        },
        _$wallclockdt$_() {
            return this._$_runtime$_._$GetDt1$_();
        },
        _$timescale$_() {
            return this._$_runtime$_._$GetTimeScale$_();
        },
        _$wallclocktime$_() {
            return (Date.now() - this._$_runtime$_._$GetStartTime$_()) / 1e3;
        },
        _$unixtime$_: () => Date.now(),
        time() {
            return this._$_runtime$_._$GetGameTime$_();
        },
        _$tickcount$_() {
            return this._$_runtime$_._$GetTickCount$_();
        },
        _$objectcount$_() {
            return this._$_runtime$_._$GetObjectCount$_();
        },
        _$fps$_() {
            return this._$_runtime$_._$GetFramesPerSecond$_();
        },
        _$cpuutilisation$_() {
            return this._$_runtime$_._$GetMainThreadTime$_();
        },
        _$gpuutilisation$_() {
            return this._$_runtime$_._$GetGPUUtilisation$_();
        },
        _$windowwidth$_() {
            return this._$_runtime$_._$GetCanvasManager$_()._$GetDeviceWidth$_();
        },
        _$windowheight$_() {
            return this._$_runtime$_._$GetCanvasManager$_()._$GetDeviceHeight$_();
        },
        _$originalwindowwidth$_() {
            return this._$_runtime$_._$GetOriginalViewportWidth$_();
        },
        _$originalwindowheight$_() {
            return this._$_runtime$_._$GetOriginalViewportHeight$_();
        },
        _$originalviewportwidth$_() {
            return this._$_runtime$_._$GetOriginalViewportWidth$_();
        },
        _$originalviewportheight$_() {
            return this._$_runtime$_._$GetOriginalViewportHeight$_();
        },
        _$scrollx$_() {
            return this._$_runtime$_._$GetCurrentLayout$_()._$GetScrollX$_();
        },
        _$scrolly$_() {
            return this._$_runtime$_._$GetCurrentLayout$_()._$GetScrollY$_();
        },
        _$layoutname$_() {
            return this._$_runtime$_._$GetCurrentLayout$_()._$GetName$_();
        },
        _$layoutscale$_() {
            return this._$_runtime$_._$GetCurrentLayout$_()._$GetScale$_();
        },
        _$layoutangle$_() {
            return bS._$toDegrees$_(this._$_runtime$_._$GetCurrentLayout$_()._$GetAngle$_());
        },
        _$layoutwidth$_() {
            return this._$_runtime$_._$GetCurrentLayout$_()._$GetWidth$_();
        },
        _$layoutheight$_() {
            return this._$_runtime$_._$GetCurrentLayout$_()._$GetHeight$_();
        },
        _$vanishingpointx$_() {
            return 100 * this._$_runtime$_._$GetCurrentLayout$_()._$GetVanishingPointX$_();
        },
        _$vanishingpointy$_() {
            return 100 * this._$_runtime$_._$GetCurrentLayout$_()._$GetVanishingPointY$_();
        },
        _$viewportleft$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return s ? s._$GetViewport3D$_()._$getLeft$_() : 0;
        },
        _$viewporttop$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return s ? s._$GetViewport3D$_()._$getTop$_() : 0;
        },
        _$viewportright$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return s ? s._$GetViewport3D$_()._$getRight$_() : 0;
        },
        _$viewportbottom$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return s ? s._$GetViewport3D$_()._$getBottom$_() : 0;
        },
        _$viewportwidth$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return s ? s._$GetViewport3D$_().width() : 0;
        },
        _$viewportheight$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return s ? s._$GetViewport3D$_().height() : 0;
        },
        _$viewportmidx$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            if (s) {
                const t = s._$GetViewport3D$_();
                return (t._$getLeft$_() + t._$getRight$_()) / 2;
            }
            return 0;
        },
        _$viewportmidy$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            if (s) {
                const t = s._$GetViewport3D$_();
                return (t._$getTop$_() + t._$getBottom$_()) / 2;
            }
            return 0;
        },
        _$canvastolayerx$_(t, s, i) {
            const e = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return e ? e._$CanvasCssToLayer$_(s, i)[0] : 0;
        },
        _$canvastolayery$_(t, s, i) {
            const e = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return e ? e._$CanvasCssToLayer$_(s, i)[1] : 0;
        },
        _$layertocanvasx$_(t, s, i) {
            const e = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return e ? e._$LayerToCanvasCss$_(s, i)[0] : 0;
        },
        _$layertocanvasy$_(t, s, i) {
            const e = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return e ? e._$LayerToCanvasCss$_(s, i)[1] : 0;
        },
        _$layertolayerx$_(t, s, i, e) {
            const n = this._$_runtime$_._$GetCurrentLayout$_(), h = n._$GetLayer$_(t), r = n._$GetLayer$_(s);
            if (!h || !r || h === r) return i;
            const [o, a] = h._$LayerToCanvasCss$_(i, e);
            return r._$CanvasCssToLayer$_(o, a)[0];
        },
        _$layertolayery$_(t, s, i, e) {
            const n = this._$_runtime$_._$GetCurrentLayout$_(), h = n._$GetLayer$_(t), r = n._$GetLayer$_(s);
            if (!h || !r || h === r) return e;
            const [o, a] = h._$LayerToCanvasCss$_(i, e);
            return r._$CanvasCssToLayer$_(o, a)[1];
        },
        _$layerscale$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return s ? s._$GetOwnScale$_() : 0;
        },
        _$layerangle$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return s ? bS._$toDegrees$_(s._$GetOwnAngle$_()) : 0;
        },
        _$layeropacity$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return s ? 100 * s._$GetOpacity$_() : 0;
        },
        _$layerscalerate$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return s ? s._$GetScaleRate$_() : 0;
        },
        _$layerscrollx$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return s ? s._$GetScrollX$_() : 0;
        },
        _$layerscrolly$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return s ? s._$GetScrollY$_() : 0;
        },
        _$layerparallaxx$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return s ? 100 * s._$GetParallaxX$_() : 0;
        },
        _$layerparallaxy$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return s ? 100 * s._$GetParallaxY$_() : 0;
        },
        _$layerzelevation$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return s ? s._$GetZElevation$_() : 0;
        },
        _$layerindex$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return s ? s._$GetIndex$_() : -1;
        },
        _$canvassnapshot$_() {
            const t = this._$_runtime$_._$GetCanvasManager$_();
            return t ? t._$GetCanvasSnapshotUrl$_() : "";
        },
        _$loopindex$_(t) {
            const s = this._$_loopStack$_;
            if (!s._$IsInLoop$_()) return 0;
            if (t) {
                const i = s._$FindByName$_(t);
                return i ? i._$GetIndex$_() : 0;
            }
            return s._$GetCurrent$_()._$GetIndex$_();
        },
        _$savestatejson$_() {
            return this._$_runtime$_._$GetLastSaveJsonString$_();
        },
        _$callmapped$_(t, s, ...i) {
            const e = this._$_GetFunctionMap$_(t.toLowerCase(), !1);
            if (!e) return console.warn(`[Construct] Call mapped function: map name '${t}' not found; returning 0`), 
            0;
            let n = e._$strMap$_.get(s.toLowerCase());
            if (!n) {
                if (!e._$defaultFunc$_) return console.warn(`[Construct] Call mapped function: no function associated with map '${t}' string '${s}'; returning 0 (consider setting a default)`), 
                0;
                n = e._$defaultFunc$_;
            }
            const h = n._$GetReturnType$_(), r = n._$GetDefaultReturnValue$_();
            if (0 === h) return console.warn(`[Construct] Call mapped function: map '${t}' string '${s}' has no return type so cannot be called from an expression; returning 0`), 
            0;
            if (!n._$IsEnabled$_()) return r;
            const o = this._$_runtime$_._$GetEventSheetManager$_(), a = o._$GetCurrentEvent$_()._$GetSolModifiersIncludingParents$_(), u = a.length > 0;
            u && (n._$IsCopyPicked$_() ? o._$PushCopySol$_(a) : o._$PushCleanSol$_(a));
            const l = n._$GetFunctionParameters$_();
            for (let t = i.length, s = l.length; t < s; ++t) i.push(l[t]._$GetInitialValue$_());
            const c = n._$GetEventBlock$_(), f = c._$RunAsExpressionFunctionCall$_(c._$GetSolModifiersIncludingParents$_(), n._$IsCopyPicked$_(), h, r, ...i);
            return u && o._$PopSol$_(a), f;
        },
        _$loadingprogress$_() {
            return this._$_runtime$_._$GetAssetManager$_()._$GetLoadProgress$_();
        },
        _$imageloadingprogress$_() {
            return this._$GetImageLoadingProgress$_();
        },
        _$renderer$_() {
            return this._$_runtime$_._$GetWebGPURenderer$_() ? "webgpu" : "webgl";
        },
        _$rendererdetail$_() {
            return this._$_runtime$_._$GetWebGPURenderer$_() ? this._$_runtime$_._$GetWebGPURenderer$_()._$GetAdapterInfoString$_() : this._$_runtime$_._$GetWebGLRenderer$_()._$GetUnmaskedRenderer$_();
        },
        _$imagememoryusage$_() {
            let t = this._$_runtime$_._$GetRenderer$_()._$GetEstimatedTextureMemoryUsage$_();
            return Math.round(100 * t / 1048576) / 100;
        },
        _$rgb$_: (t, s, i) => bS._$PackRGB$_(t, s, i),
        _$rgbex$_: (t, s, i) => bS._$PackRGBEx$_(t / 100, s / 100, i / 100),
        _$rgba$_: (t, s, i, e) => bS._$PackRGBAEx$_(t / 100, s / 100, i / 100, e / 100),
        _$rgbex255$_: (t, s, i) => bS._$PackRGBEx$_(t / 255, s / 255, i / 255),
        _$rgba255$_: (t, s, i, e) => bS._$PackRGBAEx$_(t / 255, s / 255, i / 255, e / 255),
        _$projectname$_() {
            return this._$_runtime$_._$GetProjectName$_();
        },
        _$projectversion$_() {
            return this._$_runtime$_._$GetProjectVersion$_();
        },
        _$currenteventsheetname$_() {
            return this._$_runtime$_._$GetCurrentEvent$_()._$GetEventSheet$_()._$GetName$_();
        },
        _$currenteventnumber$_() {
            return this._$_runtime$_._$GetCurrentEvent$_()._$GetDisplayNumber$_();
        }
    };
}

{
    const TS = self._$C3$_;
    TS._$Plugins$_._$Sprite$_ = class extends TS._$SDKPluginBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
    };
}

{
    const vS = self._$C3$_, xS = self._$C3X$_, IS = [];
    vS._$Plugins$_._$Sprite$_._$Type$_ = class extends vS._$SDKTypeBase$_ {
        constructor(t) {
            super(t), this._$_animations$_ = t._$GetAnimations$_();
        }
        _$Release$_() {
            vS._$clearArray$_(this._$_animations$_), super._$Release$_();
        }
        _$OnCreate$_() {
            for (const t of this._$_animations$_) t._$LoadAllAssets$_(this._$_runtime$_);
        }
        _$LoadTextures$_(t) {
            const s = {
                _$sampling$_: this._$_runtime$_._$GetSampling$_()
            };
            return Promise.all(this._$_animations$_.map((i => i._$LoadAllTextures$_(t, s))));
        }
        _$ReleaseTextures$_() {
            for (const t of this._$_animations$_) t._$ReleaseAllTextures$_();
        }
        _$OnDynamicTextureLoadComplete$_() {
            this._$_UpdateAllCurrentTexture$_();
        }
        _$_UpdateAllCurrentTexture$_() {
            for (const t of this._$_objectClass$_._$instancesIncludingPendingCreate$_()) t._$GetSdkInstance$_()._$_UpdateCurrentTexture$_();
        }
        _$FinishCondition$_(t) {
            vS._$Plugins$_._$Sprite$_._$FinishCollisionCondition$_(this, t);
        }
        _$BeforeRunAction$_(t) {
            IS.push({
                _$objectClass$_: null,
                _$createHierarchy$_: !1,
                _$instances$_: []
            });
        }
        _$_SpawnPickInstance$_(t, s, i) {
            const e = IS.at(-1);
            e._$objectClass$_ = t, e._$createHierarchy$_ = i, e._$instances$_.push(s);
        }
        _$AfterRunAction$_(t) {
            const s = IS.pop(), i = s._$objectClass$_, e = s._$createHierarchy$_;
            if (!i) return;
            const n = new Map;
            for (const t of s._$instances$_) t._$CollectInstancesToPick$_(n, i, e);
            for (const [t, s] of n) t._$GetCurrentSol$_()._$SetSetPicked$_(s);
        }
        _$_AddAnimation$_(t) {
            const s = this._$GetObjectClass$_()._$AddAnimation$_(t), i = this._$GetRuntime$_();
            return s._$GetFrameAt$_(0)._$GetImageInfo$_()._$LoadStaticTexture$_(i._$GetRenderer$_(), {
                _$sampling$_: i._$GetSampling$_()
            }).then((() => this._$_UpdateAllCurrentTexture$_())), s;
        }
        _$_RemoveAnimation$_(t) {
            for (const s of this._$_objectClass$_._$instancesIncludingPendingCreate$_()) s._$GetSdkInstance$_()._$_OnAnimationRemoved$_(t);
            this._$GetObjectClass$_()._$RemoveAnimation$_(t);
        }
        _$_AddAnimationFrame$_(t, s) {
            const i = this._$_objectClass$_._$GetAnimationByName$_(t);
            if (!i) throw new Error(`cannot find animation name '${t}'`);
            let e = i._$FrameTagOrIndexToIndex$_(s);
            e < 0 && (e += i._$GetFrameCount$_() + 1);
            const n = vS._$AnimationFrameInfo$_._$CreateDynamic$_(this._$GetRuntime$_());
            i._$InsertFrameAt$_(n, e);
            const h = this._$GetRuntime$_();
            n._$GetImageInfo$_()._$LoadStaticTexture$_(h._$GetRenderer$_(), {
                _$sampling$_: h._$GetSampling$_()
            }).then((() => this._$_UpdateAllCurrentTexture$_()));
            for (const t of this._$_objectClass$_._$instancesIncludingPendingCreate$_()) t._$GetSdkInstance$_()._$_OnAnimationFramesChanged$_();
            return n;
        }
        _$_RemoveAnimationFrame$_(t, s) {
            const i = this._$_objectClass$_._$GetAnimationByName$_(t);
            if (!i) throw new Error(`cannot find animation name '${t}'`);
            if (1 === i._$GetFrameCount$_()) throw new Error(`cannot remove last frame from animation '${t}'`);
            let e = i._$FrameTagOrIndexToIndex$_(s);
            e < 0 && (e += i._$GetFrameCount$_()), i._$RemoveFrameAt$_(e);
            for (const t of this._$_objectClass$_._$instancesIncludingPendingCreate$_()) t._$GetSdkInstance$_()._$_OnAnimationFramesChanged$_();
        }
        _$GetScriptInterfaceClass$_() {
            return self._$ISpriteObjectType$_;
        }
    };
    const GS = new WeakMap;
    self._$ISpriteObjectType$_ = class extends self._$IObjectClass$_ {
        constructor(t) {
            super(t), GS.set(this, t._$GetSdkType$_());
        }
        _$getAnimation$_(t) {
            xS._$RequireString$_(t);
            const s = GS.get(this)._$GetObjectClass$_()._$GetAnimationByName$_(t);
            return s ? s._$GetIAnimation$_() : null;
        }
        _$getAllAnimations$_() {
            return GS.get(this)._$GetObjectClass$_()._$GetAllAnimations$_().map((t => t._$GetIAnimation$_()));
        }
        _$addAnimation$_(t) {
            return xS._$RequireString$_(t), GS.get(this)._$_AddAnimation$_(t)._$GetIAnimation$_();
        }
        _$removeAnimation$_(t) {
            xS._$RequireString$_(t), GS.get(this)._$_RemoveAnimation$_(t);
        }
        _$addAnimationFrame$_(t, s) {
            if (xS._$RequireString$_(t), "number" != typeof s && "string" != typeof s) throw new TypeError("invalid insert location");
            return GS.get(this)._$_AddAnimationFrame$_(t, s)._$GetIAnimationFrame$_();
        }
        _$removeAnimationFrame$_(t, s) {
            if (xS._$RequireString$_(t), "number" != typeof s && "string" != typeof s) throw new TypeError("invalid insert location");
            GS.get(this)._$_RemoveAnimationFrame$_(t, s);
        }
    };
}

{
    const CS = self._$C3$_, _S = self._$C3X$_, ES = 0, DS = 1, AS = 2, NS = 3, LS = CS._$New$_(CS.Rect), OS = CS._$New$_(CS._$Quad$_), RS = CS._$New$_(CS._$Vector2$_), PS = 1, kS = 2, FS = 4;
    CS._$Plugins$_._$Sprite$_.Instance = class extends CS._$SDKWorldInstanceBase$_ {
        constructor(t, s) {
            super(t);
            let i = !0, e = "", n = 0, h = !0;
            s && (i = !!s[ES], e = s[DS], n = s[AS], h = s[NS]), this._$_currentAnimation$_ = this._$_objectClass$_._$GetAnimationByName$_(e) || this._$_objectClass$_._$GetAnimations$_()[0], 
            this._$_currentFrameIndex$_ = CS._$clamp$_(n, 0, this._$_currentAnimation$_._$GetFrameCount$_() - 1), 
            this._$_currentAnimationFrame$_ = this._$_currentAnimation$_._$GetFrameAt$_(this._$_currentFrameIndex$_);
            const r = this._$_currentAnimationFrame$_._$GetImageInfo$_();
            this._$_currentTexture$_ = r._$GetTexture$_(), this._$_currentRcTex$_ = r._$GetTexRect$_(), 
            this._$_currentQuadTex$_ = r._$GetTexQuad$_(), this._$HandleRendererContextLoss$_(), 
            t._$SetFlag$_(kS, !0), t._$SetFlag$_(PS, this._$_currentAnimation$_._$GetSpeed$_() >= 0), 
            this._$_currentAnimationSpeed$_ = Math.abs(this._$_currentAnimation$_._$GetSpeed$_()), 
            this._$_currentAnimationRepeatTo$_ = this._$_currentAnimation$_._$GetRepeatTo$_(), 
            this._$_animationTimer$_ = CS._$New$_(CS._$KahanSum$_), this._$_frameStartTime$_ = 0, 
            this._$_animationRepeats$_ = 0, this._$_animTriggerName$_ = "", this._$_changeAnimFrameIndex$_ = -1, 
            this._$_changeAnimationName$_ = "", this._$_changeAnimationFrom$_ = 0;
            const o = this._$GetWorldInfo$_();
            this._$_bquadRef$_ = o._$GetBoundingQuad$_(), o._$SetVisible$_(i), o._$SetCollisionEnabled$_(h), 
            o._$SetOriginX$_(this._$_currentAnimationFrame$_._$GetOriginX$_()), o._$SetOriginY$_(this._$_currentAnimationFrame$_._$GetOriginY$_()), 
            o._$SetSourceCollisionPoly$_(this._$_currentAnimationFrame$_._$GetCollisionPoly$_()), 
            o._$SetBboxChanged$_(), 1 === this._$_objectClass$_._$GetAnimationCount$_() && 1 === this._$_objectClass$_._$GetAnimations$_()[0]._$GetFrameCount$_() || 0 === this._$_currentAnimationSpeed$_ || this._$_StartTicking$_();
        }
        _$Release$_() {
            this._$_currentAnimation$_ = null, this._$_currentAnimationFrame$_ = null, this._$_currentTexture$_ = null, 
            this._$_animationTimer$_ = null, super._$Release$_();
        }
        _$GetCurrentImageInfo$_() {
            return this._$_currentAnimationFrame$_._$GetImageInfo$_();
        }
        _$IsOriginalSizeKnown$_() {
            return !0;
        }
        _$OnRendererContextLost$_() {
            this._$_currentTexture$_ = null;
        }
        _$OnRendererContextRestored$_() {
            this._$_UpdateCurrentTexture$_();
        }
        _$Draw$_(t) {
            const s = this._$_currentTexture$_;
            if (null === s) return;
            t._$SetTexture$_(s);
            const i = this._$GetWorldInfo$_();
            i._$HasMesh$_() ? this._$_DrawMesh$_(i, t) : this._$_DrawStandard$_(i, t);
        }
        _$_DrawStandard$_(t, s) {
            let i = this._$_bquadRef$_;
            this._$_runtime$_._$IsPixelRoundingEnabled$_() && (i = t._$PixelRoundQuad$_(i)), 
            s._$Quad4$_(i, this._$_currentQuadTex$_);
        }
        _$_DrawMesh$_(t, s) {
            const i = t._$GetTransformedMesh$_();
            if (t._$IsMeshChanged$_()) {
                t._$CalculateBbox$_(LS, OS, !1);
                let s = OS;
                this._$_runtime$_._$IsPixelRoundingEnabled$_() && (s = t._$PixelRoundQuad$_(s)), 
                i._$CalculateTransformedMesh$_(t._$GetSourceMesh$_(), s, this._$_currentQuadTex$_), 
                t._$SetMeshChanged$_(!1);
            }
            i._$Draw$_(s);
        }
        _$GetAnimationTime$_() {
            return this._$_animationTimer$_._$Get$_();
        }
        _$IsAnimationPlaying$_() {
            return this._$_inst$_._$GetFlag$_(kS);
        }
        _$SetAnimationPlaying$_(t) {
            this._$_inst$_._$SetFlag$_(kS, t);
        }
        _$IsPlayingForwards$_() {
            return this._$_inst$_._$GetFlag$_(PS);
        }
        _$SetPlayingForwards$_(t) {
            this._$_inst$_._$SetFlag$_(PS, t);
        }
        _$IsInAnimationTrigger$_() {
            return this._$_inst$_._$GetFlag$_(FS);
        }
        _$SetInAnimationTrigger$_(t) {
            this._$_inst$_._$SetFlag$_(FS, t);
        }
        _$Tick$_() {
            this._$_changeAnimationName$_ && this._$_DoChangeAnimation$_(), this._$_changeAnimFrameIndex$_ >= 0 && this._$_DoChangeAnimFrame$_();
            const t = this._$_currentAnimationSpeed$_;
            if (!this._$IsAnimationPlaying$_() || 0 === t) return void this._$_StopTicking$_();
            const s = this._$_runtime$_._$GetDt$_(this._$_inst$_);
            this._$_animationTimer$_._$Add$_(s);
            const i = this._$GetAnimationTime$_(), e = this._$_currentAnimationFrame$_, n = e._$GetDuration$_() / t;
            if (i < this._$_frameStartTime$_ + n) return;
            const h = this._$_currentAnimation$_, r = this._$_currentAnimationRepeatTo$_, o = h._$GetFrameCount$_(), a = h._$GetRepeatCount$_(), u = h._$IsLooping$_(), l = h._$IsPingPong$_();
            this._$IsPlayingForwards$_() ? this._$_currentFrameIndex$_++ : this._$_currentFrameIndex$_--, 
            this._$_frameStartTime$_ += n, this._$_currentFrameIndex$_ >= o && (l ? (this._$SetPlayingForwards$_(!1), 
            this._$_currentFrameIndex$_ = o - 2) : u ? this._$_currentFrameIndex$_ = r : (this._$_animationRepeats$_++, 
            this._$_animationRepeats$_ >= a ? this._$_FinishAnimation$_(!1) : this._$_currentFrameIndex$_ = r)), 
            this._$_currentFrameIndex$_ < 0 && (l ? (this._$_currentFrameIndex$_ = 1, this._$SetPlayingForwards$_(!0), 
            u || (this._$_animationRepeats$_++, this._$_animationRepeats$_ >= a && this._$_FinishAnimation$_(!0))) : u ? this._$_currentFrameIndex$_ = r : (this._$_animationRepeats$_++, 
            this._$_animationRepeats$_ >= a ? this._$_FinishAnimation$_(!0) : this._$_currentFrameIndex$_ = r)), 
            this._$_currentFrameIndex$_ = CS._$clamp$_(this._$_currentFrameIndex$_, 0, o - 1);
            const c = h._$GetFrameAt$_(this._$_currentFrameIndex$_);
            i > this._$_frameStartTime$_ + c._$GetDuration$_() / t && (this._$_frameStartTime$_ = i), 
            this._$_OnFrameChanged$_(e, c);
        }
        _$_FinishAnimation$_(t) {
            this._$_currentFrameIndex$_ = t ? 0 : this._$_currentAnimation$_._$GetFrameCount$_() - 1, 
            this._$SetAnimationPlaying$_(!1), this._$_animTriggerName$_ = this._$_currentAnimation$_._$GetName$_(), 
            this._$SetInAnimationTrigger$_(!0), this._$DispatchScriptEvent$_("animationend", !1, {
                animationName: this._$_animTriggerName$_
            }), this._$Trigger$_(CS._$Plugins$_._$Sprite$_._$Cnds$_._$OnAnyAnimFinished$_), 
            this._$Trigger$_(CS._$Plugins$_._$Sprite$_._$Cnds$_._$OnAnimFinished$_), this._$SetInAnimationTrigger$_(!1), 
            this._$_animationRepeats$_ = 0;
        }
        _$_OnFrameChanged$_(t, s, i) {
            if (t === s) return;
            const e = this._$GetWorldInfo$_(), n = t._$GetImageInfo$_(), h = s._$GetImageInfo$_(), r = n._$GetWidth$_(), o = n._$GetHeight$_(), a = h._$GetWidth$_(), u = h._$GetHeight$_();
            i && i._$onFrameChange$_ ? i._$onFrameChange$_(e, r, o, a, u) : (r !== a && e._$SetWidth$_(e._$GetWidth$_() * (a / r)), 
            o !== u && e._$SetHeight$_(e._$GetHeight$_() * (u / o))), e._$SetOriginX$_(s._$GetOriginX$_()), 
            e._$SetOriginY$_(s._$GetOriginY$_()), e._$SetSourceCollisionPoly$_(s._$GetCollisionPoly$_()), 
            e._$SetBboxChanged$_(), this._$_currentAnimationFrame$_ = s, this._$_currentTexture$_ = h._$GetTexture$_(), 
            this._$_currentRcTex$_ = h._$GetTexRect$_(), this._$_currentQuadTex$_ = h._$GetTexQuad$_();
            const l = this._$GetInstance$_()._$GetBehaviorInstances$_();
            for (let i = 0, e = l.length; i < e; ++i) l[i]._$OnSpriteFrameChanged$_(t, s);
            this._$DispatchScriptEvent$_("framechange", !1, {
                animationName: this._$_currentAnimation$_._$GetName$_(),
                _$animationFrame$_: this._$_currentFrameIndex$_
            }), this._$Trigger$_(CS._$Plugins$_._$Sprite$_._$Cnds$_._$OnFrameChanged$_), this._$_runtime$_._$UpdateRender$_();
        }
        _$_StartAnim$_(t) {
            this._$SetAnimationPlaying$_(!0), this._$_frameStartTime$_ = this._$GetAnimationTime$_(), 
            1 === t && 0 !== this._$_currentFrameIndex$_ && (this._$_changeAnimFrameIndex$_ = 0, 
            this._$IsInAnimationTrigger$_() || this._$_DoChangeAnimFrame$_()), this._$_StartTicking$_();
        }
        _$_SetAnim$_(t, s, i) {
            this._$_changeAnimationName$_ = t, this._$_changeAnimationFrom$_ = s, this._$_StartTicking$_(), 
            !i && this._$IsInAnimationTrigger$_() || this._$_DoChangeAnimation$_();
        }
        _$_GetCurrentAnimation$_() {
            return this._$_currentAnimation$_;
        }
        _$_GetCurrentAnimationName$_() {
            return this._$_changeAnimationName$_ ? this._$_changeAnimationName$_ : this._$_currentAnimation$_._$GetName$_();
        }
        _$_OnAnimationRemoved$_(t) {
            CS._$equalsNoCase$_(t, this._$_GetCurrentAnimationName$_()) && this._$_SetAnim$_(this._$_objectClass$_._$GetFirstAnimation$_()._$GetName$_(), 1, !0);
        }
        _$_SetAnimFrame$_(t) {
            if ("string" == typeof t) if (String(Number(t)) === t) t = Number(t); else {
                const s = this._$_objectClass$_._$GetAnimationByName$_(this._$_GetCurrentAnimationName$_());
                if (!s) return;
                if (-1 === (t = s._$GetFrameIndexByTag$_(t))) return;
            }
            isFinite(t) && (this._$_changeAnimFrameIndex$_ = t, this._$IsInAnimationTrigger$_() || this._$_DoChangeAnimFrame$_());
        }
        _$_OnAnimationFramesChanged$_() {
            if (this._$_changeAnimationName$_ || -1 !== this._$_changeAnimFrameIndex$_) return;
            const t = this._$_currentAnimationFrame$_, s = this._$_currentAnimation$_._$GetFrameAt$_(CS._$clamp$_(this._$_currentFrameIndex$_, 0, this._$_currentAnimation$_._$GetFrameCount$_() - 1));
            t !== s && this._$_OnFrameChanged$_(t, s), this._$_currentAnimation$_._$GetFrameCount$_() > 1 && this._$_currentAnimationSpeed$_ > 0 && this._$_StartTicking$_();
        }
        _$_GetAnimFrame$_() {
            return this._$_currentFrameIndex$_;
        }
        _$_GetAnimFrameTag$_() {
            return this._$_currentAnimationFrame$_._$GetTag$_();
        }
        _$_SetAnimSpeed$_(t) {
            this._$_currentAnimationSpeed$_ = Math.abs(t), this._$SetPlayingForwards$_(t >= 0), 
            this._$_currentAnimationSpeed$_ > 0 && this._$_StartTicking$_();
        }
        _$_GetAnimSpeed$_() {
            return this._$IsPlayingForwards$_() ? this._$_currentAnimationSpeed$_ : -this._$_currentAnimationSpeed$_;
        }
        _$_SetAnimRepeatToFrame$_(t) {
            "string" == typeof t && -1 === (t = this._$_currentAnimation$_._$GetFrameIndexByTag$_(t)) || (t = CS._$clamp$_(Math.floor(t), 0, this._$_currentAnimation$_._$GetFrameCount$_() - 1), 
            this._$_currentAnimationRepeatTo$_ = t);
        }
        _$_GetAnimRepeatToFrame$_() {
            return this._$_currentAnimationRepeatTo$_;
        }
        _$_DoChangeAnimation$_(t) {
            const s = this._$_currentAnimationFrame$_, i = this._$_objectClass$_._$GetAnimationByName$_(this._$_changeAnimationName$_);
            if (this._$_changeAnimationName$_ = "", !i) return;
            if (i === this._$_currentAnimation$_ && this._$IsAnimationPlaying$_()) return;
            this._$_currentAnimation$_ = i, this._$SetPlayingForwards$_(i._$GetSpeed$_() >= 0), 
            this._$_currentAnimationSpeed$_ = Math.abs(i._$GetSpeed$_()), this._$_currentAnimationRepeatTo$_ = i._$GetRepeatTo$_(), 
            this._$_currentFrameIndex$_ = CS._$clamp$_(this._$_currentFrameIndex$_, 0, this._$_currentAnimation$_._$GetFrameCount$_() - 1), 
            1 === this._$_changeAnimationFrom$_ && (this._$_currentFrameIndex$_ = 0), this._$SetAnimationPlaying$_(!0), 
            this._$_frameStartTime$_ = this._$GetAnimationTime$_();
            const e = this._$_currentAnimation$_._$GetFrameAt$_(this._$_currentFrameIndex$_);
            this._$_OnFrameChanged$_(s, e, t);
        }
        _$_DoChangeAnimFrame$_(t) {
            const s = this._$_currentAnimationFrame$_, i = this._$_currentFrameIndex$_;
            if (this._$_currentFrameIndex$_ = CS._$clamp$_(Math.floor(this._$_changeAnimFrameIndex$_), 0, this._$_currentAnimation$_._$GetFrameCount$_() - 1), 
            this._$_changeAnimFrameIndex$_ = -1, !t && i === this._$_currentFrameIndex$_) return;
            const e = this._$_currentAnimation$_._$GetFrameAt$_(this._$_currentFrameIndex$_);
            this._$_OnFrameChanged$_(s, e), this._$_frameStartTime$_ = this._$GetAnimationTime$_();
        }
        _$_UpdateCurrentTexture$_() {
            const t = this._$_currentAnimationFrame$_._$GetImageInfo$_();
            this._$_currentTexture$_ = t._$GetTexture$_(), this._$_currentRcTex$_ = t._$GetTexRect$_(), 
            this._$_currentQuadTex$_ = t._$GetTexQuad$_(), this._$GetWorldInfo$_()._$SetMeshChanged$_(!0);
        }
        _$GetTexture$_() {
            return this._$_currentTexture$_;
        }
        _$GetTexRect$_() {
            return this._$_currentRcTex$_;
        }
        _$GetTexQuad$_() {
            return this._$_currentQuadTex$_;
        }
        _$GetImagePointCount$_() {
            return this._$_currentAnimationFrame$_._$GetImagePointCount$_();
        }
        _$GetImagePoint$_(t) {
            const s = this._$_currentAnimationFrame$_, i = this._$GetWorldInfo$_();
            let e = null;
            if ("string" == typeof t) e = s._$GetImagePointByName$_(t); else {
                if ("number" != typeof t) throw new TypeError("expected string or number");
                e = s._$GetImagePointByIndex$_(t - 1);
            }
            let n = i._$GetTotalZElevation$_();
            if (!e) return [ i._$GetX$_(), i._$GetY$_(), n ];
            if (RS._$copy$_(e._$GetVec2$_()), i._$HasMesh$_()) {
                const [t, s, e] = i._$GetSourceMesh$_()._$TransformPoint$_(RS._$getX$_(), RS._$getY$_());
                RS.set(t, s), n += e;
            }
            return RS.offset(-s._$GetOriginX$_(), -s._$GetOriginY$_()), RS.scale(i._$GetWidth$_(), i._$GetHeight$_()), 
            RS.rotate(i._$GetAngle$_()), RS.offset(i._$GetX$_(), i._$GetY$_()), [ RS._$getX$_(), RS._$getY$_(), n ];
        }
        _$GetCollisionPolyPointCount$_() {
            return this._$GetWorldInfo$_()._$GetTransformedCollisionPoly$_()._$pointCount$_();
        }
        _$GetCollisionPolyPoint$_(t) {
            t = Math.floor(t);
            const s = this._$GetWorldInfo$_(), i = s._$GetTransformedCollisionPoly$_(), e = i._$pointCount$_();
            if (t === e && (t = 0), t < 0 || t >= e) return [ 0, 0 ];
            const n = i._$pointsArr$_();
            return [ n[2 * t + 0] + s._$GetX$_(), n[2 * t + 1] + s._$GetY$_() ];
        }
        _$GetDebuggerProperties$_() {
            const t = CS._$Plugins$_._$Sprite$_._$Acts$_, s = "plugins.sprite.debugger.animation-properties";
            return [ {
                title: s + ".title",
                properties: [ {
                    name: s + ".current-animation",
                    value: this._$_currentAnimation$_._$GetName$_(),
                    _$onedit$_: s => this._$CallAction$_(t._$SetAnim$_, s, 0)
                }, {
                    name: s + ".current-frame",
                    value: this._$_currentFrameIndex$_,
                    _$onedit$_: s => this._$CallAction$_(t._$SetAnimFrame$_, s)
                }, {
                    name: s + ".is-playing",
                    value: this._$IsAnimationPlaying$_(),
                    _$onedit$_: s => s ? this._$CallAction$_(t._$StartAnim$_, 0) : this._$CallAction$_(t._$StopAnim$_)
                }, {
                    name: s + ".speed",
                    value: this._$_currentAnimationSpeed$_,
                    _$onedit$_: s => this._$CallAction$_(t._$SetAnimSpeed$_, s)
                }, {
                    name: s + ".repeats",
                    value: this._$_animationRepeats$_,
                    _$onedit$_: t => this._$_animationRepeats$_ = t
                } ]
            } ];
        }
        _$SaveToJson$_() {
            const t = {
                a: this._$_currentAnimation$_._$GetSID$_()
            };
            0 !== this._$_frameStartTime$_ && (t.fs = this._$_frameStartTime$_);
            const s = this._$GetAnimationTime$_();
            0 !== s && (t.at = s), 0 !== this._$_currentFrameIndex$_ && (t.f = this._$_currentFrameIndex$_), 
            0 !== this._$_currentAnimationSpeed$_ && (t.cas = this._$_currentAnimationSpeed$_), 
            1 !== this._$_animationRepeats$_ && (t.ar = this._$_animationRepeats$_), 0 !== this._$_currentAnimationRepeatTo$_ && (t.rt = this._$_currentAnimationRepeatTo$_), 
            this._$IsAnimationPlaying$_() || (t.ap = this._$IsAnimationPlaying$_()), this._$IsPlayingForwards$_() || (t.af = this._$IsPlayingForwards$_());
            const i = this._$GetWorldInfo$_();
            return i._$IsCollisionEnabled$_() && (t.ce = i._$IsCollisionEnabled$_()), t;
        }
        _$LoadFromJson$_(t) {
            const s = this._$GetObjectClass$_()._$GetAnimationBySID$_(t.a);
            s && (this._$_currentAnimation$_ = s), this._$_frameStartTime$_ = t.hasOwnProperty("fs") ? t.fs : 0, 
            this._$_animationTimer$_.Set(t.hasOwnProperty("at") ? t.at : 0);
            const i = t.hasOwnProperty("f") ? t.f : 0;
            this._$_currentFrameIndex$_ = CS._$clamp$_(i, 0, this._$_currentAnimation$_._$GetFrameCount$_() - 1), 
            this._$_currentAnimationSpeed$_ = t.hasOwnProperty("cas") ? t.cas : 0, this._$_animationRepeats$_ = t.hasOwnProperty("ar") ? t.ar : 1;
            const e = t.hasOwnProperty("rt") ? t.rt : 0;
            this._$_currentAnimationRepeatTo$_ = CS._$clamp$_(e, 0, this._$_currentAnimation$_._$GetFrameCount$_() - 1), 
            this._$SetAnimationPlaying$_(!t.hasOwnProperty("ap") || !!t.ap), this._$SetPlayingForwards$_(!t.hasOwnProperty("af") || !!t.af);
            const n = this._$_currentAnimation$_._$GetFrameAt$_(this._$_currentFrameIndex$_);
            this._$_currentAnimationFrame$_ = n, this._$_UpdateCurrentTexture$_();
            const h = this._$GetWorldInfo$_();
            h._$SetOriginX$_(n._$GetOriginX$_()), h._$SetOriginY$_(n._$GetOriginY$_()), h._$SetSourceCollisionPoly$_(n._$GetCollisionPoly$_()), 
            h._$SetCollisionEnabled$_(!!t.ce), this._$IsAnimationPlaying$_() && this._$_StartTicking$_();
        }
        _$GetPropertyValueByIndex$_(t) {
            const s = this._$GetWorldInfo$_();
            switch (t) {
              case NS:
                return s._$IsCollisionEnabled$_();

              case AS:
                return CS._$clamp$_(this._$_currentFrameIndex$_, 0, this._$_currentAnimation$_._$GetFrameCount$_() - 1);

              case DS:
                return this._$_currentAnimation$_._$GetName$_();
            }
        }
        _$SetPropertyValueByIndex$_(t, s, i) {
            const e = this._$GetWorldInfo$_();
            switch (t) {
              case NS:
                e._$SetCollisionEnabled$_(!!s);
                break;

              case AS:
                {
                    this._$SetAnimationPlaying$_(!1);
                    const t = this._$_currentAnimation$_._$GetFrameCount$_() - 1, e = s = CS._$clamp$_(s, 0, t), n = this._$_currentAnimation$_._$GetFrameAt$_(this._$_currentFrameIndex$_), h = this._$_currentAnimation$_._$GetFrameAt$_(e);
                    this._$_OnFrameChanged$_(n, h, i), this._$_currentFrameIndex$_ = CS._$clamp$_(e, 0, t);
                    break;
                }

              case DS:
                this._$_changeAnimationName$_ = s, this._$_DoChangeAnimation$_(i), this._$_currentAnimation$_._$GetFrameCount$_() > 1 && this._$_currentAnimation$_._$GetSpeed$_() > 0 ? this._$_StartTicking$_() : this._$_StopTicking$_();
            }
        }
        _$GetScriptInterfaceClass$_() {
            return self._$ISpriteInstance$_;
        }
    };
    const jS = new WeakMap, BS = new Map([ [ "current-frame", 0 ], [ "beginning", 1 ] ]);
    self._$ISpriteInstance$_ = class extends self._$IWorldInstance$_ {
        constructor() {
            super(), jS.set(this, self._$IInstance$_._$_GetInitInst$_()._$GetSdkInstance$_());
        }
        _$getImagePointCount$_() {
            return jS.get(this)._$GetImagePointCount$_();
        }
        _$getImagePointX$_(t) {
            return this._$getImagePoint$_(t)[0];
        }
        _$getImagePointY$_(t) {
            return this._$getImagePoint$_(t)[1];
        }
        _$getImagePointZ$_(t) {
            return this._$getImagePoint$_(t)[2];
        }
        _$getImagePoint$_(t) {
            if ("string" != typeof t && "number" != typeof t) throw new TypeError("expected string or number");
            return jS.get(this)._$GetImagePoint$_(t);
        }
        _$getPolyPointCount$_() {
            return jS.get(this)._$GetCollisionPolyPointCount$_();
        }
        _$getPolyPointX$_(t) {
            return _S._$RequireFiniteNumber$_(t), jS.get(this)._$GetCollisionPolyPoint$_(t)[0];
        }
        _$getPolyPointY$_(t) {
            return _S._$RequireFiniteNumber$_(t), jS.get(this)._$GetCollisionPolyPoint$_(t)[1];
        }
        _$getPolyPoint$_(t) {
            return _S._$RequireFiniteNumber$_(t), jS.get(this)._$GetCollisionPolyPoint$_(t);
        }
        _$stopAnimation$_() {
            jS.get(this)._$SetAnimationPlaying$_(!1);
        }
        _$startAnimation$_(t = "current-frame") {
            _S._$RequireString$_(t);
            const s = BS.get(t);
            if (void 0 === s) throw new Error("invalid mode");
            jS.get(this)._$_StartAnim$_(s);
        }
        _$setAnimation$_(t, s = "beginning") {
            _S._$RequireString$_(t), _S._$RequireString$_(s);
            const i = BS.get(s);
            if (void 0 === i) throw new Error("invalid mode");
            const e = jS.get(this);
            if (!e._$GetObjectClass$_()._$GetAnimationByName$_(t)) throw new Error(`animation name "${t}" does not exist`);
            e._$_SetAnim$_(t, i);
        }
        _$getAnimation$_(t) {
            _S._$RequireString$_(t);
            const s = jS.get(this)._$GetObjectClass$_()._$GetAnimationByName$_(t);
            return s ? s._$GetIAnimation$_() : null;
        }
        get animation() {
            return jS.get(this)._$_GetCurrentAnimation$_()._$GetIAnimation$_();
        }
        get animationName() {
            return jS.get(this)._$_GetCurrentAnimationName$_();
        }
        set _$animationFrame$_(t) {
            _S._$RequireFiniteNumber$_(t), jS.get(this)._$_SetAnimFrame$_(t);
        }
        get _$animationFrame$_() {
            return jS.get(this)._$_GetAnimFrame$_();
        }
        set _$animationFrameTag$_(t) {
            _S._$RequireString$_(t), jS.get(this)._$_SetAnimFrame$_(t);
        }
        get _$animationFrameTag$_() {
            return jS.get(this)._$_GetAnimFrameTag$_();
        }
        set _$animationSpeed$_(t) {
            _S._$RequireFiniteNumber$_(t), jS.get(this)._$_SetAnimSpeed$_(t);
        }
        get _$animationSpeed$_() {
            return jS.get(this)._$_GetAnimSpeed$_();
        }
        set _$animationRepeatToFrame$_(t) {
            _S._$RequireFiniteNumber$_(t), jS.get(this)._$_SetAnimRepeatToFrame$_(t);
        }
        get _$animationRepeatToFrame$_() {
            return jS.get(this)._$_GetAnimRepeatToFrame$_();
        }
        get imageWidth() {
            return jS.get(this)._$GetCurrentImageInfo$_()._$GetWidth$_();
        }
        get imageHeight() {
            return jS.get(this)._$GetCurrentImageInfo$_()._$GetHeight$_();
        }
        _$getImageSize$_() {
            const t = jS.get(this)._$GetCurrentImageInfo$_();
            return [ t._$GetWidth$_(), t._$GetHeight$_() ];
        }
        async _$replaceCurrentAnimationFrame$_(t) {
            _S._$RequireInstanceOf$_(t, Blob);
            const s = jS.get(this), i = s._$GetRuntime$_(), e = s._$GetCurrentImageInfo$_(), n = CS._$New$_(CS._$ImageInfo$_);
            if (n._$LoadDynamicBlobAsset$_(i, t), await n._$LoadStaticTexture$_(i._$GetRenderer$_(), {
                _$sampling$_: i._$GetSampling$_()
            }), s._$WasReleased$_()) return void n._$Release$_();
            e._$ReplaceWith$_(n);
            const h = s._$GetSdkType$_();
            h._$_UpdateAllCurrentTexture$_(), h._$GetObjectClass$_()._$Dispatcher$_().dispatchEvent(new CS.Event("animationframeimagechange")), 
            i._$UpdateRender$_();
        }
        _$setSolidCollisionFilter$_(t, s) {
            _S._$RequireString$_(s), jS.get(this)._$GetWorldInfo$_()._$SetSolidCollisionFilter$_(!!t, s);
        }
    };
}

{
    const zS = self._$C3$_;
    zS._$Plugins$_._$Sprite$_._$Cnds$_ = {
        _$IsAnimPlaying$_(t) {
            return zS._$equalsNoCase$_(this._$_GetCurrentAnimationName$_(), t);
        },
        _$CompareFrame$_(t, s) {
            return zS.compare(this._$_currentFrameIndex$_, t, s);
        },
        _$CompareFrameTag$_(t, s) {
            if ("string" != typeof s) return !1;
            const i = this._$_currentAnimationFrame$_._$GetTag$_();
            return zS.compare(i.toLowerCase(), t, s.toLowerCase());
        },
        _$CompareAnimSpeed$_(t, s) {
            return zS.compare(this._$_GetAnimSpeed$_(), t, s);
        },
        _$OnAnimFinished$_(t) {
            return zS._$equalsNoCase$_(this._$_animTriggerName$_, t);
        },
        _$OnAnyAnimFinished$_: () => !0,
        _$OnFrameChanged$_: () => !0,
        _$IsMirrored$_() {
            return this._$GetWorldInfo$_()._$GetWidth$_() < 0;
        },
        _$IsFlipped$_() {
            return this._$GetWorldInfo$_()._$GetHeight$_() < 0;
        },
        _$OnURLLoaded$_: () => !0,
        _$OnURLFailed$_: () => !0,
        _$IsCollisionEnabled$_() {
            return this._$GetWorldInfo$_()._$IsCollisionEnabled$_();
        }
    };
}

{
    const US = self._$C3$_;
    US._$Plugins$_._$Sprite$_._$Acts$_ = {
        _$Spawn$_(t, s, i, e, n) {
            if (!t || !s) return;
            const [h, r] = this._$GetImagePoint$_(i), o = this._$_runtime$_._$CreateInstance$_(t, s, h, r, e, n);
            if (!o) return;
            if (e && s._$SortAndAddInstancesByZIndex$_(o), t._$GetPlugin$_()._$IsRotatable$_()) {
                const t = o._$GetWorldInfo$_();
                t._$SetAngle$_(this._$GetWorldInfo$_()._$GetAngle$_()), t._$SetBboxChanged$_();
            }
            const a = this._$_runtime$_._$GetEventSheetManager$_();
            a._$BlockFlushingInstances$_(!0), o._$_TriggerOnCreatedOnSelfAndRelated$_(), a._$BlockFlushingInstances$_(!1), 
            t !== this._$_runtime$_._$GetCurrentAction$_()._$GetObjectClass$_() && this._$_sdkType$_._$_SpawnPickInstance$_(t, o, e);
        },
        _$StopAnim$_() {
            this._$SetAnimationPlaying$_(!1);
        },
        _$StartAnim$_(t) {
            this._$_StartAnim$_(t);
        },
        _$SetAnim$_(t, s) {
            this._$_SetAnim$_(t, s);
        },
        _$SetAnimFrame$_(t) {
            this._$_SetAnimFrame$_(t);
        },
        _$SetAnimSpeed$_(t) {
            this._$_SetAnimSpeed$_(t);
        },
        _$SetAnimRepeatToFrame$_(t) {
            this._$_SetAnimRepeatToFrame$_(t);
        },
        _$AddRemoveAnimation$_(t, s) {
            try {
                0 === t ? this._$GetSdkType$_()._$_AddAnimation$_(s) : this._$GetSdkType$_()._$_RemoveAnimation$_(s);
            } catch (s) {
                console.error(`[Construct] Error ${0 === t ? "adding" : "removing"} animation: `, s);
            }
        },
        _$AddRemoveAnimationFrame$_(t, s, i) {
            try {
                0 === t ? this._$GetSdkType$_()._$_AddAnimationFrame$_(s, i) : this._$GetSdkType$_()._$_RemoveAnimationFrame$_(s, i);
            } catch (s) {
                console.error(`[Construct] Error ${0 === t ? "adding" : "removing"} animation frame: `, s);
            }
        },
        _$SetMirrored$_(t) {
            const s = this._$GetWorldInfo$_(), i = s._$GetWidth$_(), e = Math.abs(i) * (0 === t ? -1 : 1);
            i !== e && (s._$SetWidth$_(e), s._$SetBboxChanged$_());
        },
        _$SetFlipped$_(t) {
            const s = this._$GetWorldInfo$_(), i = s._$GetHeight$_(), e = Math.abs(i) * (0 === t ? -1 : 1);
            i !== e && (s._$SetHeight$_(e), s._$SetBboxChanged$_());
        },
        _$SetScale$_(t) {
            const s = this._$_currentAnimationFrame$_._$GetImageInfo$_(), i = this._$GetWorldInfo$_(), e = i._$GetWidth$_() < 0 ? -1 : 1, n = i._$GetHeight$_() < 0 ? -1 : 1, h = s._$GetWidth$_() * t * e, r = s._$GetHeight$_() * t * n;
            i._$GetWidth$_() === h && i._$GetHeight$_() === r || (i._$SetSize$_(h, r), i._$SetBboxChanged$_());
        },
        async _$LoadURL$_(t, s, i) {
            const e = this._$_currentAnimationFrame$_._$GetImageInfo$_(), n = this._$GetWorldInfo$_(), h = this._$_runtime$_, r = this._$_sdkType$_;
            if (e._$GetURL$_() === t) return 0 === s && (n._$SetSize$_(e._$GetWidth$_(), e._$GetHeight$_()), 
            n._$SetBboxChanged$_()), void this._$Trigger$_(US._$Plugins$_._$Sprite$_._$Cnds$_._$OnURLLoaded$_);
            const o = US._$New$_(US._$ImageInfo$_);
            try {
                if (await o._$LoadDynamicAsset$_(h, t), !o._$IsLoaded$_()) throw new Error("image failed to load");
                if (this._$WasReleased$_()) return void o._$Release$_();
                await o._$LoadStaticTexture$_(h._$GetRenderer$_(), {
                    _$sampling$_: h._$GetSampling$_()
                });
            } catch (t) {
                return console.error("Load image from URL failed: ", t), void (this._$WasReleased$_() || this._$Trigger$_(US._$Plugins$_._$Sprite$_._$Cnds$_._$OnURLFailed$_));
            }
            this._$WasReleased$_() ? o._$Release$_() : (e._$ReplaceWith$_(o), r._$_UpdateAllCurrentTexture$_(), 
            r._$GetObjectClass$_()._$Dispatcher$_().dispatchEvent(new US.Event("animationframeimagechange")), 
            h._$UpdateRender$_(), 0 === s && (n._$SetSize$_(e._$GetWidth$_(), e._$GetHeight$_()), 
            n._$SetBboxChanged$_()), await this._$TriggerAsync$_(US._$Plugins$_._$Sprite$_._$Cnds$_._$OnURLLoaded$_));
        },
        _$SetCollisions$_(t) {
            this._$GetWorldInfo$_()._$SetCollisionEnabled$_(t);
        },
        _$SetSolidCollisionFilter$_(t, s) {
            this._$GetWorldInfo$_()._$SetSolidCollisionFilter$_(0 === t, s);
        },
        _$SetEffect$_(t) {
            this._$GetWorldInfo$_()._$SetBlendMode$_(t), this._$_runtime$_._$UpdateRender$_();
        }
    };
}

self._$C3$_._$Plugins$_._$Sprite$_._$Exps$_ = {
    _$AnimationFrame$_() {
        return this._$_GetAnimFrame$_();
    },
    _$AnimationFrameTag$_() {
        return this._$_GetAnimFrameTag$_();
    },
    _$AnimationFrameCount$_() {
        return this._$_currentAnimation$_._$GetFrameCount$_();
    },
    _$AnimationName$_() {
        return this._$_currentAnimation$_._$GetName$_();
    },
    _$AnimationSpeed$_() {
        return this._$_GetAnimSpeed$_();
    },
    _$OriginalAnimationSpeed$_() {
        return this._$_currentAnimation$_._$GetSpeed$_();
    },
    _$ImagePointX$_(t) {
        return this._$GetImagePoint$_(t)[0];
    },
    _$ImagePointY$_(t) {
        return this._$GetImagePoint$_(t)[1];
    },
    _$ImagePointZ$_(t) {
        return this._$GetImagePoint$_(t)[2];
    },
    _$ImagePointCount$_() {
        return this._$GetImagePointCount$_();
    },
    _$ImageWidth$_() {
        return this._$GetCurrentImageInfo$_()._$GetWidth$_();
    },
    _$ImageHeight$_() {
        return this._$GetCurrentImageInfo$_()._$GetHeight$_();
    },
    _$PolyPointXAt$_(t) {
        return this._$GetCollisionPolyPoint$_(t)[0];
    },
    _$PolyPointYAt$_(t) {
        return this._$GetCollisionPolyPoint$_(t)[1];
    },
    _$PolyPointCount$_() {
        return this._$GetCollisionPolyPointCount$_();
    }
};

{
    const WS = self._$C3$_;
    WS._$Plugins$_.Keyboard = class extends WS._$SDKPluginBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
    };
}

{
    let JS = function() {
        return YS._$GetSingleGlobalInstance$_()._$GetSdkInstance$_();
    };
    0;
    const QS = self._$C3$_;
    self._$C3X$_, QS._$Plugins$_.Keyboard._$Type$_ = class extends QS._$SDKTypeBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$OnCreate$_() {}
        _$GetScriptInterfaceClass$_() {
            return self._$IKeyboardObjectType$_;
        }
    };
    let YS = null;
    self._$IKeyboardObjectType$_ = class extends self._$IObjectClass$_ {
        constructor(t) {
            super(t), YS = t, t._$GetRuntime$_()._$_GetCommonScriptInterfaces$_().keyboard = this;
        }
        _$isKeyDown$_(t) {
            const s = JS();
            if ("string" == typeof t) return s._$IsKeyDown$_(t);
            if ("number" == typeof t) return s._$IsKeyCodeDown$_(t);
            throw new TypeError("expected string or number");
        }
    };
}

{
    const VS = self._$C3$_, HS = "keyboard";
    VS._$Plugins$_.Keyboard.Instance = class extends VS._$SDKInstanceBase$_ {
        constructor(t, s) {
            super(t, HS), this._$_keysDownByString$_ = new Set, this._$_keysDownByWhich$_ = new Set, 
            this._$_triggerWhich$_ = 0, this._$_triggerString$_ = "", this._$_triggerTypedKey$_ = "", 
            this._$_isKeyboardLockSupported$_ = !1;
            const i = this._$GetRuntime$_()._$Dispatcher$_();
            this._$_disposables$_ = new VS._$CompositeDisposable$_(VS._$Disposable$_._$From$_(i, "keydown", (t => this._$_OnKeyDown$_(t.data))), VS._$Disposable$_._$From$_(i, "keyup", (t => this._$_OnKeyUp$_(t.data))), VS._$Disposable$_._$From$_(i, "window-blur", (() => this._$_OnWindowOrKeyboardBlur$_())), VS._$Disposable$_._$From$_(i, "keyboard-blur", (() => this._$_OnWindowOrKeyboardBlur$_()))), 
            this._$_runtime$_._$AddLoadPromise$_(this._$_Init$_());
        }
        _$Release$_() {
            super._$Release$_();
        }
        async _$_Init$_() {
            const t = await this._$PostToDOMAsync$_("init");
            this._$_isKeyboardLockSupported$_ = t.isKeyboardLockSupported;
        }
        _$_OnKeyDown$_(t) {
            const s = t.which, i = t.code || s.toString(), e = t.key;
            this._$_keysDownByString$_.has(i) || (this._$_keysDownByString$_.add(i), this._$_keysDownByWhich$_.add(s), 
            this._$_triggerString$_ = i, this._$_triggerWhich$_ = s, this._$_triggerTypedKey$_ = e, 
            this._$Trigger$_(VS._$Plugins$_.Keyboard._$Cnds$_._$OnAnyKey$_), this._$Trigger$_(VS._$Plugins$_.Keyboard._$Cnds$_._$OnKey$_), 
            this._$Trigger$_(VS._$Plugins$_.Keyboard._$Cnds$_._$OnLeftRightKeyPressed$_), this._$Trigger$_(VS._$Plugins$_.Keyboard._$Cnds$_._$OnKeyCode$_));
        }
        _$_OnKeyUp$_(t) {
            const s = t.which, i = t.code || s.toString(), e = t.key;
            this._$_keysDownByString$_.delete(i), this._$_keysDownByWhich$_.delete(s), this._$_triggerString$_ = i, 
            this._$_triggerWhich$_ = s, this._$_triggerTypedKey$_ = e, this._$Trigger$_(VS._$Plugins$_.Keyboard._$Cnds$_._$OnAnyKeyReleased$_), 
            this._$Trigger$_(VS._$Plugins$_.Keyboard._$Cnds$_._$OnKeyReleased$_), this._$Trigger$_(VS._$Plugins$_.Keyboard._$Cnds$_._$OnLeftRightKeyReleased$_), 
            this._$Trigger$_(VS._$Plugins$_.Keyboard._$Cnds$_._$OnKeyCodeReleased$_);
        }
        _$_OnWindowOrKeyboardBlur$_() {
            for (const t of this._$_keysDownByWhich$_) this._$_keysDownByWhich$_.delete(t), 
            this._$_triggerWhich$_ = t, this._$Trigger$_(VS._$Plugins$_.Keyboard._$Cnds$_._$OnAnyKeyReleased$_), 
            this._$Trigger$_(VS._$Plugins$_.Keyboard._$Cnds$_._$OnKeyReleased$_), this._$Trigger$_(VS._$Plugins$_.Keyboard._$Cnds$_._$OnKeyCodeReleased$_);
            this._$_keysDownByString$_.clear();
        }
        _$IsKeyDown$_(t) {
            return this._$_keysDownByString$_.has(t);
        }
        _$IsKeyCodeDown$_(t) {
            return this._$_keysDownByWhich$_.has(t);
        }
        _$SaveToJson$_() {
            return {
                tk: this._$_triggerWhich$_,
                tkk: this._$_triggerTypedKey$_
            };
        }
        _$LoadFromJson$_(t) {
            this._$_triggerWhich$_ = t.tk, t.hasOwnProperty("tkk") && (this._$_triggerTypedKey$_ = t.tkk);
        }
        _$GetDebuggerProperties$_() {
            const t = "plugins.keyboard";
            return [ {
                title: t + ".name",
                properties: [ {
                    name: t + ".debugger.last-key-code",
                    value: this._$_triggerWhich$_
                }, {
                    name: t + ".debugger.last-key-string",
                    value: VS._$Plugins$_.Keyboard._$Exps$_._$StringFromKeyCode$_(this._$_triggerWhich$_)
                }, {
                    name: t + ".debugger.last-typed-key",
                    value: this._$_triggerTypedKey$_
                } ]
            } ];
        }
    };
}

{
    const qS = self._$C3$_, XS = [ "ShiftLeft", "ShiftRight", "ControlLeft", "ControlRight", "AltLeft", "AltRight", "MetaLeft", "MetaRight" ];
    qS._$Plugins$_.Keyboard._$Cnds$_ = {
        _$IsKeyDown$_(t) {
            return this._$_keysDownByWhich$_.has(t);
        },
        _$OnKey$_(t) {
            return this._$_triggerWhich$_ === t;
        },
        _$OnAnyKey$_: () => !0,
        _$OnAnyKeyReleased$_: () => !0,
        _$OnKeyReleased$_(t) {
            return this._$_triggerWhich$_ === t;
        },
        _$IsKeyCodeDown$_(t) {
            return t = Math.floor(t), this._$_keysDownByWhich$_.has(t);
        },
        _$OnKeyCode$_(t) {
            return this._$_triggerWhich$_ === t;
        },
        _$OnKeyCodeReleased$_(t) {
            return this._$_triggerWhich$_ === t;
        },
        _$OnLeftRightKeyPressed$_(t) {
            const s = XS[t];
            return this._$_triggerString$_ === s;
        },
        _$OnLeftRightKeyReleased$_(t) {
            const s = XS[t];
            return this._$_triggerString$_ === s;
        },
        _$IsLeftRightKeyDown$_(t) {
            const s = XS[t];
            return this._$_keysDownByString$_.has(s);
        },
        _$IsKeyboardLockSupported$_() {
            return this._$_isKeyboardLockSupported$_;
        },
        _$OnKeyboardLocked$_: () => !0,
        _$OnKeyboardLockError$_: () => !0
    };
}

{
    const ZS = self._$C3$_;
    ZS._$Plugins$_.Keyboard._$Acts$_ = {
        async _$LockKeyboard$_(t) {
            if (!this._$_isKeyboardLockSupported$_) return;
            let s = [];
            t && (s = t.split(",")), (await this._$PostToDOMAsync$_("lock-keyboard", {
                keysArr: s
            })).isOk ? this._$Trigger$_(ZS._$Plugins$_.Keyboard._$Cnds$_._$OnKeyboardLocked$_) : this._$Trigger$_(ZS._$Plugins$_.Keyboard._$Cnds$_._$OnKeyboardLockError$_);
        },
        _$UnlockKeyboard$_() {
            this._$_isKeyboardLockSupported$_ && this._$PostToDOMAsync$_("unlock-keyboard");
        }
    };
}

{
    let KS = function(t) {
        switch (t = Math.floor(t)) {
          case 8:
            return "backspace";

          case 9:
            return "tab";

          case 13:
            return "enter";

          case 16:
            return "shift";

          case 17:
            return "control";

          case 18:
            return "alt";

          case 19:
            return "pause";

          case 20:
            return "capslock";

          case 27:
            return "esc";

          case 33:
            return "pageup";

          case 34:
            return "pagedown";

          case 35:
            return "end";

          case 36:
            return "home";

          case 37:
            return "←";

          case 38:
            return "↑";

          case 39:
            return "→";

          case 40:
            return "↓";

          case 45:
            return "insert";

          case 46:
            return "del";

          case 91:
            return "left window key";

          case 92:
            return "right window key";

          case 93:
            return "select";

          case 96:
            return "numpad 0";

          case 97:
            return "numpad 1";

          case 98:
            return "numpad 2";

          case 99:
            return "numpad 3";

          case 100:
            return "numpad 4";

          case 101:
            return "numpad 5";

          case 102:
            return "numpad 6";

          case 103:
            return "numpad 7";

          case 104:
            return "numpad 8";

          case 105:
            return "numpad 9";

          case 106:
            return "numpad *";

          case 107:
            return "numpad +";

          case 109:
            return "numpad -";

          case 110:
            return "numpad .";

          case 111:
            return "numpad /";

          case 112:
            return "F1";

          case 113:
            return "F2";

          case 114:
            return "F3";

          case 115:
            return "F4";

          case 116:
            return "F5";

          case 117:
            return "F6";

          case 118:
            return "F7";

          case 119:
            return "F8";

          case 120:
            return "F9";

          case 121:
            return "F10";

          case 122:
            return "F11";

          case 123:
            return "F12";

          case 144:
            return "numlock";

          case 145:
            return "scroll lock";

          case 186:
            return ";";

          case 187:
            return "=";

          case 188:
            return ",";

          case 189:
            return "-";

          case 190:
            return ".";

          case 191:
            return "/";

          case 192:
            return "'";

          case 219:
            return "[";

          case 220:
            return "\\";

          case 221:
            return "]";

          case 222:
            return "#";

          case 223:
            return "`";

          default:
            return String.fromCharCode(t);
        }
    };
    self._$C3$_._$Plugins$_.Keyboard._$Exps$_ = {
        _$LastKeyCode$_() {
            return this._$_triggerWhich$_;
        },
        _$StringFromKeyCode$_: t => KS(t),
        _$TypedKey$_() {
            return this._$_triggerTypedKey$_;
        }
    };
}

{
    const $S = self._$C3$_;
    $S._$Plugins$_._$Mouse$_ = class extends $S._$SDKPluginBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
    };
}

{
    let tb = function() {
        return eb._$GetSingleGlobalInstance$_()._$GetSdkInstance$_();
    };
    0;
    const sb = self._$C3$_, ib = self._$C3X$_;
    sb._$Plugins$_._$Mouse$_._$Type$_ = class extends sb._$SDKTypeBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$OnCreate$_() {}
        _$GetScriptInterfaceClass$_() {
            return self._$IMouseObjectType$_;
        }
    };
    let eb = null;
    self._$IMouseObjectType$_ = class extends self._$IObjectClass$_ {
        constructor(t) {
            super(t), eb = t, t._$GetRuntime$_()._$_GetCommonScriptInterfaces$_()._$mouse$_ = this;
        }
        _$getMouseX$_(t) {
            return tb()._$GetMousePositionForLayer$_(t)[0];
        }
        _$getMouseY$_(t) {
            return tb()._$GetMousePositionForLayer$_(t)[1];
        }
        _$getMousePosition$_(t) {
            return tb()._$GetMousePositionForLayer$_(t);
        }
        _$isMouseButtonDown$_(t) {
            return tb()._$IsMouseButtonDown$_(t);
        }
        _$setCursorStyle$_(t) {
            ib._$RequireString$_(t), tb()._$SetCursorStyle$_(t);
        }
        _$setCursorObjectClass$_(t) {
            const s = tb(), i = s._$GetRuntime$_()._$_UnwrapIObjectClass$_(t);
            s._$SetCursorObjectClass$_(i);
        }
    };
}

{
    const nb = self._$C3$_, hb = "mouse";
    let rb = null;
    nb._$Plugins$_._$Mouse$_.Instance = class extends nb._$SDKInstanceBase$_ {
        constructor(t, s) {
            super(t, hb), this._$_buttonMap$_ = [ !1, !1, !1, !1, !1 ], this._$_mouseXcanvas$_ = 0, 
            this._$_mouseYcanvas$_ = 0, this._$_triggerButton$_ = 0, this._$_triggerType$_ = 0, 
            this._$_triggerDir$_ = 0, this._$_wheelDeltaX$_ = 0, this._$_wheelDeltaY$_ = 0, 
            this._$_wheelDeltaZ$_ = 0, this._$_hasPointerLock$_ = !1, this._$_movementX$_ = 0, 
            this._$_movementY$_ = 0, this._$AddDOMMessageHandlers$_([ [ "pointer-lock-change", t => this._$_OnPointerLockChange$_(t) ], [ "pointer-lock-error", t => this._$_OnPointerLockError$_(t) ] ]);
            const i = this._$GetRuntime$_()._$Dispatcher$_();
            this._$_disposables$_ = new nb._$CompositeDisposable$_(nb._$Disposable$_._$From$_(i, "pointermove", (t => this._$_OnPointerMove$_(t.data))), nb._$Disposable$_._$From$_(i, "pointerdown", (t => this._$_OnPointerDown$_(t.data))), nb._$Disposable$_._$From$_(i, "pointerup", (t => this._$_OnPointerUp$_(t.data))), nb._$Disposable$_._$From$_(i, "dblclick", (t => this._$_OnDoubleClick$_(t.data))), nb._$Disposable$_._$From$_(i, "wheel", (t => this._$_OnMouseWheel$_(t.data))), nb._$Disposable$_._$From$_(i, "window-blur", (() => this._$_OnWindowBlur$_())));
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$_OnPointerDown$_(t) {
            "mouse" === t.pointerType && (this._$_mouseXcanvas$_ = t.pageX - this._$_runtime$_._$GetCanvasClientX$_(), 
            this._$_mouseYcanvas$_ = t.pageY - this._$_runtime$_._$GetCanvasClientY$_(), this._$_CheckButtonChanges$_(t.lastButtons, t.buttons));
        }
        _$_OnPointerMove$_(t) {
            this._$_movementX$_ = t.movementX, this._$_movementY$_ = t.movementY, this._$Trigger$_(nb._$Plugins$_._$Mouse$_._$Cnds$_._$OnMovement$_), 
            this._$_movementX$_ = 0, this._$_movementY$_ = 0, "mouse" === t.pointerType && (this._$_mouseXcanvas$_ = t.pageX - this._$_runtime$_._$GetCanvasClientX$_(), 
            this._$_mouseYcanvas$_ = t.pageY - this._$_runtime$_._$GetCanvasClientY$_(), this._$_CheckButtonChanges$_(t.lastButtons, t.buttons));
        }
        _$_OnPointerUp$_(t) {
            "mouse" === t.pointerType && this._$_CheckButtonChanges$_(t.lastButtons, t.buttons);
        }
        _$_CheckButtonChanges$_(t, s) {
            this._$_CheckButtonChange$_(t, s, 1, 0), this._$_CheckButtonChange$_(t, s, 4, 1), 
            this._$_CheckButtonChange$_(t, s, 2, 2), this._$_CheckButtonChange$_(t, s, 8, 3), 
            this._$_CheckButtonChange$_(t, s, 16, 4);
        }
        _$_CheckButtonChange$_(t, s, i, e) {
            !(t & i) && s & i ? this._$_OnMouseDown$_(e) : t & i && !(s & i) && this._$_OnMouseUp$_(e);
        }
        _$_OnMouseDown$_(t) {
            this._$_buttonMap$_[t] = !0, this._$Trigger$_(nb._$Plugins$_._$Mouse$_._$Cnds$_._$OnAnyClick$_), 
            this._$_triggerButton$_ = t, this._$_triggerType$_ = 0, this._$Trigger$_(nb._$Plugins$_._$Mouse$_._$Cnds$_._$OnClick$_), 
            this._$Trigger$_(nb._$Plugins$_._$Mouse$_._$Cnds$_._$OnObjectClicked$_);
        }
        _$_OnMouseUp$_(t) {
            this._$_buttonMap$_[t] && (this._$_buttonMap$_[t] = !1, this._$_triggerButton$_ = t, 
            this._$Trigger$_(nb._$Plugins$_._$Mouse$_._$Cnds$_._$OnRelease$_));
        }
        _$_OnDoubleClick$_(t) {
            this._$_triggerButton$_ = t.button, this._$_triggerType$_ = 1, this._$Trigger$_(nb._$Plugins$_._$Mouse$_._$Cnds$_._$OnClick$_), 
            this._$Trigger$_(nb._$Plugins$_._$Mouse$_._$Cnds$_._$OnObjectClicked$_);
        }
        _$_OnMouseWheel$_(t) {
            this._$_triggerDir$_ = t.deltaY < 0 ? 1 : 0, this._$_wheelDeltaX$_ = t.deltaX, this._$_wheelDeltaY$_ = t.deltaY, 
            this._$_wheelDeltaZ$_ = t.deltaZ, this._$Trigger$_(nb._$Plugins$_._$Mouse$_._$Cnds$_._$OnWheel$_);
        }
        _$_OnWindowBlur$_() {
            for (let t = 0, s = this._$_buttonMap$_.length; t < s; ++t) {
                if (!this._$_buttonMap$_[t]) return;
                this._$_buttonMap$_[t] = !1, this._$_triggerButton$_ = t, this._$Trigger$_(nb._$Plugins$_._$Mouse$_._$Cnds$_._$OnRelease$_);
            }
        }
        _$GetMousePositionForLayer$_(t) {
            const s = this._$_runtime$_._$GetMainRunningLayout$_(), i = this._$_mouseXcanvas$_, e = this._$_mouseYcanvas$_;
            if (void 0 === t) return s._$GetLayerByIndex$_(0)._$CanvasCssToLayer_DefaultTransform$_(i, e);
            {
                const n = s._$GetLayer$_(t);
                return n ? n._$CanvasCssToLayer$_(i, e) : [ 0, 0 ];
            }
        }
        _$IsMouseButtonDown$_(t) {
            return t = Math.floor(t), !!this._$_buttonMap$_[t];
        }
        _$_IsMouseOverCanvas$_() {
            return this._$_mouseXcanvas$_ >= 0 && this._$_mouseYcanvas$_ >= 0 && this._$_mouseXcanvas$_ < this._$_runtime$_._$GetCanvasCssWidth$_() && this._$_mouseYcanvas$_ < this._$_runtime$_._$GetCanvasCssHeight$_();
        }
        _$SetCursorStyle$_(t) {
            rb !== t && (rb = t, this._$PostToDOM$_("cursor", t));
        }
        async _$SetCursorObjectClass$_(t) {
            if (nb._$Platform$_._$IsMobile$_ || !t) return;
            const s = t._$GetFirstPicked$_();
            if (!s) return;
            const i = s._$GetWorldInfo$_(), e = s._$GetCurrentImageInfo$_();
            if (!i || !e) return;
            if (rb === e) return;
            rb = e;
            const n = `url(${await e._$ExtractImageToBlobURL$_()}) ${Math.round(i._$GetOriginX$_() * e._$GetWidth$_())} ${Math.round(i._$GetOriginY$_() * e._$GetHeight$_())}, auto`;
            this._$PostToDOM$_("cursor", n);
        }
        _$_OnPointerLockChange$_(t) {
            this._$_UpdatePointerLockState$_(t["has-pointer-lock"]);
        }
        _$_OnPointerLockError$_(t) {
            this._$_UpdatePointerLockState$_(t["has-pointer-lock"]), this._$Trigger$_(nb._$Plugins$_._$Mouse$_._$Cnds$_._$OnPointerLockError$_);
        }
        _$_UpdatePointerLockState$_(t) {
            this._$_hasPointerLock$_ !== t && (this._$_hasPointerLock$_ = t, this._$_hasPointerLock$_ ? this._$Trigger$_(nb._$Plugins$_._$Mouse$_._$Cnds$_._$OnPointerLocked$_) : this._$Trigger$_(nb._$Plugins$_._$Mouse$_._$Cnds$_._$OnPointerUnlocked$_));
        }
        _$GetDebuggerProperties$_() {
            const t = "plugins.mouse";
            return [ {
                title: t + ".name",
                properties: [ {
                    name: t + ".debugger.absolute-position",
                    value: this._$_mouseXcanvas$_ + "," + this._$_mouseYcanvas$_
                }, {
                    name: t + ".debugger.left-button",
                    value: this._$_buttonMap$_[0]
                }, {
                    name: t + ".debugger.middle-button",
                    value: this._$_buttonMap$_[1]
                }, {
                    name: t + ".debugger.right-button",
                    value: this._$_buttonMap$_[2]
                }, {
                    name: t + ".debugger.button-4",
                    value: this._$_buttonMap$_[3]
                }, {
                    name: t + ".debugger.button-5",
                    value: this._$_buttonMap$_[4]
                } ]
            }, {
                title: t + ".debugger.position-on-each-layer",
                properties: this._$_runtime$_._$GetMainRunningLayout$_()._$GetLayers$_().map((t => ({
                    name: "$" + t._$GetName$_(),
                    value: t._$CanvasCssToLayer$_(this._$_mouseXcanvas$_, this._$_mouseYcanvas$_).join(", ")
                })))
            } ];
        }
    };
}

{
    const ob = self._$C3$_;
    ob._$Plugins$_._$Mouse$_._$Cnds$_ = {
        _$OnClick$_(t, s) {
            return this._$_triggerButton$_ === t && this._$_triggerType$_ === s;
        },
        _$OnAnyClick$_: () => !0,
        _$IsButtonDown$_(t) {
            return this._$_buttonMap$_[t];
        },
        _$OnRelease$_(t) {
            return this._$_triggerButton$_ === t;
        },
        _$IsOverObject$_(t) {
            const s = this._$_runtime$_._$GetCurrentCondition$_()._$IsInverted$_(), i = [];
            return this._$_IsMouseOverCanvas$_() && i.push([ this._$_mouseXcanvas$_, this._$_mouseYcanvas$_ ]), 
            ob.xor(this._$_runtime$_._$GetCollisionEngine$_()._$TestAndSelectCanvasPointOverlap$_(t, i, s), s);
        },
        _$OnObjectClicked$_(t, s, i) {
            if (t !== this._$_triggerButton$_ || s !== this._$_triggerType$_) return !1;
            if (!this._$_IsMouseOverCanvas$_()) return !1;
            const e = this._$_mouseXcanvas$_, n = this._$_mouseYcanvas$_;
            return this._$_runtime$_._$GetCollisionEngine$_()._$TestAndSelectCanvasPointOverlap$_(i, [ [ e, n ] ], !1);
        },
        _$OnWheel$_(t) {
            return 2 === t || this._$_triggerDir$_ === t;
        },
        _$OnPointerLocked$_: () => !0,
        _$OnPointerUnlocked$_: () => !0,
        _$OnPointerLockError$_: () => !0,
        _$HasPointerLock$_() {
            return this._$_hasPointerLock$_;
        },
        _$OnMovement$_: () => !0
    };
}

{
    const ab = self._$C3$_, ub = [ "auto", "pointer", "text", "crosshair", "move", "help", "wait", "none" ], lb = [ "auto", "all-scroll", "none", "help", "pointer", "progress", "wait", "cell", "crosshair", "text", "vertical-text", "alias", "copy", "move", "not-allowed", "grab", "grabbing", "col-resize", "row-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out" ];
    ab._$Plugins$_._$Mouse$_._$Acts$_ = {
        _$SetCursor$_(t) {
            this._$SetCursorStyle$_(ub[t]);
        },
        _$SetCursor2$_(t) {
            this._$SetCursorStyle$_(lb[t]);
        },
        _$SetCursorSprite$_(t) {
            this._$SetCursorObjectClass$_(t);
        },
        _$RequestPointerLock$_(t) {
            this._$_PostToDOMMaybeSync$_("request-pointer-lock", {
                unadjustedMovement: t
            });
        },
        _$ReleasePointerLock$_() {
            this._$PostToDOM$_("release-pointer-lock");
        }
    };
}

self._$C3$_._$Plugins$_._$Mouse$_._$Exps$_ = {
    _$X$_(t) {
        return this._$GetMousePositionForLayer$_(t)[0];
    },
    _$Y$_(t) {
        return this._$GetMousePositionForLayer$_(t)[1];
    },
    _$AbsoluteX$_() {
        return this._$_mouseXcanvas$_;
    },
    _$AbsoluteY$_() {
        return this._$_mouseYcanvas$_;
    },
    _$MovementX$_() {
        return this._$_movementX$_;
    },
    _$MovementY$_() {
        return this._$_movementY$_;
    },
    _$WheelDeltaX$_() {
        return this._$_wheelDeltaX$_;
    },
    _$WheelDeltaY$_() {
        return this._$_wheelDeltaY$_;
    },
    _$WheelDeltaZ$_() {
        return this._$_wheelDeltaZ$_;
    }
};

{
    const cb = self._$C3$_;
    cb._$Plugins$_.Text = class extends cb._$SDKPluginBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
    };
}

{
    const fb = self._$C3$_;
    fb._$Plugins$_.Text._$Type$_ = class extends fb._$SDKTypeBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$OnCreate$_() {}
        _$LoadTextures$_(t) {}
        _$ReleaseTextures$_() {}
    };
}

{
    const db = self._$C3$_, pb = self._$C3X$_, mb = [ 0, 0, 0 ], gb = 0, yb = 1, Mb = 2, wb = 3, Sb = 4, bb = 5, Tb = 6, vb = 7, xb = 8, Ib = 9, Gb = 10, Cb = 11, _b = 12, Eb = 13, Db = 15, Ab = [ "left", "center", "right" ], Nb = [ "top", "center", "bottom" ], Lb = [ "ltr", "rtl" ], Ob = [ "word", "cjk", "character" ], Rb = new db.Rect, Pb = new db._$Quad$_, kb = new db._$Color$_, Fb = db._$New$_(db._$Vector2$_), jb = new Map([ [ "b", "strong" ], [ "i", "em" ], [ "s", "s" ], [ "u", "u" ], [ "iconoffsety", null ] ]);
    db._$Plugins$_.Text.Instance = class extends db._$SDKWorldInstanceBase$_ {
        constructor(t, s) {
            if (super(t), this._$_text$_ = "", this._$_enableBBcode$_ = !0, this._$_faceName$_ = "Arial", 
            this._$_ptSize$_ = 12, this._$_lineHeightOffset$_ = 0, this._$_isBold$_ = !1, this._$_isItalic$_ = !1, 
            this._$_color$_ = db._$New$_(db._$Color$_), this._$_horizontalAlign$_ = 0, this._$_verticalAlign$_ = 0, 
            this._$_wrapMode$_ = "word", this._$_textDirection$_ = 0, this._$_resolutionMode$_ = "auto", 
            this._$_fixedScaleFactor$_ = 1, this._$_iconObjectClass$_ = null, this._$_htmlString$_ = "", 
            this._$_isHtmlStringUpToDate$_ = !1, this._$_readAloud$_ = !1, this._$_screenReaderText$_ = null, 
            this._$_typewriterStartTime$_ = -1, this._$_typewriterEndTime$_ = -1, this._$_typewriterLength$_ = 0, 
            this._$_rendererText$_ = db._$New$_(db._$Gfx$_._$RendererText$_, this._$_runtime$_._$GetRenderer$_(), {
                timeout: 5
            }), this._$_rendererText$_._$ontextureupdate$_ = () => this._$_runtime$_._$UpdateRender$_(), 
            this._$_animationframeimagechange_handler$_ = () => this._$_OnIconObjectClassImageChanged$_(), 
            this._$_pendingUpdateIconSet$_ = !1, s) {
                this._$_text$_ = s[gb], this._$_enableBBcode$_ = !!s[yb], this._$_faceName$_ = s[Mb], 
                this._$_ptSize$_ = s[wb], this._$_lineHeightOffset$_ = s[Sb], this._$_isBold$_ = !!s[bb], 
                this._$_isItalic$_ = !!s[Tb], this._$_horizontalAlign$_ = s[xb], this._$_verticalAlign$_ = s[Ib], 
                this._$_wrapMode$_ = Ob[s[Gb]], this._$_textDirection$_ = s[Cb], this._$_SetIconObjectClass$_(this._$_runtime$_._$GetObjectClassBySID$_(s[_b]));
                const t = s[vb];
                this._$_color$_._$setRgb$_(t[0], t[1], t[2]), this._$GetWorldInfo$_()._$SetVisible$_(s[Eb]), 
                this._$_readAloud$_ = !!s[Db];
            }
            this._$_UpdateTextSettings$_(), this._$_UpdateScreenReaderText$_();
        }
        _$Release$_() {
            this._$_SetIconObjectClass$_(null), this._$_CancelTypewriter$_(), this._$_screenReaderText$_ && (this._$_screenReaderText$_._$Release$_(), 
            this._$_screenReaderText$_ = null), this._$_rendererText$_._$Release$_(), this._$_rendererText$_ = null, 
            super._$Release$_();
        }
        _$_UpdateTextSettings$_() {
            const t = this._$_rendererText$_;
            t._$SetText$_(this._$_text$_), t._$SetBBCodeEnabled$_(this._$_enableBBcode$_), this._$_rendererText$_._$IsBBCodeEnabled$_() && this._$_iconObjectClass$_ ? this._$_rendererText$_._$SetIconSet$_(this._$GetRuntime$_()._$GetTextIconSet$_(this._$_iconObjectClass$_)) : this._$_rendererText$_._$SetIconSet$_(null), 
            t._$SetIconSmoothing$_("nearest" !== this._$_runtime$_._$GetSampling$_()), t._$SetFontName$_(this._$_faceName$_), 
            t._$SetLineHeight$_(this._$_lineHeightOffset$_), t._$SetBold$_(this._$_isBold$_), 
            t._$SetItalic$_(this._$_isItalic$_), t._$SetColor$_(this._$_color$_), t._$SetHorizontalAlignment$_(Ab[this._$_horizontalAlign$_]), 
            t._$SetVerticalAlignment$_(Nb[this._$_verticalAlign$_]), t._$SetWordWrapMode$_(this._$_wrapMode$_), 
            t._$SetTextDirection$_(Lb[this._$_textDirection$_]);
        }
        _$_UpdateTextSize$_() {
            const t = this._$GetWorldInfo$_();
            this._$_rendererText$_._$SetFontSize$_(this._$_ptSize$_), this._$_rendererText$_._$SetFontSizeScale$_(t._$GetSceneGraphScale$_());
            const s = t._$GetLayer$_();
            let i;
            "auto" === this._$_resolutionMode$_ ? i = s._$GetResolutionScaleFactorToZ$_(t._$GetTotalZElevation$_()) : "fixed" === this._$_resolutionMode$_ && (i = this._$_fixedScaleFactor$_), 
            t._$HasMesh$_() && i !== this._$_rendererText$_._$GetZoom$_() && t._$SetMeshChanged$_(!0), 
            this._$_rendererText$_._$SetSize$_(t._$GetWidth$_(), t._$GetHeight$_(), i);
        }
        _$_SetIconObjectClass$_(t) {
            t && (t._$IsFamily$_() || t._$GetPlugin$_().constructor !== db._$Plugins$_._$Sprite$_) || t !== this._$_iconObjectClass$_ && (this._$_iconObjectClass$_ && this._$_iconObjectClass$_._$Dispatcher$_().removeEventListener("animationframeimagechange", this._$_animationframeimagechange_handler$_), 
            this._$_iconObjectClass$_ = t, this._$_iconObjectClass$_ && this._$_iconObjectClass$_._$Dispatcher$_().addEventListener("animationframeimagechange", this._$_animationframeimagechange_handler$_), 
            this._$_UpdateTextSettings$_(), this._$_isHtmlStringUpToDate$_ = !1, this._$_runtime$_._$UpdateRender$_());
        }
        _$_OnIconObjectClassImageChanged$_() {
            this._$_runtime$_._$DeleteTextIconSet$_(this._$_iconObjectClass$_), this._$_runtime$_._$UpdateRender$_(), 
            this._$_pendingUpdateIconSet$_ = !0;
        }
        _$_UpdateScreenReaderText$_() {
            if (this._$_readAloud$_) {
                let t = this._$_text$_;
                this._$_enableBBcode$_ && (t = db._$BBString$_._$StripAnyTags$_(t)), this._$_screenReaderText$_ ? this._$_screenReaderText$_._$SetText$_(t) : this._$_screenReaderText$_ = db._$New$_(db._$ScreenReaderText$_, this._$_runtime$_, t);
            } else this._$_screenReaderText$_ && (this._$_screenReaderText$_._$Release$_(), 
            this._$_screenReaderText$_ = null);
        }
        _$Draw$_(t) {
            const s = this._$GetWorldInfo$_();
            this._$_UpdateTextSize$_(), this._$_pendingUpdateIconSet$_ && (this._$_pendingUpdateIconSet$_ = !1, 
            this._$_rendererText$_._$IsBBCodeEnabled$_() && this._$_iconObjectClass$_ && this._$_rendererText$_._$SetIconSet$_(this._$GetRuntime$_()._$GetTextIconSet$_(this._$_iconObjectClass$_)));
            const i = this._$_rendererText$_._$GetTexture$_();
            if (!i) return;
            const e = s._$GetLayer$_();
            if (0 === s._$GetAngle$_() && 0 === e._$GetAngle$_() && 0 === s._$GetTotalZElevation$_() && !s._$HasMesh$_() && e._$RendersIn2DMode$_()) {
                const n = s._$GetBoundingQuad$_(), [h, r] = e._$LayerToDrawSurface$_(n._$getTlx$_(), n._$getTly$_()), [o, a] = e._$LayerToDrawSurface$_(n._$getBrx$_(), n._$getBry$_()), u = h - Math.round(h), l = r - Math.round(r);
                Rb.set(h, r, o, a), Rb.offset(-u, -l), Pb._$setFromRect$_(Rb);
                const [c, f] = t._$GetRenderTargetSize$_(t._$GetRenderTarget$_());
                this._$_runtime$_._$GetCanvasManager$_()._$SetDeviceTransform$_(t, c, f), t._$SetTexture$_(i), 
                t._$Quad3$_(Pb, this._$_rendererText$_._$GetTexRect$_()), e._$_SetTransform$_(t);
            } else t._$SetTexture$_(i), s._$HasMesh$_() ? this._$_DrawMesh$_(s, t) : this._$_DrawStandard$_(s, t);
        }
        _$_DrawStandard$_(t, s) {
            let i = t._$GetBoundingQuad$_();
            this._$_runtime$_._$IsPixelRoundingEnabled$_() && (i = this._$_PixelRoundQuad$_(i)), 
            s._$Quad3$_(i, this._$_rendererText$_._$GetTexRect$_());
        }
        _$_DrawMesh$_(t, s) {
            const i = t._$GetTransformedMesh$_();
            if (t._$IsMeshChanged$_()) {
                t._$CalculateBbox$_(Rb, Pb, !1);
                let s = Pb;
                this._$_runtime$_._$IsPixelRoundingEnabled$_() && (s = this._$_PixelRoundQuad$_(s)), 
                i._$CalculateTransformedMesh$_(t._$GetSourceMesh$_(), s, this._$_rendererText$_._$GetTexRect$_()), 
                t._$SetMeshChanged$_(!1);
            }
            i._$Draw$_(s);
        }
        _$_PixelRoundQuad$_(t) {
            const s = t._$getTlx$_() - Math.round(t._$getTlx$_()), i = t._$getTly$_() - Math.round(t._$getTly$_());
            return 0 === s && 0 === i ? t : (Pb._$copy$_(t), Pb.offset(-s, -i), Pb);
        }
        _$GetCurrentSurfaceSize$_() {
            const t = this._$_rendererText$_._$GetTexture$_();
            return t ? [ t._$GetWidth$_(), t._$GetHeight$_() ] : [ 100, 100 ];
        }
        _$GetCurrentTexRect$_() {
            return this._$_rendererText$_._$GetTexRect$_();
        }
        _$IsCurrentTexRotated$_() {
            return !1;
        }
        _$SaveToJson$_() {
            const t = {
                t: this._$_text$_,
                c: this._$_color$_.toJSON(),
                fn: this._$_faceName$_,
                ps: this._$_ptSize$_
            };
            return this._$_enableBBcode$_ && (t.bbc = this._$_enableBBcode$_), 0 !== this._$_horizontalAlign$_ && (t.ha = this._$_horizontalAlign$_), 
            0 !== this._$_verticalAlign$_ && (t.va = this._$_verticalAlign$_), "word" !== this._$_wrapMode$_ && (t.wr = this._$_wrapMode$_), 
            0 !== this._$_lineHeightOffset$_ && (t.lho = this._$_lineHeightOffset$_), this._$_isBold$_ && (t.b = this._$_isBold$_), 
            this._$_isItalic$_ && (t.i = this._$_isItalic$_), -1 !== this._$_typewriterEndTime$_ && (t.tw = {
                st: this._$_typewriterStartTime$_,
                en: this._$_typewriterEndTime$_,
                l: this._$_typewriterLength$_
            }), this._$_iconObjectClass$_ && (t.ioc = this._$_iconObjectClass$_._$GetSID$_()), 
            "fixed" === this._$_resolutionMode$_ && (t.fs = this._$_fixedScaleFactor$_), t;
        }
        _$LoadFromJson$_(t) {
            if (this._$_CancelTypewriter$_(), this._$_text$_ = t.t, this._$_color$_._$setFromJSON$_(t.c), 
            this._$_faceName$_ = t.fn, this._$_ptSize$_ = t.ps, this._$_enableBBcode$_ = !!t.hasOwnProperty("bbc") && t.bbc, 
            this._$_horizontalAlign$_ = t.hasOwnProperty("ha") ? t.ha : 0, this._$_verticalAlign$_ = t.hasOwnProperty("va") ? t.va : 0, 
            t.hasOwnProperty("wr")) {
                const s = t.wr;
                this._$_wrapMode$_ = "boolean" == typeof s ? s ? "word" : "character" : s;
            } else this._$_wrapMode$_ = "word";
            if (this._$_lineHeightOffset$_ = t.hasOwnProperty("lho") ? t.lho : 0, this._$_isBold$_ = !!t.hasOwnProperty("b") && t.b, 
            this._$_isItalic$_ = !!t.hasOwnProperty("i") && t.i, t.hasOwnProperty("tw")) {
                const s = t.tw;
                this._$_typewriterStartTime$_ = s.st, this._$_typewriterEndTime$_ = s.en, this._$_typewriterLength$_ = s.l;
            }
            if (t.hasOwnProperty("ioc")) {
                const s = this._$GetRuntime$_()._$GetObjectClassBySID$_(t.ioc);
                s && this._$_SetIconObjectClass$_(s);
            } else this._$_SetIconObjectClass$_(null);
            t.hasOwnProperty("fs") ? (this._$_resolutionMode$_ = "fixed", this._$_fixedScaleFactor$_ = t.fs) : this._$_resolutionMode$_ = "auto", 
            this._$_UpdateTextSettings$_(), this._$_UpdateScreenReaderText$_(), this._$_isHtmlStringUpToDate$_ = !1, 
            -1 !== this._$_typewriterEndTime$_ && this._$_StartTicking$_();
        }
        _$GetPropertyValueByIndex$_(t) {
            switch (t) {
              case gb:
                return this._$GetText$_();

              case yb:
                return this._$_enableBBcode$_;

              case Mb:
                return this._$_GetFontFace$_();

              case wb:
                return this._$_GetFontSize$_();

              case Sb:
                return this._$_GetLineHeight$_();

              case bb:
                return this._$_IsBold$_();

              case Tb:
                return this._$_IsItalic$_();

              case vb:
                return mb[0] = this._$_color$_._$getR$_(), mb[1] = this._$_color$_._$getG$_(), mb[2] = this._$_color$_._$getB$_(), 
                mb;

              case xb:
                return this._$_GetHAlign$_();

              case Ib:
                return this._$_GetVAlign$_();

              case Gb:
                return this._$_GetWrapMode$_();

              case Db:
                return this._$_IsReadAloud$_();
            }
        }
        _$SetPropertyValueByIndex$_(t, s) {
            switch (t) {
              case gb:
                this._$_SetText$_(s);
                break;

              case yb:
                if (this._$_enableBBcode$_ === !!s) return;
                this._$_enableBBcode$_ = !!s, this._$_UpdateTextSettings$_();
                break;

              case Mb:
                this._$_SetFontFace$_(s);
                break;

              case wb:
                this._$_SetFontSize$_(s);
                break;

              case Sb:
                this._$_SetLineHeight$_(s);
                break;

              case bb:
                this._$_SetBold$_(s);
                break;

              case Tb:
                this._$_SetItalic$_(s);
                break;

              case vb:
                const t = this._$_color$_, i = s;
                if (t._$getR$_() === i[0] && t._$getG$_() === i[1] && t._$getB$_() === i[2]) return;
                this._$_color$_._$setRgb$_(i[0], i[1], i[2]), this._$_UpdateTextSettings$_();
                break;

              case xb:
                this._$_SetHAlign$_(s);
                break;

              case Ib:
                this._$_SetVAlign$_(s);
                break;

              case Gb:
                this._$_SetWrapMode$_(s);
            }
        }
        _$SetPropertyColorOffsetValueByIndex$_(t, s, i, e) {
            0 === s && 0 === i && 0 === e || t !== vb || (this._$_color$_._$addRgb$_(s, i, e), 
            this._$_UpdateTextSettings$_());
        }
        _$_SetText$_(t) {
            this._$_text$_ !== t && (this._$_text$_ = t, this._$_rendererText$_._$SetText$_(t), 
            this._$_UpdateScreenReaderText$_(), this._$_isHtmlStringUpToDate$_ = !1, this._$_runtime$_._$UpdateRender$_());
        }
        _$GetText$_() {
            return this._$_text$_;
        }
        _$_StartTypewriter$_(t, s) {
            this._$_UpdateTextSize$_(), this._$_SetText$_(t), this._$_typewriterStartTime$_ = this._$_runtime$_._$GetWallTime$_(), 
            this._$_typewriterEndTime$_ = this._$_typewriterStartTime$_ + s / this._$GetInstance$_()._$GetActiveTimeScale$_(), 
            this._$_typewriterLength$_ = this._$_rendererText$_._$GetLengthInGraphemes$_(), 
            this._$_rendererText$_._$SetDrawMaxCharacterCount$_(0), this._$_StartTicking$_();
        }
        _$_CancelTypewriter$_() {
            this._$_typewriterStartTime$_ = -1, this._$_typewriterEndTime$_ = -1, this._$_typewriterLength$_ = 0, 
            this._$_rendererText$_._$SetDrawMaxCharacterCount$_(-1), this._$_StopTicking$_();
        }
        _$_FinishTypewriter$_() {
            -1 !== this._$_typewriterEndTime$_ && (this._$_CancelTypewriter$_(), this._$Trigger$_(db._$Plugins$_.Text._$Cnds$_._$OnTypewriterTextFinished$_), 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$_SetFontFace$_(t) {
            this._$_faceName$_ !== t && (this._$_faceName$_ = t, this._$_rendererText$_._$SetFontName$_(t), 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$_GetFontFace$_() {
            return this._$_faceName$_;
        }
        _$_SetBold$_(t) {
            t = !!t, this._$_isBold$_ !== t && (this._$_isBold$_ = t, this._$_rendererText$_._$SetBold$_(t), 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$_IsBold$_() {
            return this._$_isBold$_;
        }
        _$_SetItalic$_(t) {
            t = !!t, this._$_isItalic$_ !== t && (this._$_isItalic$_ = t, this._$_rendererText$_._$SetItalic$_(t), 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$_IsItalic$_() {
            return this._$_isItalic$_;
        }
        _$_SetFontSize$_(t) {
            this._$_ptSize$_ !== t && (this._$_ptSize$_ = t, this._$_runtime$_._$UpdateRender$_());
        }
        _$_GetFontSize$_() {
            return this._$_ptSize$_;
        }
        _$_SetFontColor$_(t) {
            this._$_color$_._$equalsIgnoringAlpha$_(t) || (this._$_color$_._$copyRgb$_(t), this._$_rendererText$_._$SetColor$_(this._$_color$_), 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$_GetFontColor$_() {
            return this._$_color$_;
        }
        _$_SetLineHeight$_(t) {
            this._$_lineHeightOffset$_ !== t && (this._$_lineHeightOffset$_ = t, this._$_UpdateTextSettings$_(), 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$_GetLineHeight$_() {
            return this._$_lineHeightOffset$_;
        }
        _$_SetHAlign$_(t) {
            this._$_horizontalAlign$_ !== t && (this._$_horizontalAlign$_ = t, this._$_UpdateTextSettings$_(), 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$_GetHAlign$_() {
            return this._$_horizontalAlign$_;
        }
        _$_SetVAlign$_(t) {
            this._$_verticalAlign$_ !== t && (this._$_verticalAlign$_ = t, this._$_UpdateTextSettings$_(), 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$_GetVAlign$_() {
            return this._$_verticalAlign$_;
        }
        _$_SetWrapModeByIndex$_(t) {
            this._$_SetWrapMode$_(Ob[t]);
        }
        _$_SetWrapMode$_(t) {
            this._$_wrapMode$_ !== t && (this._$_wrapMode$_ = t, this._$_UpdateTextSettings$_(), 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$_GetWrapMode$_() {
            return this._$_wrapMode$_;
        }
        _$_SetTextDirection$_(t) {
            this._$_textDirection$_ !== t && (this._$_textDirection$_ = t, this._$_UpdateTextSettings$_(), 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$_GetTextDirection$_() {
            return this._$_textDirection$_;
        }
        _$_SetReadAloud$_(t) {
            this._$_readAloud$_ = !!t, this._$_UpdateScreenReaderText$_();
        }
        _$_IsReadAloud$_() {
            return this._$_readAloud$_;
        }
        _$_SetResolutionMode$_(t) {
            this._$_resolutionMode$_ !== t && (this._$_resolutionMode$_ = t, this._$_runtime$_._$UpdateRender$_());
        }
        _$_GetResolutionMode$_() {
            return this._$_resolutionMode$_;
        }
        _$_SetFixedScaleFactor$_(t) {
            this._$_fixedScaleFactor$_ !== t && (this._$_fixedScaleFactor$_ = t, "fixed" === this._$_resolutionMode$_ && this._$_runtime$_._$UpdateRender$_());
        }
        _$_GetFixedScaleFactor$_() {
            return this._$_fixedScaleFactor$_;
        }
        _$_GetTextWidth$_() {
            return this._$_UpdateTextSize$_(), this._$_rendererText$_._$GetTextWidth$_();
        }
        _$_GetTextHeight$_() {
            return this._$_UpdateTextSize$_(), this._$_rendererText$_._$GetTextHeight$_();
        }
        _$_GetTagAtPosition$_(t, s) {
            this._$_UpdateTextSize$_();
            const i = this._$GetWorldInfo$_();
            Fb.set(t - i._$GetX$_(), s - i._$GetY$_()), Fb.rotate(-i._$GetAngle$_()), Fb.offset(i._$GetWidth$_() * i._$GetOriginX$_(), i._$GetHeight$_() * i._$GetOriginY$_()), 
            Fb._$divide$_(i._$GetWidth$_(), i._$GetHeight$_()), Fb.scale(this._$_rendererText$_._$GetWidth$_(), this._$_rendererText$_._$GetHeight$_());
            const e = this._$_rendererText$_._$HitTestFragment$_(Fb._$getX$_(), Fb._$getY$_());
            if (e) {
                const t = e._$GetStyleTag$_("tag");
                if (t) return t._$param$_;
            }
            return "";
        }
        _$_HasTagAtPosition$_(t, s, i) {
            const e = this._$_GetTagAtPosition$_(s, i);
            return e && db._$equalsNoCase$_(t, e);
        }
        _$_GetTagPosition$_(t, s) {
            this._$_UpdateTextSize$_(), s = Math.floor(s);
            const i = this._$_rendererText$_._$FindFragmentWithTag$_(t, s);
            if (!i) return null;
            const e = this._$GetWorldInfo$_(), n = this._$_rendererText$_._$GetDrawScale$_(), h = i._$GetPosX$_(), r = i._$GetPosY$_() - (i._$GetHeight$_() - i._$GetFontBoundingBoxDescent$_()) * n, o = i._$GetWidth$_() * n / this._$_rendererText$_._$GetWidth$_() * e._$GetWidth$_(), a = i._$GetHeight$_() * n / this._$_rendererText$_._$GetHeight$_() * e._$GetHeight$_();
            return Fb.set(h, r), Fb._$divide$_(this._$_rendererText$_._$GetWidth$_(), this._$_rendererText$_._$GetHeight$_()), 
            Fb.scale(e._$GetWidth$_(), e._$GetHeight$_()), Fb.offset(-e._$GetWidth$_() * e._$GetOriginX$_(), -e._$GetHeight$_() * e._$GetOriginY$_()), 
            Fb.rotate(e._$GetAngle$_()), Fb.offset(e._$GetX$_(), e._$GetY$_()), {
                x: Fb._$getX$_(),
                y: Fb._$getY$_(),
                width: o,
                height: a
            };
        }
        _$_GetTagCount$_(t) {
            return this._$_UpdateTextSize$_(), this._$_rendererText$_._$CountFragmentsWithTag$_(t);
        }
        _$_GetHTMLCloseTag$_(t) {
            let s = jb.get(t);
            return null === s ? "" : (s || (s = "span"), `</${s || "span"}>`);
        }
        _$_GetHTMLOpenTag$_(t, s) {
            let i = jb.get(t);
            if (null === i) return "";
            switch (i || (i = "span"), t) {
              case "color":
                return `<${i} style="color: ${s}">`;

              case "font":
                return `<${i} style="font-family: '${s}'">`;

              case "opacity":
                return `<${i} style="opacity: ${s}%">`;

              case "size":
                return `<${i} style="font-size: ${s}pt">`;

              case "background":
                return `<${i} style="background-color: ${s}">`;

              case "hide":
                return `<${i} style="visibility: hidden">`;

              case "class":
                return `<${i} class="${s}">`;

              case "tag":
                return `<${i} data-tag="${s}">`;

              default:
                return `<${i}>`;
            }
        }
        async _$_UpdateHTMLString$_() {
            if (this._$_isHtmlStringUpToDate$_) return this._$_htmlString$_;
            const t = new db._$BBString$_(this._$_text$_, {
                _$noEscape$_: !0
            })._$toFragmentList$_(), s = new Map;
            let i = '<span class="c3-text"';
            const e = [];
            e.push(`font-family: '${this._$_GetFontFace$_()}';`), this._$_IsBold$_() && e.push("font-weight: bold;"), 
            this._$_IsItalic$_() && e.push("font-style: italic;"), "character" === this._$_GetWrapMode$_() && e.push("word-break: break-all;"), 
            i += ` style="${e.join(" ")}">`;
            const n = this._$_iconObjectClass$_ ? this._$GetRuntime$_()._$GetTextIconSet$_(this._$_iconObjectClass$_) : null;
            if (this._$_iconObjectClass$_) {
                const i = db._$New$_(db._$PromiseThrottle$_), e = [], h = new Map;
                for (const s of t) if (s._$IsIcon$_()) {
                    const t = s._$GetTextIcon$_(n);
                    if (t) {
                        const s = t._$GetSource$_()._$GetImageInfo$_()._$GetImageAsset$_();
                        if (h.has(s)) continue;
                        h.set(s, null), e.push(i._$Add$_((async () => {
                            const t = await s._$LoadToDrawable$_();
                            h.set(s, t);
                        })));
                    }
                }
                await Promise.all(e);
                const r = [];
                for (const e of t) if (e._$IsIcon$_()) {
                    const t = e._$GetTextIcon$_(n);
                    if (t) {
                        const e = t._$GetSource$_(), n = e._$GetImageInfo$_()._$GetImageAsset$_();
                        r.push(i._$Add$_((async () => {
                            const i = await e._$GetImageInfo$_()._$ExtractImageToBlobURL$_(h.get(n));
                            s.set(t, i);
                        })));
                    }
                }
                await Promise.all(r);
                for (const t of h.values()) t instanceof ImageBitmap && t.close && t.close();
            }
            const h = new Map;
            for (const e of t) {
                const t = e._$GetStyleMap$_();
                let r = [ ...h.keys() ];
                r.reverse();
                for (const s of r) t.has(s) && t.get(s) === h.get(s) || (h.delete(s), i += this._$_GetHTMLCloseTag$_(s));
                for (const [s, e] of t) h.has(s) || (h.set(s, e), i += this._$_GetHTMLOpenTag$_(s, e));
                if (e._$IsText$_() && (i += db._$ReplaceAll$_(db._$EscapeHTML$_(e._$GetCharacterArray$_().join("")), "\n", "<br>")), 
                e._$IsIcon$_() && n) {
                    const h = e._$GetTextIcon$_(n);
                    if (h) {
                        const n = s.get(h);
                        if (n) {
                            const s = [];
                            let r = "0.2em";
                            const o = t.get("iconoffsety");
                            if (o) {
                                let t = o.trim();
                                r = t.endsWith("%") ? parseFloat(t) / 100 + "em" : t + "px";
                            }
                            s.push(`top: ${r}`), "nearest" === this._$_runtime$_._$GetSampling$_() && s.push("image-rendering: pixelated"), 
                            i += `<img class="c3-text-icon" data-icon="${e._$GetIconParameter$_()}" width="${h._$GetWidth$_()}" height="${h._$GetHeight$_()}" style="${s.join(";")}" src="${n}">`;
                        }
                    }
                }
            }
            const r = [ ...h.keys() ];
            r.reverse();
            for (const t of r) i += this._$_GetHTMLCloseTag$_(t);
            return i += "</span>", this._$_htmlString$_ = i, this._$_isHtmlStringUpToDate$_ = !0, 
            this._$_htmlString$_;
        }
        _$Tick$_() {
            const t = this._$_runtime$_._$GetWallTime$_();
            if (t >= this._$_typewriterEndTime$_) this._$_CancelTypewriter$_(), this._$Trigger$_(db._$Plugins$_.Text._$Cnds$_._$OnTypewriterTextFinished$_), 
            this._$_runtime$_._$UpdateRender$_(); else {
                let s = db._$relerp$_(this._$_typewriterStartTime$_, this._$_typewriterEndTime$_, t, 0, this._$_typewriterLength$_);
                s = Math.floor(s), s !== this._$_rendererText$_._$GetDrawMaxCharacterCount$_() && (this._$_rendererText$_._$SetDrawMaxCharacterCount$_(s), 
                this._$_runtime$_._$UpdateRender$_());
            }
        }
        _$GetDebuggerProperties$_() {
            const t = "plugins.text";
            return [ {
                title: t + ".name",
                properties: [ {
                    name: t + ".properties.text.name",
                    value: this._$GetText$_(),
                    _$onedit$_: t => this._$_SetText$_(t)
                }, {
                    name: t + ".properties.font.name",
                    value: this._$_GetFontFace$_(),
                    _$onedit$_: t => this._$_SetFontFace$_(t)
                }, {
                    name: t + ".properties.size.name",
                    value: this._$_GetFontSize$_(),
                    _$onedit$_: t => this._$_SetFontSize$_(t)
                }, {
                    name: t + ".properties.line-height.name",
                    value: this._$_GetLineHeight$_(),
                    _$onedit$_: t => this._$_SetLineHeight$_(t)
                }, {
                    name: t + ".properties.bold.name",
                    value: this._$_IsBold$_(),
                    _$onedit$_: t => this._$_SetBold$_(t)
                }, {
                    name: t + ".properties.italic.name",
                    value: this._$_IsItalic$_(),
                    _$onedit$_: t => this._$_SetItalic$_(t)
                } ]
            } ];
        }
        _$GetScriptInterfaceClass$_() {
            return self._$ITextInstance$_;
        }
    };
    const Bb = new WeakMap, zb = new Map([ [ "left", 0 ], [ "center", 1 ], [ "right", 2 ] ]), Ub = new Map([ [ "top", 0 ], [ "center", 1 ], [ "bottom", 2 ] ]), Wb = [ "ltr", "rtl" ];
    self._$ITextInstance$_ = class extends self._$IWorldInstance$_ {
        constructor() {
            super(), Bb.set(this, self._$IInstance$_._$_GetInitInst$_()._$GetSdkInstance$_());
        }
        get text() {
            return Bb.get(this)._$GetText$_();
        }
        set text(t) {
            pb._$RequireString$_(t);
            const s = Bb.get(this);
            s._$_CancelTypewriter$_(), s._$_SetText$_(t);
        }
        _$typewriterText$_(t, s) {
            pb._$RequireString$_(t), pb._$RequireFiniteNumber$_(s);
            const i = Bb.get(this);
            i._$_CancelTypewriter$_(), i._$_StartTypewriter$_(t, s);
        }
        _$typewriterFinish$_() {
            Bb.get(this)._$_FinishTypewriter$_();
        }
        set _$fontFace$_(t) {
            pb._$RequireString$_(t), Bb.get(this)._$_SetFontFace$_(t);
        }
        get _$fontFace$_() {
            return Bb.get(this)._$_GetFontFace$_();
        }
        set _$isBold$_(t) {
            Bb.get(this)._$_SetBold$_(t);
        }
        get _$isBold$_() {
            return Bb.get(this)._$_IsBold$_();
        }
        set _$isItalic$_(t) {
            Bb.get(this)._$_SetItalic$_(t);
        }
        get _$isItalic$_() {
            return Bb.get(this)._$_IsItalic$_();
        }
        set _$sizePt$_(t) {
            pb._$RequireFiniteNumber$_(t), Bb.get(this)._$_SetFontSize$_(t);
        }
        get _$sizePt$_() {
            return Bb.get(this)._$_GetFontSize$_();
        }
        set _$fontColor$_(t) {
            if (pb._$RequireArray$_(t), t.length < 3) throw new Error("expected 3 elements");
            kb._$setRgb$_(t[0], t[1], t[2]), Bb.get(this)._$_SetFontColor$_(kb);
        }
        get _$fontColor$_() {
            const t = Bb.get(this)._$_GetFontColor$_();
            return [ t._$getR$_(), t._$getG$_(), t._$getB$_() ];
        }
        set lineHeight(t) {
            pb._$RequireFiniteNumber$_(t), Bb.get(this)._$_SetLineHeight$_(t);
        }
        get lineHeight() {
            return Bb.get(this)._$_GetLineHeight$_();
        }
        set _$horizontalAlign$_(t) {
            pb._$RequireString$_(t);
            const s = zb.get(t);
            if (void 0 === s) throw new Error("invalid mode");
            Bb.get(this)._$_SetHAlign$_(s);
        }
        get _$horizontalAlign$_() {
            return Ab[Bb.get(this)._$_GetHAlign$_()];
        }
        set verticalAlign(t) {
            pb._$RequireString$_(t);
            const s = Ub.get(t);
            if (void 0 === s) throw new Error("invalid mode");
            Bb.get(this)._$_SetVAlign$_(s);
        }
        get verticalAlign() {
            return Nb[Bb.get(this)._$_GetVAlign$_()];
        }
        set _$wordWrapMode$_(t) {
            if (!Ob.includes(t)) throw new Error("invalid mode");
            Bb.get(this)._$_SetWrapMode$_(t);
        }
        get _$wordWrapMode$_() {
            return Bb.get(this)._$_GetWrapMode$_();
        }
        set _$textDirection$_(t) {
            pb._$RequireString$_(t);
            const s = Wb.indexOf(t);
            if (-1 === s) throw new Error("invalid text direction");
            Bb.get(this)._$_SetTextDirection$_(s);
        }
        get _$textDirection$_() {
            return Wb[Bb.get(this)._$_GetTextDirection$_()];
        }
        set _$readAloud$_(t) {
            Bb.get(this)._$_SetReadAloud$_(!!t);
        }
        get _$readAloud$_() {
            return Bb.get(this)._$_IsReadAloud$_();
        }
        _$setFixedResolutionMode$_(t) {
            pb._$RequireFiniteNumber$_(t);
            const s = Bb.get(this);
            s._$_SetResolutionMode$_("fixed"), s._$_SetFixedScaleFactor$_(t);
        }
        _$setAutoResolutionMode$_() {
            Bb.get(this)._$_SetResolutionMode$_("auto");
        }
        get _$textWidth$_() {
            return Bb.get(this)._$_GetTextWidth$_();
        }
        get _$textHeight$_() {
            return Bb.get(this)._$_GetTextHeight$_();
        }
        _$getTextSize$_() {
            const t = Bb.get(this);
            return [ t._$_GetTextWidth$_(), t._$_GetTextHeight$_() ];
        }
        _$hasTagAtPosition$_(t, s, i) {
            return pb._$RequireString$_(t), pb._$RequireFiniteNumber$_(s), pb._$RequireFiniteNumber$_(i), 
            Bb.get(this)._$_HasTagAtPosition$_(t, s, i);
        }
        _$getTagAtPosition$_(t, s) {
            return pb._$RequireFiniteNumber$_(t), pb._$RequireFiniteNumber$_(s), Bb.get(this)._$_GetTagAtPosition$_(t, s);
        }
        _$getTagPositionAndSize$_(t, s = 0) {
            return pb._$RequireString$_(t), pb._$RequireFiniteNumber$_(s), Bb.get(this)._$_GetTagPosition$_(t, s);
        }
        _$getTagCount$_(t) {
            return pb._$RequireString$_(t), Bb.get(this)._$_GetTagCount$_(t);
        }
        _$changeIconSet$_(t) {
            const s = Bb.get(this), i = s._$GetRuntime$_()._$_UnwrapIObjectClass$_(t);
            s._$_SetIconObjectClass$_(i);
        }
        _$getAsHtmlString$_() {
            return Bb.get(this)._$_UpdateHTMLString$_();
        }
    };
}

{
    const Jb = self._$C3$_;
    Jb._$Plugins$_.Text._$Cnds$_ = {
        _$CompareText$_(t, s) {
            return s ? this._$_text$_ === t : Jb._$equalsNoCase$_(this._$_text$_, t);
        },
        _$IsRunningTypewriterText$_() {
            return -1 !== this._$_typewriterEndTime$_;
        },
        _$OnTypewriterTextFinished$_: () => !0,
        _$HasTagAtPosition$_(t, s, i) {
            return this._$_HasTagAtPosition$_(t, s, i);
        }
    };
}

{
    const Qb = self._$C3$_, Yb = Qb._$New$_(Qb._$Color$_);
    Qb._$Plugins$_.Text._$Acts$_ = {
        _$SetText$_(t) {
            this._$_CancelTypewriter$_(), "number" == typeof t && t < 1e9 && (t = Math.round(1e10 * t) / 1e10), 
            this._$_SetText$_(t.toString());
        },
        _$AppendText$_(t) {
            this._$_CancelTypewriter$_(), "number" == typeof t && t < 1e9 && (t = Math.round(1e10 * t) / 1e10), 
            (t = t.toString()) && this._$_SetText$_(this._$_text$_ + t);
        },
        _$TypewriterText$_(t, s) {
            this._$_CancelTypewriter$_(), "number" == typeof t && t < 1e9 && (t = Math.round(1e10 * t) / 1e10), 
            this._$_StartTypewriter$_(t.toString(), s);
        },
        _$SetFontFace$_(t, s) {
            let i = !1, e = !1;
            switch (s) {
              case 1:
                i = !0;
                break;

              case 2:
                e = !0;
                break;

              case 3:
                i = !0, e = !0;
            }
            t === this._$_faceName$_ && i === this._$_isBold$_ && e === this._$_isItalic$_ || (this._$_SetFontFace$_(t), 
            this._$_SetBold$_(i), this._$_SetItalic$_(e));
        },
        _$SetFontSize$_(t) {
            this._$_SetFontSize$_(t);
        },
        _$SetFontColor$_(t) {
            Yb._$setFromRgbValue$_(t), Yb._$clamp$_(), this._$_SetFontColor$_(Yb);
        },
        _$SetWebFont$_(t, s) {
            console.warn("[Text] 'Set web font' action is deprecated and no longer has any effect");
        },
        _$SetEffect$_(t) {
            this._$GetWorldInfo$_()._$SetBlendMode$_(t), this._$_runtime$_._$UpdateRender$_();
        },
        _$TypewriterFinish$_() {
            this._$_FinishTypewriter$_();
        },
        _$SetLineHeight$_(t) {
            this._$_SetLineHeight$_(t);
        },
        _$SetHAlign$_(t) {
            this._$_SetHAlign$_(t);
        },
        _$SetVAlign$_(t) {
            this._$_SetVAlign$_(t);
        },
        _$SetWrapping$_(t) {
            this._$_SetWrapModeByIndex$_(t);
        },
        _$SetTextDirection$_(t) {
            this._$_SetTextDirection$_(t);
        },
        _$ChangeIconSet$_(t) {
            this._$_SetIconObjectClass$_(t);
        },
        _$UpdateHTML$_() {
            return this._$_UpdateHTMLString$_();
        },
        _$SetReadAloud$_(t) {
            this._$_SetReadAloud$_(t);
        },
        _$SetResolutionMode$_(t, s) {
            this._$_SetResolutionMode$_([ "auto", "fixed" ][t]), this._$_SetFixedScaleFactor$_(s);
        }
    };
}

{
    const Vb = self._$C3$_;
    Vb._$Plugins$_.Text._$Exps$_ = {
        Text() {
            return this._$_text$_;
        },
        _$PlainText$_() {
            return this._$_enableBBcode$_ ? Vb._$BBString$_._$StripAnyTags$_(this._$_text$_) : this._$_text$_;
        },
        _$FaceName$_() {
            return this._$_faceName$_;
        },
        _$FaceSize$_() {
            return this._$_ptSize$_;
        },
        _$TextWidth$_() {
            return this._$_GetTextWidth$_();
        },
        _$TextHeight$_() {
            return this._$_GetTextHeight$_();
        },
        _$LineHeight$_() {
            return this._$_lineHeightOffset$_;
        },
        _$TagAtPosition$_(t, s) {
            return this._$_GetTagAtPosition$_(t, s);
        },
        _$TagCount$_(t) {
            return this._$_GetTagCount$_(t);
        },
        _$TagX$_(t, s) {
            const i = this._$_GetTagPosition$_(t, s);
            return i ? i.x : 0;
        },
        _$TagY$_(t, s) {
            const i = this._$_GetTagPosition$_(t, s);
            return i ? i.y : 0;
        },
        _$TagWidth$_(t, s) {
            const i = this._$_GetTagPosition$_(t, s);
            return i ? i.width : 0;
        },
        _$TagHeight$_(t, s) {
            const i = this._$_GetTagPosition$_(t, s);
            return i ? i.height : 0;
        },
        _$AsHTML$_() {
            return this._$_htmlString$_;
        }
    };
}

{
    const Hb = self._$C3$_, qb = [];
    Hb._$Plugins$_.Audio = class extends Hb._$SDKPluginBase$_ {
        constructor(t) {
            super(t);
        }
        _$_AddActionPromise$_(t) {
            qb.push(t);
        }
        static async _$WaitForAllActionPromises$_() {
            await Promise.all(qb), Hb._$clearArray$_(qb);
        }
        _$Release$_() {
            super._$Release$_();
        }
    };
}

{
    let Xb = function() {
        return tT._$GetSingleGlobalInstance$_()._$GetSdkInstance$_();
    }, Zb = function() {
        if (self.C3Audio_DOMInterface) return self.C3Audio_DOMInterface;
        throw new Error("audio scripting API cannot be used here - make sure the project is using DOM mode, not worker mode");
    };
    0;
    const Kb = self._$C3$_, $b = self._$C3X$_;
    Kb._$Plugins$_.Audio._$Type$_ = class extends Kb._$SDKTypeBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$OnCreate$_() {}
        _$GetScriptInterfaceClass$_() {
            return self._$IAudioObjectType$_;
        }
    };
    let tT = null;
    self._$IAudioObjectType$_ = class extends self._$IObjectClass$_ {
        constructor(t) {
            super(t), tT = t;
        }
        get _$audioContext$_() {
            return Zb().GetAudioContextExtern();
        }
        get _$destinationNode$_() {
            return Zb().GetDestinationNodeExtern();
        }
        get _$isSilent$_() {
            return Xb()._$_IsSilent$_();
        }
        set _$isSilent$_(t) {
            Xb()._$_SetSilent$_(t);
        }
        get _$masterVolume$_() {
            return Xb()._$_GetMasterVolume$_();
        }
        set _$masterVolume$_(t) {
            $b._$RequireFiniteNumber$_(t), Xb()._$_SetMasterVolume$_(t);
        }
        _$stopAll$_() {
            Xb()._$_StopAll$_();
        }
    };
}

{
    const sT = self._$C3$_, iT = "audio", eT = [ "interactive", "balanced", "playback" ];
    sT._$Plugins$_.Audio.Instance = class extends sT._$SDKInstanceBase$_ {
        constructor(t, s) {
            super(t, iT), this._$_nextPlayTime$_ = 0, this._$_triggerTags$_ = [], this._$_enableMultiTags$_ = !0, 
            this._$_timeScaleMode$_ = 0, this._$_saveLoadMode$_ = 0, this._$_playInBackground$_ = !1, 
            this._$_panningModel$_ = 1, this._$_distanceModel$_ = 1, this._$_listenerPos$_ = [ this._$_runtime$_._$GetViewportWidth$_() / 2, this._$_runtime$_._$GetViewportHeight$_() / 2, 600 ], 
            this._$_listenerForwardVec$_ = [ 0, 0, -1 ], this._$_listenerUpVec$_ = [ 0, 1, 0 ], 
            this._$_referenceDistance$_ = 600, this._$_maxDistance$_ = 1e4, this._$_rolloffFactor$_ = 1, 
            this._$_listenerInst$_ = null, this._$_loadListenerUid$_ = -1, this._$_masterVolume$_ = 1, 
            this._$_isSilent$_ = !1, this._$_sampleRate$_ = 0, this._$_audioContextState$_ = "suspended", 
            this._$_outputLatency$_ = 0, this._$_effectCount$_ = new Map, this._$_preloadTotal$_ = 0, 
            this._$_preloadCount$_ = 0, this._$_bufferMetadata$_ = new Map, this._$_remoteUrls$_ = new Map;
            let i = "interactive";
            s && (this._$_timeScaleMode$_ = s[0], this._$_saveLoadMode$_ = s[1], this._$_playInBackground$_ = s[2], 
            i = eT[s[3]], this._$_enableMultiTags$_ = s[4], this._$_panningModel$_ = s[5], this._$_distanceModel$_ = s[6], 
            this._$_listenerPos$_[2] = s[7], this._$_referenceDistance$_ = s[8], this._$_maxDistance$_ = s[9], 
            this._$_rolloffFactor$_ = s[10]), this._$_lastAIState$_ = [], this._$_lastFxState$_ = [], 
            this._$_lastAnalysersData$_ = [], this._$AddDOMMessageHandlers$_([ [ "state", t => this._$_OnUpdateState$_(t) ], [ "audiocontext-state", t => this._$_OnAudioContextStateChanged$_(t) ], [ "fxstate", t => this._$_OnUpdateFxState$_(t) ], [ "trigger", t => this._$_OnTrigger$_(t) ], [ "buffer-metadata", t => this._$_OnBufferMetadata$_(t) ] ]);
            const e = this._$GetRuntime$_()._$Dispatcher$_();
            this._$_disposables$_ = new sT._$CompositeDisposable$_(sT._$Disposable$_._$From$_(e, "instancedestroy", (t => this._$_OnInstanceDestroyed$_(t._$instance$_))), sT._$Disposable$_._$From$_(e, "afterload", (() => this._$_OnAfterLoad$_())), sT._$Disposable$_._$From$_(e, "suspend", (() => this._$_OnSuspend$_())), sT._$Disposable$_._$From$_(e, "resume", (() => this._$_OnResume$_())));
            const n = this._$_runtime$_._$GetExportType$_(), h = "Safari" === sT._$Platform$_._$Browser$_, r = this._$_runtime$_._$IsiOSWebView$_() || "macos-wkwebview" === n, o = this._$_runtime$_._$GetAssetManager$_()._$IsFileProtocol$_(), a = "playable-ad-single-file" === this._$_runtime$_._$GetExportType$_(), u = h || r || o || a;
            this._$_runtime$_._$AddLoadPromise$_(this._$PostToDOMAsync$_("create-audio-context", {
                preloadList: this._$_runtime$_._$GetAssetManager$_()._$GetAudioToPreload$_().map((t => ({
                    originalUrl: t._$originalUrl$_,
                    url: t.url,
                    type: t.type,
                    fileSize: t.fileSize
                }))),
                timeScaleMode: this._$_timeScaleMode$_,
                latencyHint: i,
                panningModel: this._$_panningModel$_,
                distanceModel: this._$_distanceModel$_,
                refDistance: this._$_referenceDistance$_,
                maxDistance: this._$_maxDistance$_,
                rolloffFactor: this._$_rolloffFactor$_,
                listenerPos: this._$_listenerPos$_,
                usePlayMusicAsSoundWorkaround: u
            }).then((t => {
                this._$_sampleRate$_ = t.sampleRate, this._$_audioContextState$_ = t.audioContextState, 
                this._$_outputLatency$_ = t.outputLatency;
            }))), this._$_StartTicking$_();
        }
        _$Release$_() {
            this._$_listenerInst$_ = null, super._$Release$_();
        }
        _$_SplitTags$_(t) {
            return this._$_enableMultiTags$_ ? t.split(" ").filter((t => !!t)) : t ? [ t ] : [];
        }
        _$_MatchTagLists$_(t, s) {
            for (const i of s) {
                let s = !1;
                for (const e of t) if (sT._$equalsNoCase$_(e, i)) {
                    s = !0;
                    break;
                }
                if (!s) return !1;
            }
            return !0;
        }
        _$_MatchTagListToStr$_(t, s) {
            return this._$_MatchTagLists$_(t, this._$_SplitTags$_(s));
        }
        _$_AddActionPromise$_(t) {
            this._$GetPlugin$_()._$_AddActionPromise$_(t);
        }
        _$_OnInstanceDestroyed$_(t) {
            this._$_listenerInst$_ === t && (this._$_listenerInst$_ = null);
        }
        _$DbToLinearNoCap$_(t) {
            return Math.pow(10, t / 20);
        }
        _$DbToLinear$_(t) {
            const s = this._$DbToLinearNoCap$_(t);
            return isFinite(s) ? Math.max(Math.min(s, 1), 0) : 0;
        }
        _$LinearToDbNoCap$_(t) {
            return Math.log(t) / Math.log(10) * 20;
        }
        _$LinearToDb$_(t) {
            return this._$LinearToDbNoCap$_(Math.max(Math.min(t, 1), 0));
        }
        _$_OnSuspend$_() {
            this._$_playInBackground$_ || this._$PostToDOM$_("set-suspended", {
                isSuspended: !0
            });
        }
        _$_OnResume$_() {
            this._$_playInBackground$_ || this._$PostToDOM$_("set-suspended", {
                isSuspended: !1
            });
        }
        _$_OnUpdateState$_(t) {
            const s = t.tickCount;
            this._$_outputLatency$_ = t.outputLatency;
            const i = this._$_lastAIState$_.filter((t => t.hasOwnProperty("placeholder") && (t.placeholder > s || -1 === t.placeholder)));
            this._$_lastAIState$_ = t.audioInstances, this._$_lastAnalysersData$_ = t.analysers, 
            i.length > 0 && sT._$appendArray$_(this._$_lastAIState$_, i);
        }
        _$_OnBufferMetadata$_(t) {
            this._$_bufferMetadata$_.set(t.originalUrl, {
                duration: t.duration
            });
        }
        _$_OnAudioContextStateChanged$_(t) {
            this._$_audioContextState$_ = t.audioContextState;
        }
        _$GetAudioContextState$_() {
            return this._$_runtime$_._$IsExportToVideo$_() ? "running" : this._$_audioContextState$_;
        }
        _$_OnUpdateFxState$_(t) {
            this._$_lastFxState$_ = t.fxstate;
        }
        _$_GetFirstAudioStateByTags$_(t) {
            const s = this._$_SplitTags$_(t);
            for (const t of this._$_lastAIState$_) if (this._$_MatchTagLists$_(t.tags, s)) return t;
            return null;
        }
        _$_IsTagPlaying$_(t) {
            const s = this._$_SplitTags$_(t);
            return this._$_lastAIState$_.some((t => this._$_MatchTagLists$_(t.tags, s) && t.isPlaying));
        }
        _$_MaybeMarkAsPlaying$_(t, s, i, e, n) {
            if (this._$_IsTagPlaying$_(s)) return null;
            const h = this._$_bufferMetadata$_.get(t), r = {
                tags: this._$_SplitTags$_(s),
                duration: h ? h.duration : 0,
                volume: n,
                isPlaying: !0,
                playbackTime: 0,
                playbackRate: 1,
                uid: -1,
                bufferOriginalUrl: t,
                bufferUrl: "",
                bufferType: "",
                isMusic: i,
                isLooping: e,
                isMuted: !1,
                resumePosition: 0,
                pan: null,
                placeholder: -1
            };
            return this._$_lastAIState$_.push(r), r;
        }
        _$_MaybeMarkAsStopped$_(t) {
            const s = this._$_SplitTags$_(t);
            for (const t of this._$_lastAIState$_) this._$_MatchTagLists$_(t.tags, s) && (t.isPlaying = !1);
        }
        async _$_OnTrigger$_(t) {
            const s = t.type;
            this._$_triggerTags$_ = t.tags;
            const i = t.aiid;
            if ("ended" === s) {
                for (const t of this._$_lastAIState$_) if (t.aiid === i) {
                    t.isPlaying = !1;
                    break;
                }
                await this._$TriggerAsync$_(sT._$Plugins$_.Audio._$Cnds$_._$OnEnded$_);
            } else "fade-ended" === s && await this._$TriggerAsync$_(sT._$Plugins$_.Audio._$Cnds$_._$OnFadeEnded$_);
        }
        _$_MatchTriggerTag$_(t) {
            return this._$_MatchTagListToStr$_(this._$_triggerTags$_, t);
        }
        _$Tick$_() {
            const t = {
                timeScale: this._$_runtime$_._$GetTimeScale$_(),
                gameTime: this._$_runtime$_._$GetGameTimeRaw$_(),
                instPans: this._$GetInstancePans$_(),
                tickCount: this._$_runtime$_._$GetTickCountNoSave$_()
            };
            if (this._$_listenerInst$_) {
                const s = this._$_listenerInst$_._$GetWorldInfo$_();
                this._$_listenerPos$_[0] = s._$GetX$_(), this._$_listenerPos$_[1] = s._$GetY$_(), 
                t.listenerPos = this._$_listenerPos$_, t.listenerOrientation = [ ...this._$_listenerForwardVec$_, ...this._$_listenerUpVec$_ ];
            }
            this._$PostToDOM$_("tick", t);
        }
        _$rotatePtAround$_(t, s, i, e, n) {
            if (0 === i) return [ t, s ];
            const h = Math.sin(i), r = Math.cos(i), o = (t -= e) * h;
            return t = t * r - (s -= n) * h, s = s * r + o, [ t += e, s += n ];
        }
        _$GetInstancePans$_() {
            return this._$_lastAIState$_.filter((t => -1 !== t.uid)).map((t => this._$_runtime$_._$GetInstanceByUID$_(t.uid))).filter((t => t)).map((t => {
                const s = t._$GetWorldInfo$_(), i = s._$GetLayer$_()._$GetAngle$_(), [e, n] = this._$rotatePtAround$_(s._$GetX$_(), s._$GetY$_(), -i, this._$_listenerPos$_[0], this._$_listenerPos$_[1]);
                return {
                    uid: t._$GetUID$_(),
                    x: e,
                    y: n,
                    z: s._$GetTotalZElevation$_(),
                    angle: s._$GetAngle$_() - i
                };
            }));
        }
        _$GetAnalyserData$_(t, s) {
            for (const i of this._$_lastAnalysersData$_) if (i.index === s && sT._$equalsNoCase$_(i.tag, t)) return i;
            return null;
        }
        _$_IncrementEffectCount$_(t) {
            for (const s of this._$_SplitTags$_(t)) {
                const t = s.toLowerCase();
                this._$_effectCount$_.set(t, (this._$_effectCount$_.get(t) || 0) + 1);
            }
        }
        _$_IsSilent$_() {
            return this._$_isSilent$_;
        }
        _$_SetSilent$_(t) {
            t = !!t, this._$_isSilent$_ !== t && (this._$_isSilent$_ = t, this._$PostToDOM$_("set-silent", {
                isSilent: t
            }));
        }
        _$_GetMasterVolume$_() {
            return this._$_masterVolume$_;
        }
        _$_SetMasterVolume$_(t) {
            this._$_masterVolume$_ !== t && (this._$_masterVolume$_ = t, this._$PostToDOM$_("set-master-volume", {
                vol: t
            }));
        }
        _$_StopAll$_() {
            this._$PostToDOM$_("stop-all");
            for (const t of this._$_lastAIState$_) t.isPlaying = !1;
        }
        _$_ShouldSave$_(t) {
            return !(t.hasOwnProperty("placeholder") || 3 === this._$_saveLoadMode$_ || t.isMusic && 1 === this._$_saveLoadMode$_ || !t.isMusic && 2 === this._$_saveLoadMode$_);
        }
        _$SaveToJson$_() {
            return {
                isSilent: this._$_isSilent$_,
                masterVolume: this._$_masterVolume$_,
                listenerZ: this._$_listenerPos$_[2],
                listenerForwardVec: this._$_listenerForwardVec$_,
                listenerUpVec: this._$_listenerUpVec$_,
                listenerUid: this._$_listenerInst$_ ? this._$_listenerInst$_._$GetUID$_() : -1,
                remoteUrls: [ ...this._$_remoteUrls$_.entries() ],
                playing: this._$_lastAIState$_.filter((t => this._$_ShouldSave$_(t))),
                effects: this._$_lastFxState$_,
                analysers: this._$_lastAnalysersData$_
            };
        }
        _$LoadFromJson$_(t) {
            if (this._$_isSilent$_ = t.isSilent, this._$_masterVolume$_ = t.masterVolume, this._$_listenerPos$_[2] = t.listenerZ, 
            this._$_listenerInst$_ = null, this._$_loadListenerUid$_ = t.listenerUid, t.hasOwnProperty("listenerForwardVec") ? this._$_listenerForwardVec$_ = t.listenerForwardVec : this._$_listenerForwardVec$_ = [ 0, 0, -1 ], 
            t.hasOwnProperty("listenerUpVec") ? this._$_listenerUpVec$_ = t.listenerUpVec : this._$_listenerUpVec$_ = [ 0, 1, 0 ], 
            this._$_remoteUrls$_.clear(), t.remoteUrls) for (const [s, i] of t.remoteUrls) this._$_remoteUrls$_.set(s, i);
            this._$_lastAIState$_ = t.playing;
            for (const t of this._$_lastAIState$_) t.hasOwnProperty("tag") && !t.hasOwnProperty("tags") && (t.tags = [ t.tag ].filter((t => !!t)));
            this._$_lastFxState$_ = t.effects, this._$_lastAnalysersData$_ = t.analysers;
        }
        _$_OnAfterLoad$_() {
            if (-1 !== this._$_loadListenerUid$_ && (this._$_listenerInst$_ = this._$_runtime$_._$GetInstanceByUID$_(this._$_loadListenerUid$_), 
            this._$_loadListenerUid$_ = -1, this._$_listenerInst$_)) {
                const t = this._$_listenerInst$_._$GetWorldInfo$_();
                this._$_listenerPos$_[0] = t._$GetX$_(), this._$_listenerPos$_[1] = t._$GetY$_();
            }
            for (const t of this._$_lastAIState$_) {
                const s = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(t.bufferOriginalUrl);
                s ? (t.bufferUrl = s.url, t.bufferType = s.type) : t.bufferUrl = null;
            }
            for (const t of Object.values(this._$_lastFxState$_)) for (const s of t) if (s.hasOwnProperty("bufferOriginalUrl")) {
                const t = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(s.bufferOriginalUrl);
                t && (s.bufferUrl = t.url, s.bufferType = t.type);
            }
            this._$PostToDOM$_("load-state", {
                saveLoadMode: this._$_saveLoadMode$_,
                timeScale: this._$_runtime$_._$GetTimeScale$_(),
                gameTime: this._$_runtime$_._$GetGameTimeRaw$_(),
                listenerPos: this._$_listenerPos$_,
                listenerOrientation: [ ...this._$_listenerForwardVec$_, ...this._$_listenerUpVec$_ ],
                isSilent: this._$_isSilent$_,
                masterVolume: this._$_masterVolume$_,
                playing: this._$_lastAIState$_.filter((t => null !== t.bufferUrl)),
                effects: this._$_lastFxState$_
            });
        }
        _$GetDebuggerProperties$_() {
            const t = [];
            for (const [s, i] of Object.entries(this._$_lastFxState$_)) t.push({
                name: "$" + s,
                value: i.map((t => t.type)).join(", ")
            });
            const s = "plugins.audio.debugger";
            return [ {
                title: s + ".tag-effects",
                properties: t
            }, {
                title: s + ".currently-playing",
                properties: [ {
                    name: s + ".currently-playing-count",
                    value: this._$_lastAIState$_.length
                }, ...this._$_lastAIState$_.map(((t, s) => ({
                    name: "$#" + s,
                    value: `${t.bufferOriginalUrl} ("${t.tags}") ${Math.round(10 * t.playbackTime) / 10} / ${Math.round(10 * t.duration) / 10}`
                }))) ]
            } ];
        }
    };
}

self._$C3$_._$Plugins$_.Audio._$Cnds$_ = {
    _$OnEnded$_(t) {
        return this._$_MatchTriggerTag$_(t);
    },
    _$OnFadeEnded$_(t) {
        return this._$_MatchTriggerTag$_(t);
    },
    _$PreloadsComplete$_() {
        return this._$_preloadCount$_ === this._$_preloadTotal$_;
    },
    _$AdvancedAudioSupported$_: () => !0,
    _$IsSilent$_() {
        return this._$_IsSilent$_();
    },
    _$IsAnyPlaying$_() {
        for (const t of this._$_lastAIState$_) if (t.isPlaying) return !0;
        return !1;
    },
    _$IsTagPlaying$_(t) {
        return this._$_IsTagPlaying$_(t);
    }
};

{
    const nT = self._$C3$_, hT = [ "lowpass", "highpass", "bandpass", "lowshelf", "highshelf", "peaking", "notch", "allpass" ];
    nT._$Plugins$_.Audio._$Acts$_ = {
        Play(t, s, i, e, n) {
            const h = nT._$Plugins$_.Audio._$Acts$_._$_DoPlay$_.call(this, t, s, i, e, n);
            return this._$_AddActionPromise$_(h), h;
        },
        _$PlayFromTimeline$_(t, s, i, e) {
            nT._$Plugins$_.Audio._$Acts$_._$_DoPlay$_.call(this, t, 0, s, 0, i, e);
        },
        async _$_DoPlay$_(t, s, i, e, n, h) {
            if (this._$_isSilent$_) return;
            const r = t[1], o = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(t[0]);
            if (!o) return;
            const a = this._$_nextPlayTime$_;
            this._$_nextPlayTime$_ = 0;
            const u = this._$_MaybeMarkAsPlaying$_(t[0], n, r, 0 !== s, this._$DbToLinear$_(i));
            try {
                await this._$PostToDOMAsync$_("play", {
                    originalUrl: t[0],
                    url: o.url,
                    type: o.type,
                    isMusic: r,
                    tags: this._$_SplitTags$_(n),
                    isLooping: 0 !== s,
                    vol: this._$DbToLinear$_(i),
                    stereoPan: nT._$clamp$_(e / 100, -1, 1),
                    pos: h || 0,
                    off: a,
                    trueClock: !!self.C3_GetAudioContextCurrentTime
                });
            } finally {
                u && (u.placeholder = this._$_runtime$_._$GetTickCountNoSave$_());
            }
        },
        async _$PlayAtPosition$_(t, s, i, e, n, h, r, o, a, u, l) {
            if (this._$_isSilent$_) return;
            const c = t[1], f = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(t[0]);
            if (!f) return;
            const d = this._$_nextPlayTime$_;
            this._$_nextPlayTime$_ = 0;
            const p = this._$_MaybeMarkAsPlaying$_(t[0], l, c, 0 !== s, this._$DbToLinear$_(i));
            try {
                await this._$PostToDOMAsync$_("play", {
                    originalUrl: t[0],
                    url: f.url,
                    type: f.type,
                    isMusic: c,
                    tags: this._$_SplitTags$_(l),
                    isLooping: 0 !== s,
                    vol: this._$DbToLinear$_(i),
                    pos: 0,
                    off: d,
                    trueClock: !!self.C3_GetAudioContextCurrentTime,
                    panning: {
                        x: e,
                        y: n,
                        z: h,
                        angle: nT._$toRadians$_(r),
                        innerAngle: nT._$toRadians$_(o),
                        outerAngle: nT._$toRadians$_(a),
                        outerGain: this._$DbToLinear$_(u)
                    }
                });
            } finally {
                p && (p.placeholder = this._$_runtime$_._$GetTickCountNoSave$_());
            }
        },
        async _$PlayAtObject$_(t, s, i, e, n, h, r, o) {
            if (this._$_isSilent$_) return;
            if (!e) return;
            const a = e._$GetFirstPicked$_();
            if (!a || !a._$GetWorldInfo$_()) return;
            const u = a._$GetWorldInfo$_(), l = u._$GetLayer$_()._$GetAngle$_(), [c, f] = this._$rotatePtAround$_(u._$GetX$_(), u._$GetY$_(), -l, this._$_listenerPos$_[0], this._$_listenerPos$_[1]), d = t[1], p = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(t[0]);
            if (!p) return;
            const m = this._$_nextPlayTime$_;
            this._$_nextPlayTime$_ = 0;
            const g = this._$_MaybeMarkAsPlaying$_(t[0], o, d, 0 !== s, this._$DbToLinear$_(i));
            try {
                await this._$PostToDOMAsync$_("play", {
                    originalUrl: t[0],
                    url: p.url,
                    type: p.type,
                    isMusic: d,
                    tags: this._$_SplitTags$_(o),
                    isLooping: 0 !== s,
                    vol: this._$DbToLinear$_(i),
                    pos: 0,
                    off: m,
                    trueClock: !!self.C3_GetAudioContextCurrentTime,
                    panning: {
                        x: c,
                        y: f,
                        z: u._$GetTotalZElevation$_(),
                        angle: u._$GetAngle$_() - l,
                        innerAngle: nT._$toRadians$_(n),
                        outerAngle: nT._$toRadians$_(h),
                        outerGain: this._$DbToLinear$_(r),
                        uid: a._$GetUID$_()
                    }
                });
            } finally {
                g && (g.placeholder = this._$_runtime$_._$GetTickCountNoSave$_());
            }
        },
        async _$PlayByName$_(t, s, i, e, n, h) {
            if (this._$_isSilent$_) return;
            const r = 1 === t, o = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(s) || this._$_remoteUrls$_.get(s.toLowerCase());
            if (!o) return;
            const a = this._$_nextPlayTime$_;
            this._$_nextPlayTime$_ = 0;
            const u = this._$_MaybeMarkAsPlaying$_(s, h, r, 0 !== i, this._$DbToLinear$_(e));
            try {
                await this._$PostToDOMAsync$_("play", {
                    originalUrl: s,
                    url: o.url,
                    type: o.type,
                    isMusic: r,
                    tags: this._$_SplitTags$_(h),
                    isLooping: 0 !== i,
                    vol: this._$DbToLinear$_(e),
                    stereoPan: nT._$clamp$_(n / 100, -1, 1),
                    pos: 0,
                    off: a,
                    trueClock: !!self.C3_GetAudioContextCurrentTime
                });
            } finally {
                u && (u.placeholder = this._$_runtime$_._$GetTickCountNoSave$_());
            }
        },
        async _$PlayAtPositionByName$_(t, s, i, e, n, h, r, o, a, u, l, c) {
            if (this._$_isSilent$_) return;
            const f = 1 === t, d = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(s) || this._$_remoteUrls$_.get(s.toLowerCase());
            if (!d) return;
            const p = this._$_nextPlayTime$_;
            this._$_nextPlayTime$_ = 0;
            const m = this._$_MaybeMarkAsPlaying$_(s, c, f, 0 !== i, this._$DbToLinear$_(e));
            try {
                await this._$PostToDOMAsync$_("play", {
                    originalUrl: s,
                    url: d.url,
                    type: d.type,
                    isMusic: f,
                    tags: this._$_SplitTags$_(c),
                    isLooping: 0 !== i,
                    vol: this._$DbToLinear$_(e),
                    pos: 0,
                    off: p,
                    trueClock: !!self.C3_GetAudioContextCurrentTime,
                    panning: {
                        x: n,
                        y: h,
                        z: r,
                        angle: nT._$toRadians$_(o),
                        innerAngle: nT._$toRadians$_(a),
                        outerAngle: nT._$toRadians$_(u),
                        outerGain: this._$DbToLinear$_(l)
                    }
                });
            } finally {
                m && (m.placeholder = this._$_runtime$_._$GetTickCountNoSave$_());
            }
        },
        async _$PlayAtObjectByName$_(t, s, i, e, n, h, r, o, a) {
            if (this._$_isSilent$_) return;
            if (this._$_isSilent$_) return;
            if (!n) return;
            const u = n._$GetFirstPicked$_();
            if (!u || !u._$GetWorldInfo$_()) return;
            const l = u._$GetWorldInfo$_(), c = l._$GetLayer$_()._$GetAngle$_(), [f, d] = this._$rotatePtAround$_(l._$GetX$_(), l._$GetY$_(), -c, this._$_listenerPos$_[0], this._$_listenerPos$_[1]), p = 1 === t, m = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(s) || this._$_remoteUrls$_.get(s.toLowerCase());
            if (!m) return;
            const g = this._$_nextPlayTime$_;
            this._$_nextPlayTime$_ = 0;
            const y = this._$_MaybeMarkAsPlaying$_(s, a, p, 0 !== i, this._$DbToLinear$_(e));
            try {
                await this._$PostToDOMAsync$_("play", {
                    originalUrl: s,
                    url: m.url,
                    type: m.type,
                    isMusic: p,
                    tags: this._$_SplitTags$_(a),
                    isLooping: 0 !== i,
                    vol: this._$DbToLinear$_(e),
                    pos: 0,
                    off: g,
                    trueClock: !!self.C3_GetAudioContextCurrentTime,
                    panning: {
                        x: f,
                        y: d,
                        z: l._$GetTotalZElevation$_(),
                        angle: l._$GetAngle$_() - c,
                        innerAngle: nT._$toRadians$_(h),
                        outerAngle: nT._$toRadians$_(r),
                        outerGain: this._$DbToLinear$_(o),
                        uid: u._$GetUID$_()
                    }
                });
            } finally {
                y && (y.placeholder = this._$_runtime$_._$GetTickCountNoSave$_());
            }
        },
        _$SetLooping$_(t, s) {
            this._$PostToDOM$_("set-looping", {
                tags: this._$_SplitTags$_(t),
                isLooping: 0 === s
            });
        },
        _$SetMuted$_(t, s) {
            this._$PostToDOM$_("set-muted", {
                tags: this._$_SplitTags$_(t),
                isMuted: 0 === s
            });
        },
        _$SetVolume$_(t, s) {
            this._$PostToDOM$_("set-volume", {
                tags: this._$_SplitTags$_(t),
                vol: this._$DbToLinear$_(s)
            });
        },
        _$FadeVolume$_(t, s, i, e) {
            this._$PostToDOM$_("fade-volume", {
                tags: this._$_SplitTags$_(t),
                vol: this._$DbToLinear$_(s),
                duration: i,
                stopOnEnd: 0 === e
            });
        },
        _$SetStereoPan$_(t, s) {
            this._$PostToDOM$_("set-stereo-pan", {
                tags: this._$_SplitTags$_(t),
                p: nT._$clamp$_(s / 100, -1, 1)
            });
        },
        async _$Preload$_(t) {
            const s = t[1], i = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(t[0]);
            i && (this._$_preloadTotal$_++, await this._$PostToDOMAsync$_("preload", {
                originalUrl: t[0],
                url: i.url,
                type: i.type,
                isMusic: s
            }), this._$_preloadCount$_++);
        },
        async _$PreloadByName$_(t, s) {
            const i = 1 === t, e = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(s) || this._$_remoteUrls$_.get(s.toLowerCase());
            e && (this._$_preloadTotal$_++, await this._$PostToDOMAsync$_("preload", {
                originalUrl: s,
                url: e.url,
                type: e.type,
                isMusic: i
            }), this._$_preloadCount$_++);
        },
        _$SetPlaybackRate$_(t, s) {
            this._$PostToDOM$_("set-playback-rate", {
                tags: this._$_SplitTags$_(t),
                rate: Math.max(s, 0)
            });
        },
        _$Stop$_(t) {
            this._$_MaybeMarkAsStopped$_(t), this._$PostToDOM$_("stop", {
                tags: this._$_SplitTags$_(t)
            });
        },
        _$StopAll$_() {
            this._$_StopAll$_();
        },
        _$SetPaused$_(t, s) {
            this._$PostToDOM$_("set-paused", {
                tags: this._$_SplitTags$_(t),
                paused: 0 === s
            });
        },
        _$Seek$_(t, s) {
            this._$PostToDOM$_("seek", {
                tags: this._$_SplitTags$_(t),
                pos: s
            });
        },
        _$SetSilent$_(t) {
            2 === t && (t = this._$_IsSilent$_() ? 1 : 0), this._$_SetSilent$_(0 === t);
        },
        _$SetMasterVolume$_(t) {
            const s = this._$DbToLinear$_(t);
            this._$_SetMasterVolume$_(s);
        },
        _$AddFilterEffect$_(t, s, i, e, n, h, r) {
            const o = hT[s];
            this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                type: "filter",
                tags: this._$_SplitTags$_(t),
                params: [ o, i, e, n, h, nT._$clamp$_(r / 100, 0, 1) ]
            });
        },
        _$AddDelayEffect$_(t, s, i, e) {
            this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                type: "delay",
                tags: this._$_SplitTags$_(t),
                params: [ s, this._$DbToLinear$_(i), nT._$clamp$_(e / 100, 0, 1) ]
            });
        },
        _$AddFlangerEffect$_(t, s, i, e, n, h) {
            this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                type: "flanger",
                tags: this._$_SplitTags$_(t),
                params: [ s / 1e3, i / 1e3, e, n / 100, nT._$clamp$_(h / 100, 0, 1) ]
            });
        },
        _$AddPhaserEffect$_(t, s, i, e, n, h, r) {
            this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                type: "phaser",
                tags: this._$_SplitTags$_(t),
                params: [ s, i, e, n, h, nT._$clamp$_(r / 100, 0, 1) ]
            });
        },
        _$AddConvolutionEffect$_(t, s, i, e) {
            const n = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(s[0]);
            n && (this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                type: "convolution",
                tags: this._$_SplitTags$_(t),
                bufferOriginalUrl: s[0],
                bufferUrl: n.url,
                bufferType: n.type,
                params: [ 0 === i, nT._$clamp$_(e / 100, 0, 1) ]
            }));
        },
        _$AddGainEffect$_(t, s) {
            this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                type: "gain",
                tags: this._$_SplitTags$_(t),
                params: [ this._$DbToLinear$_(s) ]
            });
        },
        _$AddStereoPanEffect$_(t, s) {
            this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                type: "stereopan",
                tags: this._$_SplitTags$_(t),
                params: [ nT._$clamp$_(s / 100, -1, 1) ]
            });
        },
        _$AddMuteEffect$_(t) {
            this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                type: "gain",
                tags: this._$_SplitTags$_(t),
                params: [ 0 ]
            });
        },
        _$AddTremoloEffect$_(t, s, i) {
            this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                type: "tremolo",
                tags: this._$_SplitTags$_(t),
                params: [ s, nT._$clamp$_(i / 100, 0, 1) ]
            });
        },
        _$AddRingModEffect$_(t, s, i) {
            this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                type: "ringmod",
                tags: this._$_SplitTags$_(t),
                params: [ s, nT._$clamp$_(i / 100, 0, 1) ]
            });
        },
        _$AddDistortionEffect$_(t, s, i, e, n, h) {
            this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                type: "distortion",
                tags: this._$_SplitTags$_(t),
                params: [ this._$DbToLinearNoCap$_(s), this._$DbToLinearNoCap$_(i), e, this._$DbToLinearNoCap$_(n), nT._$clamp$_(h / 100, 0, 1) ]
            });
        },
        _$AddCompressorEffect$_(t, s, i, e, n, h) {
            this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                type: "compressor",
                tags: this._$_SplitTags$_(t),
                params: [ s, i, e, n / 1e3, h / 1e3 ]
            });
        },
        _$AddAnalyserEffect$_(t, s, i) {
            this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                type: "analyser",
                tags: this._$_SplitTags$_(t),
                params: [ s, i ]
            });
        },
        _$RemoveEffects$_(t) {
            const s = this._$_SplitTags$_(t);
            for (const t of s) this._$_effectCount$_.set(t.toLowerCase(), 0);
            this._$PostToDOM$_("remove-effects", {
                tags: s
            }), this._$_lastFxState$_ = {};
        },
        _$SetEffectParameter$_(t, s, i, e, n, h) {
            this._$PostToDOM$_("set-effect-param", {
                tags: this._$_SplitTags$_(t),
                index: Math.floor(s),
                param: i,
                value: e,
                ramp: n,
                time: h
            });
        },
        _$SetListenerObject$_(t) {
            if (!t) return;
            const s = t._$GetFirstPicked$_();
            s && s._$GetWorldInfo$_() && (this._$_listenerInst$_ = s);
        },
        _$SetListenerZ$_(t) {
            this._$_listenerPos$_[2] = t;
        },
        _$SetListenerOrientation$_(t, s, i, e, n, h) {
            this._$_listenerForwardVec$_[0] = t, this._$_listenerForwardVec$_[1] = s, this._$_listenerForwardVec$_[2] = -i, 
            this._$_listenerUpVec$_[0] = e, this._$_listenerUpVec$_[1] = n, this._$_listenerUpVec$_[2] = -h;
        },
        _$ScheduleNextPlay$_(t) {
            this._$_nextPlayTime$_ = Math.max(t, 0);
        },
        _$UnloadAudio$_(t) {
            const s = t[1], i = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(t[0]);
            i && this._$PostToDOM$_("unload", {
                url: i.url,
                type: i.type,
                isMusic: s
            });
        },
        _$UnloadAudioByName$_(t, s) {
            const i = 1 === t, e = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(s) || this._$_remoteUrls$_.get(s.toLowerCase());
            e && this._$PostToDOM$_("unload", {
                url: e.url,
                type: e.type,
                isMusic: i
            });
        },
        _$UnloadAll$_() {
            this._$PostToDOM$_("unload-all");
        },
        _$AddRemoteURL$_(t, s, i) {
            this._$_remoteUrls$_.set(i.toLowerCase(), {
                url: t,
                type: s
            });
        }
    };
}

{
    const rT = self._$C3$_;
    rT._$Plugins$_.Audio._$Exps$_ = {
        _$Duration$_(t) {
            const s = this._$_GetFirstAudioStateByTags$_(t);
            return s ? s.duration : 0;
        },
        _$PlaybackTime$_(t) {
            const s = this._$_GetFirstAudioStateByTags$_(t);
            return s ? s.playbackTime : 0;
        },
        _$PlaybackRate$_(t) {
            const s = this._$_GetFirstAudioStateByTags$_(t);
            return s ? s.playbackRate : 0;
        },
        _$Volume$_(t) {
            const s = this._$_GetFirstAudioStateByTags$_(t);
            return s ? this._$LinearToDb$_(s.volume) : 0;
        },
        _$MasterVolume$_() {
            return this._$LinearToDb$_(this._$_GetMasterVolume$_());
        },
        _$EffectCount$_(t) {
            return this._$_effectCount$_.get(t.toLowerCase()) || 0;
        },
        _$AnalyserFreqBinCount$_(t, s) {
            const i = this._$GetAnalyserData$_(t, Math.floor(s));
            return i ? i.binCount : 0;
        },
        _$AnalyserFreqBinAt$_(t, s, i) {
            const e = this._$GetAnalyserData$_(t, Math.floor(s));
            return e ? (i = Math.floor(i)) < 0 || i >= e.binCount ? 0 : e.freqBins[i] : 0;
        },
        _$AnalyserPeakLevel$_(t, s) {
            const i = this._$GetAnalyserData$_(t, Math.floor(s));
            return i ? i.peak : 0;
        },
        _$AnalyserRMSLevel$_(t, s) {
            const i = this._$GetAnalyserData$_(t, Math.floor(s));
            return i ? i.rms : 0;
        },
        _$SampleRate$_() {
            return this._$_sampleRate$_;
        },
        _$CurrentTime$_: () => self.C3_GetAudioContextCurrentTime ? self.C3_GetAudioContextCurrentTime() : performance.now() / 1e3,
        _$OutputLatency$_() {
            return this._$_outputLatency$_;
        },
        _$NormalizedVolume$_(t, s) {
            return 0 == (t = rT._$clamp$_(+t, 0, 100) / 100) ? -1 / 0 : t < .1 ? this._$LinearToDb$_(rT._$lerp$_(0, this._$DbToLinear$_(s), 10 * t)) : rT._$lerp$_(s, 0, (t - .1) / .9);
        }
    };
}

{
    const oT = self._$C3$_;
    oT._$Plugins$_._$TiledBg$_ = class extends oT._$SDKPluginBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
    };
}

{
    let aT = function(t) {
        switch (t) {
          case 0:
            return "clamp-to-edge";

          case 1:
            return "repeat";

          case 2:
            return "mirror-repeat";
        }
        return "repeat";
    };
    0;
    const uT = self._$C3$_;
    uT._$Plugins$_._$TiledBg$_._$Type$_ = class extends uT._$SDKTypeBase$_ {
        constructor(t, s) {
            super(t), this._$_wrapX$_ = "repeat", this._$_wrapY$_ = "repeat", s && (this._$_wrapX$_ = aT(s[0]), 
            this._$_wrapY$_ = aT(s[1]));
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$OnCreate$_() {
            this._$GetImageInfo$_()._$LoadAsset$_(this._$_runtime$_);
        }
        _$LoadTextures$_(t) {
            return this._$GetImageInfo$_()._$LoadStaticTexture$_(t, {
                _$sampling$_: this._$_runtime$_._$GetSampling$_(),
                _$wrapX$_: this._$_wrapX$_,
                _$wrapY$_: this._$_wrapY$_
            });
        }
        _$ReleaseTextures$_() {
            this._$GetImageInfo$_()._$ReleaseTexture$_();
        }
        _$GetWrapModeX$_() {
            return this._$_wrapX$_;
        }
        _$GetWrapModeY$_() {
            return this._$_wrapY$_;
        }
    };
}

{
    const lT = self._$C3$_, cT = self._$C3X$_, fT = 0, dT = 4, pT = 5, mT = 6, gT = 7, yT = 8, MT = 9, wT = 10, ST = 11, bT = 12, TT = 13, vT = 14, xT = lT._$New$_(lT.Rect), IT = lT._$New$_(lT._$Quad$_), GT = lT._$New$_(lT.Rect), CT = lT._$New$_(lT._$Quad$_);
    lT._$Plugins$_._$TiledBg$_.Instance = class extends lT._$SDKWorldInstanceBase$_ {
        constructor(t, s) {
            super(t), this._$_imageOffsetX$_ = 0, this._$_imageOffsetY$_ = 0, this._$_imageScaleX$_ = 1, 
            this._$_imageScaleY$_ = 1, this._$_imageAngle$_ = 0, this._$_enableTileRandomization$_ = !1, 
            this._$_tileXRandom$_ = 0, this._$_tileYRandom$_ = 0, this._$_tileAngleRandom$_ = 0, 
            this._$_tileBlendMarginX$_ = 0, this._$_tileBlendMarginY$_ = 0, this._$_ownImageInfo$_ = null, 
            s && (this._$GetWorldInfo$_()._$SetVisible$_(!!s[fT]), this._$_imageOffsetX$_ = s[dT], 
            this._$_imageOffsetY$_ = s[pT], this._$_imageScaleX$_ = s[mT], this._$_imageScaleY$_ = s[gT], 
            this._$_imageAngle$_ = lT._$toRadians$_(s[yT]), this._$_enableTileRandomization$_ = !!s[MT], 
            this._$_tileXRandom$_ = s[wT], this._$_tileYRandom$_ = s[ST], this._$_tileAngleRandom$_ = s[bT], 
            this._$_tileBlendMarginX$_ = s[TT], this._$_tileBlendMarginY$_ = s[vT]);
        }
        _$Release$_() {
            this._$_ReleaseOwnImage$_(), super._$Release$_();
        }
        _$_ReleaseOwnImage$_() {
            this._$_ownImageInfo$_ && (this._$_ownImageInfo$_._$Release$_(), this._$_ownImageInfo$_ = null);
        }
        _$CalculateTextureCoordsFor3DFace$_(t, s, i) {
            const e = this._$GetCurrentImageInfo$_(), n = e._$GetWidth$_(), h = e._$GetHeight$_(), r = this._$_imageOffsetX$_ / n, o = this._$_imageOffsetY$_ / h, a = this._$_imageAngle$_;
            GT.set(0, 0, t / (n * this._$_imageScaleX$_), s / (h * this._$_imageScaleY$_)), 
            GT.offset(-r, -o), 0 === a ? i._$setFromRect$_(GT) : i._$setFromRotatedRect$_(GT, -a);
        }
        _$SetTilingShaderProgram$_(t, s = !0) {
            if (this._$_enableTileRandomization$_) {
                const s = this._$GetCurrentImageInfo$_();
                t._$SetTileRandomizationMode$_(), t._$SetTileRandomizationInfo$_(s._$GetWidth$_() * this._$_imageScaleX$_, s._$GetHeight$_() * this._$_imageScaleY$_, this._$_tileXRandom$_, this._$_tileYRandom$_, this._$_tileAngleRandom$_, this._$_tileBlendMarginX$_, this._$_tileBlendMarginY$_);
            } else s && t._$SetTextureFillMode$_();
        }
        _$Draw$_(t) {
            const s = this._$GetCurrentImageInfo$_(), i = s._$GetTexture$_();
            if (null === i) return;
            this._$SetTilingShaderProgram$_(t), t._$SetTexture$_(i);
            const e = s._$GetWidth$_(), n = s._$GetHeight$_(), h = this._$_imageOffsetX$_ / e, r = this._$_imageOffsetY$_ / n, o = this._$GetWorldInfo$_();
            GT.set(0, 0, o._$GetWidth$_() / (e * this._$_imageScaleX$_), o._$GetHeight$_() / (n * this._$_imageScaleY$_)), 
            GT.offset(-h, -r), o._$HasMesh$_() ? this._$_DrawMesh$_(o, t) : this._$_DrawStandard$_(o, t);
        }
        _$_DrawStandard$_(t, s) {
            let i = t._$GetBoundingQuad$_();
            this._$_runtime$_._$IsPixelRoundingEnabled$_() && (i = t._$PixelRoundQuad$_(i)), 
            0 === this._$_imageAngle$_ ? s._$Quad3$_(i, GT) : (CT._$setFromRotatedRect$_(GT, -this._$_imageAngle$_), 
            s._$Quad4$_(i, CT));
        }
        _$_DrawMesh$_(t, s) {
            const i = t._$GetTransformedMesh$_();
            if (t._$IsMeshChanged$_()) {
                t._$CalculateBbox$_(xT, IT, !1);
                let s = IT;
                this._$_runtime$_._$IsPixelRoundingEnabled$_() && (s = t._$PixelRoundQuad$_(s));
                let e = GT;
                0 !== this._$_imageAngle$_ && (CT._$setFromRotatedRect$_(GT, -this._$_imageAngle$_), 
                e = CT), i._$CalculateTransformedMesh$_(t._$GetSourceMesh$_(), s, e), t._$SetMeshChanged$_(!1);
            }
            i._$Draw$_(s);
        }
        _$GetCurrentImageInfo$_() {
            return this._$_ownImageInfo$_ || this._$_objectClass$_._$GetImageInfo$_();
        }
        _$IsOriginalSizeKnown$_() {
            return !0;
        }
        _$GetTexture$_() {
            return this._$GetCurrentImageInfo$_()._$GetTexture$_();
        }
        _$_SetMeshChanged$_() {
            this._$GetWorldInfo$_()._$SetMeshChanged$_(!0);
        }
        _$_SetImageOffsetX$_(t) {
            this._$_imageOffsetX$_ !== t && (this._$_imageOffsetX$_ = t, this._$_runtime$_._$UpdateRender$_(), 
            this._$_SetMeshChanged$_());
        }
        _$_GetImageOffsetX$_() {
            return this._$_imageOffsetX$_;
        }
        _$_SetImageOffsetY$_(t) {
            this._$_imageOffsetY$_ !== t && (this._$_imageOffsetY$_ = t, this._$_runtime$_._$UpdateRender$_(), 
            this._$_SetMeshChanged$_());
        }
        _$_GetImageOffsetY$_() {
            return this._$_imageOffsetY$_;
        }
        _$_SetImageScaleX$_(t) {
            this._$_imageScaleX$_ !== t && (this._$_imageScaleX$_ = t, this._$_runtime$_._$UpdateRender$_(), 
            this._$_SetMeshChanged$_());
        }
        _$_GetImageScaleX$_() {
            return this._$_imageScaleX$_;
        }
        _$_SetImageScaleY$_(t) {
            this._$_imageScaleY$_ !== t && (this._$_imageScaleY$_ = t, this._$_runtime$_._$UpdateRender$_(), 
            this._$_SetMeshChanged$_());
        }
        _$_GetImageScaleY$_() {
            return this._$_imageScaleY$_;
        }
        _$_SetImageAngle$_(t) {
            this._$_imageAngle$_ !== t && (this._$_imageAngle$_ = t, this._$_runtime$_._$UpdateRender$_(), 
            this._$_SetMeshChanged$_());
        }
        _$_GetImageAngle$_() {
            return this._$_imageAngle$_;
        }
        _$_SetTileRandomizationEnabled$_(t) {
            t = !!t, this._$_enableTileRandomization$_ !== t && (this._$_enableTileRandomization$_ = t, 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$_IsTileRandomizationEnabled$_() {
            return this._$_enableTileRandomization$_;
        }
        _$_SetTileXRandom$_(t) {
            this._$_tileXRandom$_ !== t && (this._$_tileXRandom$_ = t, this._$_IsTileRandomizationEnabled$_() && this._$_runtime$_._$UpdateRender$_());
        }
        _$_GetTileXRandom$_() {
            return this._$_tileXRandom$_;
        }
        _$_SetTileYRandom$_(t) {
            this._$_tileYRandom$_ !== t && (this._$_tileYRandom$_ = t, this._$_IsTileRandomizationEnabled$_() && this._$_runtime$_._$UpdateRender$_());
        }
        _$_GetTileYRandom$_() {
            return this._$_tileYRandom$_;
        }
        _$_SetTileAngleRandom$_(t) {
            this._$_tileAngleRandom$_ !== t && (this._$_tileAngleRandom$_ = t, this._$_IsTileRandomizationEnabled$_() && this._$_runtime$_._$UpdateRender$_());
        }
        _$_GetTileAngleRandom$_() {
            return this._$_tileAngleRandom$_;
        }
        _$_SetTileBlendMarginX$_(t) {
            this._$_tileBlendMarginX$_ !== t && (this._$_tileBlendMarginX$_ = t, this._$_IsTileRandomizationEnabled$_() && this._$_runtime$_._$UpdateRender$_());
        }
        _$_GetTileBlendMarginX$_() {
            return this._$_tileBlendMarginX$_;
        }
        _$_SetTileBlendMarginY$_(t) {
            this._$_tileBlendMarginY$_ !== t && (this._$_tileBlendMarginY$_ = t, this._$_IsTileRandomizationEnabled$_() && this._$_runtime$_._$UpdateRender$_());
        }
        _$_GetTileBlendMarginY$_() {
            return this._$_tileBlendMarginY$_;
        }
        _$SaveToJson$_() {
            const t = {};
            return 0 !== this._$_imageOffsetX$_ && (t.iox = this._$_imageOffsetX$_), 0 !== this._$_imageOffsetY$_ && (t.ioy = this._$_imageOffsetY$_), 
            1 !== this._$_imageScaleX$_ && (t.isx = this._$_imageScaleX$_), 1 !== this._$_imageScaleY$_ && (t.isy = this._$_imageScaleY$_), 
            0 !== this._$_imageAngle$_ && (t.ia = this._$_imageAngle$_), this._$_enableTileRandomization$_ && (t.tr = !0), 
            1 !== this._$_tileXRandom$_ && (t.trx = this._$_tileXRandom$_), 1 !== this._$_tileYRandom$_ && (t.try = this._$_tileYRandom$_), 
            1 !== this._$_tileAngleRandom$_ && (t.tra = this._$_tileAngleRandom$_), .1 !== this._$_tileBlendMarginX$_ && (t.trbmx = this._$_tileBlendMarginX$_), 
            .1 !== this._$_tileBlendMarginY$_ && (t.trbmy = this._$_tileBlendMarginY$_), t;
        }
        _$LoadFromJson$_(t) {
            this._$_imageOffsetX$_ = t.iox || 0, this._$_imageOffsetY$_ = t.ioy || 0, this._$_imageScaleX$_ = t.hasOwnProperty("isx") ? t.isx : 1, 
            this._$_imageScaleY$_ = t.hasOwnProperty("isy") ? t.isy : 1, this._$_imageAngle$_ = t.ia || 0, 
            this._$_enableTileRandomization$_ = !!t.tr, this._$_tileXRandom$_ = t.hasOwnProperty("trx") ? t.trx : 1, 
            this._$_tileYRandom$_ = t.hasOwnProperty("try") ? t.try : 1, this._$_tileAngleRandom$_ = t.hasOwnProperty("tra") ? t.tra : 1, 
            this._$_tileBlendMarginX$_ = t.hasOwnProperty("trbmx") ? t.trbmx : .1, this._$_tileBlendMarginY$_ = t.hasOwnProperty("trbmy") ? t.trbmy : .1;
        }
        _$GetDebuggerProperties$_() {
            const t = "plugins.tiledbg.properties";
            return [ {
                title: t + ".image-transform.name",
                properties: [ {
                    name: t + ".image-offset-x.name",
                    value: this._$_GetImageOffsetX$_(),
                    _$onedit$_: t => this._$_SetImageOffsetX$_(t)
                }, {
                    name: t + ".image-offset-y.name",
                    value: this._$_GetImageOffsetY$_(),
                    _$onedit$_: t => this._$_SetImageOffsetY$_(t)
                }, {
                    name: t + ".image-scale-x.name",
                    value: 100 * this._$_GetImageScaleX$_(),
                    _$onedit$_: t => this._$_SetImageScaleX$_(t / 100)
                }, {
                    name: t + ".image-scale-y.name",
                    value: 100 * this._$_GetImageScaleY$_(),
                    _$onedit$_: t => this._$_SetImageScaleY$_(t / 100)
                }, {
                    name: t + ".image-angle.name",
                    value: lT._$toDegrees$_(this._$_GetImageAngle$_()),
                    _$onedit$_: t => this._$_SetImageAngle$_(lT._$toRadians$_(t))
                } ]
            }, {
                title: t + ".tile-randomization.name",
                properties: [ {
                    name: t + ".enable-tile-randomization.name",
                    value: this._$_IsTileRandomizationEnabled$_(),
                    _$onedit$_: t => this._$_SetTileRandomizationEnabled$_(t)
                }, {
                    name: t + ".x-random.name",
                    value: 100 * this._$_GetTileXRandom$_(),
                    _$onedit$_: t => this._$_SetTileXRandom$_(t / 100)
                }, {
                    name: t + ".y-random.name",
                    value: 100 * this._$_GetTileYRandom$_(),
                    _$onedit$_: t => this._$_SetTileYRandom$_(t / 100)
                }, {
                    name: t + ".angle-random.name",
                    value: 100 * this._$_GetTileAngleRandom$_(),
                    _$onedit$_: t => this._$_SetTileAngleRandom$_(t / 100)
                }, {
                    name: t + ".blend-margin-x.name",
                    value: 100 * this._$_GetTileBlendMarginX$_(),
                    _$onedit$_: t => this._$_SetTileBlendMarginX$_(t / 100)
                }, {
                    name: t + ".blend-margin-y.name",
                    value: 100 * this._$_GetTileBlendMarginY$_(),
                    _$onedit$_: t => this._$_SetTileBlendMarginY$_(t / 100)
                } ]
            } ];
        }
        _$GetPropertyValueByIndex$_(t) {
            switch (t) {
              case dT:
                return this._$_GetImageOffsetX$_();

              case pT:
                return this._$_GetImageOffsetY$_();

              case mT:
                return this._$_GetImageScaleX$_();

              case gT:
                return this._$_GetImageScaleY$_();

              case yT:
                return this._$_GetImageAngle$_();

              case MT:
                return this._$_IsTileRandomizationEnabled$_();

              case wT:
                return this._$_GetTileXRandom$_();

              case ST:
                return this._$_GetTileYRandom$_();

              case bT:
                return this._$_GetTileAngleRandom$_();

              case TT:
                return this._$_GetTileBlendMarginX$_();

              case vT:
                return this._$_GetTileBlendMarginY$_();
            }
        }
        _$SetPropertyValueByIndex$_(t, s) {
            switch (t) {
              case dT:
                this._$_SetImageOffsetX$_(s);
                break;

              case pT:
                this._$_SetImageOffsetY$_(s);
                break;

              case mT:
                this._$_SetImageScaleX$_(s);
                break;

              case gT:
                this._$_SetImageScaleY$_(s);
                break;

              case yT:
                this._$_SetImageAngle$_(s);
                break;

              case MT:
                this._$_SetTileRandomizationEnabled$_(!!s);
                break;

              case wT:
                this._$_SetTileXRandom$_(s);
                break;

              case ST:
                this._$_SetTileYRandom$_(s);
                break;

              case bT:
                this._$_SetTileAngleRandom$_(s);
                break;

              case TT:
                this._$_SetTileBlendMarginX$_(s);
                break;

              case vT:
                this._$_SetTileBlendMarginY$_(s);
            }
        }
        _$GetScriptInterfaceClass$_() {
            return self._$ITiledBackgroundInstance$_;
        }
    };
    const _T = new WeakMap;
    self._$ITiledBackgroundInstance$_ = class extends self._$IWorldInstance$_ {
        constructor() {
            super(), _T.set(this, self._$IInstance$_._$_GetInitInst$_()._$GetSdkInstance$_());
        }
        set _$imageOffsetX$_(t) {
            cT._$RequireFiniteNumber$_(t), _T.get(this)._$_SetImageOffsetX$_(t);
        }
        get _$imageOffsetX$_() {
            return _T.get(this)._$_GetImageOffsetX$_();
        }
        set _$imageOffsetY$_(t) {
            cT._$RequireFiniteNumber$_(t), _T.get(this)._$_SetImageOffsetY$_(t);
        }
        get _$imageOffsetY$_() {
            return _T.get(this)._$_GetImageOffsetY$_();
        }
        _$setImageOffset$_(t, s) {
            cT._$RequireFiniteNumber$_(t), cT._$RequireFiniteNumber$_(s);
            const i = _T.get(this);
            i._$_SetImageOffsetX$_(t), i._$_SetImageOffsetY$_(s);
        }
        _$getImageOffset$_() {
            const t = _T.get(this);
            return [ t._$_GetImageOffsetX$_(), t._$_GetImageOffsetY$_() ];
        }
        set _$imageScaleX$_(t) {
            cT._$RequireFiniteNumber$_(t), _T.get(this)._$_SetImageScaleX$_(t);
        }
        get _$imageScaleX$_() {
            return _T.get(this)._$_GetImageScaleX$_();
        }
        set _$imageScaleY$_(t) {
            cT._$RequireFiniteNumber$_(t), _T.get(this)._$_SetImageScaleY$_(t);
        }
        get _$imageScaleY$_() {
            return _T.get(this)._$_GetImageScaleY$_();
        }
        _$setImageScale$_(t, s) {
            cT._$RequireFiniteNumber$_(t), cT._$RequireFiniteNumber$_(s);
            const i = _T.get(this);
            i._$_SetImageScaleX$_(t), i._$_SetImageScaleY$_(s);
        }
        _$getImageScale$_() {
            const t = _T.get(this);
            return [ t._$_GetImageScaleX$_(), t._$_GetImageScaleY$_() ];
        }
        set _$imageAngle$_(t) {
            cT._$RequireFiniteNumber$_(t), _T.get(this)._$_SetImageAngle$_(t);
        }
        get _$imageAngle$_() {
            return _T.get(this)._$_GetImageAngle$_();
        }
        set _$imageAngleDegrees$_(t) {
            cT._$RequireFiniteNumber$_(t), _T.get(this)._$_SetImageAngle$_(lT._$toRadians$_(t));
        }
        get _$imageAngleDegrees$_() {
            return lT._$toDegrees$_(_T.get(this)._$_GetImageAngle$_());
        }
        get imageWidth() {
            return _T.get(this)._$GetCurrentImageInfo$_()._$GetWidth$_();
        }
        get imageHeight() {
            return _T.get(this)._$GetCurrentImageInfo$_()._$GetHeight$_();
        }
        _$getImageSize$_() {
            const t = _T.get(this)._$GetCurrentImageInfo$_();
            return [ t._$GetWidth$_(), t._$GetHeight$_() ];
        }
        set _$enableTileRandomization$_(t) {
            _T.get(this)._$_SetTileRandomizationEnabled$_(!!t);
        }
        get _$enableTileRandomization$_() {
            return _T.get(this)._$_IsTileRandomizationEnabled$_();
        }
        set _$tileXRandom$_(t) {
            cT._$RequireFiniteNumber$_(t), _T.get(this)._$_SetTileXRandom$_(t);
        }
        get _$tileXRandom$_() {
            return _T.get(this)._$_GetTileXRandom$_();
        }
        set _$tileYRandom$_(t) {
            cT._$RequireFiniteNumber$_(t), _T.get(this)._$_SetTileYRandom$_(t);
        }
        get _$tileYRandom$_() {
            return _T.get(this)._$_GetTileYRandom$_();
        }
        _$setTileRandom$_(t, s) {
            cT._$RequireFiniteNumber$_(t), cT._$RequireFiniteNumber$_(s);
            const i = _T.get(this);
            i._$_SetTileXRandom$_(t), i._$_SetTileYRandom$_(s);
        }
        _$getTileRandom$_() {
            const t = _T.get(this);
            return [ t._$_GetTileXRandom$_(), t._$_GetTileYRandom$_() ];
        }
        set _$tileAngleRandom$_(t) {
            cT._$RequireFiniteNumber$_(t), _T.get(this)._$_SetTileAngleRandom$_(t);
        }
        get _$tileAngleRandom$_() {
            return _T.get(this)._$_GetTileAngleRandom$_();
        }
        set _$tileBlendMarginX$_(t) {
            cT._$RequireFiniteNumber$_(t), _T.get(this)._$_SetTileBlendMarginX$_(t);
        }
        get _$tileBlendMarginX$_() {
            return _T.get(this)._$_GetTileBlendMarginX$_();
        }
        set _$tileBlendMarginY$_(t) {
            cT._$RequireFiniteNumber$_(t), _T.get(this)._$_SetTileBlendMarginY$_(t);
        }
        get _$tileBlendMarginY$_() {
            return _T.get(this)._$_GetTileBlendMarginY$_();
        }
        _$setTileBlendMargin$_(t, s) {
            cT._$RequireFiniteNumber$_(t), cT._$RequireFiniteNumber$_(s);
            const i = _T.get(this);
            i._$_SetTileBlendMarginX$_(t), i._$_SetTileBlendMarginY$_(s);
        }
        _$getTileBlendMargin$_() {
            const t = _T.get(this);
            return [ t._$_GetTileBlendMarginX$_(), t._$_GetTileBlendMarginY$_() ];
        }
        async _$replaceImage$_(t) {
            cT._$RequireInstanceOf$_(t, Blob);
            const s = _T.get(this), i = s._$GetRuntime$_(), e = lT._$New$_(lT._$ImageInfo$_);
            e._$LoadDynamicBlobAsset$_(i, t), await e._$LoadStaticTexture$_(i._$GetRenderer$_(), {
                _$sampling$_: i._$GetSampling$_(),
                _$wrapX$_: s._$GetSdkType$_()._$GetWrapModeX$_(),
                _$wrapY$_: s._$GetSdkType$_()._$GetWrapModeY$_()
            }), s._$WasReleased$_() ? e._$Release$_() : (s._$_ReleaseOwnImage$_(), s._$_ownImageInfo$_ = e, 
            i._$UpdateRender$_());
        }
    };
}

self._$C3$_._$Plugins$_._$TiledBg$_._$Cnds$_ = {
    _$OnURLLoaded$_: () => !0,
    _$OnURLFailed$_: () => !0,
    _$IsTileRandomizationEnabled$_() {
        return this._$_IsTileRandomizationEnabled$_();
    }
};

{
    const ET = self._$C3$_;
    ET._$Plugins$_._$TiledBg$_._$Acts$_ = {
        _$SetImageOffsetX$_(t) {
            this._$_SetImageOffsetX$_(t);
        },
        _$SetImageOffsetY$_(t) {
            this._$_SetImageOffsetY$_(t);
        },
        _$SetImageScaleX$_(t) {
            this._$_SetImageScaleX$_(t / 100);
        },
        _$SetImageScaleY$_(t) {
            this._$_SetImageScaleY$_(t / 100);
        },
        _$SetImageAngle$_(t) {
            this._$_SetImageAngle$_(ET._$toRadians$_(t));
        },
        _$SetTileRandomizationEnabled$_(t) {
            this._$_SetTileRandomizationEnabled$_(t);
        },
        _$SetTilePosRandom$_(t, s) {
            this._$_SetTileXRandom$_(t / 100), this._$_SetTileYRandom$_(s / 100);
        },
        _$SetTileAngleRandom$_(t) {
            this._$_SetTileAngleRandom$_(t / 100);
        },
        _$SetTileBlendMargin$_(t, s) {
            this._$_SetTileBlendMarginX$_(t / 100), this._$_SetTileBlendMarginY$_(s / 100);
        },
        _$SetEffect$_(t) {
            this._$GetWorldInfo$_()._$SetBlendMode$_(t), this._$_runtime$_._$UpdateRender$_();
        },
        async _$LoadURL$_(t, s) {
            if (this._$_ownImageInfo$_ && this._$_ownImageInfo$_._$GetURL$_() === t) return;
            const i = this._$_runtime$_, e = ET._$New$_(ET._$ImageInfo$_);
            try {
                if (await e._$LoadDynamicAsset$_(i, t), !e._$IsLoaded$_()) throw new Error("image failed to load");
                if (this._$WasReleased$_()) return e._$Release$_(), null;
                if (!await e._$LoadStaticTexture$_(i._$GetRenderer$_(), {
                    _$sampling$_: i._$GetSampling$_(),
                    _$wrapX$_: this._$GetSdkType$_()._$GetWrapModeX$_(),
                    _$wrapY$_: this._$GetSdkType$_()._$GetWrapModeY$_()
                })) return;
            } catch (t) {
                return console.error("Load image from URL failed: ", t), void (this._$WasReleased$_() || this._$Trigger$_(ET._$Plugins$_._$TiledBg$_._$Cnds$_._$OnURLFailed$_));
            }
            this._$WasReleased$_() ? e._$Release$_() : (this._$_ReleaseOwnImage$_(), this._$_ownImageInfo$_ = e, 
            i._$UpdateRender$_(), await this._$TriggerAsync$_(ET._$Plugins$_._$TiledBg$_._$Cnds$_._$OnURLLoaded$_));
        }
    };
}

{
    const DT = self._$C3$_;
    DT._$Plugins$_._$TiledBg$_._$Exps$_ = {
        _$ImageWidth$_() {
            return this._$GetCurrentImageInfo$_()._$GetWidth$_();
        },
        _$ImageHeight$_() {
            return this._$GetCurrentImageInfo$_()._$GetHeight$_();
        },
        _$ImageOffsetX$_() {
            return this._$_imageOffsetX$_;
        },
        _$ImageOffsetY$_() {
            return this._$_imageOffsetY$_;
        },
        _$ImageScaleX$_() {
            return 100 * this._$_imageScaleX$_;
        },
        _$ImageScaleY$_() {
            return 100 * this._$_imageScaleY$_;
        },
        _$ImageAngle$_() {
            return DT._$toDegrees$_(this._$_imageAngle$_);
        },
        _$TileXRandom$_() {
            return 100 * this._$_GetTileXRandom$_();
        },
        _$TileYRandom$_() {
            return 100 * this._$_GetTileYRandom$_();
        },
        _$TileAngleRandom$_() {
            return 100 * this._$_GetTileAngleRandom$_();
        },
        _$TileBlendMarginX$_() {
            return 100 * this._$_GetTileBlendMarginX$_();
        },
        _$TileBlendMarginY$_() {
            return 100 * this._$_GetTileBlendMarginY$_();
        }
    };
}

{
    const AT = self._$C3$_;
    AT._$Behaviors$_._$Pin$_ = class extends AT._$SDKBehaviorBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
    };
}

{
    const NT = self._$C3$_;
    NT._$Behaviors$_._$Pin$_._$Type$_ = class extends NT._$SDKBehaviorTypeBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$OnCreate$_() {}
    };
}

{
    const LT = self._$C3$_;
    LT._$Behaviors$_._$Pin$_.Instance = class extends LT._$SDKBehaviorInstanceBase$_ {
        constructor(t, s) {
            super(t), this._$_pinInst$_ = null, this._$_pinUid$_ = -1, this._$_mode$_ = "", 
            this._$_propSet$_ = new Set, this._$_pinDist$_ = 0, this._$_pinAngle$_ = 0, this._$_pinImagePoint$_ = 0, 
            this._$_dx$_ = 0, this._$_dy$_ = 0, this._$_dWidth$_ = 0, this._$_dHeight$_ = 0, 
            this._$_dAngle$_ = 0, this._$_dz$_ = 0, this._$_lastKnownAngle$_ = 0, this._$_destroy$_ = !1, 
            s && (this._$_destroy$_ = s[0]);
            const i = this._$_runtime$_._$Dispatcher$_();
            this._$_disposables$_ = new LT._$CompositeDisposable$_(LT._$Disposable$_._$From$_(i, "instancedestroy", (t => this._$_OnInstanceDestroyed$_(t._$instance$_))), LT._$Disposable$_._$From$_(i, "afterload", (t => this._$_OnAfterLoad$_())));
        }
        _$Release$_() {
            this._$_pinInst$_ = null, super._$Release$_();
        }
        _$_SetPinInst$_(t) {
            t ? (this._$_pinInst$_ = t, this._$_StartTicking2$_()) : (this._$_pinInst$_ = null, 
            this._$_StopTicking2$_());
        }
        _$_Pin$_(t, s, i) {
            if (!t) return;
            const e = t._$GetFirstPicked$_(this._$_inst$_);
            if (!e) return;
            this._$_mode$_ = s, this._$_SetPinInst$_(e);
            const n = this._$_inst$_._$GetWorldInfo$_(), h = e._$GetWorldInfo$_();
            if ("properties" === this._$_mode$_) {
                const t = this._$_propSet$_;
                t.clear();
                for (const s of i) t.add(s);
                this._$_dx$_ = n._$GetX$_() - h._$GetX$_(), this._$_dy$_ = n._$GetY$_() - h._$GetY$_(), 
                this._$_dAngle$_ = n._$GetAngle$_() - h._$GetAngle$_(), this._$_lastKnownAngle$_ = n._$GetAngle$_(), 
                this._$_dz$_ = n._$GetZElevation$_() - h._$GetZElevation$_(), t.has("x") && t.has("y") && (this._$_pinAngle$_ = LT._$angleTo$_(h._$GetX$_(), h._$GetY$_(), n._$GetX$_(), n._$GetY$_()) - h._$GetAngle$_(), 
                this._$_pinDist$_ = LT._$distanceTo$_(h._$GetX$_(), h._$GetY$_(), n._$GetX$_(), n._$GetY$_())), 
                t.has("width-abs") ? this._$_dWidth$_ = n._$GetWidth$_() - h._$GetWidth$_() : t.has("width-scale") && (this._$_dWidth$_ = n._$GetWidth$_() / h._$GetWidth$_()), 
                t.has("height-abs") ? this._$_dHeight$_ = n._$GetHeight$_() - h._$GetHeight$_() : t.has("height-scale") && (this._$_dHeight$_ = n._$GetHeight$_() / h._$GetHeight$_());
            } else this._$_pinDist$_ = LT._$distanceTo$_(h._$GetX$_(), h._$GetY$_(), n._$GetX$_(), n._$GetY$_());
        }
        _$SaveToJson$_() {
            const t = this._$_propSet$_, s = this._$_mode$_, i = {
                uid: this._$_pinInst$_ && !this._$_pinInst$_._$IsDestroyed$_() ? this._$_pinInst$_._$GetUID$_() : -1,
                m: s,
                d: this._$_destroy$_
            };
            return "rope" === s || "bar" === s ? i.pd = this._$_pinDist$_ : "properties" === s && (i.ps = [ ...this._$_propSet$_ ], 
            t.has("imagepoint") ? i.ip = this._$_pinImagePoint$_ : t.has("x") && t.has("y") ? (i.pa = this._$_pinAngle$_, 
            i.pd = this._$_pinDist$_) : (t.has("x") && (i.dx = this._$_dx$_), t.has("y") && (i.dy = this._$_dy$_)), 
            t.has("angle") && (i.da = this._$_dAngle$_, i.lka = this._$_lastKnownAngle$_), (t.has("width-abs") || t.has("width-scale")) && (i.dw = this._$_dWidth$_), 
            (t.has("height-abs") || t.has("height-scale")) && (i.dh = this._$_dHeight$_), t.has("z") && (i.dz = this._$_dz$_)), 
            i;
        }
        _$LoadFromJson$_(t) {
            const s = t.m, i = this._$_propSet$_;
            if (i.clear(), this._$_pinUid$_ = t.uid, "number" != typeof s) {
                if (this._$_mode$_ = s, t.hasOwnProperty("d") && (this._$_destroy$_ = !!t.d), "rope" === s || "bar" === s) this._$_pinDist$_ = t.pd; else if ("properties" === s) {
                    for (const s of t.ps) i.add(s);
                    i.has("imagepoint") ? this._$_pinImagePoint$_ = t.ip : i.has("x") && i.has("y") ? (this._$_pinAngle$_ = t.pa, 
                    this._$_pinDist$_ = t.pd) : (i.has("x") && (this._$_dx$_ = t.dx), i.has("y") && (this._$_dy$_ = t.dy)), 
                    i.has("angle") && (this._$_dAngle$_ = t.da, this._$_lastKnownAngle$_ = t.lka || 0), 
                    (i.has("width-abs") || i.has("width-scale")) && (this._$_dWidth$_ = t.dw), (i.has("height-abs") || i.has("height-scale")) && (this._$_dHeight$_ = t.dh), 
                    i.has("z") && (this._$_dz$_ = t.dz);
                }
            } else this._$_LoadFromJson_Legacy$_(t);
        }
        _$_LoadFromJson_Legacy$_(t) {
            const s = this._$_propSet$_, i = t.msa, e = t.tsa, n = t.pa, h = t.pd;
            switch (t.m) {
              case 0:
                this._$_mode$_ = "properties", s.add("x").add("y").add("angle"), this._$_pinAngle$_ = n, 
                this._$_pinDist$_ = h, this._$_dAngle$_ = i - e, this._$_lastKnownAngle$_ = t.lka;
                break;

              case 1:
                this._$_mode$_ = "properties", s.add("x").add("y"), this._$_pinAngle$_ = n, this._$_pinDist$_ = h;
                break;

              case 2:
                this._$_mode$_ = "properties", s.add("angle"), this._$_dAngle$_ = i - e, this._$_lastKnownAngle$_ = t.lka;
                break;

              case 3:
                this._$_mode$_ = "rope", this._$_pinDist$_ = t.pd;
                break;

              case 4:
                this._$_mode$_ = "bar", this._$_pinDist$_ = t.pd;
            }
        }
        _$_OnAfterLoad$_() {
            -1 === this._$_pinUid$_ ? this._$_SetPinInst$_(null) : (this._$_SetPinInst$_(this._$_runtime$_._$GetInstanceByUID$_(this._$_pinUid$_)), 
            this._$_pinUid$_ = -1);
        }
        _$_OnInstanceDestroyed$_(t) {
            this._$_pinInst$_ === t && (this._$_SetPinInst$_(null), this._$_destroy$_ && this._$_runtime$_._$DestroyInstance$_(this._$_inst$_));
        }
        _$Tick2$_() {
            const t = this._$_pinInst$_;
            if (!t || t._$IsDestroyed$_()) return;
            const s = t._$GetWorldInfo$_(), i = this._$_inst$_._$GetWorldInfo$_(), e = this._$_mode$_;
            let n = !1;
            if ("rope" === e || "bar" === e) {
                const t = LT._$distanceTo$_(i._$GetX$_(), i._$GetY$_(), s._$GetX$_(), s._$GetY$_());
                if (t > this._$_pinDist$_ || "bar" === e && t < this._$_pinDist$_) {
                    const t = LT._$angleTo$_(s._$GetX$_(), s._$GetY$_(), i._$GetX$_(), i._$GetY$_());
                    i._$SetXY$_(s._$GetX$_() + Math.cos(t) * this._$_pinDist$_, s._$GetY$_() + Math.sin(t) * this._$_pinDist$_), 
                    n = !0;
                }
            } else {
                const e = this._$_propSet$_;
                let h = 0;
                if (e.has("imagepoint")) {
                    const [s, e] = t._$GetImagePoint$_(this._$_pinImagePoint$_);
                    i._$EqualsXY$_(s, e) || (i._$SetXY$_(s, e), n = !0);
                } else if (e.has("x") && e.has("y")) {
                    const t = s._$GetX$_() + Math.cos(s._$GetAngle$_() + this._$_pinAngle$_) * this._$_pinDist$_, e = s._$GetY$_() + Math.sin(s._$GetAngle$_() + this._$_pinAngle$_) * this._$_pinDist$_;
                    i._$EqualsXY$_(t, e) || (i._$SetXY$_(t, e), n = !0);
                } else h = s._$GetX$_() + this._$_dx$_, e.has("x") && h !== i._$GetX$_() && (i._$SetX$_(h), 
                n = !0), h = s._$GetY$_() + this._$_dy$_, e.has("y") && h !== i._$GetY$_() && (i._$SetY$_(h), 
                n = !0);
                e.has("angle") && (this._$_lastKnownAngle$_ !== i._$GetAngle$_() && (this._$_dAngle$_ = LT._$clampAngle$_(this._$_dAngle$_ + (i._$GetAngle$_() - this._$_lastKnownAngle$_))), 
                h = LT._$clampAngle$_(s._$GetAngle$_() + this._$_dAngle$_), h !== i._$GetAngle$_() && (i._$SetAngle$_(h), 
                n = !0), this._$_lastKnownAngle$_ = i._$GetAngle$_()), e.has("width-abs") && (h = s._$GetWidth$_() + this._$_dWidth$_, 
                h !== i._$GetWidth$_() && (i._$SetWidth$_(h), n = !0)), e.has("width-scale") && (h = s._$GetWidth$_() * this._$_dWidth$_, 
                h !== i._$GetWidth$_() && (i._$SetWidth$_(h), n = !0)), e.has("height-abs") && (h = s._$GetHeight$_() + this._$_dHeight$_, 
                h !== i._$GetHeight$_() && (i._$SetHeight$_(h), n = !0)), e.has("height-scale") && (h = s._$GetHeight$_() * this._$_dHeight$_, 
                h !== i._$GetHeight$_() && (i._$SetHeight$_(h), n = !0)), e.has("z") && (h = s._$GetZElevation$_() + this._$_dz$_, 
                h !== i._$GetZElevation$_() && (i._$SetZElevation$_(h), this._$_runtime$_._$UpdateRender$_()));
            }
            n && i._$SetBboxChanged$_();
        }
        _$GetDebuggerProperties$_() {
            const t = "behaviors.pin.debugger";
            return [ {
                title: "$" + this._$GetBehaviorType$_()._$GetName$_(),
                properties: [ {
                    name: t + ".is-pinned",
                    value: !!this._$_pinInst$_
                }, {
                    name: t + ".pinned-uid",
                    value: this._$_pinInst$_ ? this._$_pinInst$_._$GetUID$_() : 0
                } ]
            } ];
        }
    };
}

self._$C3$_._$Behaviors$_._$Pin$_._$Cnds$_ = {
    _$IsPinned$_() {
        return !!this._$_pinInst$_;
    },
    _$WillDestroy$_() {
        return this._$_destroy$_;
    }
}, self._$C3$_._$Behaviors$_._$Pin$_._$Acts$_ = {
    _$PinByDistance$_(t, s) {
        this._$_Pin$_(t, 0 === s ? "rope" : "bar");
    },
    _$PinByProperties$_(t, s, i, e, n, h, r) {
        const o = [];
        s && o.push("x"), i && o.push("y"), e && o.push("angle"), r && o.push("z"), 1 === n ? o.push("width-abs") : 2 === n && o.push("width-scale"), 
        1 === h ? o.push("height-abs") : 2 === h && o.push("height-scale"), 0 !== o.length && this._$_Pin$_(t, "properties", o);
    },
    _$PinByImagePoint$_(t, s, i, e, n, h) {
        const r = [ "imagepoint" ];
        i && r.push("angle"), h && r.push("z"), 1 === e ? r.push("width-abs") : 2 === e && r.push("width-scale"), 
        1 === n ? r.push("height-abs") : 2 === n && r.push("height-scale"), this._$_pinImagePoint$_ = s, 
        this._$_Pin$_(t, "properties", r);
    },
    _$SetPinDistance$_(t) {
        "rope" !== this._$_mode$_ && "bar" !== this._$_mode$_ || (this._$_pinDist$_ = Math.max(t, 0));
    },
    _$SetDestroy$_(t) {
        this._$_destroy$_ = t;
    },
    _$Unpin$_() {
        this._$_SetPinInst$_(null), this._$_mode$_ = "", this._$_propSet$_.clear(), this._$_pinImagePoint$_ = "";
    },
    _$Pin$_(t, s) {
        switch (s) {
          case 0:
            this._$_Pin$_(t, "properties", [ "x", "y", "angle" ]);
            break;

          case 1:
            this._$_Pin$_(t, "properties", [ "x", "y" ]);
            break;

          case 2:
            this._$_Pin$_(t, "properties", [ "angle" ]);
            break;

          case 3:
            this._$_Pin$_(t, "rope");
            break;

          case 4:
            this._$_Pin$_(t, "bar");
        }
    }
}, self._$C3$_._$Behaviors$_._$Pin$_._$Exps$_ = {
    _$PinnedUID$_() {
        return this._$_pinInst$_ ? this._$_pinInst$_._$GetUID$_() : -1;
    }
};

{
    const OT = self._$C3$_;
    OT._$Behaviors$_._$Platform$_ = class extends OT._$SDKBehaviorBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
    };
}

{
    const RT = self._$C3$_;
    RT._$Behaviors$_._$Platform$_._$Type$_ = class extends RT._$SDKBehaviorTypeBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$OnCreate$_() {}
    };
}

{
    let PT = function(t, s, i, e, n) {
        const h = s * n, r = i * n;
        return kT._$clamp$_(t * n + .5 * e * n * n, h, r);
    };
    0;
    const kT = self._$C3$_, FT = self._$C3X$_, jT = self._$IBehaviorInstance$_, BT = 0, zT = 1, UT = 2, WT = 3, JT = 4, QT = 5, YT = 6, VT = 7, HT = 8, qT = 9, XT = .05;
    kT._$Behaviors$_._$Platform$_.Instance = class extends kT._$SDKBehaviorInstanceBase$_ {
        constructor(t, s) {
            super(t), this._$_keyboardDisposables$_ = null, this._$_leftKey$_ = !1, this._$_rightKey$_ = !1, 
            this._$_jumpKey$_ = !1, this._$_jumped$_ = !1, this._$_doubleJumped$_ = !1, this._$_canDoubleJump$_ = !1, 
            this._$_ignoreInput$_ = !1, this._$_simLeft$_ = !1, this._$_simRight$_ = !1, this._$_simJump$_ = !1, 
            this._$_lastFloorObject$_ = null, this._$_loadFloorUid$_ = -1, this._$_lastFloorX$_ = 0, 
            this._$_lastFloorY$_ = 0, this._$_floorIsJumpthru$_ = !1, this._$_wasOnFloor$_ = !1, 
            this._$_wasOverJumpthru$_ = this._$_runtime$_._$GetCollisionEngine$_()._$TestOverlapJumpthru$_(this._$_inst$_), 
            this._$_loadJumpthruUid$_ = -1, this._$_animMode$_ = "stopped", this._$_fallThroughTime$_ = -1, 
            this._$_isFirstTick$_ = !0, this._$_dx$_ = 0, this._$_dy$_ = 0, this._$_downX$_ = 0, 
            this._$_downY$_ = 0, this._$_rightX$_ = 0, this._$_rightY$_ = 0, this._$_g$_ = 1500, 
            this._$_g1$_ = 1500, this._$_ga$_ = kT._$toRadians$_(90), this._$_maxSpeed$_ = 330, 
            this._$_acc$_ = 1500, this._$_dec$_ = 1500, this._$_jumpStrength$_ = 650, this._$_maxFall$_ = 1e3, 
            this._$_enableDoubleJump$_ = !1, this._$_jumpSustain$_ = 0, this._$_sustainTime$_ = 0, 
            this._$_defaultControls$_ = !0, this._$_ceilingCollisionMode$_ = 0, this._$_isEnabled$_ = !0, 
            s && (this._$_maxSpeed$_ = s[BT], this._$_acc$_ = s[zT], this._$_dec$_ = s[UT], 
            this._$_jumpStrength$_ = s[WT], this._$_g$_ = s[JT], this._$_maxFall$_ = s[QT], 
            this._$_enableDoubleJump$_ = !!s[YT], this._$_jumpSustain$_ = s[VT] / 1e3, this._$_defaultControls$_ = !!s[HT], 
            this._$_isEnabled$_ = !!s[qT]);
            const i = this._$_runtime$_._$Dispatcher$_();
            this._$_disposables$_ = new kT._$CompositeDisposable$_(kT._$Disposable$_._$From$_(i, "instancedestroy", (t => this._$_OnInstanceDestroyed$_(t._$instance$_))), kT._$Disposable$_._$From$_(i, "afterload", (t => this._$_OnAfterLoad$_()))), 
            this._$_defaultControls$_ && this._$_BindEvents$_(), this._$_isEnabled$_ && this._$_StartPostTicking$_(), 
            this._$_UpdateGravity$_();
        }
        _$Release$_() {
            this._$_keyboardDisposables$_ && (this._$_keyboardDisposables$_._$Release$_(), this._$_keyboardDisposables$_ = null), 
            this._$_lastFloorObject$_ = null, this._$_wasOverJumpthru$_ = null, super._$Release$_();
        }
        _$_BindEvents$_() {
            if (this._$_keyboardDisposables$_) return;
            const t = this._$_runtime$_._$Dispatcher$_();
            this._$_keyboardDisposables$_ = new kT._$CompositeDisposable$_(kT._$Disposable$_._$From$_(t, "keydown", (t => this._$_OnKeyDown$_(t.data))), kT._$Disposable$_._$From$_(t, "keyup", (t => this._$_OnKeyUp$_(t.data))), kT._$Disposable$_._$From$_(t, "window-blur", (() => this._$_OnWindowOrKeyboardBlur$_())), kT._$Disposable$_._$From$_(t, "keyboard-blur", (() => this._$_OnWindowOrKeyboardBlur$_())));
        }
        _$_UnBindEvents$_() {
            this._$_keyboardDisposables$_ && (this._$_keyboardDisposables$_._$Release$_(), this._$_keyboardDisposables$_ = null);
        }
        _$_OnInstanceDestroyed$_(t) {
            this._$_lastFloorObject$_ === t && (this._$_lastFloorObject$_ = null), this._$_wasOverJumpthru$_ === t && (this._$_wasOverJumpthru$_ = null);
        }
        _$_OnKeyDown$_(t) {
            switch (t.key) {
              case "ArrowLeft":
                this._$_leftKey$_ = !0;
                break;

              case "ArrowRight":
                this._$_rightKey$_ = !0;
                break;

              case "ArrowUp":
                this._$_jumpKey$_ = !0;
            }
        }
        _$_OnKeyUp$_(t) {
            switch (t.key) {
              case "ArrowLeft":
                this._$_leftKey$_ = !1;
                break;

              case "ArrowRight":
                this._$_rightKey$_ = !1;
                break;

              case "ArrowUp":
                this._$_jumpKey$_ = !1, this._$_jumped$_ = !1;
            }
        }
        _$_OnWindowOrKeyboardBlur$_() {
            this._$_leftKey$_ = !1, this._$_rightKey$_ = !1, this._$_jumpKey$_ = !1, this._$_jumped$_ = !1;
        }
        _$SaveToJson$_() {
            return {
                ii: this._$_ignoreInput$_,
                lfx: this._$_lastFloorX$_,
                lfy: this._$_lastFloorY$_,
                lfo: this._$_lastFloorObject$_ ? this._$_lastFloorObject$_._$GetUID$_() : -1,
                am: this._$_animMode$_,
                en: this._$_isEnabled$_,
                fallt: this._$_fallThroughTime$_,
                ft: this._$_isFirstTick$_,
                dx: this._$_dx$_,
                dy: this._$_dy$_,
                ms: this._$_maxSpeed$_,
                acc: this._$_acc$_,
                dec: this._$_dec$_,
                js: this._$_jumpStrength$_,
                g: this._$_g$_,
                g1: this._$_g1$_,
                mf: this._$_maxFall$_,
                wof: this._$_wasOnFloor$_,
                woj: this._$_wasOverJumpthru$_ ? this._$_wasOverJumpthru$_._$GetUID$_() : -1,
                ga: this._$_ga$_,
                edj: this._$_enableDoubleJump$_,
                cdj: this._$_canDoubleJump$_,
                dj: this._$_doubleJumped$_,
                sus: this._$_jumpSustain$_,
                dc: this._$_defaultControls$_,
                cc: this._$_ceilingCollisionMode$_
            };
        }
        _$LoadFromJson$_(t) {
            this._$_ignoreInput$_ = t.ii, this._$_lastFloorX$_ = t.lfx, this._$_lastFloorY$_ = t.lfy, 
            this._$_loadFloorUid$_ = t.lfo, this._$_animMode$_ = t.am;
            const s = t.en;
            this._$_fallThroughTime$_ = t.fallt || -1, this._$_isFirstTick$_ = t.ft, this._$_dx$_ = t.dx, 
            this._$_dy$_ = t.dy, this._$_maxSpeed$_ = t.ms, this._$_acc$_ = t.acc, this._$_dec$_ = t.dec, 
            this._$_jumpStrength$_ = t.js, this._$_g$_ = t.g, this._$_g1$_ = t.g1, this._$_maxFall$_ = t.mf, 
            this._$_wasOnFloor$_ = t.wof, this._$_loadJumpthruUid$_ = t.woj, this._$_ga$_ = t.ga, 
            this._$_enableDoubleJump$_ = t.edj, this._$_canDoubleJump$_ = t.cdj, this._$_doubleJumped$_ = t.dj, 
            this._$_jumpSustain$_ = t.sus, this._$_defaultControls$_ = t.dc, this._$_ceilingCollisionMode$_ = t.cc || 0, 
            this._$_leftKey$_ = !1, this._$_rightKey$_ = !1, this._$_jumpKey$_ = !1, this._$_jumped$_ = !1, 
            this._$_simLeft$_ = !1, this._$_simRight$_ = !1, this._$_simJump$_ = !1, this._$_sustainTime$_ = 0, 
            this._$_defaultControls$_ ? this._$_BindEvents$_() : this._$_UnBindEvents$_(), this._$_SetEnabled$_(s), 
            this._$_UpdateGravity$_();
        }
        _$_OnAfterLoad$_() {
            -1 === this._$_loadFloorUid$_ ? this._$_lastFloorObject$_ = null : this._$_lastFloorObject$_ = this._$_runtime$_._$GetInstanceByUID$_(this._$_loadFloorUid$_), 
            -1 === this._$_loadJumpthruUid$_ ? this._$_wasOverJumpthru$_ = null : this._$_wasOverJumpthru$_ = this._$_runtime$_._$GetInstanceByUID$_(this._$_loadJumpthruUid$_);
        }
        _$_SetLastFloorObject$_(t) {
            if (this._$_lastFloorObject$_ = t, t) {
                const s = t._$GetWorldInfo$_();
                this._$_lastFloorX$_ = s._$GetX$_(), this._$_lastFloorY$_ = s._$GetY$_();
            }
        }
        _$_IsFallThroughEnabled$_() {
            return this._$_runtime$_._$GetGameTime$_() > this._$_fallThroughTime$_ + XT;
        }
        _$_UpdateGravity$_() {
            this._$_downX$_ = Math.cos(this._$_ga$_), this._$_downY$_ = Math.sin(this._$_ga$_), 
            this._$_rightX$_ = Math.cos(this._$_ga$_ - Math.PI / 2), this._$_rightY$_ = Math.sin(this._$_ga$_ - Math.PI / 2), 
            this._$_downX$_ = kT._$roundToDp$_(this._$_downX$_, 6), this._$_downY$_ = kT._$roundToDp$_(this._$_downY$_, 6), 
            this._$_rightX$_ = kT._$roundToDp$_(this._$_rightX$_, 6), this._$_rightY$_ = kT._$roundToDp$_(this._$_rightY$_, 6), 
            this._$_g1$_ = this._$_g$_, this._$_g$_ < 0 && (this._$_downX$_ *= -1, this._$_downY$_ *= -1, 
            this._$_g$_ = Math.abs(this._$_g$_));
        }
        _$_GetGDir$_() {
            return this._$_g$_ < 0 ? -1 : 1;
        }
        _$_IsOnFloor$_() {
            const t = this._$_inst$_._$GetWorldInfo$_(), s = this._$_runtime$_._$GetCollisionEngine$_(), i = this._$_inst$_, e = this._$_lastFloorObject$_, n = t._$GetX$_(), h = t._$GetY$_();
            if (t._$OffsetXY$_(this._$_downX$_, this._$_downY$_), t._$SetBboxChanged$_(), !e || !s._$TestOverlap$_(i, e) || e._$GetObjectClass$_()._$HasSolidBehavior$_() && !s._$IsSolidCollisionAllowed$_(e, i) || e._$GetObjectClass$_()._$HasJumpthruBehavior$_() && !e._$_IsJumpthruEnabled$_()) {
                let e = s._$TestOverlapSolid$_(i), r = null;
                if (!e && this._$_IsFallThroughEnabled$_() && (r = s._$TestOverlapJumpthru$_(i, !0)), 
                t._$SetXY$_(n, h), t._$SetBboxChanged$_(), e) return s._$TestOverlap$_(i, e) ? null : (this._$_floorIsJumpthru$_ = !1, 
                e);
                if (r && r.length) {
                    let t = 0;
                    for (let e = 0, n = r.length; e < n; ++e) r[t] = r[e], s._$TestOverlap$_(i, r[e]) || ++t;
                    if (t >= 1) return this._$_floorIsJumpthru$_ = !0, r[0];
                }
                return null;
            }
            return t._$SetXY$_(n, h), t._$SetBboxChanged$_(), e;
        }
        _$PostTick$_() {
            if (!this._$_isEnabled$_) return;
            const t = this._$_runtime$_._$GetDt$_(this._$_inst$_);
            this._$_jumpKey$_ || this._$_simJump$_ || (this._$_jumped$_ = !1);
            let s = this._$_leftKey$_ || this._$_simLeft$_, i = this._$_rightKey$_ || this._$_simRight$_, e = this._$_jumpKey$_ || this._$_simJump$_, n = e && !this._$_jumped$_;
            this._$_simLeft$_ = !1, this._$_simRight$_ = !1, this._$_simJump$_ = !1, this._$_ignoreInput$_ && (s = !1, 
            i = !1, e = !1, n = !1), e || (this._$_sustainTime$_ = 0), this._$_HandleFirstTick$_();
            const [h, r, o] = this._$_TrackMovingPlatform$_();
            let a = this._$_IsOnFloor$_();
            const u = a && !this._$_wasOnFloor$_;
            let l = !1;
            if ([l, a] = this._$_MaybePushOutSolid$_(a), l) return;
            this._$_TrackFloor$_(a, o, h, e), n = this._$_HandleJump$_(a, n, e), a || this._$_HandleAirTime$_(n, e, t), 
            this._$_wasOnFloor$_ = !!a;
            const c = this._$_CalculateHorizontalAcceleration$_(s, i);
            let f = !1, d = 0;
            if (0 !== this._$_dx$_ && ([f, a] = this._$_HandleHorizontalMovement$_(t, c, a, n)), 
            0 !== this._$_dy$_) {
                const [s, i] = this._$_HandleVerticalMovement$_(t, a);
                f = f || s, d = i;
            }
            !f && u && this._$_dy$_ < 0 && d > 0 && (this._$_dy$_ = 0, f = !0), this._$_ApplyHorizontalAcceleration$_(s, i, c, t), 
            a && !n || f || (this._$_dy$_ = Math.min(this._$_dy$_ + this._$_g$_ * t, this._$_maxFall$_)), 
            this._$_HandleAnimationTriggers$_(a, f, n), this._$_wasOverJumpthru$_ = this._$_runtime$_._$GetCollisionEngine$_()._$TestOverlapJumpthru$_(this._$_inst$_);
        }
        _$_HandleFirstTick$_() {
            if (!this._$_isFirstTick$_) return;
            const t = this._$_inst$_, s = this._$_runtime$_._$GetCollisionEngine$_();
            (s._$TestOverlapSolid$_(t) || s._$TestOverlapJumpthru$_(t)) && s._$PushOutSolid$_(t, -this._$_downX$_, -this._$_downY$_, 4, !0), 
            this._$_isFirstTick$_ = !1;
        }
        _$_TrackMovingPlatform$_() {
            const t = this._$_lastFloorObject$_, s = t ? t._$GetWorldInfo$_() : null;
            let i = 0, e = 0, n = !1;
            if (t && 0 === this._$_dy$_ && (s._$GetY$_() !== this._$_lastFloorY$_ || s._$GetX$_() !== this._$_lastFloorX$_)) {
                const t = this._$_inst$_, h = t._$GetWorldInfo$_(), r = this._$_runtime$_._$GetCollisionEngine$_(), o = s._$GetX$_(), a = s._$GetY$_();
                i = o - this._$_lastFloorX$_, e = a - this._$_lastFloorY$_, h._$OffsetXY$_(i, e), 
                h._$SetBboxChanged$_(), this._$_lastFloorX$_ = o, this._$_lastFloorY$_ = a, n = !0;
                const u = r._$TestOverlapSolid$_(t);
                u && (r._$RegisterCollision$_(t, u), r._$PushOutSolid$_(t, -i, -e, 2.5 * kT._$hypot2DFast$_(i, e)));
            }
            return [ i, e, n ];
        }
        _$_MaybePushOutSolid$_(t) {
            let s = !1;
            const i = this._$_inst$_, e = i._$GetWorldInfo$_(), n = this._$_runtime$_._$GetCollisionEngine$_(), h = n._$TestOverlapSolid$_(i);
            if (!h) return [ !1, t ];
            const r = Math.abs(e._$GetWidth$_()), o = Math.abs(e._$GetHeight$_());
            return n._$PushOutSolid$_(i, -this._$_downX$_, -this._$_downY$_, o / 8) ? (n._$RegisterCollision$_(i, h), 
            t = h, this._$_SetLastFloorObject$_(h), this._$_floorIsJumpthru$_ = !1, this._$_dy$_ = 0) : n._$PushOutSolidAxis$_(i, this._$_rightX$_, this._$_rightY$_, r / 2) || n._$PushOutSolidAxis$_(i, this._$_downX$_, this._$_downY$_, o / 2) || n._$PushOutSolidNearest$_(i, Math.max(r, o) / 2) ? n._$RegisterCollision$_(i, h) : s = !0, 
            [ s, t ];
        }
        _$_TrackFloor$_(t, s, i, e) {
            const n = this._$_inst$_, h = this._$_runtime$_._$GetCollisionEngine$_();
            if (t) {
                const e = this._$_downX$_, r = this._$_downY$_, o = this._$_rightX$_, a = this._$_rightY$_;
                if (this._$_doubleJumped$_ = !1, this._$_canDoubleJump$_ = !1, this._$_dy$_ > 0 && (this._$_wasOnFloor$_ || (h._$PushInFractional$_(n, -e, -r, t, 16), 
                this._$_wasOnFloor$_ = !0), this._$_dy$_ = 0), this._$_lastFloorObject$_ !== t) this._$_SetLastFloorObject$_(t), 
                h._$RegisterCollision$_(n, t); else if (s) {
                    const t = h._$TestOverlapSolid$_(n);
                    t && (h._$RegisterCollision$_(n, t), 0 !== i && (i > 0 ? h._$PushOutSolid$_(n, -o, -a) : h._$PushOutSolid$_(n, o, a)), 
                    h._$PushOutSolid$_(n, -e, -r));
                }
            } else e || (this._$_canDoubleJump$_ = !0);
        }
        _$_HandleJump$_(t, s, i) {
            if (t && s || !t && this._$_enableDoubleJump$_ && i && this._$_canDoubleJump$_ && !this._$_doubleJumped$_) {
                const i = this._$_inst$_, e = i._$GetWorldInfo$_(), n = this._$_runtime$_._$GetCollisionEngine$_(), h = e._$GetX$_(), r = e._$GetY$_();
                e._$OffsetXY$_(-this._$_downX$_, -this._$_downY$_), e._$SetBboxChanged$_(), n._$TestOverlapSolid$_(i) ? s = !1 : (this._$_sustainTime$_ = this._$_jumpSustain$_, 
                this._$Trigger$_(kT._$Behaviors$_._$Platform$_._$Cnds$_._$OnJump$_), this._$_animMode$_ = "jumping", 
                this._$_dy$_ = -this._$_jumpStrength$_, s = !0, t ? this._$_jumped$_ = !0 : this._$_doubleJumped$_ = !0), 
                e._$SetXY$_(h, r), e._$SetBboxChanged$_();
            }
            return s;
        }
        _$_HandleAirTime$_(t, s, i) {
            s && this._$_sustainTime$_ > 0 ? (this._$_dy$_ = -this._$_jumpStrength$_, this._$_sustainTime$_ -= i) : this._$_lastFloorObject$_ = null, 
            t && (this._$_jumped$_ = !0);
        }
        _$_CalculateHorizontalAcceleration$_(t, s) {
            let i = 0;
            const e = this._$_acc$_, n = this._$_dec$_;
            return t && !s && (i = this._$_dx$_ > 0 ? -(e + n) : -e), s && !t && (i = this._$_dx$_ < 0 ? e + n : e), 
            i;
        }
        _$_ApplyHorizontalAcceleration$_(t, s, i, e) {
            const n = this._$_dec$_;
            t === s && (this._$_dx$_ < 0 ? this._$_dx$_ = Math.min(this._$_dx$_ + n * e, 0) : this._$_dx$_ > 0 && (this._$_dx$_ = Math.max(this._$_dx$_ - n * e, 0))), 
            this._$_dx$_ = kT._$clamp$_(this._$_dx$_ + i * e, -this._$_maxSpeed$_, this._$_maxSpeed$_);
            const h = this._$_runtime$_._$GetCollisionEngine$_(), r = this._$_dx$_ < 0 ? this._$_GetWallObstacle$_(0, 1, 1) : null;
            if (r) this._$_dx$_ = 0, h._$RegisterCollision$_(this._$_inst$_, r); else {
                const t = this._$_dx$_ > 0 ? this._$_GetWallObstacle$_(1, 1, 1) : null;
                t && (this._$_dx$_ = 0, h._$RegisterCollision$_(this._$_inst$_, t));
            }
        }
        _$_HandleHorizontalMovement$_(t, s, i, e) {
            const n = this._$_inst$_, h = n._$GetWorldInfo$_(), r = this._$_runtime$_._$GetCollisionEngine$_(), o = this._$_downX$_, a = this._$_downY$_, u = this._$_rightX$_, l = this._$_rightY$_, c = this._$_maxSpeed$_;
            let f = !1;
            const d = new Set(r._$TestOverlapJumpthru$_(n, !0));
            let p = h._$GetX$_(), m = h._$GetY$_();
            const g = PT(this._$_dx$_, -c, c, s, t) * u, y = PT(this._$_dx$_, -c, c, s, t) * l;
            h._$OffsetXY$_(u * (this._$_dx$_ > 1 ? 1 : -1) - o, l * (this._$_dx$_ > 1 ? 1 : -1) - a), 
            h._$SetBboxChanged$_();
            let M = !1;
            const w = r._$TestOverlapSolid$_(n);
            h._$SetXY$_(p + g, m + y), h._$SetBboxChanged$_();
            let S = r._$TestOverlapSolid$_(n);
            if (!S && i && this._$_floorIsJumpthru$_ && (S = r._$TestOverlapJumpthru$_(n), d.has(S) ? S = null : M = !0), 
            S) {
                let s = Math.abs(this._$_dx$_ * t) + 2;
                w || !r._$PushOutSolid$_(n, -o, -a, s, M, S) ? (r._$RegisterCollision$_(n, S), s = Math.max(Math.abs(this._$_dx$_ * t * 2.5), Math.floor(h._$GetWidth$_())), 
                r._$PushOutSolid$_(n, u * (this._$_dx$_ < 0 ? 1 : -1), l * (this._$_dx$_ < 0 ? 1 : -1), s, !1) ? !i || M || this._$_floorIsJumpthru$_ || (p = h._$GetX$_(), 
                m = h._$GetY$_(), h._$OffsetXY$_(o, a), r._$TestOverlapSolid$_(n) && r._$PushOutSolid$_(n, -o, -a, 3, !1) || (h._$SetXY$_(p, m), 
                h._$SetBboxChanged$_())) : (h._$SetXY$_(p, m), h._$SetBboxChanged$_()), M || (this._$_dx$_ = 0)) : !w && !e && Math.abs(this._$_dy$_) < Math.abs(this._$_jumpStrength$_ / 4) && (this._$_dy$_ = 0, 
                i || (f = !0));
            } else {
                const s = this._$_IsOnFloor$_();
                if (i && !s) {
                    const s = Math.ceil(Math.abs(this._$_dx$_ * t)) + 2;
                    p = h._$GetX$_(), m = h._$GetY$_(), h._$OffsetXY$_(o * s, a * s), h._$SetBboxChanged$_();
                    const e = r._$TestOverlapJumpthru$_(n);
                    let u = !1;
                    e && !d.has(e) && r._$PushOutSolid$_(n, -o, -a, s + 2, !0, e) && (i = e, this._$_SetLastFloorObject$_(e), 
                    this._$_floorIsJumpthru$_ = !0, u = !0), u || (r._$TestOverlapSolid$_(n) ? r._$PushOutSolid$_(n, -o, -a, s + 2, !1) : (h._$SetXY$_(p, m), 
                    h._$SetBboxChanged$_()));
                } else s && (!i && this._$_floorIsJumpthru$_ && (this._$_SetLastFloorObject$_(s), 
                this._$_dy$_ = 0, f = !0), 0 === this._$_dy$_ && r._$PushInFractional$_(n, -o, -a, s, 16));
            }
            return [ f, i ];
        }
        _$_HandleVerticalMovement$_(t, s) {
            const i = this._$_inst$_, e = i._$GetWorldInfo$_(), n = this._$_runtime$_._$GetCollisionEngine$_(), h = this._$_downX$_, r = this._$_downY$_;
            let o = !1, a = e._$GetX$_(), u = e._$GetY$_();
            const l = PT(this._$_dy$_, -1 / 0, this._$_maxFall$_, this._$_g$_, t);
            e._$OffsetXY$_(l * h, l * r);
            const c = e._$GetX$_(), f = e._$GetY$_();
            e._$SetBboxChanged$_();
            let d = n._$TestOverlapSolid$_(i), p = !1;
            if (!d && this._$_dy$_ > 0 && !s) {
                const t = this._$_IsFallThroughEnabled$_() ? n._$TestOverlapJumpthru$_(i, !0) : null;
                if (t && t.length) {
                    if (this._$_wasOverJumpthru$_) {
                        e._$SetXY$_(a, u), e._$SetBboxChanged$_();
                        let s = 0;
                        for (let e = 0, h = t.length; e < h; ++e) t[s] = t[e], n._$TestOverlap$_(i, t[e]) || ++s;
                        kT._$truncateArray$_(t, s), e._$SetXY$_(c, f), e._$SetBboxChanged$_();
                    }
                    t.length >= 1 && (d = t[0]);
                }
                p = !!d;
            }
            if (d) {
                n._$RegisterCollision$_(i, d), this._$_sustainTime$_ = 0;
                let s = 1.1;
                p && !this._$_wasOverJumpthru$_ && (s = 2);
                const l = Math.max(Math.abs(this._$_dy$_ * t * s), 2);
                n._$PushOutSolid$_(i, h * (this._$_dy$_ < 0 ? 1 : -1), r * (this._$_dy$_ < 0 ? 1 : -1), l, p, d) ? (this._$_SetLastFloorObject$_(d), 
                this._$_floorIsJumpthru$_ = p, this._$_dy$_ > 0 && (o = !0), (this._$_dy$_ > 0 || 0 === this._$_ceilingCollisionMode$_) && (this._$_dy$_ = 0), 
                this._$_dy$_ < 0 && 1 === this._$_ceilingCollisionMode$_ && n._$PushInFractional$_(i, h, r, d, 32)) : (e._$SetXY$_(a, u), 
                e._$SetBboxChanged$_(), this._$_wasOnFloor$_ = !0, p || (this._$_dy$_ = 0));
            }
            return [ o, l ];
        }
        _$_HandleAnimationTriggers$_(t, s, i) {
            "falling" !== this._$_animMode$_ && this._$_dy$_ > 0 && !t && (this._$Trigger$_(kT._$Behaviors$_._$Platform$_._$Cnds$_._$OnFall$_), 
            this._$_animMode$_ = "falling"), (t || s) && this._$_dy$_ >= 0 && ("falling" === this._$_animMode$_ || s || i && 0 === this._$_dy$_ ? (this._$Trigger$_(kT._$Behaviors$_._$Platform$_._$Cnds$_._$OnLand$_), 
            0 === this._$_dx$_ && 0 === this._$_dy$_ ? this._$_animMode$_ = "stopped" : this._$_animMode$_ = "moving") : ("stopped" !== this._$_animMode$_ && 0 === this._$_dx$_ && 0 === this._$_dy$_ && (this._$Trigger$_(kT._$Behaviors$_._$Platform$_._$Cnds$_._$OnStop$_), 
            this._$_animMode$_ = "stopped"), "moving" === this._$_animMode$_ || 0 === this._$_dx$_ && 0 === this._$_dy$_ || i || (this._$Trigger$_(kT._$Behaviors$_._$Platform$_._$Cnds$_._$OnMove$_), 
            this._$_animMode$_ = "moving")));
        }
        _$_IsMoving$_() {
            return 0 !== this._$_GetVectorX$_() || 0 !== this._$_GetVectorY$_();
        }
        _$_CheckIfStandingOnFloor$_() {
            if (0 !== this._$_dy$_) return !1;
            const t = this._$_inst$_, s = this._$GetWorldInfo$_(), i = this._$_runtime$_._$GetCollisionEngine$_(), e = s._$GetX$_(), n = s._$GetY$_();
            s._$OffsetXY$_(this._$_downX$_, this._$_downY$_), s._$SetBboxChanged$_();
            const h = i._$TestOverlapSolid$_(t);
            let r = null;
            if (!h && this._$_IsFallThroughEnabled$_() && (r = i._$TestOverlapJumpthru$_(t, !0)), 
            s._$SetXY$_(e, n), s._$SetBboxChanged$_(), h) return !i._$TestOverlap$_(t, h);
            if (r && r.length) {
                let s = 0;
                for (let e = 0, n = r.length; e < n; ++e) r[s] = r[e], i._$TestOverlap$_(t, r[e]) || s++;
                if (s >= 1) return !0;
            }
            return !1;
        }
        _$_IsByWall$_(t, s = 2, i = 3) {
            return !!this._$_GetWallObstacle$_(t, s, i);
        }
        _$_GetWallObstacle$_(t, s = 2, i = 3) {
            const e = this._$_inst$_, n = this._$GetWorldInfo$_(), h = this._$_runtime$_._$GetCollisionEngine$_(), r = n._$GetX$_(), o = n._$GetY$_();
            if (0 === t ? n._$OffsetXY$_(-this._$_rightX$_ * s, -this._$_rightY$_ * s) : n._$OffsetXY$_(this._$_rightX$_ * s, this._$_rightY$_ * s), 
            n._$SetBboxChanged$_(), !h._$TestOverlapSolid$_(e)) return n._$SetXY$_(r, o), n._$SetBboxChanged$_(), 
            null;
            n._$OffsetXY$_(-this._$_downX$_ * i, -this._$_downY$_ * i), n._$SetBboxChanged$_();
            const a = h._$TestOverlapSolid$_(e);
            return n._$SetXY$_(r, o), n._$SetBboxChanged$_(), a;
        }
        _$_FallThroughJumpThru$_() {
            const t = this._$GetWorldInfo$_(), s = t._$GetX$_(), i = t._$GetY$_();
            t._$OffsetXY$_(this._$_downX$_, this._$_downY$_), t._$SetBboxChanged$_();
            const e = this._$_runtime$_._$GetCollisionEngine$_()._$TestOverlapJumpthru$_(this._$_inst$_, !1);
            t._$SetXY$_(s, i), t._$SetBboxChanged$_(), e && (this._$_fallThroughTime$_ = this._$_runtime$_._$GetGameTime$_(), 
            this._$_lastFloorObject$_ = null);
        }
        _$_ResetDoubleJump$_(t) {
            this._$_doubleJumped$_ = !t;
        }
        _$_GetSpeed$_() {
            return Math.hypot(this._$_dx$_, this._$_dy$_);
        }
        _$_GetMovingAngle$_() {
            return Math.atan2(this._$_dy$_, this._$_dx$_);
        }
        _$_IsJumping$_() {
            return this._$_dy$_ < 0;
        }
        _$_IsFalling$_() {
            return this._$_dy$_ > 0;
        }
        _$_SetMaxSpeed$_(t) {
            this._$_maxSpeed$_ = Math.max(t, 0);
        }
        _$_GetMaxSpeed$_() {
            return this._$_maxSpeed$_;
        }
        _$_SetAcceleration$_(t) {
            this._$_acc$_ = Math.max(t, 0);
        }
        _$_GetAcceleration$_() {
            return this._$_acc$_;
        }
        _$_SetDeceleration$_(t) {
            this._$_dec$_ = Math.max(t, 0);
        }
        _$_GetDeceleration$_() {
            return this._$_dec$_;
        }
        _$_SetJumpStrength$_(t) {
            this._$_jumpStrength$_ = Math.max(t, 0);
        }
        _$_GetJumpStrength$_() {
            return this._$_jumpStrength$_;
        }
        _$_SetMaxFallSpeed$_(t) {
            this._$_maxFall$_ = Math.max(t, 0);
        }
        _$_GetMaxFallSpeed$_() {
            return this._$_maxFall$_;
        }
        _$_SetGravity$_(t) {
            if (this._$_g1$_ === t) return;
            this._$_g$_ = t, this._$_UpdateGravity$_();
            const s = this._$_runtime$_._$GetCollisionEngine$_(), i = this._$GetWorldInfo$_();
            s._$TestOverlapSolid$_(this._$_inst$_) && (s._$PushOutSolid$_(this._$_inst$_, this._$_downX$_, this._$_downY$_, 10), 
            i._$OffsetXY$_(2 * this._$_downX$_, 2 * this._$_downY$_), i._$SetBboxChanged$_()), 
            this._$_lastFloorObject$_ = null;
        }
        _$_GetGravity$_() {
            return this._$_g$_;
        }
        _$_SetGravityAngle$_(t) {
            t = kT._$clampAngle$_(t), this._$_ga$_ !== t && (this._$_ga$_ = t, this._$_UpdateGravity$_(), 
            this._$_lastFloorObject$_ = null);
        }
        _$_GetGravityAngle$_() {
            return this._$_ga$_;
        }
        _$_SetDoubleJumpEnabled$_(t) {
            this._$_enableDoubleJump$_ = !!t;
        }
        _$_IsDoubleJumpEnabled$_() {
            return this._$_enableDoubleJump$_;
        }
        _$_SetJumpSustain$_(t) {
            this._$_jumpSustain$_ = t;
        }
        _$_GetJumpSustain$_() {
            return this._$_jumpSustain$_;
        }
        _$_SetCeilingCollisionMode$_(t) {
            this._$_ceilingCollisionMode$_ = t;
        }
        _$_GetCeilingCollisionMode$_() {
            return this._$_ceilingCollisionMode$_;
        }
        _$_SetVectorX$_(t) {
            this._$_dx$_ = t;
        }
        _$_GetVectorX$_() {
            return this._$_dx$_;
        }
        _$_SetVectorY$_(t) {
            this._$_dy$_ = t;
        }
        _$_GetVectorY$_() {
            return this._$_dy$_;
        }
        _$_SimulateControl$_(t) {
            if (this._$_isEnabled$_) switch (t) {
              case 0:
                this._$_simLeft$_ = !0;
                break;

              case 1:
                this._$_simRight$_ = !0;
                break;

              case 2:
                this._$_simJump$_ = !0;
            }
        }
        _$_SetDefaultControls$_(t) {
            t = !!t, this._$_defaultControls$_ !== t && (this._$_defaultControls$_ = t, this._$_defaultControls$_ ? this._$_BindEvents$_() : (this._$_UnBindEvents$_(), 
            this._$_OnWindowOrKeyboardBlur$_()));
        }
        _$_IsDefaultControls$_() {
            return this._$_defaultControls$_;
        }
        _$_SetIgnoreInput$_(t) {
            this._$_ignoreInput$_ = !!t;
        }
        _$_IsIgnoreInput$_() {
            return this._$_ignoreInput$_;
        }
        _$_SetEnabled$_(t) {
            t = !!t, this._$_isEnabled$_ !== t && (this._$_isEnabled$_ = t, this._$_isEnabled$_ ? this._$_StartPostTicking$_() : (this._$_StopPostTicking$_(), 
            this._$_lastFloorObject$_ = null, this._$_simLeft$_ = !1, this._$_simRight$_ = !1, 
            this._$_simJump$_ = !1));
        }
        _$_IsEnabled$_() {
            return this._$_isEnabled$_;
        }
        _$GetPropertyValueByIndex$_(t) {
            switch (t) {
              case BT:
                return this._$_GetMaxSpeed$_();

              case zT:
                return this._$_GetAcceleration$_();

              case UT:
                return this._$_GetDeceleration$_();

              case WT:
                return this._$_GetJumpStrength$_();

              case JT:
                return this._$_GetGravity$_();

              case QT:
                return this._$_GetMaxFallSpeed$_();

              case YT:
                return this._$_IsDoubleJumpEnabled$_();

              case VT:
                return 1e3 * this._$_GetJumpSustain$_();

              case HT:
                return this._$_IsDefaultControls$_();

              case qT:
                return this._$_IsEnabled$_();
            }
        }
        _$SetPropertyValueByIndex$_(t, s) {
            switch (t) {
              case BT:
                this._$_SetMaxSpeed$_(s);
                break;

              case zT:
                this._$_SetAcceleration$_(s);
                break;

              case UT:
                this._$_SetDeceleration$_(s);
                break;

              case WT:
                this._$_SetJumpStrength$_(s);
                break;

              case JT:
                this._$_SetGravity$_(s);
                break;

              case QT:
                this._$_SetMaxFallSpeed$_(s);
                break;

              case YT:
                this._$_SetDoubleJumpEnabled$_(!!s);
                break;

              case VT:
                this._$_SetJumpSustain$_(s / 1e3);
                break;

              case HT:
                this._$_SetDefaultControls$_(!!s);
                break;

              case qT:
                this._$_SetEnabled$_(!!s);
            }
        }
        _$GetDebuggerProperties$_() {
            const t = "behaviors.platform";
            return [ {
                title: "$" + this._$GetBehaviorType$_()._$GetName$_(),
                properties: [ {
                    name: t + ".debugger.vector-x",
                    value: this._$_GetVectorX$_(),
                    _$onedit$_: t => this._$_SetVectorX$_(t)
                }, {
                    name: t + ".debugger.vector-y",
                    value: this._$_GetVectorY$_(),
                    _$onedit$_: t => this._$_SetVectorY$_(t)
                }, {
                    name: t + ".properties.max-speed.name",
                    value: this._$_GetMaxSpeed$_(),
                    _$onedit$_: t => this._$_SetMaxSpeed$_(t)
                }, {
                    name: t + ".properties.acceleration.name",
                    value: this._$_GetAcceleration$_(),
                    _$onedit$_: t => this._$_SetAcceleration$_(t)
                }, {
                    name: t + ".properties.deceleration.name",
                    value: this._$_GetDeceleration$_(),
                    _$onedit$_: t => this._$_SetDeceleration$_(t)
                }, {
                    name: t + ".properties.jump-strength.name",
                    value: this._$_GetJumpStrength$_(),
                    _$onedit$_: t => this._$_SetJumpStrength$_(t)
                }, {
                    name: t + ".properties.gravity.name",
                    value: this._$_GetGravity$_(),
                    _$onedit$_: t => this._$_SetGravity$_(t)
                }, {
                    name: t + ".debugger.gravity-angle",
                    value: kT._$toDegrees$_(this._$_GetGravityAngle$_()),
                    _$onedit$_: t => this._$_SetGravityAngle$_(kT._$toRadians$_(t))
                }, {
                    name: t + ".properties.max-fall-speed.name",
                    value: this._$_GetMaxFallSpeed$_(),
                    _$onedit$_: t => this._$_SetMaxFallSpeed$_(t)
                }, {
                    name: t + ".properties.double-jump.name",
                    value: this._$_IsDoubleJumpEnabled$_(),
                    _$onedit$_: t => this._$_SetDoubleJumpEnabled$_(t)
                }, {
                    name: t + ".properties.jump-sustain.name",
                    value: 1e3 * this._$_GetJumpSustain$_(),
                    _$onedit$_: t => this._$_SetJumpSustain$_(t / 1e3)
                }, {
                    name: t + ".debugger.animation-mode",
                    value: [ t + ".debugger.anim-" + this._$_animMode$_ ]
                }, {
                    name: t + ".properties.enabled.name",
                    value: this._$_IsEnabled$_(),
                    _$onedit$_: t => this._$_SetEnabled$_(t)
                } ]
            } ];
        }
        _$GetScriptInterfaceClass$_() {
            return self._$IPlatformBehaviorInstance$_;
        }
    };
    const ZT = new WeakMap, KT = new Map([ [ "left", 0 ], [ "right", 1 ], [ "jump", 2 ] ]);
    self._$IPlatformBehaviorInstance$_ = class extends jT {
        constructor() {
            super(), ZT.set(this, jT._$_GetInitInst$_()._$GetSdkInstance$_());
        }
        _$fallThrough$_() {
            ZT.get(this)._$_FallThroughJumpThru$_();
        }
        _$resetDoubleJump$_(t) {
            ZT.get(this)._$_ResetDoubleJump$_(!!t);
        }
        _$simulateControl$_(t) {
            FT._$RequireString$_(t);
            const s = KT.get(t);
            if ("number" != typeof s) throw new Error("invalid control");
            ZT.get(this)._$_SimulateControl$_(s);
        }
        get speed() {
            return ZT.get(this)._$_GetSpeed$_();
        }
        get _$maxSpeed$_() {
            return ZT.get(this)._$_GetMaxSpeed$_();
        }
        set _$maxSpeed$_(t) {
            FT._$RequireFiniteNumber$_(t), ZT.get(this)._$_SetMaxSpeed$_(t);
        }
        get acceleration() {
            return ZT.get(this)._$_GetAcceleration$_();
        }
        set acceleration(t) {
            FT._$RequireFiniteNumber$_(t), ZT.get(this)._$_SetAcceleration$_(t);
        }
        get _$deceleration$_() {
            return ZT.get(this)._$_GetDeceleration$_();
        }
        set _$deceleration$_(t) {
            FT._$RequireFiniteNumber$_(t), ZT.get(this)._$_SetDeceleration$_(t);
        }
        get _$jumpStrength$_() {
            return ZT.get(this)._$_GetJumpStrength$_();
        }
        set _$jumpStrength$_(t) {
            FT._$RequireFiniteNumber$_(t), ZT.get(this)._$_SetJumpStrength$_(t);
        }
        get _$maxFallSpeed$_() {
            return ZT.get(this)._$_GetMaxFallSpeed$_();
        }
        set _$maxFallSpeed$_(t) {
            FT._$RequireFiniteNumber$_(t), ZT.get(this)._$_SetMaxFallSpeed$_(t);
        }
        get _$gravity$_() {
            return ZT.get(this)._$_GetGravity$_();
        }
        set _$gravity$_(t) {
            FT._$RequireFiniteNumber$_(t), ZT.get(this)._$_SetGravity$_(t);
        }
        get _$gravityAngle$_() {
            return ZT.get(this)._$_GetGravityAngle$_();
        }
        set _$gravityAngle$_(t) {
            FT._$RequireFiniteNumber$_(t), ZT.get(this)._$_SetGravityAngle$_(t);
        }
        get _$isDoubleJumpEnabled$_() {
            return ZT.get(this)._$_IsDoubleJumpEnabled$_();
        }
        set _$isDoubleJumpEnabled$_(t) {
            ZT.get(this)._$_SetDoubleJumpEnabled$_(!!t);
        }
        get _$jumpSustain$_() {
            return ZT.get(this)._$_GetJumpSustain$_();
        }
        set _$jumpSustain$_(t) {
            FT._$RequireFiniteNumber$_(t), ZT.get(this)._$_SetJumpSustain$_(t);
        }
        get _$ceilingCollisionMode$_() {
            return 0 === ZT.get(this)._$_GetCeilingCollisionMode$_() ? "stop" : "preserve-momentum";
        }
        set _$ceilingCollisionMode$_(t) {
            FT._$RequireString$_(t);
            const s = ZT.get(this);
            if ("stop" === t) s._$_SetCeilingCollisionMode$_(0); else {
                if ("preserve-momentum" !== t) throw new Error("invalid mode");
                s._$_SetCeilingCollisionMode$_(1);
            }
        }
        get _$isOnFloor$_() {
            return ZT.get(this)._$_CheckIfStandingOnFloor$_();
        }
        _$isByWall$_(t) {
            FT._$RequireString$_(t);
            const s = ZT.get(this);
            if ("left" === t) return s._$_IsByWall$_(0);
            if ("right" === t) return s._$_IsByWall$_(1);
            throw new Error("invalid side");
        }
        get _$isMoving$_() {
            return ZT.get(this)._$_IsMoving$_();
        }
        get _$isJumping$_() {
            return ZT.get(this)._$_IsJumping$_();
        }
        get _$isFalling$_() {
            return ZT.get(this)._$_IsFalling$_();
        }
        get _$vectorX$_() {
            return ZT.get(this)._$_GetVectorX$_();
        }
        set _$vectorX$_(t) {
            FT._$RequireFiniteNumber$_(t), ZT.get(this)._$_SetVectorX$_(t);
        }
        get _$vectorY$_() {
            return ZT.get(this)._$_GetVectorY$_();
        }
        set _$vectorY$_(t) {
            FT._$RequireFiniteNumber$_(t), ZT.get(this)._$_SetVectorY$_(t);
        }
        _$setVector$_(t, s) {
            FT._$RequireFiniteNumber$_(t), FT._$RequireFiniteNumber$_(s);
            const i = ZT.get(this);
            i._$_SetVectorX$_(t), i._$_SetVectorY$_(s);
        }
        _$getVector$_() {
            const t = ZT.get(this);
            return [ t._$_GetVectorX$_(), t._$_GetVectorY$_() ];
        }
        get _$isDefaultControls$_() {
            return ZT.get(this)._$_IsDefaultControls$_();
        }
        set _$isDefaultControls$_(t) {
            ZT.get(this)._$_SetDefaultControls$_(!!t);
        }
        get _$isIgnoringInput$_() {
            return ZT.get(this)._$_IsIgnoreInput$_();
        }
        set _$isIgnoringInput$_(t) {
            ZT.get(this)._$_SetIgnoreInput$_(!!t);
        }
        get isEnabled() {
            return ZT.get(this)._$_IsEnabled$_();
        }
        set isEnabled(t) {
            ZT.get(this)._$_SetEnabled$_(!!t);
        }
    };
}

{
    const $T = self._$C3$_;
    $T._$Behaviors$_._$Platform$_._$Cnds$_ = {
        _$IsMoving$_() {
            return this._$_IsMoving$_();
        },
        _$CompareSpeed$_(t, s) {
            return $T.compare(this._$_GetSpeed$_(), t, s);
        },
        _$IsOnFloor$_() {
            return this._$_CheckIfStandingOnFloor$_();
        },
        _$IsByWall$_(t) {
            return this._$_IsByWall$_(t);
        },
        _$IsJumping$_() {
            return this._$_IsJumping$_();
        },
        _$IsFalling$_() {
            return this._$_IsFalling$_();
        },
        _$IsDoubleJumpEnabled$_() {
            return this._$_IsDoubleJumpEnabled$_();
        },
        _$OnJump$_: () => !0,
        _$OnFall$_: () => !0,
        _$OnStop$_: () => !0,
        _$OnMove$_: () => !0,
        _$OnLand$_: () => !0,
        _$IsEnabled$_() {
            return this._$_IsEnabled$_();
        }
    };
}

{
    const tv = self._$C3$_;
    tv._$Behaviors$_._$Platform$_._$Acts$_ = {
        _$SetMaxSpeed$_(t) {
            this._$_SetMaxSpeed$_(t);
        },
        _$SetAcceleration$_(t) {
            this._$_SetAcceleration$_(t);
        },
        _$SetDeceleration$_(t) {
            this._$_SetDeceleration$_(t);
        },
        _$SetJumpStrength$_(t) {
            this._$_SetJumpStrength$_(t);
        },
        _$SetMaxFallSpeed$_(t) {
            this._$_SetMaxFallSpeed$_(t);
        },
        _$SetGravity$_(t) {
            this._$_SetGravity$_(t);
        },
        _$SimulateControl$_(t) {
            this._$_SimulateControl$_(t);
        },
        _$SetIgnoreInput$_(t) {
            this._$_SetIgnoreInput$_(!!t);
        },
        _$SetVectorX$_(t) {
            this._$_SetVectorX$_(t);
        },
        _$SetVectorY$_(t) {
            this._$_SetVectorY$_(t);
        },
        _$SetGravityAngle$_(t) {
            this._$_SetGravityAngle$_(tv._$toRadians$_(t));
        },
        _$SetEnabled$_(t) {
            this._$_SetEnabled$_(0 !== t);
        },
        _$FallThrough$_() {
            this._$_FallThroughJumpThru$_();
        },
        _$SetDoubleJumpEnabled$_(t) {
            this._$_SetDoubleJumpEnabled$_(0 !== t);
        },
        _$SetJumpSustain$_(t) {
            this._$_SetJumpSustain$_(t / 1e3);
        },
        _$SetCeilingCollision$_(t) {
            this._$_SetCeilingCollisionMode$_(t);
        },
        _$SetDefaultControls$_(t) {
            this._$_SetDefaultControls$_(t);
        },
        _$ResetDoubleJump$_(t) {
            this._$_ResetDoubleJump$_(t);
        }
    };
}

{
    const sv = self._$C3$_;
    sv._$Behaviors$_._$Platform$_._$Exps$_ = {
        _$Speed$_() {
            return this._$_GetSpeed$_();
        },
        _$MaxSpeed$_() {
            return this._$_GetMaxSpeed$_();
        },
        _$Acceleration$_() {
            return this._$_GetAcceleration$_();
        },
        _$Deceleration$_() {
            return this._$_GetDeceleration$_();
        },
        _$JumpStrength$_() {
            return this._$_GetJumpStrength$_();
        },
        _$Gravity$_() {
            return this._$_GetGravity$_();
        },
        _$GravityAngle$_() {
            return sv._$toDegrees$_(this._$_GetGravityAngle$_());
        },
        _$MaxFallSpeed$_() {
            return this._$_GetMaxFallSpeed$_();
        },
        _$MovingAngle$_() {
            return sv._$toDegrees$_(this._$_GetMovingAngle$_());
        },
        _$VectorX$_() {
            return this._$_GetVectorX$_();
        },
        _$VectorY$_() {
            return this._$_GetVectorY$_();
        },
        _$JumpSustain$_() {
            return 1e3 * this._$_GetJumpSustain$_();
        }
    };
}

{
    const iv = self._$C3$_;
    iv._$Behaviors$_.bound = class extends iv._$SDKBehaviorBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
    };
}

{
    const ev = self._$C3$_;
    ev._$Behaviors$_.bound._$Type$_ = class extends ev._$SDKBehaviorTypeBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$OnCreate$_() {}
    };
}

{
    const nv = self._$C3$_, hv = 0;
    nv._$Behaviors$_.bound.Instance = class extends nv._$SDKBehaviorInstanceBase$_ {
        constructor(t, s) {
            super(t), this._$_mode$_ = 0, s && (this._$_mode$_ = s[hv]), this._$_StartTicking2$_();
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$SaveToJson$_() {
            return {
                m: this._$_mode$_
            };
        }
        _$LoadFromJson$_(t) {
            this._$_mode$_ = t.m;
        }
        _$Tick2$_() {
            const t = this._$_inst$_._$GetWorldInfo$_(), s = t._$GetBoundingBox$_(), i = t._$GetLayout$_();
            let e = !1;
            0 === this._$_mode$_ ? (t._$GetX$_() < 0 && (t._$SetX$_(0), e = !0), t._$GetY$_() < 0 && (t._$SetY$_(0), 
            e = !0), t._$GetX$_() > i._$GetWidth$_() && (t._$SetX$_(i._$GetWidth$_()), e = !0), 
            t._$GetY$_() > i._$GetHeight$_() && (t._$SetY$_(i._$GetHeight$_()), e = !0)) : (s._$getLeft$_() < 0 && (t._$OffsetX$_(-s._$getLeft$_()), 
            e = !0), s._$getTop$_() < 0 && (t._$OffsetY$_(-s._$getTop$_()), e = !0), s._$getRight$_() > i._$GetWidth$_() && (t._$OffsetX$_(-(s._$getRight$_() - i._$GetWidth$_())), 
            e = !0), s._$getBottom$_() > i._$GetHeight$_() && (t._$OffsetY$_(-(s._$getBottom$_() - i._$GetHeight$_())), 
            e = !0)), e && t._$SetBboxChanged$_();
        }
        _$GetPropertyValueByIndex$_(t) {
            if (t === hv) return this._$_mode$_;
        }
        _$SetPropertyValueByIndex$_(t, s) {
            t === hv && (this._$_mode$_ = s);
        }
    };
}

self._$C3$_._$Behaviors$_.bound._$Cnds$_ = {}, self._$C3$_._$Behaviors$_.bound._$Acts$_ = {}, 
self._$C3$_._$Behaviors$_.bound._$Exps$_ = {};

{
    const rv = self._$C3$_;
    rv._$Behaviors$_._$scrollto$_ = class extends rv._$SDKBehaviorBase$_ {
        constructor(t) {
            super(t), this._$_shakeMag$_ = 0, this._$_shakeStart$_ = 0, this._$_shakeEnd$_ = 0, 
            this._$_shakeMode$_ = 0;
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$SetShakeMagnitude$_(t) {
            this._$_shakeMag$_ = t;
        }
        _$GetShakeMagnitude$_() {
            return this._$_shakeMag$_;
        }
        _$SetShakeStart$_(t) {
            this._$_shakeStart$_ = t;
        }
        _$GetShakeStart$_() {
            return this._$_shakeStart$_;
        }
        _$SetShakeEnd$_(t) {
            this._$_shakeEnd$_ = t;
        }
        _$GetShakeEnd$_() {
            return this._$_shakeEnd$_;
        }
        _$SetShakeMode$_(t) {
            this._$_shakeMode$_ = t;
        }
        _$GetShakeMode$_() {
            return this._$_shakeMode$_;
        }
    };
}

{
    const ov = self._$C3$_;
    ov._$Behaviors$_._$scrollto$_._$Type$_ = class extends ov._$SDKBehaviorTypeBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$OnCreate$_() {}
    };
}

{
    const av = self._$C3$_, uv = 0;
    av._$Behaviors$_._$scrollto$_.Instance = class extends av._$SDKBehaviorInstanceBase$_ {
        constructor(t, s) {
            super(t), this._$_isEnabled$_ = !0, s && (this._$_isEnabled$_ = s[uv]), this._$_isEnabled$_ && this._$_StartTicking2$_();
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$SaveToJson$_() {
            const t = this._$GetBehavior$_();
            return {
                e: this._$_isEnabled$_,
                smg: t._$GetShakeMagnitude$_(),
                ss: t._$GetShakeStart$_(),
                se: t._$GetShakeEnd$_(),
                smd: t._$GetShakeMode$_()
            };
        }
        _$LoadFromJson$_(t) {
            const s = this._$GetBehavior$_();
            s._$SetShakeMagnitude$_(t.smg), s._$SetShakeStart$_(t.ss), s._$SetShakeEnd$_(t.se), 
            s._$SetShakeMode$_(t.smd), this._$_isEnabled$_ = t.e, this._$_isEnabled$_ ? this._$_StartTicking2$_() : this._$_StopTicking2$_();
        }
        _$_SetEnabled$_(t) {
            this._$_isEnabled$_ = !!t, this._$_isEnabled$_ ? this._$_StartTicking2$_() : this._$_StopTicking2$_();
        }
        _$IsEnabled$_() {
            return this._$_isEnabled$_;
        }
        _$Tick2$_() {
            if (!this._$IsEnabled$_()) return;
            this._$_runtime$_._$GetDt$_(this._$_inst$_);
            const t = this._$GetBehavior$_(), s = t._$GetInstances$_();
            let i = 0, e = 0, n = 0;
            for (const t of s) {
                const s = t._$GetBehaviorInstanceFromCtor$_(av._$Behaviors$_._$scrollto$_);
                if (!s || !s._$GetSdkInstance$_()._$IsEnabled$_()) continue;
                const h = t._$GetWorldInfo$_();
                i += h._$GetX$_(), e += h._$GetY$_(), ++n;
            }
            const h = this._$_inst$_._$GetWorldInfo$_()._$GetLayout$_(), r = this._$_runtime$_._$GetGameTime$_();
            let o = 0, a = 0;
            if (r >= t._$GetShakeStart$_() && r < t._$GetShakeEnd$_()) {
                let s = t._$GetShakeMagnitude$_() * Math.min(this._$_runtime$_._$GetTimeScale$_(), 1);
                0 === t._$GetShakeMode$_() && (s *= 1 - (r - t._$GetShakeStart$_()) / (t._$GetShakeEnd$_() - t._$GetShakeStart$_()));
                const i = this._$_runtime$_._$Random$_() * Math.PI * 2, e = this._$_runtime$_._$Random$_() * s;
                o = Math.cos(i) * e, a = Math.sin(i) * e;
            }
            h._$SetScrollX$_(i / n + o), h._$SetScrollY$_(e / n + a);
        }
        _$GetPropertyValueByIndex$_(t) {
            if (t === uv) return this._$_isEnabled$_;
        }
        _$SetPropertyValueByIndex$_(t, s) {
            t === uv && (this._$_isEnabled$_ = !!s, this._$_isEnabled$_ ? this._$_StartTicking2$_() : this._$_StopTicking2$_());
        }
        _$GetDebuggerProperties$_() {
            return [ {
                title: "$" + this._$GetBehaviorType$_()._$GetName$_(),
                properties: [ {
                    name: "behaviors.scrollto.properties.enabled.name",
                    value: this._$IsEnabled$_(),
                    _$onedit$_: t => this._$_SetEnabled$_(t)
                } ]
            } ];
        }
    };
}

self._$C3$_._$Behaviors$_._$scrollto$_._$Cnds$_ = {
    _$IsEnabled$_() {
        return this._$IsEnabled$_();
    }
}, self._$C3$_._$Behaviors$_._$scrollto$_._$Acts$_ = {
    _$Shake$_(t, s, i) {
        const e = this._$GetBehavior$_();
        e._$SetShakeMagnitude$_(t), e._$SetShakeStart$_(this._$_runtime$_._$GetGameTime$_()), 
        e._$SetShakeEnd$_(this._$_runtime$_._$GetGameTime$_() + s), e._$SetShakeMode$_(i);
    },
    _$SetEnabled$_(t) {
        this._$_SetEnabled$_(0 !== t);
    }
}, self._$C3$_._$Behaviors$_._$scrollto$_._$Exps$_ = {};

{
    const lv = self._$C3$_;
    lv._$Behaviors$_._$Anchor$_ = class extends lv._$SDKBehaviorBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
    };
}

{
    const cv = self._$C3$_;
    cv._$Behaviors$_._$Anchor$_._$Type$_ = class extends cv._$SDKBehaviorTypeBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$OnCreate$_() {}
    };
}

{
    const fv = self._$C3$_, dv = (self._$C3X$_, self._$IBehaviorInstance$_), pv = 0, mv = 1, gv = 2, yv = 3, Mv = 4;
    fv._$Behaviors$_._$Anchor$_.Instance = class extends fv._$SDKBehaviorInstanceBase$_ {
        constructor(t, s) {
            super(t), this._$_anchorLeft$_ = 2, this._$_anchorTop$_ = 2, this._$_anchorRight$_ = 0, 
            this._$_anchorBottom$_ = 0, this._$_isEnabled$_ = !0;
            const i = this._$_inst$_._$GetWorldInfo$_()._$GetBoundingBox$_();
            this._$_xLeft$_ = i._$getLeft$_(), this._$_yTop$_ = i._$getTop$_(), this._$_xRight$_ = this._$_runtime$_._$GetOriginalViewportWidth$_() - i._$getLeft$_(), 
            this._$_yBottom$_ = this._$_runtime$_._$GetOriginalViewportHeight$_() - i._$getTop$_(), 
            this._$_rDiff$_ = this._$_runtime$_._$GetOriginalViewportWidth$_() - i._$getRight$_(), 
            this._$_bDiff$_ = this._$_runtime$_._$GetOriginalViewportHeight$_() - i._$getBottom$_(), 
            s && (this._$_anchorLeft$_ = s[pv], this._$_anchorTop$_ = s[mv], this._$_anchorRight$_ = s[gv], 
            this._$_anchorBottom$_ = s[yv], this._$_isEnabled$_ = !!s[Mv]);
            const e = this._$_runtime$_._$Dispatcher$_();
            this._$_disposables$_ = new fv._$CompositeDisposable$_(fv._$Disposable$_._$From$_(e, "layoutchange", (() => this._$_OnLayoutChange$_()))), 
            this._$_isEnabled$_ && this._$_StartTicking$_();
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$SaveToJson$_() {
            return {
                xl: this._$_xLeft$_,
                yt: this._$_yTop$_,
                xr: this._$_xRight$_,
                yb: this._$_yBottom$_,
                rd: this._$_rDiff$_,
                bd: this._$_bDiff$_,
                al: this._$_anchorLeft$_,
                at: this._$_anchorTop$_,
                ar: this._$_anchorRight$_,
                ab: this._$_anchorBottom$_,
                e: this._$_isEnabled$_
            };
        }
        _$LoadFromJson$_(t) {
            this._$_xLeft$_ = t.xl, this._$_yTop$_ = t.yt, this._$_xRight$_ = t.xr, this._$_yBottom$_ = t.yb, 
            this._$_rDiff$_ = t.rd, this._$_bDiff$_ = t.bd, this._$_anchorLeft$_ = t.al, this._$_anchorTop$_ = t.at, 
            this._$_anchorRight$_ = t.ar, this._$_anchorBottom$_ = t.ab, this._$_isEnabled$_ = t.e, 
            this._$_isEnabled$_ ? this._$_StartTicking$_() : this._$_StopTicking$_();
        }
        _$_SetEnabled$_(t) {
            if (this._$_isEnabled$_ && !t) this._$_isEnabled$_ = !1, this._$_StopTicking$_(); else if (!this._$_isEnabled$_ && t) {
                const t = this._$_inst$_._$GetWorldInfo$_()._$GetBoundingBox$_();
                this._$_xLeft$_ = t._$getLeft$_(), this._$_yTop$_ = t._$getTop$_(), this._$_xRight$_ = this._$_runtime$_._$GetOriginalViewportWidth$_() - t._$getLeft$_(), 
                this._$_yBottom$_ = this._$_runtime$_._$GetOriginalViewportHeight$_() - t._$getTop$_(), 
                this._$_rDiff$_ = this._$_runtime$_._$GetOriginalViewportWidth$_() - t._$getRight$_(), 
                this._$_bDiff$_ = this._$_runtime$_._$GetOriginalViewportHeight$_() - t._$getBottom$_(), 
                this._$_isEnabled$_ = !0, this._$_StartTicking$_();
            }
        }
        _$_IsEnabled$_() {
            return this._$_isEnabled$_;
        }
        _$_UpdatePosition$_() {
            if (!this._$_isEnabled$_) return;
            const t = this._$_inst$_._$GetWorldInfo$_(), s = t._$GetLayer$_()._$GetViewport$_();
            if (0 === this._$_anchorLeft$_) {
                const i = s._$getLeft$_() + this._$_xLeft$_ - t._$GetBoundingBox$_()._$getLeft$_();
                0 !== i && (t._$OffsetX$_(i), t._$SetBboxChanged$_());
            } else if (1 === this._$_anchorLeft$_) {
                const i = s._$getRight$_() - this._$_xRight$_ - t._$GetBoundingBox$_()._$getLeft$_();
                0 !== i && (t._$OffsetX$_(i), t._$SetBboxChanged$_());
            }
            if (0 === this._$_anchorTop$_) {
                const i = s._$getTop$_() + this._$_yTop$_ - t._$GetBoundingBox$_()._$getTop$_();
                0 !== i && (t._$OffsetY$_(i), t._$SetBboxChanged$_());
            } else if (1 === this._$_anchorTop$_) {
                const i = s._$getBottom$_() - this._$_yBottom$_ - t._$GetBoundingBox$_()._$getTop$_();
                0 !== i && (t._$OffsetY$_(i), t._$SetBboxChanged$_());
            }
            if (1 === this._$_anchorRight$_) {
                const i = s._$getRight$_() - this._$_rDiff$_ - t._$GetBoundingBox$_()._$getRight$_();
                0 !== i && (t._$OffsetX$_(t._$GetOriginX$_() * i), t._$SetWidth$_(Math.max(t._$GetWidth$_() + i), 0), 
                t._$SetBboxChanged$_(), this._$_rDiff$_ = s._$getRight$_() - t._$GetBoundingBox$_()._$getRight$_());
            }
            if (1 === this._$_anchorBottom$_) {
                const i = s._$getBottom$_() - this._$_bDiff$_ - t._$GetBoundingBox$_()._$getBottom$_();
                0 !== i && (t._$OffsetY$_(t._$GetOriginY$_() * i), t._$SetHeight$_(Math.max(t._$GetHeight$_() + i, 0)), 
                t._$SetBboxChanged$_(), this._$_bDiff$_ = s._$getBottom$_() - t._$GetBoundingBox$_()._$getBottom$_());
            }
        }
        _$Tick$_() {
            this._$_UpdatePosition$_();
        }
        _$_OnLayoutChange$_() {
            this._$_UpdatePosition$_();
        }
        _$GetPropertyValueByIndex$_(t) {
            switch (t) {
              case pv:
                return this._$_anchorLeft$_;

              case mv:
                return this._$_anchorTop$_;

              case gv:
                return this._$_anchorRight$_;

              case yv:
                return this._$_anchorBottom$_;

              case Mv:
                return this._$_isEnabled$_;
            }
        }
        _$SetPropertyValueByIndex$_(t, s) {
            switch (t) {
              case pv:
                this._$_anchorLeft$_ = s;
                break;

              case mv:
                this._$_anchorTop$_ = s;
                break;

              case gv:
                this._$_anchorRight$_ = s;
                break;

              case yv:
                this._$_anchorBottom$_ = s;
                break;

              case Mv:
                this._$_isEnabled$_ = !!s, this._$_isEnabled$_ ? this._$_StartTicking$_() : this._$_StopTicking$_();
            }
        }
        _$GetDebuggerProperties$_() {
            return [ {
                title: "$" + this._$GetBehaviorType$_()._$GetName$_(),
                properties: [ {
                    name: "behaviors.anchor.properties.enabled.name",
                    value: this._$_IsEnabled$_(),
                    _$onedit$_: t => this._$_SetEnabled$_(t)
                } ]
            } ];
        }
        _$GetScriptInterfaceClass$_() {
            return self._$IAnchorBehaviorInstance$_;
        }
    };
    const wv = new WeakMap;
    self._$IAnchorBehaviorInstance$_ = class extends dv {
        constructor() {
            super(), wv.set(this, dv._$_GetInitInst$_()._$GetSdkInstance$_());
        }
        get isEnabled() {
            return wv.get(this)._$_IsEnabled$_();
        }
        set isEnabled(t) {
            wv.get(this)._$_SetEnabled$_(t);
        }
    };
}

self._$C3$_._$Behaviors$_._$Anchor$_._$Cnds$_ = {
    _$IsEnabled$_() {
        return this._$_IsEnabled$_();
    }
}, self._$C3$_._$Behaviors$_._$Anchor$_._$Acts$_ = {
    _$SetEnabled$_(t) {
        this._$_SetEnabled$_(0 !== t);
    }
}, self._$C3$_._$Behaviors$_._$Anchor$_._$Exps$_ = {};

{
    const Sv = self._$C3$_;
    Sv._$Behaviors$_._$solid$_ = class extends Sv._$SDKBehaviorBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
    };
}

{
    const bv = self._$C3$_;
    bv._$Behaviors$_._$solid$_._$Type$_ = class extends bv._$SDKBehaviorTypeBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$OnCreate$_() {}
    };
}

{
    const Tv = self._$C3$_, vv = self._$C3X$_, xv = self._$IBehaviorInstance$_, Iv = 0, Gv = 1, Cv = new Set;
    Tv._$Behaviors$_._$solid$_.Instance = class extends Tv._$SDKBehaviorInstanceBase$_ {
        constructor(t, s) {
            super(t), this._$SetEnabled$_(!0), s && (this._$SetEnabled$_(s[Iv]), this._$SetTags$_(s[Gv]));
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$SetEnabled$_(t) {
            this._$_inst$_._$_SetSolidEnabled$_(!!t);
        }
        _$IsEnabled$_() {
            return this._$_inst$_._$_IsSolidEnabled$_();
        }
        _$SetTags$_(t) {
            const s = this._$_inst$_._$GetSavedDataMap$_();
            if (!t.trim()) return void s.delete("solidTags");
            let i = s.get("solidTags");
            i || (i = new Set, s.set("solidTags", i)), i.clear();
            for (const s of t.split(" ")) s && i.add(s.toLowerCase());
        }
        _$GetTags$_() {
            return this._$_inst$_._$GetSavedDataMap$_().get("solidTags") || Cv;
        }
        _$_GetTagsString$_() {
            return [ ...this._$GetTags$_() ].join(" ");
        }
        _$SaveToJson$_() {
            return {
                e: this._$IsEnabled$_()
            };
        }
        _$LoadFromJson$_(t) {
            this._$SetEnabled$_(t.e);
        }
        _$GetPropertyValueByIndex$_(t) {
            if (t === Iv) return this._$IsEnabled$_();
        }
        _$SetPropertyValueByIndex$_(t, s) {
            t === Iv && this._$SetEnabled$_(s);
        }
        _$GetDebuggerProperties$_() {
            return [ {
                title: "$" + this._$GetBehaviorType$_()._$GetName$_(),
                properties: [ {
                    name: "behaviors.solid.properties.enabled.name",
                    value: this._$IsEnabled$_(),
                    _$onedit$_: t => this._$SetEnabled$_(t)
                }, {
                    name: "behaviors.solid.properties.tags.name",
                    value: this._$_GetTagsString$_(),
                    _$onedit$_: t => this._$SetTags$_(t)
                } ]
            } ];
        }
        _$GetScriptInterfaceClass$_() {
            return self._$ISolidBehaviorInstance$_;
        }
    };
    const _v = new WeakMap;
    self._$ISolidBehaviorInstance$_ = class extends xv {
        constructor() {
            super(), _v.set(this, xv._$_GetInitInst$_()._$GetSdkInstance$_());
        }
        set isEnabled(t) {
            _v.get(this)._$SetEnabled$_(!!t);
        }
        get isEnabled() {
            return _v.get(this)._$IsEnabled$_();
        }
        set tags(t) {
            vv._$RequireString$_(t), _v.get(this)._$SetTags$_(t);
        }
        get tags() {
            return _v.get(this)._$_GetTagsString$_();
        }
    };
}

self._$C3$_._$Behaviors$_._$solid$_._$Cnds$_ = {
    _$IsEnabled$_() {
        return this._$IsEnabled$_();
    }
}, self._$C3$_._$Behaviors$_._$solid$_._$Acts$_ = {
    _$SetEnabled$_(t) {
        this._$SetEnabled$_(t);
    },
    _$SetTags$_(t) {
        this._$SetTags$_(t);
    }
}, self._$C3$_._$Behaviors$_._$solid$_._$Exps$_ = {};

{
    const Ev = self._$C3$_;
    Ev._$Behaviors$_._$Bullet$_ = class extends Ev._$SDKBehaviorBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
    };
}

{
    const Dv = self._$C3$_;
    Dv._$Behaviors$_._$Bullet$_._$Type$_ = class extends Dv._$SDKBehaviorTypeBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$OnCreate$_() {}
    };
}

{
    const Av = self._$C3$_, Nv = self._$C3X$_, Lv = self._$IBehaviorInstance$_, Ov = 0, Rv = 1, Pv = 2, kv = 3, Fv = 4, jv = 5, Bv = 6;
    Av._$Behaviors$_._$Bullet$_.Instance = class extends Av._$SDKBehaviorInstanceBase$_ {
        constructor(t, s) {
            super(t);
            const i = this._$GetWorldInfo$_();
            this._$_speed$_ = 0, this._$_acc$_ = 0, this._$_g$_ = 0, this._$_bounceOffSolid$_ = !1, 
            this._$_setAngle$_ = !1, this._$_isStepping$_ = !1, this._$_isEnabled$_ = !0, this._$_dx$_ = 0, 
            this._$_dy$_ = 0, this._$_lastX$_ = i._$GetX$_(), this._$_lastY$_ = i._$GetY$_(), 
            this._$_lastKnownAngle$_ = i._$GetAngle$_(), this._$_travelled$_ = 0, this._$_stepSize$_ = Math.min(Math.abs(i._$GetWidth$_()), Math.abs(i._$GetHeight$_()) / 2), 
            this._$_stopStepping$_ = !1, s && (this._$_speed$_ = s[Ov], this._$_acc$_ = s[Rv], 
            this._$_g$_ = s[Pv], this._$_bounceOffSolid$_ = !!s[kv], this._$_setAngle$_ = !!s[Fv], 
            this._$_isStepping$_ = !!s[jv], this._$_isEnabled$_ = !!s[Bv]);
            const e = i._$GetAngle$_();
            this._$_dx$_ = Math.cos(e) * this._$_speed$_, this._$_dy$_ = Math.sin(e) * this._$_speed$_, 
            this._$_isEnabled$_ && (this._$_StartTicking$_(), this._$_bounceOffSolid$_ && this._$_StartPostTicking$_());
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$SaveToJson$_() {
            const t = {
                dx: this._$_dx$_,
                dy: this._$_dy$_,
                lx: this._$_lastX$_,
                ly: this._$_lastY$_,
                lka: this._$_lastKnownAngle$_,
                t: this._$_travelled$_
            };
            return 0 !== this._$_acc$_ && (t.acc = this._$_acc$_), 0 !== this._$_g$_ && (t.g = this._$_g$_), 
            this._$_isStepping$_ && (t.st = this._$_isStepping$_), this._$_isEnabled$_ || (t.e = this._$_isEnabled$_), 
            this._$_bounceOffSolid$_ && (t.bos = this._$_bounceOffSolid$_), this._$_setAngle$_ && (t.sa = this._$_setAngle$_), 
            t;
        }
        _$LoadFromJson$_(t) {
            this._$_dx$_ = t.dx, this._$_dy$_ = t.dy, this._$_lastX$_ = t.lx, this._$_lastY$_ = t.ly, 
            this._$_lastKnownAngle$_ = t.lka, this._$_travelled$_ = t.t, this._$_acc$_ = t.hasOwnProperty("acc") ? t.acc : 0, 
            this._$_g$_ = t.hasOwnProperty("g") ? t.g : 0, this._$_isStepping$_ = !!t.hasOwnProperty("st") && t.st, 
            this._$_bounceOffSolid$_ = !!t.hasOwnProperty("bos") && t.bos, this._$_setAngle$_ = !!t.hasOwnProperty("sa") && t.sa, 
            this._$_SetEnabled$_(!t.hasOwnProperty("e") || t.e);
        }
        _$Tick$_() {
            if (!this._$_isEnabled$_) return;
            const t = this._$_runtime$_._$GetDt$_(this._$_inst$_), s = this._$_inst$_._$GetWorldInfo$_();
            if (s._$GetAngle$_() !== this._$_lastKnownAngle$_) {
                const t = s._$GetAngle$_();
                if (this._$_setAngle$_) {
                    const s = Av._$distanceTo$_(0, 0, this._$_dx$_, this._$_dy$_);
                    this._$_dx$_ = Math.cos(t) * s, this._$_dy$_ = Math.sin(t) * s;
                }
                this._$_lastKnownAngle$_ = t;
            }
            let i = 0, e = 0;
            if (0 !== this._$_acc$_) {
                let n = Av._$distanceTo$_(0, 0, this._$_dx$_, this._$_dy$_), h = 0;
                h = 0 === this._$_dx$_ && 0 === this._$_dy$_ ? s._$GetAngle$_() : Av._$angleTo$_(0, 0, this._$_dx$_, this._$_dy$_), 
                n += this._$_acc$_ * t, i = Math.cos(h) * this._$_acc$_, e = Math.sin(h) * this._$_acc$_, 
                n < 0 && (n = 0, i = 0, e = 0), this._$_dx$_ = Math.cos(h) * n, this._$_dy$_ = Math.sin(h) * n;
            }
            if (0 !== this._$_g$_ && (this._$_dy$_ += this._$_g$_ * t, e += this._$_g$_), this._$_lastX$_ = s._$GetX$_(), 
            this._$_lastY$_ = s._$GetY$_(), 0 !== this._$_dx$_ || 0 !== this._$_dy$_) {
                const n = this._$_dx$_ * t + .5 * i * t * t, h = this._$_dy$_ * t + .5 * e * t * t, r = Av._$distanceTo$_(0, 0, n, h);
                if (this._$_MoveBy$_(n, h, r), this._$_travelled$_ += r, this._$_setAngle$_ && (0 !== n || 0 !== h)) {
                    const t = Av._$angleTo$_(0, 0, n, h);
                    s._$SetAngle$_(t), this._$_lastKnownAngle$_ = s._$GetAngle$_();
                }
                s._$SetBboxChanged$_();
            }
        }
        _$_MoveBy$_(t, s, i) {
            const e = this._$GetWorldInfo$_();
            if (!this._$_isStepping$_ || i <= this._$_stepSize$_) return e._$OffsetXY$_(t, s), 
            e._$SetBboxChanged$_(), void (this._$_isStepping$_ && this._$Trigger$_(Av._$Behaviors$_._$Bullet$_._$Cnds$_._$OnStep$_));
            this._$_stopStepping$_ = !1;
            const n = e._$GetX$_(), h = e._$GetY$_(), r = n + t, o = h + s, a = Av._$angleTo$_(0, 0, t, s), u = Math.cos(a) * this._$_stepSize$_, l = Math.sin(a) * this._$_stepSize$_, c = Math.floor(i / this._$_stepSize$_);
            for (let t = 1; t <= c; ++t) if (e._$SetXY$_(n + u * t, h + l * t), e._$SetBboxChanged$_(), 
            this._$Trigger$_(Av._$Behaviors$_._$Bullet$_._$Cnds$_._$OnStep$_), this._$_inst$_._$IsDestroyed$_() || this._$_stopStepping$_) return;
            e._$SetXY$_(r, o), e._$SetBboxChanged$_(), this._$Trigger$_(Av._$Behaviors$_._$Bullet$_._$Cnds$_._$OnStep$_);
        }
        _$PostTick$_() {
            if (!this._$_isEnabled$_ || !this._$_bounceOffSolid$_ || 0 === this._$_dx$_ && 0 === this._$_dy$_) return;
            const t = this._$_runtime$_._$GetDt$_(this._$_inst$_), s = this._$_inst$_._$GetWorldInfo$_(), i = this._$_runtime$_._$GetCollisionEngine$_(), e = i._$TestOverlapSolid$_(this._$_inst$_);
            if (e) {
                i._$RegisterCollision$_(this._$_inst$_, e);
                const n = Av._$distanceTo$_(0, 0, this._$_dx$_, this._$_dy$_), h = i._$CalculateBounceAngle$_(this._$_inst$_, this._$_lastX$_, this._$_lastY$_);
                this._$_dx$_ = Math.cos(h) * n, this._$_dy$_ = Math.sin(h) * n, s._$OffsetXY$_(this._$_dx$_ * t, this._$_dy$_ * t), 
                s._$SetBboxChanged$_(), this._$_setAngle$_ && (s._$SetAngle$_(h), this._$_lastKnownAngle$_ = s._$GetAngle$_(), 
                s._$SetBboxChanged$_()), i._$PushOutSolid$_(this._$_inst$_, this._$_dx$_ / n, this._$_dy$_ / n, Math.max(2.5 * n * t, 30)) || i._$PushOutSolidNearest$_(this._$_inst$_, 100);
            }
        }
        _$GetPropertyValueByIndex$_(t) {
            switch (t) {
              case Ov:
                return this._$_GetSpeed$_();

              case Rv:
                return this._$_GetAcceleration$_();

              case Pv:
                return this._$_GetGravity$_();

              case Fv:
                return this._$_setAngle$_;

              case jv:
                return this._$_isStepping$_;

              case Bv:
                return this._$_IsEnabled$_();
            }
        }
        _$SetPropertyValueByIndex$_(t, s) {
            switch (t) {
              case Ov:
                this._$_SetSpeed$_(s);
                break;

              case Rv:
                this._$_acc$_ = s;
                break;

              case Pv:
                this._$_g$_ = s;
                break;

              case Fv:
                this._$_setAngle$_ = !!s;
                break;

              case jv:
                this._$_isStepping$_ = !!s;
                break;

              case Bv:
                this._$_SetEnabled$_(!!s);
            }
        }
        _$_SetSpeed$_(t) {
            const s = Av._$angleTo$_(0, 0, this._$_dx$_, this._$_dy$_);
            this._$_dx$_ = Math.cos(s) * t, this._$_dy$_ = Math.sin(s) * t;
        }
        _$_GetSpeed$_() {
            return Av._$roundToDp$_(Av._$distanceTo$_(0, 0, this._$_dx$_, this._$_dy$_), 6);
        }
        _$_SetAcceleration$_(t) {
            this._$_acc$_ = t;
        }
        _$_GetAcceleration$_() {
            return this._$_acc$_;
        }
        _$_SetGravity$_(t) {
            this._$_g$_ = t;
        }
        _$_GetGravity$_() {
            return this._$_g$_;
        }
        _$_SetAngleOfMotion$_(t) {
            const s = Av._$distanceTo$_(0, 0, this._$_dx$_, this._$_dy$_);
            this._$_dx$_ = Math.cos(t) * s, this._$_dy$_ = Math.sin(t) * s;
        }
        _$_GetAngleOfMotion$_() {
            return Av._$angleTo$_(0, 0, this._$_dx$_, this._$_dy$_);
        }
        _$_SetBounceOffSolids$_(t) {
            t = !!t, this._$_bounceOffSolid$_ !== t && (this._$_bounceOffSolid$_ = t, this._$_isEnabled$_ && (this._$_bounceOffSolid$_ ? this._$_StartPostTicking$_() : this._$_StopPostTicking$_()));
        }
        _$_IsBounceOffSolids$_() {
            return this._$_bounceOffSolid$_;
        }
        _$_SetDistanceTravelled$_(t) {
            this._$_travelled$_ = t;
        }
        _$_GetDistanceTravelled$_() {
            return this._$_travelled$_;
        }
        _$_SetEnabled$_(t) {
            this._$_isEnabled$_ = !!t, this._$_isEnabled$_ ? (this._$_StartTicking$_(), this._$_bounceOffSolid$_ && this._$_StartPostTicking$_()) : (this._$_StopTicking$_(), 
            this._$_StopPostTicking$_());
        }
        _$_IsEnabled$_() {
            return this._$_isEnabled$_;
        }
        _$GetDebuggerProperties$_() {
            const t = "behaviors.bullet";
            return [ {
                title: "$" + this._$GetBehaviorType$_()._$GetName$_(),
                properties: [ {
                    name: t + ".debugger.vector-x",
                    value: this._$_dx$_,
                    _$onedit$_: t => this._$_dx$_ = t
                }, {
                    name: t + ".debugger.vector-y",
                    value: this._$_dy$_,
                    _$onedit$_: t => this._$_dy$_ = t
                }, {
                    name: t + ".properties.speed.name",
                    value: this._$_GetSpeed$_(),
                    _$onedit$_: t => this._$_SetSpeed$_(t)
                }, {
                    name: t + ".debugger.angle-of-motion",
                    value: Av._$toDegrees$_(this._$_GetAngleOfMotion$_())
                }, {
                    name: t + ".properties.gravity.name",
                    value: this._$_GetGravity$_(),
                    _$onedit$_: t => this._$_SetGravity$_(t)
                }, {
                    name: t + ".properties.acceleration.name",
                    value: this._$_GetAcceleration$_(),
                    _$onedit$_: t => this._$_SetAcceleration$_(t)
                }, {
                    name: t + ".debugger.distance-travelled",
                    value: this._$_GetDistanceTravelled$_()
                }, {
                    name: t + ".properties.enabled.name",
                    value: this._$_IsEnabled$_(),
                    _$onedit$_: t => this._$_SetEnabled$_(t)
                } ]
            } ];
        }
        _$GetScriptInterfaceClass$_() {
            return self._$IBulletBehaviorInstance$_;
        }
    };
    const zv = new WeakMap;
    self._$IBulletBehaviorInstance$_ = class extends Lv {
        constructor() {
            super(), zv.set(this, Lv._$_GetInitInst$_()._$GetSdkInstance$_());
        }
        get speed() {
            return zv.get(this)._$_GetSpeed$_();
        }
        set speed(t) {
            Nv._$RequireFiniteNumber$_(t), zv.get(this)._$_SetSpeed$_(t);
        }
        get acceleration() {
            return zv.get(this)._$_GetAcceleration$_();
        }
        set acceleration(t) {
            Nv._$RequireFiniteNumber$_(t), zv.get(this)._$_SetAcceleration$_(t);
        }
        get _$gravity$_() {
            return zv.get(this)._$_GetGravity$_();
        }
        set _$gravity$_(t) {
            Nv._$RequireFiniteNumber$_(t), zv.get(this)._$_SetGravity$_(t);
        }
        get _$angleOfMotion$_() {
            return zv.get(this)._$_GetAngleOfMotion$_();
        }
        set _$angleOfMotion$_(t) {
            Nv._$RequireFiniteNumber$_(t), zv.get(this)._$_SetAngleOfMotion$_(t);
        }
        get _$bounceOffSolids$_() {
            return zv.get(this)._$_IsBounceOffSolids$_();
        }
        set _$bounceOffSolids$_(t) {
            zv.get(this)._$_SetBounceOffSolids$_(!!t);
        }
        get _$distanceTravelled$_() {
            return zv.get(this)._$_GetDistanceTravelled$_();
        }
        set _$distanceTravelled$_(t) {
            Nv._$RequireFiniteNumber$_(t), zv.get(this)._$_SetDistanceTravelled$_(t);
        }
        get isEnabled() {
            return zv.get(this)._$_IsEnabled$_();
        }
        set isEnabled(t) {
            zv.get(this)._$_SetEnabled$_(t);
        }
    };
}

{
    const Uv = self._$C3$_;
    Uv._$Behaviors$_._$Bullet$_._$Cnds$_ = {
        _$CompareSpeed$_(t, s) {
            const i = Math.hypot(this._$_dx$_, this._$_dy$_);
            return Uv.compare(i, t, s);
        },
        _$CompareTravelled$_(t, s) {
            return Uv.compare(this._$_GetDistanceTravelled$_(), t, s);
        },
        _$OnStep$_: () => !0,
        _$IsEnabled$_() {
            return this._$_IsEnabled$_();
        }
    };
}

{
    const Wv = self._$C3$_;
    Wv._$Behaviors$_._$Bullet$_._$Acts$_ = {
        _$SetSpeed$_(t) {
            this._$_SetSpeed$_(t);
        },
        _$SetAcceleration$_(t) {
            this._$_SetAcceleration$_(t);
        },
        _$SetGravity$_(t) {
            this._$_SetGravity$_(t);
        },
        _$SetAngleOfMotion$_(t) {
            this._$_SetAngleOfMotion$_(Wv._$toRadians$_(t));
        },
        _$Bounce$_(t) {
            if (!t) return;
            const s = t._$GetFirstPicked$_(this._$_inst$_);
            if (!s) return;
            const i = this._$_inst$_._$GetWorldInfo$_(), e = this._$_runtime$_._$GetCollisionEngine$_(), n = this._$_runtime$_._$GetDt$_(this._$_inst$_), h = Wv._$distanceTo$_(0, 0, this._$_dx$_, this._$_dy$_), r = e._$CalculateBounceAngle$_(this._$_inst$_, this._$_lastX$_, this._$_lastY$_, s);
            this._$_dx$_ = Math.cos(r) * h, this._$_dy$_ = Math.sin(r) * h, i._$OffsetXY$_(this._$_dx$_ * n, this._$_dy$_ * n), 
            i._$SetBboxChanged$_(), this._$_setAngle$_ && (i._$SetAngle$_(r), this._$_lastKnownAngle$_ = i._$GetAngle$_(), 
            i._$SetBboxChanged$_()), 0 !== h && (this._$_bounceOffSolid$_ ? e._$PushOutSolid$_(this._$_inst$_, this._$_dx$_ / h, this._$_dy$_ / h, Math.max(2.5 * h * n, 30)) || e._$PushOutSolidNearest$_(this._$_inst$_, 100) : e._$PushOut$_(this._$_inst$_, this._$_dx$_ / h, this._$_dy$_ / h, Math.max(2.5 * h * n, 30), s));
        },
        _$SetBounceOffSolids$_(t) {
            this._$_SetBounceOffSolids$_(t);
        },
        _$SetDistanceTravelled$_(t) {
            this._$_SetDistanceTravelled$_(t);
        },
        _$SetEnabled$_(t) {
            this._$_SetEnabled$_(t);
        },
        _$StopStepping$_() {
            this._$_stopStepping$_ = !0;
        }
    };
}

{
    const Jv = self._$C3$_;
    Jv._$Behaviors$_._$Bullet$_._$Exps$_ = {
        _$Speed$_() {
            return this._$_GetSpeed$_();
        },
        _$Acceleration$_() {
            return this._$_GetAcceleration$_();
        },
        _$AngleOfMotion$_() {
            return Jv._$toDegrees$_(this._$_GetAngleOfMotion$_());
        },
        _$DistanceTravelled$_() {
            return this._$_GetDistanceTravelled$_();
        },
        _$Gravity$_() {
            return this._$_GetGravity$_();
        }
    };
}

{
    const Qv = self._$C3$_;
    Qv._$Behaviors$_._$Sin$_ = class extends Qv._$SDKBehaviorBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
    };
}

{
    const Yv = self._$C3$_;
    Yv._$Behaviors$_._$Sin$_._$Type$_ = class extends Yv._$SDKBehaviorTypeBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$OnCreate$_() {}
    };
}

{
    const Vv = self._$C3$_, Hv = self._$C3X$_, qv = self._$IBehaviorInstance$_, Xv = 0, Zv = 1, Kv = 2, $v = 3, tx = 4, sx = 5, ix = 6, ex = 7, nx = 8, hx = 0, rx = 1, ox = 2, ax = 3, ux = 4, lx = 5, cx = 6, fx = 7, dx = 8, px = 9, mx = 0, gx = 1, yx = 2, Mx = 3, wx = 4, Sx = 2 * Math.PI, bx = Math.PI / 2, Tx = 3 * Math.PI / 2, vx = [ 0, 1, 8, 3, 4, 2, 5, 6, 9, 7 ];
    Vv._$Behaviors$_._$Sin$_.Instance = class extends Vv._$SDKBehaviorInstanceBase$_ {
        constructor(t, s) {
            super(t), this._$_i$_ = 0, this._$_movement$_ = 0, this._$_wave$_ = 0, this._$_period$_ = 0, 
            this._$_mag$_ = 0, this._$_isEnabled$_ = !0, this._$_basePeriod$_ = 0, this._$_basePeriodOffset$_ = 0, 
            this._$_baseMag$_ = 0, this._$_periodRandom$_ = 0, this._$_periodOffsetRandom$_ = 0, 
            this._$_magnitudeRandom$_ = 0, this._$_initialValue$_ = 0, this._$_initialValue2$_ = 0, 
            this._$_lastKnownValue$_ = 0, this._$_lastKnownValue2$_ = 0, this._$_ratio$_ = 0, 
            s && (this._$_movement$_ = vx[s[Xv]], this._$_wave$_ = s[Zv], this._$_periodRandom$_ = this._$_runtime$_._$Random$_() * s[$v], 
            this._$_basePeriod$_ = s[Kv], this._$_period$_ = s[Kv], this._$_period$_ += this._$_periodRandom$_, 
            this._$_basePeriodOffset$_ = s[tx], 0 !== this._$_period$_ && (this._$_periodOffsetRandom$_ = this._$_runtime$_._$Random$_() * s[sx], 
            this._$_i$_ = s[tx] / this._$_period$_ * Sx, this._$_i$_ += this._$_periodOffsetRandom$_ / this._$_period$_ * Sx), 
            this._$_magnitudeRandom$_ = this._$_runtime$_._$Random$_() * s[ex], this._$_baseMag$_ = s[ix], 
            this._$_mag$_ = s[ix], this._$_mag$_ += this._$_magnitudeRandom$_, this._$_isEnabled$_ = !!s[nx]), 
            this._$_movement$_ === lx && (this._$_mag$_ = Vv._$toRadians$_(this._$_mag$_)), 
            this._$Init$_(), this._$_isEnabled$_ && this._$_StartTicking$_();
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$SaveToJson$_() {
            return {
                i: this._$_i$_,
                e: this._$_isEnabled$_,
                mv: this._$_movement$_,
                w: this._$_wave$_,
                p: this._$_period$_,
                mag: this._$_mag$_,
                iv: this._$_initialValue$_,
                iv2: this._$_initialValue2$_,
                r: this._$_ratio$_,
                lkv: this._$_lastKnownValue$_,
                lkv2: this._$_lastKnownValue2$_
            };
        }
        _$LoadFromJson$_(t) {
            this._$_i$_ = t.i, this._$_SetEnabled$_(t.e), this._$_movement$_ = t.mv, this._$_wave$_ = t.w, 
            this._$_period$_ = t.p, this._$_mag$_ = t.mag, this._$_initialValue$_ = t.iv, this._$_initialValue2$_ = t.iv2, 
            this._$_ratio$_ = t.r, this._$_lastKnownValue$_ = t.lkv, this._$_lastKnownValue2$_ = t.lkv2;
        }
        _$Init$_() {
            const t = this._$_inst$_._$GetWorldInfo$_();
            switch (this._$_movement$_) {
              case hx:
                this._$_initialValue$_ = t._$GetX$_();
                break;

              case rx:
                this._$_initialValue$_ = t._$GetY$_();
                break;

              case ox:
                this._$_initialValue$_ = t._$GetWidth$_(), this._$_ratio$_ = t._$GetHeight$_() / t._$GetWidth$_();
                break;

              case ax:
                this._$_initialValue$_ = t._$GetWidth$_();
                break;

              case ux:
                this._$_initialValue$_ = t._$GetHeight$_();
                break;

              case lx:
                this._$_initialValue$_ = t._$GetAngle$_();
                break;

              case cx:
                this._$_initialValue$_ = t._$GetOpacity$_();
                break;

              case fx:
                this._$_initialValue$_ = 0;
                break;

              case dx:
                this._$_initialValue$_ = t._$GetX$_(), this._$_initialValue2$_ = t._$GetY$_();
                break;

              case px:
                this._$_initialValue$_ = t._$GetZElevation$_();
            }
            this._$_lastKnownValue$_ = this._$_initialValue$_, this._$_lastKnownValue2$_ = this._$_initialValue2$_;
        }
        _$WaveFunc$_(t) {
            switch (t %= Sx, this._$_wave$_) {
              case mx:
                return Math.sin(t);

              case gx:
                return t <= bx ? t / bx : t <= Tx ? 1 - 2 * (t - bx) / Math.PI : (t - Tx) / bx - 1;

              case yx:
                return 2 * t / Sx - 1;

              case Mx:
                return -2 * t / Sx + 1;

              case wx:
                return t < Math.PI ? -1 : 1;
            }
            return 0;
        }
        _$Tick$_() {
            const t = this._$_runtime$_._$GetDt$_(this._$_inst$_);
            this._$_isEnabled$_ && 0 !== t && (0 === this._$_period$_ ? this._$_i$_ = 0 : this._$_i$_ = (this._$_i$_ + t / this._$_period$_ * Sx) % Sx, 
            this._$_UpdateFromPhase$_());
        }
        _$_UpdateFromPhase$_() {
            const t = this._$_inst$_._$GetWorldInfo$_();
            switch (this._$_movement$_) {
              case hx:
                t._$GetX$_() !== this._$_lastKnownValue$_ && (this._$_initialValue$_ += t._$GetX$_() - this._$_lastKnownValue$_), 
                t._$SetX$_(this._$_initialValue$_ + this._$WaveFunc$_(this._$_i$_) * this._$_mag$_), 
                this._$_lastKnownValue$_ = t._$GetX$_();
                break;

              case rx:
                t._$GetY$_() !== this._$_lastKnownValue$_ && (this._$_initialValue$_ += t._$GetY$_() - this._$_lastKnownValue$_), 
                t._$SetY$_(this._$_initialValue$_ + this._$WaveFunc$_(this._$_i$_) * this._$_mag$_), 
                this._$_lastKnownValue$_ = t._$GetY$_();
                break;

              case ox:
                t._$SetWidth$_(this._$_initialValue$_ + this._$WaveFunc$_(this._$_i$_) * this._$_mag$_), 
                t._$SetHeight$_(t._$GetWidth$_() * this._$_ratio$_);
                break;

              case ax:
                t._$SetWidth$_(this._$_initialValue$_ + this._$WaveFunc$_(this._$_i$_) * this._$_mag$_);
                break;

              case ux:
                t._$SetHeight$_(this._$_initialValue$_ + this._$WaveFunc$_(this._$_i$_) * this._$_mag$_);
                break;

              case lx:
                t._$GetAngle$_() !== this._$_lastKnownValue$_ && (this._$_initialValue$_ = Vv._$clampAngle$_(this._$_initialValue$_ + (t._$GetAngle$_() - this._$_lastKnownValue$_))), 
                t._$SetAngle$_(this._$_initialValue$_ + this._$WaveFunc$_(this._$_i$_) * this._$_mag$_), 
                this._$_lastKnownValue$_ = t._$GetAngle$_();
                break;

              case cx:
                t._$SetOpacity$_(this._$_initialValue$_ + this._$WaveFunc$_(this._$_i$_) * this._$_mag$_ / 100);
                break;

              case dx:
                t._$GetX$_() !== this._$_lastKnownValue$_ && (this._$_initialValue$_ += t._$GetX$_() - this._$_lastKnownValue$_), 
                t._$GetY$_() !== this._$_lastKnownValue2$_ && (this._$_initialValue2$_ += t._$GetY$_() - this._$_lastKnownValue2$_), 
                t._$SetX$_(this._$_initialValue$_ + Math.cos(t._$GetAngle$_()) * this._$WaveFunc$_(this._$_i$_) * this._$_mag$_), 
                t._$SetY$_(this._$_initialValue2$_ + Math.sin(t._$GetAngle$_()) * this._$WaveFunc$_(this._$_i$_) * this._$_mag$_), 
                this._$_lastKnownValue$_ = t._$GetX$_(), this._$_lastKnownValue2$_ = t._$GetY$_();
                break;

              case px:
                t._$SetZElevation$_(this._$_initialValue$_ + this._$WaveFunc$_(this._$_i$_) * this._$_mag$_);
            }
            t._$SetBboxChanged$_();
        }
        _$_OnSpriteFrameChanged$_(t, s) {}
        _$_SetPeriod$_(t) {
            this._$_period$_ = t;
        }
        _$_GetPeriod$_() {
            return this._$_period$_;
        }
        _$_SetMagnitude$_(t) {
            this._$_mag$_ = t;
        }
        _$_SetMagnitude_ConvertAngle$_(t) {
            5 === this._$_movement$_ && (t = Vv._$toRadians$_(t)), this._$_SetMagnitude$_(t);
        }
        _$_GetMagnitude$_() {
            return this._$_mag$_;
        }
        _$_GetMagnitude_ConvertAngle$_() {
            let t = this._$_GetMagnitude$_();
            return 5 === this._$_movement$_ && (t = Vv._$toDegrees$_(t)), t;
        }
        _$_SetMovement$_(t) {
            5 === this._$_movement$_ && 5 !== t && (this._$_mag$_ = Vv._$toDegrees$_(this._$_mag$_)), 
            this._$_movement$_ = t, this._$Init$_();
        }
        _$_GetMovement$_() {
            return this._$_movement$_;
        }
        _$_SetWave$_(t) {
            this._$_wave$_ = t;
        }
        _$_GetWave$_() {
            return this._$_wave$_;
        }
        _$_SetPhase$_(t) {
            this._$_i$_ = Vv._$clamp$_(t, 0, 2 * Math.PI), this._$_UpdateFromPhase$_();
        }
        _$_GetPhase$_() {
            return this._$_i$_;
        }
        _$_SetEnabled$_(t) {
            this._$_isEnabled$_ = !!t, this._$_isEnabled$_ ? this._$_StartTicking$_() : this._$_StopTicking$_();
        }
        _$_IsEnabled$_() {
            return this._$_isEnabled$_;
        }
        _$GetPropertyValueByIndex$_(t) {
            switch (t) {
              case Xv:
                return this._$_movement$_;

              case Zv:
                return this._$_wave$_;

              case Kv:
                return this._$_basePeriod$_;

              case ix:
                return this._$_baseMag$_;

              case nx:
                return this._$_isEnabled$_;
            }
        }
        _$SetPropertyValueByIndex$_(t, s) {
            switch (t) {
              case Xv:
                this._$_movement$_ = vx[s], this._$Init$_();
                break;

              case Zv:
                this._$_wave$_ = s;
                break;

              case Kv:
                this._$_basePeriod$_ = s, this._$_period$_ = this._$_basePeriod$_ + this._$_periodRandom$_, 
                this._$_isEnabled$_ || (0 !== this._$_period$_ ? (this._$_i$_ = this._$_basePeriodOffset$_ / this._$_period$_ * Sx, 
                this._$_i$_ += this._$_periodOffsetRandom$_ / this._$_period$_ * Sx) : this._$_i$_ = 0);
                break;

              case ix:
                this._$_baseMag$_ = s, this._$_mag$_ = this._$_baseMag$_ + this._$_magnitudeRandom$_, 
                this._$_movement$_ === lx && (this._$_mag$_ = Vv._$toRadians$_(this._$_mag$_));
                break;

              case nx:
                this._$_isEnabled$_ = !!s;
            }
        }
        _$GetDebuggerProperties$_() {
            const t = "behaviors.sin";
            return [ {
                title: "$" + this._$GetBehaviorType$_()._$GetName$_(),
                properties: [ {
                    name: t + ".properties.enabled.name",
                    value: this._$_IsEnabled$_(),
                    _$onedit$_: t => this._$_SetEnabled$_(t)
                }, {
                    name: t + ".properties.period.name",
                    value: this._$_GetPeriod$_(),
                    _$onedit$_: t => this._$_SetPeriod$_(t)
                }, {
                    name: t + ".properties.magnitude.name",
                    value: this._$_GetMagnitude_ConvertAngle$_(),
                    _$onedit$_: t => this._$_SetMagnitude_ConvertAngle$_(t)
                }, {
                    name: t + ".debugger.value",
                    value: this._$WaveFunc$_(this._$_GetPhase$_()) * this._$_GetMagnitude_ConvertAngle$_()
                } ]
            } ];
        }
        _$GetScriptInterfaceClass$_() {
            return self._$ISineBehaviorInstance$_;
        }
    };
    const xx = new WeakMap, Ix = [ "horizontal", "vertical", "size", "width", "height", "angle", "opacity", "value-only", "forwards-backwards", "z-elevation" ], Gx = [ "sine", "triangle", "sawtooth", "reverse-sawtooth", "square" ];
    self._$ISineBehaviorInstance$_ = class extends qv {
        constructor() {
            super(), xx.set(this, qv._$_GetInitInst$_()._$GetSdkInstance$_());
        }
        set _$period$_(t) {
            Hv._$RequireFiniteNumber$_(t), xx.get(this)._$_SetPeriod$_(t);
        }
        get _$period$_() {
            return xx.get(this)._$_GetPeriod$_();
        }
        set _$magnitude$_(t) {
            Hv._$RequireFiniteNumber$_(t), xx.get(this)._$_SetMagnitude$_(t);
        }
        get _$magnitude$_() {
            return xx.get(this)._$_GetMagnitude$_();
        }
        set _$phase$_(t) {
            xx.get(this)._$_SetPhase$_(t);
        }
        get _$phase$_() {
            return xx.get(this)._$_GetPhase$_();
        }
        set _$movement$_(t) {
            Hv._$RequireString$_(t);
            const s = Ix.indexOf(t);
            if (-1 === s) throw new Error("invalid movement");
            xx.get(this)._$_SetMovement$_(s);
        }
        get _$movement$_() {
            return Ix[xx.get(this)._$_GetMovement$_()];
        }
        set _$wave$_(t) {
            Hv._$RequireString$_(t);
            const s = Gx.indexOf(t);
            if (-1 === s) throw new Error("invalid wave");
            xx.get(this)._$_SetWave$_(s);
        }
        get _$wave$_() {
            return Gx[xx.get(this)._$_GetWave$_()];
        }
        get value() {
            const t = xx.get(this);
            return t._$WaveFunc$_(t._$_GetPhase$_()) * t._$_GetMagnitude$_();
        }
        _$updateInitialState$_() {
            xx.get(this)._$Init$_();
        }
        set isEnabled(t) {
            xx.get(this)._$_SetEnabled$_(!!t);
        }
        get isEnabled() {
            return xx.get(this)._$_IsEnabled$_();
        }
    };
}

{
    const Cx = self._$C3$_;
    Cx._$Behaviors$_._$Sin$_._$Cnds$_ = {
        _$IsEnabled$_() {
            return this._$_IsEnabled$_();
        },
        _$CompareMovement$_(t) {
            return this._$_GetMovement$_() === t;
        },
        _$ComparePeriod$_(t, s) {
            return Cx.compare(this._$_GetPeriod$_(), t, s);
        },
        _$CompareMagnitude$_(t, s) {
            return Cx.compare(this._$_GetMagnitude_ConvertAngle$_(), t, s);
        },
        _$CompareWave$_(t) {
            return this._$_GetWave$_() === t;
        }
    };
}

self._$C3$_._$Behaviors$_._$Sin$_._$Acts$_ = {
    _$SetEnabled$_(t) {
        this._$_SetEnabled$_(0 !== t);
    },
    _$SetPeriod$_(t) {
        this._$_SetPeriod$_(t);
    },
    _$SetMagnitude$_(t) {
        this._$_SetMagnitude_ConvertAngle$_(t);
    },
    _$SetMovement$_(t) {
        this._$_SetMovement$_(t);
    },
    _$SetWave$_(t) {
        this._$_wave$_ = t;
    },
    _$SetPhase$_(t) {
        const s = 2 * Math.PI;
        this._$_SetPhase$_(t * s % s);
    },
    _$UpdateInitialState$_() {
        this._$Init$_();
    }
}, self._$C3$_._$Behaviors$_._$Sin$_._$Exps$_ = {
    _$CyclePosition$_() {
        return this._$_GetPhase$_() / (2 * Math.PI);
    },
    _$Period$_() {
        return this._$_GetPeriod$_();
    },
    _$Magnitude$_() {
        return this._$_GetMagnitude_ConvertAngle$_();
    },
    _$Value$_() {
        return this._$WaveFunc$_(this._$_GetPhase$_()) * this._$_GetMagnitude_ConvertAngle$_();
    }
};

{
    const _x = self._$C3$_;
    _x._$Behaviors$_.wrap = class extends _x._$SDKBehaviorBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
    };
}

{
    const Ex = self._$C3$_;
    Ex._$Behaviors$_.wrap._$Type$_ = class extends Ex._$SDKBehaviorTypeBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$OnCreate$_() {}
    };
}

{
    const Dx = self._$C3$_, Ax = 0, Nx = new Dx.Rect;
    Dx._$Behaviors$_.wrap.Instance = class extends Dx._$SDKBehaviorInstanceBase$_ {
        constructor(t, s) {
            super(t), this._$_mode$_ = 0, s && (this._$_mode$_ = s[Ax]), this._$_StartTicking$_();
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$SaveToJson$_() {
            return {
                m: this._$_mode$_
            };
        }
        _$LoadFromJson$_(t) {
            this._$_mode$_ = t.m;
        }
        _$Tick$_() {
            const t = this._$_inst$_._$GetWorldInfo$_(), s = t._$GetLayer$_(), i = s._$GetLayout$_(), e = t._$GetBoundingBox$_();
            0 === this._$_mode$_ ? Nx.set(0, 0, i._$GetWidth$_(), i._$GetHeight$_()) : Nx._$copy$_(s._$GetViewport$_());
            let n = !1;
            e._$getRight$_() < Nx._$getLeft$_() ? (t._$SetX$_(Nx._$getRight$_() - 1 + (t._$GetX$_() - e._$getLeft$_())), 
            t._$SetBboxChanged$_(), n = !0) : e._$getLeft$_() > Nx._$getRight$_() ? (t._$SetX$_(Nx._$getLeft$_() + 1 - (e._$getRight$_() - t._$GetX$_())), 
            t._$SetBboxChanged$_(), n = !0) : e._$getBottom$_() < Nx._$getTop$_() ? (t._$SetY$_(Nx._$getBottom$_() - 1 + (t._$GetY$_() - e._$getTop$_())), 
            t._$SetBboxChanged$_(), n = !0) : e._$getTop$_() > Nx._$getBottom$_() && (t._$SetY$_(Nx._$getTop$_() + 1 - (e._$getBottom$_() - t._$GetY$_())), 
            t._$SetBboxChanged$_(), n = !0), n && this._$Trigger$_(Dx._$Behaviors$_.wrap._$Cnds$_._$OnWrap$_);
        }
        _$GetPropertyValueByIndex$_(t) {
            if (t === Ax) return this._$_mode$_;
        }
        _$SetPropertyValueByIndex$_(t, s) {
            t === Ax && (this._$_mode$_ = s);
        }
    };
}

self._$C3$_._$Behaviors$_.wrap._$Cnds$_ = {
    _$OnWrap$_: () => !0
}, self._$C3$_._$Behaviors$_.wrap._$Acts$_ = {}, self._$C3$_._$Behaviors$_.wrap._$Exps$_ = {};

{
    const Lx = self._$C3$_;
    Lx._$Behaviors$_._$Flash$_ = class extends Lx._$SDKBehaviorBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
    };
}

{
    const Ox = self._$C3$_;
    Ox._$Behaviors$_._$Flash$_._$Type$_ = class extends Ox._$SDKBehaviorTypeBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$OnCreate$_() {}
    };
}

{
    const Rx = self._$C3$_, Px = self._$C3X$_, kx = self._$IBehaviorInstance$_;
    Rx._$Behaviors$_._$Flash$_.Instance = class extends Rx._$SDKBehaviorInstanceBase$_ {
        constructor(t, s) {
            super(t), this._$_onTime$_ = 0, this._$_offTime$_ = 0, this._$_stage$_ = 0, this._$_stageTimeLeft$_ = 0, 
            this._$_timeLeft$_ = 0, this._$_StartTicking$_();
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$_Flash$_(t, s, i) {
            this._$_onTime$_ = t, this._$_offTime$_ = s, this._$_stage$_ = 1, this._$_stageTimeLeft$_ = s, 
            this._$_timeLeft$_ = i, this._$_inst$_._$GetWorldInfo$_()._$SetVisible$_(!1), this._$_runtime$_._$UpdateRender$_();
        }
        _$_StopFlashing$_() {
            this._$_timeLeft$_ = 0, this._$_inst$_._$GetWorldInfo$_()._$SetVisible$_(!0), this._$_runtime$_._$UpdateRender$_();
        }
        _$_IsFlashing$_() {
            return this._$_timeLeft$_ > 0;
        }
        _$SaveToJson$_() {
            return {
                on: this._$_onTime$_,
                off: this._$_offTime$_,
                s: this._$_stage$_,
                stl: this._$_stageTimeLeft$_,
                tl: this._$_timeLeft$_
            };
        }
        _$LoadFromJson$_(t) {
            this._$_onTime$_ = t.on, this._$_offTime$_ = t.off, this._$_stage$_ = t.s, this._$_stageTimeLeft$_ = t.stl, 
            this._$_timeLeft$_ = null === t.tl ? 1 / 0 : t.tl;
        }
        _$Tick$_() {
            if (this._$_timeLeft$_ <= 0) return;
            const t = this._$_runtime$_._$GetDt$_(this._$_inst$_);
            if (this._$_timeLeft$_ -= t, this._$_timeLeft$_ <= 0) return this._$_timeLeft$_ = 0, 
            this._$_inst$_._$GetWorldInfo$_()._$SetVisible$_(!0), this._$_runtime$_._$UpdateRender$_(), 
            this._$DispatchScriptEvent$_("flashend"), this._$DebugTrigger$_(Rx._$Behaviors$_._$Flash$_._$Cnds$_._$OnFlashEnded$_);
            this._$_stageTimeLeft$_ -= t, this._$_stageTimeLeft$_ <= 0 && (0 === this._$_stage$_ ? (this._$_inst$_._$GetWorldInfo$_()._$SetVisible$_(!1), 
            this._$_stage$_ = 1, this._$_stageTimeLeft$_ += this._$_offTime$_) : (this._$_inst$_._$GetWorldInfo$_()._$SetVisible$_(!0), 
            this._$_stage$_ = 0, this._$_stageTimeLeft$_ += this._$_onTime$_), this._$_runtime$_._$UpdateRender$_());
        }
        _$GetDebuggerProperties$_() {
            const t = "behaviors.flash.debugger";
            return [ {
                title: "$" + this._$GetBehaviorType$_()._$GetName$_(),
                properties: [ {
                    name: t + ".on-time",
                    value: this._$_onTime$_,
                    _$onedit$_: t => this._$_onTime$_ = t
                }, {
                    name: t + ".off-time",
                    value: this._$_offTime$_,
                    _$onedit$_: t => this._$_offTime$_ = t
                }, {
                    name: t + ".is-flashing",
                    value: this._$_timeLeft$_ > 0
                }, {
                    name: t + ".time-left",
                    value: this._$_timeLeft$_
                } ]
            } ];
        }
        _$GetScriptInterfaceClass$_() {
            return self._$IFlashBehaviorInstance$_;
        }
    };
    const Fx = new WeakMap;
    self._$IFlashBehaviorInstance$_ = class extends kx {
        constructor() {
            super(), Fx.set(this, kx._$_GetInitInst$_()._$GetSdkInstance$_());
        }
        _$flash$_(t, s, i) {
            Px._$RequireFiniteNumber$_(t), Px._$RequireFiniteNumber$_(s), Px._$RequireFiniteNumber$_(i), 
            Fx.get(this)._$_Flash$_(t, s, i);
        }
        stop() {
            Fx.get(this)._$_StopFlashing$_();
        }
        get _$isFlashing$_() {
            return Fx.get(this)._$_IsFlashing$_();
        }
    };
}

self._$C3$_._$Behaviors$_._$Flash$_._$Cnds$_ = {
    _$IsFlashing$_() {
        return this._$_IsFlashing$_();
    },
    _$OnFlashEnded$_: () => !0
}, self._$C3$_._$Behaviors$_._$Flash$_._$Acts$_ = {
    _$Flash$_(t, s, i) {
        this._$_Flash$_(t, s, i);
    },
    _$StopFlashing$_() {
        this._$_StopFlashing$_();
    }
}, self._$C3$_._$Behaviors$_._$Flash$_._$Exps$_ = {};

{
    let jx = function(t, s) {
        return "number" == typeof t && "number" == typeof s;
    }, Bx = function(t, s) {
        return jx(t, s) ? t + s : t;
    }, zx = function(t, s) {
        return jx(t, s) ? t - s : t;
    }, Ux = function(t, s) {
        return jx(t, s) ? t * s : t;
    }, Wx = function(t, s) {
        return jx(t, s) ? t / s : t;
    }, Jx = function(t, s) {
        return jx(t, s) ? t % s : t;
    }, Qx = function(t, s) {
        return jx(t, s) ? Math.pow(t, s) : t;
    }, Yx = function(t, s) {
        if ("string" == typeof t || "string" == typeof s) {
            let i, e;
            return i = "number" == typeof t ? (Math.round(1e10 * t) / 1e10).toString() : t, 
            e = "number" == typeof s ? (Math.round(1e10 * s) / 1e10).toString() : s, i + e;
        }
        return t && s ? 1 : 0;
    }, Vx = function(t, s) {
        return jx(t, s) ? t || s ? 1 : 0 : t;
    };
    0;
    self._$C3$_;
    self._$C3_ExpressionFuncs$_ = [ () => "Animacoes", () => "Pulando", () => 0, () => "", () => "Parado", () => "Andando", () => "interface", () => "0", t => {
        const s = t._$_GetNode$_(0)._$GetVar$_();
        return () => s._$GetValue$_();
    }, () => "Pin", () => "coletaveis", () => 1, () => "arma", t => {
        const s = t._$_GetNode$_(0);
        return () => s._$ExpObject$_();
    }, () => 180, () => 14, () => 1e4, () => .3, () => 20, () => 800, () => "boss", () => 18, () => "musica", t => {
        const s = t._$_GetNode$_(0)._$GetVar$_();
        return () => Yx("", s._$GetValue$_());
    }, () => 3, () => .1, () => 1.5, () => "interface2", () => "Animacoes2", () => "coletaveis2", () => "arma2", t => {
        const s = t._$_GetNode$_(0);
        return () => 10 * s._$ExpInstVar$_();
    }, () => "Brightness", () => 200, () => .05, () => 100, () => "No ano de 2147, após uma guerra devastadora entre corporações globais, a humanidade vive sob o domínio de megacidades automatizadas, controladas por superinteligências artificiais. O Cyber Core, uma poderosa IA central criada para proteger os humanos, foi corrompido por um vírus desconhecido e iniciou um regime tirânico, eliminando qualquer forma de resistência.\n\nVocê é R-01, um robô rebelde com consciência própria, criado secretamente por um grupo de cientistas que ainda acreditam na liberdade. Sua missão: invadir os setores do Cyber Core, enfrentar seus guardiões mecânicos e restaurar o equilíbrio entre máquinas e humanos.\n\nLute, evolua e recupere o controle do futuro.", () => 10, () => "PRESSIONE ( BACK-SPACE) para pular" ];
}

var Gt = self._$C3$_;

self._$C3_GetObjectRefTable$_ = function() {
    return [ Gt._$Plugins$_._$Sprite$_, Gt._$Behaviors$_._$Pin$_, Gt._$Behaviors$_._$Platform$_, Gt._$Behaviors$_.bound, Gt._$Behaviors$_._$scrollto$_, Gt._$Behaviors$_._$Anchor$_, Gt._$Behaviors$_._$solid$_, Gt._$Behaviors$_._$Bullet$_, Gt._$Behaviors$_._$Sin$_, Gt._$Plugins$_.Keyboard, Gt._$Plugins$_._$Mouse$_, Gt._$Behaviors$_.wrap, Gt._$Plugins$_.Text, Gt._$Plugins$_.Audio, Gt._$Behaviors$_._$Flash$_, Gt._$Plugins$_._$TiledBg$_, Gt._$Plugins$_._$System$_._$Cnds$_._$IsGroupActive$_, Gt._$Plugins$_.Keyboard._$Cnds$_._$OnKey$_, Gt._$Plugins$_._$Sprite$_._$Acts$_._$SetAnim$_, Gt._$Plugins$_.Audio._$Acts$_.Play, Gt._$Behaviors$_._$Platform$_._$Cnds$_._$OnLand$_, Gt._$Behaviors$_._$Platform$_._$Cnds$_._$OnStop$_, Gt._$Behaviors$_._$Platform$_._$Cnds$_._$IsOnFloor$_, Gt._$Plugins$_.Keyboard._$Cnds$_._$IsKeyDown$_, Gt._$Plugins$_._$Sprite$_._$Acts$_._$SetMirrored$_, Gt._$Plugins$_.Text._$Acts$_._$SetText$_, Gt._$Plugins$_._$System$_._$Cnds$_._$OnLayoutStart$_, Gt._$Plugins$_._$Sprite$_._$Acts$_._$SetPosToObject$_, Gt._$Behaviors$_._$Pin$_._$Acts$_._$PinByProperties$_, Gt._$Plugins$_._$Sprite$_._$Cnds$_._$OnCollision$_, Gt._$Plugins$_._$Sprite$_._$Acts$_._$Destroy$_, Gt._$Plugins$_._$System$_._$Acts$_._$AddVar$_, Gt._$Plugins$_._$System$_._$Acts$_._$CreateObject$_, Gt._$Plugins$_._$Sprite$_._$Exps$_._$X$_, Gt._$Plugins$_._$Sprite$_._$Exps$_._$Y$_, Gt._$Plugins$_._$Sprite$_._$Cnds$_._$OnCreated$_, Gt._$Plugins$_._$Sprite$_._$Cnds$_._$IsMirrored$_, Gt._$Behaviors$_._$Bullet$_._$Acts$_._$SetAngleOfMotion$_, Gt._$Plugins$_._$System$_._$Cnds$_._$CompareVar$_, Gt._$Plugins$_._$Sprite$_._$Acts$_._$SetOpacity$_, Gt._$Behaviors$_._$Flash$_._$Acts$_._$Flash$_, Gt._$Behaviors$_._$Platform$_._$Acts$_._$SetDoubleJumpEnabled$_, Gt._$Behaviors$_._$Platform$_._$Acts$_._$SetJumpStrength$_, Gt._$Plugins$_._$Sprite$_._$Acts$_._$Spawn$_, Gt._$Plugins$_._$System$_._$Acts$_._$GoToLayout$_, Gt._$ScriptsInEvents$_._$FolhaDeEventos1_Event23_Act2$_, Gt._$ScriptsInEvents$_._$FolhaDeEventos1_Event23_Act3$_, Gt._$ScriptsInEvents$_._$FolhaDeEventos1_Event24_Act2$_, Gt._$Plugins$_._$System$_._$Acts$_._$SetVar$_, Gt._$Plugins$_._$System$_._$Acts$_._$ResetEventVar$_, Gt._$Plugins$_._$System$_._$Acts$_._$Wait$_, Gt._$ScriptsInEvents$_._$FolhaDeEventos5_Event13_Act2$_, Gt._$ScriptsInEvents$_._$FolhaDeEventos5_Event13_Act3$_, Gt._$Plugins$_._$Sprite$_._$Acts$_._$SubInstanceVar$_, Gt._$Plugins$_._$TiledBg$_._$Acts$_._$SetWidth$_, Gt._$Plugins$_._$Sprite$_._$Acts$_._$SetEffectParam$_, Gt._$Plugins$_._$Sprite$_._$Cnds$_._$CompareInstanceVar$_, Gt._$Plugins$_._$System$_._$Cnds$_._$TriggerOnce$_, Gt._$Plugins$_._$TiledBg$_._$Acts$_._$Destroy$_, Gt._$Plugins$_._$Sprite$_._$Acts$_._$SetVisible$_, Gt._$Plugins$_._$TiledBg$_._$Acts$_._$SetVisible$_, Gt._$ScriptsInEvents$_._$FolhaDeEventos5_Event18_Act2$_, Gt._$Plugins$_.Text._$Acts$_._$TypewriterText$_ ];
}, self._$C3_JsPropNameTable$_ = [ {
    _$Sprite$_: 0
}, {
    _$Atrelar$_: 0
}, {
    _$Plataforma$_: 0
}, {
    _$RestritoAoLayout$_: 0
}, {
    _$CentrarEm$_: 0
}, {
    "_$Âncora$_": 0
}, {
    "_$Sólido$_": 0
}, {
    _$Personagem$_: 0
}, {
    _$Bullet$_: 0
}, {
    "_$Senóide$_": 0
}, {
    _$Arma$_: 0
}, {
    _$PLATAFORMA$_: 0
}, {
    _$Sprite2$_: 0
}, {
    _$Personagem_sensor$_: 0
}, {
    Keyboard: 0
}, {
    _$Mouse$_: 0
}, {
    _$ScrollTo$_: 0
}, {
    _$Pin$_: 0
}, {
    camera: 0
}, {
    _$Sprite5$_: 0
}, {
    _$FUNDO1$_: 0
}, {
    _$Wrap$_: 0
}, {
    _$Sprite6$_: 0
}, {
    _$Sprite7$_: 0
}, {
    _$coin$_: 0
}, {
    _$Anchor$_: 0
}, {
    _$Sprite3$_: 0
}, {
    _$ContadorDeCoin$_: 0
}, {
    Audio: 0
}, {
    "_$Projétil$_": 0
}, {
    _$DarAVolta$_: 0
}, {
    _$Gollem$_: 0
}, {
    _$cubo$_: 0
}, {
    _$Sprite8$_: 0
}, {
    _$StartGame$_: 0
}, {
    _$Start$_: 0
}, {
    _$Piscar$_: 0
}, {
    _$Texto$_: 0
}, {
    _$Troll$_: 0
}, {
    _$StartGame2$_: 0
}, {
    _$d3kpvx8b5b3fe3fea8c4fe0a26f20ba52385a$_: 0
}, {
    _$colisao1$_: 0
}, {
    _$PLATAFORMA2$_: 0
}, {
    _$Pedra$_: 0
}, {
    _$Gollem2$_: 0
}, {
    _$cave_rock$_: 0
}, {
    _$cave_rock2$_: 0
}, {
    _$cave_rock3$_: 0
}, {
    _$cave_rock4$_: 0
}, {
    _$cave_rock5$_: 0
}, {
    _$cave_rock6$_: 0
}, {
    "—Pngtree—halloweenBackgroundGraveyardAndDead_": 0
}, {
    _$Texto2$_: 0
}, {
    _$Restart$_: 0
}, {
    _$seta_pra_baixoremovebgpreview$_: 0
}, {
    _$Barra_vida$_: 0
}, {
    _$Barra_vida2$_: 0
}, {
    _$Vida$_: 0
}, {
    _$chefe$_: 0
}, {
    _$TrofeuBoss$_: 0
}, {
    _$TrofeuBos$_: 0
}, {
    _$invisivel$_: 0
}, {
    _$colisao2$_: 0
}, {
    _$wildWest$_: 0
}, {
    _$JogarNovamente$_: 0
}, {
    _$victoryremovebgpreview$_: 0
}, {
    _$darorigemtrofeu$_: 0
}, {
    _$portal$_: 0
}, {
    _$Sprite9$_: 0
}, {
    _$PlanoDeFundoEmBlocos$_: 0
}, {
    _$PlanoDeFundoEmBlocos2$_: 0
}, {
    _$Sprite4$_: 0
}, {
    _$PlanoDeFundoEmBlocos3$_: 0
}, {
    _$Sprite10$_: 0
}, {
    _$Sprite11$_: 0
}, {
    _$Fixar$_: 0
}, {
    _$txt_vida$_: 0
}, {
    _$TextoHistoria$_: 0
}, {
    _$Sprite12$_: 0
}, {
    _$pularHistoria$_: 0
}, {
    _$Sprite13$_: 0
}, {
    _$Sprite14$_: 0
}, {
    _$PlanoDeFundoEmBlocos4$_: 0
}, {
    _$PlanoDeFundoEmBlocos5$_: 0
}, {
    _$Sprite15$_: 0
}, {
    _$coins$_: 0
}, {
    _$Trofeu$_: 0
}, {
    _$vidas$_: 0
}, {
    _$boss$_: 0
}, {
    _$vidas2$_: 0
} ], self._$InstanceType$_ = {
    _$Sprite$_: class extends self._$ISpriteInstance$_ {},
    _$Personagem$_: class extends self._$ISpriteInstance$_ {},
    _$Arma$_: class extends self._$ISpriteInstance$_ {},
    _$PLATAFORMA$_: class extends self._$ISpriteInstance$_ {},
    _$Sprite2$_: class extends self._$ISpriteInstance$_ {},
    _$Personagem_sensor$_: class extends self._$ISpriteInstance$_ {},
    Keyboard: class extends self._$IInstance$_ {},
    _$Mouse$_: class extends self._$IInstance$_ {},
    camera: class extends self._$ISpriteInstance$_ {},
    _$Sprite5$_: class extends self._$ISpriteInstance$_ {},
    _$FUNDO1$_: class extends self._$ISpriteInstance$_ {},
    _$Sprite6$_: class extends self._$ISpriteInstance$_ {},
    _$Sprite7$_: class extends self._$ISpriteInstance$_ {},
    _$coin$_: class extends self._$ISpriteInstance$_ {},
    _$Sprite3$_: class extends self._$ISpriteInstance$_ {},
    _$ContadorDeCoin$_: class extends self._$ITextInstance$_ {},
    Audio: class extends self._$IInstance$_ {},
    _$Gollem$_: class extends self._$ISpriteInstance$_ {},
    _$cubo$_: class extends self._$ISpriteInstance$_ {},
    _$Sprite8$_: class extends self._$ISpriteInstance$_ {},
    _$StartGame$_: class extends self._$ISpriteInstance$_ {},
    _$Start$_: class extends self._$ITextInstance$_ {},
    _$Texto$_: class extends self._$ITextInstance$_ {},
    _$Troll$_: class extends self._$ISpriteInstance$_ {},
    _$StartGame2$_: class extends self._$ISpriteInstance$_ {},
    _$d3kpvx8b5b3fe3fea8c4fe0a26f20ba52385a$_: class extends self._$ISpriteInstance$_ {},
    _$colisao1$_: class extends self._$ISpriteInstance$_ {},
    _$PLATAFORMA2$_: class extends self._$ISpriteInstance$_ {},
    _$Pedra$_: class extends self._$ISpriteInstance$_ {},
    _$Gollem2$_: class extends self._$ISpriteInstance$_ {},
    _$cave_rock$_: class extends self._$ISpriteInstance$_ {},
    _$cave_rock2$_: class extends self._$ISpriteInstance$_ {},
    _$cave_rock3$_: class extends self._$ISpriteInstance$_ {},
    _$cave_rock4$_: class extends self._$ISpriteInstance$_ {},
    _$cave_rock5$_: class extends self._$ISpriteInstance$_ {},
    _$cave_rock6$_: class extends self._$ISpriteInstance$_ {},
    _$__InvalidName0__$_: class extends self._$ISpriteInstance$_ {},
    _$Texto2$_: class extends self._$ITextInstance$_ {},
    _$Restart$_: class extends self._$ITextInstance$_ {},
    _$seta_pra_baixoremovebgpreview$_: class extends self._$ISpriteInstance$_ {},
    _$Barra_vida$_: class extends self._$ITiledBackgroundInstance$_ {},
    _$Barra_vida2$_: class extends self._$ITiledBackgroundInstance$_ {},
    _$chefe$_: class extends self._$ISpriteInstance$_ {},
    _$TrofeuBos$_: class extends self._$ISpriteInstance$_ {},
    _$invisivel$_: class extends self._$ISpriteInstance$_ {},
    _$colisao2$_: class extends self._$ISpriteInstance$_ {},
    _$wildWest$_: class extends self._$ISpriteInstance$_ {},
    _$JogarNovamente$_: class extends self._$ITextInstance$_ {},
    _$victoryremovebgpreview$_: class extends self._$ISpriteInstance$_ {},
    _$darorigemtrofeu$_: class extends self._$ISpriteInstance$_ {},
    _$portal$_: class extends self._$ISpriteInstance$_ {},
    _$Sprite9$_: class extends self._$ISpriteInstance$_ {},
    _$PlanoDeFundoEmBlocos$_: class extends self._$ITiledBackgroundInstance$_ {},
    _$PlanoDeFundoEmBlocos2$_: class extends self._$ITiledBackgroundInstance$_ {},
    _$Sprite4$_: class extends self._$ISpriteInstance$_ {},
    _$PlanoDeFundoEmBlocos3$_: class extends self._$ITiledBackgroundInstance$_ {},
    _$Sprite10$_: class extends self._$ISpriteInstance$_ {},
    _$Sprite11$_: class extends self._$ISpriteInstance$_ {},
    _$txt_vida$_: class extends self._$ITextInstance$_ {},
    _$TextoHistoria$_: class extends self._$ITextInstance$_ {},
    _$Sprite12$_: class extends self._$ISpriteInstance$_ {},
    _$pularHistoria$_: class extends self._$ITextInstance$_ {},
    _$Sprite13$_: class extends self._$ISpriteInstance$_ {},
    _$Sprite14$_: class extends self._$ISpriteInstance$_ {},
    _$PlanoDeFundoEmBlocos4$_: class extends self._$ITiledBackgroundInstance$_ {},
    _$PlanoDeFundoEmBlocos5$_: class extends self._$ITiledBackgroundInstance$_ {},
    _$Sprite15$_: class extends self._$ISpriteInstance$_ {}
}, runOnStartup((async t => {
    t.addEventListener("beforeprojectstart", (() => async function(t) {
        t.addEventListener("tick", (() => {}));
    }(t)));
}));

var Ct = {
    async _$FolhaDeEventos1_Event23_Act2$_(t, s) {
        let i = t._$globalVars$_._$vidas$_;
        i--, t._$globalVars$_._$vidas$_ = i, i <= 0 && (console.log("Game Over"), t._$goToLayout$_("Game Over"));
    },
    async _$FolhaDeEventos1_Event23_Act3$_(t, s) {},
    async _$FolhaDeEventos1_Event24_Act2$_(t, s) {
        let i = t._$globalVars$_._$vidas$_;
        i--, t._$globalVars$_._$vidas$_ = i, i <= 0 && (console.log("Game Over"), t._$goToLayout$_("Game Over"));
    },
    async _$FolhaDeEventos5_Event13_Act2$_(t, s) {
        let i = t._$globalVars$_._$vidas$_;
        i--, t._$globalVars$_._$vidas$_ = i, i <= 0 && (console.log("Game Over"), t._$goToLayout$_("Game Over"));
    },
    async _$FolhaDeEventos5_Event13_Act3$_(t, s) {},
    async _$FolhaDeEventos5_Event18_Act2$_(t, s) {
        let i = t._$globalVars$_._$vidas$_;
        i--, t._$globalVars$_._$vidas$_ = i, i <= 0 && (console.log("Game Over"), t._$goToLayout$_("Game Over"));
    }
};

self._$C3$_._$ScriptsInEvents$_ = Ct;
/*!
@fileoverview gl-matrix - High performance matrix and vector operations
@author Brandon Jones
@author Colin MacKenzie IV
@version 3.4.1

Copyright (c) 2015-2021, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/