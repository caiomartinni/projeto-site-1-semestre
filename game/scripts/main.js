// Generated by Construct, the game and animation creation tool
// Visit: https://www.construct.net

"use strict";

window._$DOMHandler$_ = class {
    constructor(t, s) {
        this._$_iRuntime$_ = t, this._$_componentId$_ = s, this._$_hasTickCallback$_ = !1, 
        this._$_tickCallback$_ = () => this._$Tick$_();
    }
    _$Attach$_() {}
    _$PostToRuntime$_(t, s, i, e) {
        this._$_iRuntime$_._$PostToRuntimeComponent$_(this._$_componentId$_, t, s, i, e);
    }
    _$PostToRuntimeAsync$_(t, s, i, e) {
        return this._$_iRuntime$_._$PostToRuntimeComponentAsync$_(this._$_componentId$_, t, s, i, e);
    }
    _$_PostToRuntimeMaybeSync$_(t, s, i) {
        this._$_iRuntime$_._$UsesWorker$_() ? this._$PostToRuntime$_(t, s, i) : this._$_iRuntime$_._$_GetLocalRuntime$_()._OnMessageFromDOM({
            type: "event",
            component: this._$_componentId$_,
            handler: t,
            dispatchOpts: i || null,
            data: s,
            responseId: null
        });
    }
    _$AddRuntimeMessageHandler$_(t, s) {
        this._$_iRuntime$_._$AddRuntimeComponentMessageHandler$_(this._$_componentId$_, t, s);
    }
    _$AddRuntimeMessageHandlers$_(t) {
        for (const [s, i] of t) this._$AddRuntimeMessageHandler$_(s, i);
    }
    _$GetRuntimeInterface$_() {
        return this._$_iRuntime$_;
    }
    _$GetComponentID$_() {
        return this._$_componentId$_;
    }
    _$_StartTicking$_() {
        this._$_hasTickCallback$_ || (this._$_iRuntime$_._$_AddRAFCallback$_(this._$_tickCallback$_), 
        this._$_hasTickCallback$_ = !0);
    }
    _$_StopTicking$_() {
        this._$_hasTickCallback$_ && (this._$_iRuntime$_._$_RemoveRAFCallback$_(this._$_tickCallback$_), 
        this._$_hasTickCallback$_ = !1);
    }
    _$Tick$_() {}
}, window._$RateLimiter$_ = class {
    constructor(t, s) {
        this._$_callback$_ = t, this._$_interval$_ = s, this._$_timerId$_ = -1, this._$_lastCallTime$_ = -1 / 0, 
        this._$_timerCallFunc$_ = () => this._$_OnTimer$_(), this._$_ignoreReset$_ = !1, 
        this._$_canRunImmediate$_ = !1;
    }
    _$SetCanRunImmediate$_(t) {
        this._$_canRunImmediate$_ = !!t;
    }
    _$Call$_() {
        if (-1 !== this._$_timerId$_) return;
        const t = Date.now(), s = t - this._$_lastCallTime$_, i = this._$_interval$_;
        s >= i && this._$_canRunImmediate$_ ? (this._$_lastCallTime$_ = t, this._$_RunCallback$_()) : this._$_timerId$_ = self.setTimeout(this._$_timerCallFunc$_, Math.max(i - s, 4));
    }
    _$_RunCallback$_() {
        this._$_ignoreReset$_ = !0, this._$_callback$_(), this._$_ignoreReset$_ = !1;
    }
    _$Reset$_() {
        this._$_ignoreReset$_ || (this._$_CancelTimer$_(), this._$_lastCallTime$_ = Date.now());
    }
    _$_OnTimer$_() {
        this._$_timerId$_ = -1, this._$_lastCallTime$_ = Date.now(), this._$_RunCallback$_();
    }
    _$_CancelTimer$_() {
        -1 !== this._$_timerId$_ && (self.clearTimeout(this._$_timerId$_), this._$_timerId$_ = -1);
    }
    _$Release$_() {
        this._$_CancelTimer$_(), this._$_callback$_ = null, this._$_timerCallFunc$_ = null;
    }
};

{
    class t {
        constructor(t) {
            this._$_elem$_ = t, this._$_hadFirstUpdate$_ = !1, this._$_isVisibleFlag$_ = !0, 
            this._$_wantHtmlIndex$_ = -1, this._$_actualHtmlIndex$_ = -1, this._$_htmlZIndex$_ = -1;
        }
        _$SetVisibleFlag$_(t) {
            this._$_isVisibleFlag$_ = !!t;
        }
        _$GetVisibleFlag$_() {
            return this._$_isVisibleFlag$_;
        }
        _$HadFirstUpdate$_() {
            return this._$_hadFirstUpdate$_;
        }
        _$SetHadFirstUpdate$_() {
            this._$_hadFirstUpdate$_ = !0;
        }
        _$GetWantHTMLIndex$_() {
            return this._$_wantHtmlIndex$_;
        }
        _$SetWantHTMLIndex$_(t) {
            this._$_wantHtmlIndex$_ = t;
        }
        _$GetActualHTMLIndex$_() {
            return this._$_actualHtmlIndex$_;
        }
        _$SetActualHTMLIndex$_(t) {
            this._$_actualHtmlIndex$_ = t;
        }
        _$SetHTMLZIndex$_(t) {
            this._$_htmlZIndex$_ = t;
        }
        _$GetHTMLZIndex$_() {
            return this._$_htmlZIndex$_;
        }
        _$GetElement$_() {
            return this._$_elem$_;
        }
    }
    window._$DOMElementHandler$_ = class extends self._$DOMHandler$_ {
        constructor(t, s) {
            super(t, s), this._$_elementMap$_ = new Map, this._$_autoAttach$_ = !0, this._$AddRuntimeMessageHandlers$_([ [ "create", t => this._$_OnCreate$_(t) ], [ "destroy", t => this._$_OnDestroy$_(t) ], [ "set-visible", t => this._$_OnSetVisible$_(t) ], [ "update-position", t => this._$_OnUpdatePosition$_(t) ], [ "update-state", t => this._$_OnUpdateState$_(t) ], [ "focus", t => this._$_OnSetFocus$_(t) ], [ "set-css-style", t => this._$_OnSetCssStyle$_(t) ], [ "set-attribute", t => this._$_OnSetAttribute$_(t) ], [ "remove-attribute", t => this._$_OnRemoveAttribute$_(t) ] ]), 
            this._$AddDOMElementMessageHandler$_("get-element", (t => t));
        }
        _$SetAutoAttach$_(t) {
            this._$_autoAttach$_ = !!t;
        }
        _$AddDOMElementMessageHandler$_(t, s) {
            this._$AddRuntimeMessageHandler$_(t, (t => {
                const i = t.elementId, e = this._$GetElementById$_(i);
                return s(e, t);
            }));
        }
        _$AddDOMElementMessageHandlers$_(t) {
            for (const [s, i] of t) this._$AddDOMElementMessageHandler$_(s, i);
        }
        _$_OnCreate$_(s) {
            const i = s.elementId, e = this._$CreateElement$_(i, s), h = new t(e);
            this._$_elementMap$_.set(i, h), e.style.boxSizing = "border-box", e.style.display = "none", 
            h._$SetVisibleFlag$_(s.isVisible);
            const n = this._$_GetFocusElement$_(e);
            n.addEventListener("focus", (t => this._$_OnFocus$_(i))), n.addEventListener("blur", (t => this._$_OnBlur$_(i)));
            const o = s.htmlIndex;
            if (h._$SetWantHTMLIndex$_(o), h._$SetHTMLZIndex$_(s.htmlZIndex), this._$_autoAttach$_) {
                const t = this._$GetRuntimeInterface$_()._$GetAvailableHTMLIndex$_(o);
                h._$SetActualHTMLIndex$_(t), this._$GetRuntimeInterface$_()._$GetHTMLWrapElement$_(t).appendChild(e);
            }
        }
        _$CreateElement$_(t, s) {
            throw new Error("required override");
        }
        _$DestroyElement$_(t) {}
        _$_OnDestroy$_(t) {
            const s = t.elementId, i = this._$GetElementById$_(s);
            this._$DestroyElement$_(i), this._$_autoAttach$_ && i.parentElement.removeChild(i), 
            this._$_elementMap$_.delete(s);
        }
        _$PostToRuntimeElement$_(t, s, i) {
            i || (i = {}), i.elementId = s, this._$PostToRuntime$_(t, i);
        }
        _$_PostToRuntimeElementMaybeSync$_(t, s, i) {
            i || (i = {}), i.elementId = s, this._$_PostToRuntimeMaybeSync$_(t, i);
        }
        _$_OnSetVisible$_(t) {
            if (!this._$_autoAttach$_) return;
            const s = this._$_elementMap$_.get(t.elementId), i = s._$GetElement$_();
            s._$HadFirstUpdate$_() ? i.style.display = t.isVisible ? "" : "none" : s._$SetVisibleFlag$_(t.isVisible);
        }
        _$_OnUpdatePosition$_(t) {
            if (!this._$_autoAttach$_) return;
            const s = this._$_elementMap$_.get(t.elementId), i = s._$GetElement$_(), e = this._$GetRuntimeInterface$_();
            i.style.left = t.left + "px", i.style.top = t.top + "px", i.style.width = t.width + "px", 
            i.style.height = t.height + "px";
            const h = t.fontSize;
            null !== h && (i.style.fontSize = h + "em");
            const n = t.htmlIndex;
            s._$SetWantHTMLIndex$_(n);
            const o = e._$GetAvailableHTMLIndex$_(n);
            o !== s._$GetActualHTMLIndex$_() && (i.remove(), e._$GetHTMLWrapElement$_(o).appendChild(i), 
            s._$SetActualHTMLIndex$_(o), e._$_UpdateHTMLElementsZOrder$_());
            const r = t.htmlZIndex;
            r !== s._$GetHTMLZIndex$_() && (s._$SetHTMLZIndex$_(r), e._$_UpdateHTMLElementsZOrder$_()), 
            s._$HadFirstUpdate$_() || (s._$SetHadFirstUpdate$_(), s._$GetVisibleFlag$_() && (i.style.display = ""));
        }
        _$_OnHTMLLayersChanged$_() {
            if (this._$_autoAttach$_) for (const t of this._$_elementMap$_.values()) {
                const s = this._$GetRuntimeInterface$_()._$GetAvailableHTMLIndex$_(t._$GetWantHTMLIndex$_()), i = t._$GetActualHTMLIndex$_();
                if (-1 !== s && -1 !== i && s !== i) {
                    const i = t._$GetElement$_();
                    i.remove(), this._$GetRuntimeInterface$_()._$GetHTMLWrapElement$_(s).appendChild(i), 
                    t._$SetActualHTMLIndex$_(s);
                }
            }
        }
        _$_GetAllElementStatesForZOrderUpdate$_() {
            return this._$_autoAttach$_ ? [ ...this._$_elementMap$_.values() ] : null;
        }
        _$_OnUpdateState$_(t) {
            const s = this._$GetElementById$_(t.elementId);
            this._$UpdateState$_(s, t);
        }
        _$UpdateState$_(t, s) {
            throw new Error("required override");
        }
        _$_GetFocusElement$_(t) {
            return t;
        }
        _$_OnFocus$_(t) {
            this._$PostToRuntimeElement$_("elem-focused", t);
        }
        _$_OnBlur$_(t) {
            this._$PostToRuntimeElement$_("elem-blurred", t);
        }
        _$_OnSetFocus$_(t) {
            const s = this._$_GetFocusElement$_(this._$GetElementById$_(t.elementId));
            t.focus ? s.focus() : s.blur();
        }
        _$_OnSetCssStyle$_(t) {
            const s = this._$GetElementById$_(t.elementId), i = t.prop, e = t.val;
            i.startsWith("--") ? s.style.setProperty(i, e) : s.style[i] = e;
        }
        _$_OnSetAttribute$_(t) {
            this._$GetElementById$_(t.elementId).setAttribute(t.name, t.val);
        }
        _$_OnRemoveAttribute$_(t) {
            this._$GetElementById$_(t.elementId).removeAttribute(t.name);
        }
        _$GetElementById$_(t) {
            const s = this._$_elementMap$_.get(t);
            if (!s) throw new Error(`no element with id ${t}`);
            return s._$GetElement$_();
        }
    };
}

{
    const s = /(iphone|ipod|ipad|macos|macintosh|mac os x)/i.test(navigator.userAgent), i = /android/i.test(navigator.userAgent), e = /safari/i.test(navigator.userAgent) && !/(chrome|chromium|edg\/|OPR\/|nwjs)/i.test(navigator.userAgent);
    let h = 0;
    function n(t) {
        const s = document.createElement("script");
        return s.async = !1, s.type = "module", t._$isStringSrc$_ ? new Promise((i => {
            const e = "c3_resolve_" + h;
            ++h, self[e] = i, s.textContent = t._$str$_ + `\n\nself["${e}"]();`, document.head.appendChild(s);
        })) : new Promise(((i, e) => {
            s.onload = i, s.onerror = e, s.src = t, document.head.appendChild(s);
        }));
    }
    async function o() {
        if (!navigator.userActivation || "undefined" == typeof OffscreenCanvas) return !1;
        try {
            let t = !1;
            const s = new Blob([ '\n\tself.addEventListener("message", () =>\n\t{\n\t\ttry {\n\t\t\tconst offscreenCanvas = new OffscreenCanvas(32, 32);\n\t\t\tconst gl = offscreenCanvas.getContext("webgl");\n\t\t\tself.postMessage(!!gl);\n\t\t}\n\t\tcatch (err)\n\t\t{\n\t\t\tconsole.warn("Feature detection worker error:", err);\n\t\t\tself.postMessage(false);\n\t\t}\n\t});' ], {
                type: "text/javascript"
            }), i = new Worker(URL.createObjectURL(s), {
                get type() {
                    t = !0;
                }
            }), e = await new Promise((t => {
                i.addEventListener("message", (s => {
                    i.terminate(), t(s.data);
                })), i.postMessage("");
            }));
            return t && e;
        } catch (t) {
            return console.warn("Error feature detecting worker mode: ", t), !1;
        }
    }
    let r = new Audio;
    const a = {
        "audio/webm; codecs=opus": !!r.canPlayType("audio/webm; codecs=opus"),
        "audio/ogg; codecs=opus": !!r.canPlayType("audio/ogg; codecs=opus"),
        "audio/webm; codecs=vorbis": !!r.canPlayType("audio/webm; codecs=vorbis"),
        "audio/ogg; codecs=vorbis": !!r.canPlayType("audio/ogg; codecs=vorbis"),
        "audio/mp4": !!r.canPlayType("audio/mp4"),
        "audio/mpeg": !!r.canPlayType("audio/mpeg")
    };
    async function c(t) {
        const s = await l(t);
        return new TextDecoder("utf-8").decode(s);
    }
    function l(t) {
        return new Promise(((s, i) => {
            const e = new FileReader;
            e.onload = t => s(t.target.result), e.onerror = t => i(t), e.readAsArrayBuffer(t);
        }));
    }
    r = null;
    const u = [];
    let d = 0;
    const w = 8;
    window.RealFile = window.File;
    const f = [], p = new Map, m = new Map;
    let y = 0;
    const g = [];
    self.runOnStartup = function(t) {
        if ("function" != typeof t) throw new Error("runOnStartup called without a function");
        g.push(t);
    };
    const v = new Set([ "cordova", "playable-ad-single-file", "playable-ad-zip", "instant-games" ]);
    function b(t) {
        return v.has(t);
    }
    let _ = !1;
    window._$RuntimeInterface$_ = class t {
        constructor(t) {
            if (this._$_useWorker$_ = t._$useWorker$_, this._$_messageChannelPort$_ = null, 
            this._$_runtimeBaseUrl$_ = "", this._$_scriptFolder$_ = t._$scriptFolder$_, this._$_worker$_ = null, 
            this._$_localRuntime$_ = null, this._$_domHandlers$_ = [], this._$_runtimeDomHandler$_ = null, 
            this._$_isFirstSizeUpdate$_ = !0, this._$_canvasLayers$_ = [], this._$_pendingRemoveElements$_ = [], 
            this._$_pendingUpdateHTMLZOrder$_ = !1, this._$_updateHTMLZOrderRAFCallback$_ = () => this._$_DoUpdateHTMLElementsZOrder$_(), 
            this._$_isExportingToVideo$_ = !1, this._$_exportToVideoDuration$_ = 0, this._$_jobScheduler$_ = null, 
            this._$_rafId$_ = -1, this._$_rafFunc$_ = () => this._$_OnRAFCallback$_(), this._$_rafCallbacks$_ = new Set, 
            this._$_wrapperInitResolve$_ = null, this._$_wrapperComponentIds$_ = [], this._$_exportType$_ = t._$exportType$_, 
            this._$_isFileProtocol$_ = "file" === location.protocol.substr(0, 4), this._$_directoryHandles$_ = [], 
            "playable-ad-single-file" !== this._$_exportType$_ && "playable-ad-zip" !== this._$_exportType$_ && "instant-games" !== this._$_exportType$_ || (this._$_useWorker$_ = !1), 
            e && (this._$_useWorker$_ = !1), "cordova" === this._$_exportType$_ && this._$_useWorker$_ && i) {
                const t = /Chrome\/(\d+)/i.exec(navigator.userAgent);
                t && parseInt(t[1], 10) >= 90 || (this._$_useWorker$_ = !1);
            }
            this._$IsAnyWebView2Wrapper$_() ? self.chrome.webview.addEventListener("message", (t => this._$_OnWrapperMessage$_(t.data, t.additionalObjects))) : "macos-wkwebview" === this._$_exportType$_ ? self.C3WrapperOnMessage = t => this._$_OnWrapperMessage$_(JSON.parse(t)) : "linux-cef" === this._$_exportType$_ && self.c3_linux_cef_set_message_callback((t => this._$_OnWrapperMessage$_(JSON.parse(t)))), 
            this._$_localFileBlobs$_ = null, this._$_localFileStrings$_ = null, "html5" !== this._$_exportType$_ || window.isSecureContext || console.warn("[Construct] Warning: the browser indicates this is not a secure context. Some features may be unavailable. Use secure (HTTPS) hosting to ensure all features are available."), 
            this._$AddRuntimeComponentMessageHandler$_("canvas", "update-size", (t => this._$_OnUpdateCanvasSize$_(t))), 
            this._$AddRuntimeComponentMessageHandler$_("canvas", "set-html-layer-count", (t => this._OnSetHTMLLayerCount(t))), 
            this._$AddRuntimeComponentMessageHandler$_("canvas", "cleanup-html-layers", (() => this._$_OnCleanUpHTMLLayers$_())), 
            this._$AddRuntimeComponentMessageHandler$_("canvas", "update-html-layer-dom-state", (t => this._$_UpdateHTMLLayerDOMProperties$_(t.layersDomState))), 
            this._$AddRuntimeComponentMessageHandler$_("runtime", "cordova-fetch-local-file", (t => this._$_OnCordovaFetchLocalFile$_(t))), 
            this._$AddRuntimeComponentMessageHandler$_("runtime", "create-job-worker", (t => this._$_OnCreateJobWorker$_(t))), 
            this._$AddRuntimeComponentMessageHandler$_("runtime", "send-wrapper-extension-message", (t => this._$_OnSendWrapperExtensionMessage$_(t))), 
            "cordova" === this._$_exportType$_ ? document.addEventListener("deviceready", (() => this._$_Init$_(t))) : this._$_Init$_(t), 
            this._$_skipAndroidVirtualKeyboardDetection$_ = 0;
        }
        _$Release$_() {
            this._$_CancelAnimationFrame$_(), this._$_messageChannelPort$_ && (this._$_messageChannelPort$_.onmessage = null, 
            this._$_messageChannelPort$_ = null), this._$_worker$_ && (this._$_worker$_.terminate(), 
            this._$_worker$_ = null), this._$_localRuntime$_ && (this._$_localRuntime$_._$Release$_(), 
            this._$_localRuntime$_ = null);
            for (const {canvas: t, _$htmlWrap$_: s} of this._$_canvasLayers$_) t.remove(), s.remove();
            this._$_canvasLayers$_.length = 0;
        }
        _$GetMainCanvas$_() {
            return this._$_canvasLayers$_[0].canvas;
        }
        _$GetAvailableHTMLIndex$_(t) {
            return Math.min(t, this._$_canvasLayers$_.length - 1);
        }
        _$GetHTMLWrapElement$_(t) {
            if (t < 0 || t >= this._$_canvasLayers$_.length) throw new RangeError("invalid canvas layer");
            return this._$_canvasLayers$_[t]._$htmlWrap$_;
        }
        _GetHTMLWrapElement(t) {
            return this._$GetHTMLWrapElement$_(t);
        }
        _$GetRuntimeBaseURL$_() {
            return this._$_runtimeBaseUrl$_;
        }
        _$UsesWorker$_() {
            return this._$_useWorker$_;
        }
        _$GetExportType$_() {
            return this._$_exportType$_;
        }
        _$IsFileProtocol$_() {
            return this._$_isFileProtocol$_;
        }
        _$GetScriptFolder$_() {
            return this._$_scriptFolder$_;
        }
        _$IsiOSCordova$_() {
            return s && "cordova" === this._$_exportType$_;
        }
        _$IsiOSWebView$_() {
            const t = navigator.userAgent;
            return s && b(this._$_exportType$_) || navigator.standalone || /crios\/|fxios\/|edgios\//i.test(t);
        }
        _$IsAndroid$_() {
            return i;
        }
        _$IsAndroidWebView$_() {
            return i && b(this._$_exportType$_);
        }
        _$IsWindowsWebView2$_() {
            return "windows-webview2" === this._$_exportType$_ || !!("preview" === this._$_exportType$_ && window.chrome && window.chrome.webview && window.chrome.webview.postMessage);
        }
        _$IsAnyWebView2Wrapper$_() {
            return this._$IsWindowsWebView2$_() || "xbox-uwp-webview2" === this._$_exportType$_;
        }
        _$SkipNextAndroidVirtualKeyboardDetection$_() {
            this._$IsAndroidWebView$_() && this._$_skipAndroidVirtualKeyboardDetection$_++;
        }
        _$CanDoAndroidVirtualKeyboardDetection$_() {
            return this._$_CanDoAndroidVirtualKeyboardDetection$_().next().value;
        }
        * _$_CanDoAndroidVirtualKeyboardDetection$_() {
            if (!this._$IsAndroidWebView$_()) return !0;
            yield 0 === this._$_skipAndroidVirtualKeyboardDetection$_, this._$_skipAndroidVirtualKeyboardDetection$_ > 0 && this._$_skipAndroidVirtualKeyboardDetection$_--;
        }
        async _$_Init$_(t) {
            if (this._$_useWorker$_ && (await o() || (this._$_useWorker$_ = !1)), "macos-wkwebview" === this._$_exportType$_ && this._$_SendWrapperMessage$_({
                type: "ready"
            }), this._$IsAnyWebView2Wrapper$_() || "macos-wkwebview" === this._$_exportType$_ || "linux-cef" === this._$_exportType$_) {
                this._$_SetupDesktopWrapperPolyfills$_();
                const t = await this._$_InitWrapper$_();
                this._$_wrapperComponentIds$_ = t.registeredComponentIds;
            }
            if ("playable-ad-single-file" === this._$_exportType$_ && (this._$_localFileBlobs$_ = self.c3_base64files, 
            this._$_localFileStrings$_ = {}, await this._$_ConvertDataUrisToBlobs$_()), "nwjs" === this._$_exportType$_ && self.nw && (self.nw.Window.get().on("close", (() => self.nw.App.quit())), 
            self.nw.App.manifest["c3-steam-mode"])) {
                let t = 0;
                this._$_AddRAFCallback$_((() => {
                    t++, document.documentElement.style.opacity = t % 2 == 0 ? "1" : "0.999";
                }));
            }
            if (t._$runtimeBaseUrl$_) this._$_runtimeBaseUrl$_ = t._$runtimeBaseUrl$_; else {
                const t = location.origin;
                this._$_runtimeBaseUrl$_ = ("null" === t ? "file:///" : t) + location.pathname;
                const s = this._$_runtimeBaseUrl$_.lastIndexOf("/");
                -1 !== s && (this._$_runtimeBaseUrl$_ = this._$_runtimeBaseUrl$_.substr(0, s + 1));
            }
            const s = new MessageChannel;
            if (this._$_messageChannelPort$_ = s.port1, this._$_messageChannelPort$_.onmessage = t => this._OnMessageFromRuntime(t.data), 
            window.c3_addPortMessageHandler && window.c3_addPortMessageHandler((t => this._$_OnMessageFromDebugger$_(t))), 
            this._$_jobScheduler$_ = new self._$JobSchedulerDOM$_(this), await this._$_jobScheduler$_._$Init$_(), 
            "object" == typeof window.StatusBar && window.StatusBar.hide(), "object" == typeof window.AndroidFullScreen) try {
                await new Promise(((t, s) => {
                    window.AndroidFullScreen.immersiveMode(t, s);
                }));
            } catch (t) {
                console.error("Failed to enter Android immersive mode: ", t);
            }
            this._$_useWorker$_ ? await this._$_InitWorker$_(t, s.port2) : await this._$_InitDOM$_(t, s.port2);
        }
        _$_GetCommonRuntimeOptions$_(s) {
            return {
                runtimeBaseUrl: this._$_runtimeBaseUrl$_,
                previewUrl: location.href,
                windowInnerWidth: this._$_GetWindowInnerWidth$_(),
                windowInnerHeight: this._$_GetWindowInnerHeight$_(),
                cssDisplayMode: this._$GetCssDisplayMode$_(),
                devicePixelRatio: window.devicePixelRatio,
                isFullscreen: t._$IsDocumentFullscreen$_(),
                swClientId: window.cr_swClientId || "",
                exportType: s._$exportType$_,
                isNWjs: "undefined" != typeof nw,
                fileMap: globalThis._$c3_swFileMap$_ ?? new Map(Object.entries(this._$_localFileBlobs$_ ?? {})),
                scriptFolder: this._$_scriptFolder$_,
                isDebug: new URLSearchParams(self.location.search).has("debug"),
                ife: !!self._$ife$_,
                jobScheduler: this._$_jobScheduler$_._$GetPortData$_(),
                supportedAudioFormats: a,
                isFileProtocol: this._$_isFileProtocol$_,
                isiOSCordova: this._$IsiOSCordova$_(),
                isiOSWebView: this._$IsiOSWebView$_(),
                isWindowsWebView2: this._$IsWindowsWebView2$_(),
                isAnyWebView2Wrapper: this._$IsAnyWebView2Wrapper$_(),
                wrapperComponentIds: this._$_wrapperComponentIds$_,
                isFBInstantAvailable: void 0 !== self.FBInstant
            };
        }
        async _$_InitWorker$_(t, s) {
            const i = t._$workerMainUrl$_;
            "preview" === this._$_exportType$_ ? (this._$_worker$_ = new Worker("previewworker.js", {
                type: "module",
                name: "Runtime"
            }), await new Promise(((t, s) => {
                const e = i => {
                    this._$_worker$_.removeEventListener("message", e), i.data && "ok" === i.data.type ? t() : s();
                };
                this._$_worker$_.addEventListener("message", e), this._$_worker$_.postMessage({
                    type: "construct-worker-init",
                    import: new URL(i, this._$_runtimeBaseUrl$_).toString()
                });
            }))) : this._$_worker$_ = await this._$CreateWorker$_(i, {
                type: "module",
                name: "Runtime"
            });
            const e = document.createElement("canvas");
            e.style.display = "none";
            const h = e.transferControlToOffscreen();
            document.body.appendChild(e);
            const n = document.createElement("div");
            n.className = "c3htmlwrap", n.setAttribute("interactive", ""), document.body.appendChild(n), 
            this._$_canvasLayers$_.push({
                canvas: e,
                _$htmlWrap$_: n,
                _$lastHtmlLayerDomState$_: {
                    isVisible: !0,
                    opacity: 1,
                    _$isInteractive$_: !0
                }
            }), window.c3canvas = e, self.C3_InsertHTMLPlaceholders && self.C3_InsertHTMLPlaceholders(), 
            this._$_worker$_.postMessage(Object.assign(this._$_GetCommonRuntimeOptions$_(t), {
                type: "init-runtime",
                isInWorker: !0,
                messagePort: s,
                canvas: h,
                runtimeScriptList: t._$runtimeScriptList$_,
                projectMainScriptPath: t._$projectMainScriptPath$_,
                scriptsInEventsPath: t._$scriptsInEventsPath$_
            }), [ s, h, ...this._$_jobScheduler$_._$GetPortTransferables$_() ]), this._$_domHandlers$_ = f.map((t => new t(this))), 
            this._$_FindRuntimeDOMHandler$_(), this._$_runtimeDomHandler$_._$_AddDefaultCanvasEventHandlers$_(e), 
            this._$_runtimeDomHandler$_._$_AddDefaultHTMLWrapEventHandlers$_(n), this._$_runtimeDomHandler$_._$_EnableWindowResizeEvent$_(), 
            self.c3_callFunction = (t, s) => this._$_runtimeDomHandler$_._$_InvokeFunctionFromJS$_(t, s), 
            "preview" === this._$_exportType$_ && (self.goToLastErrorScript = () => this._$PostToRuntimeComponent$_("runtime", "go-to-last-error-script"));
        }
        async _$_InitDOM$_(t, s) {
            const i = document.createElement("canvas");
            i.style.display = "none", document.body.appendChild(i);
            const e = document.createElement("div");
            e.className = "c3htmlwrap", e.setAttribute("interactive", ""), document.body.appendChild(e), 
            this._$_canvasLayers$_.push({
                canvas: i,
                _$htmlWrap$_: e,
                _$lastHtmlLayerDomState$_: {
                    isVisible: !0,
                    opacity: 1,
                    _$isInteractive$_: !0
                }
            }), window.c3canvas = i, self.C3_InsertHTMLPlaceholders && self.C3_InsertHTMLPlaceholders(), 
            this._$_domHandlers$_ = f.map((t => new t(this))), this._$_FindRuntimeDOMHandler$_(), 
            this._$_runtimeDomHandler$_._$_AddDefaultCanvasEventHandlers$_(i), this._$_runtimeDomHandler$_._$_AddDefaultHTMLWrapEventHandlers$_(e);
            const h = await Promise.all(t._$runtimeScriptList$_.map((t => this._$_MaybeGetPlatformSpecificScriptURL$_(t))));
            await Promise.all(h.map((t => n(t))));
            const o = t._$projectMainScriptPath$_, r = t._$scriptsInEventsPath$_;
            if (o) try {
                if (await n(o), "preview" === this._$_exportType$_ && !globalThis._$C3_ProjectMainScriptOK$_) throw new Error("main script did not run to completion");
            } catch (t) {
                this._$_RemoveLoadingMessage$_(), console.error("Error loading project main script: ", t), 
                alert(`Failed to load the project main script (${o}). Check all your JavaScript code has valid syntax, all imports are written correctly, and that an exception was not thrown running the script. Press F12 and check the console for error details.`);
            }
            if (r) try {
                if (await n(r), "preview" === this._$_exportType$_ && !globalThis._$C3$_._$ScriptsInEvents$_) throw new Error("scripts in events did not run to completion");
            } catch (t) {
                this._$_RemoveLoadingMessage$_(), console.error("Error loading scripts in events: ", t), 
                alert("Failed to load scripts in events. Check all your JavaScript code has valid syntax, all imports are written correctly, and that an exception was not thrown running the 'Imports for events' script. Press F12 and check the console for error details.");
            }
            const a = Object.assign(this._$_GetCommonRuntimeOptions$_(t), {
                isInWorker: !1,
                messagePort: s,
                canvas: i,
                runOnStartupFunctions: g
            });
            this._$_runtimeDomHandler$_._$_EnableWindowResizeEvent$_(), this._$_OnBeforeCreateRuntime$_(), 
            this._$_localRuntime$_ = self.C3_CreateRuntime(a), await self.C3_InitRuntime(this._$_localRuntime$_, a);
        }
        async _$CreateWorker$_(t, s) {
            if (t.startsWith("blob:")) return new Worker(t, s);
            if ("cordova" === this._$_exportType$_ && this._$_isFileProtocol$_) {
                const i = await this._$CordovaFetchLocalFileAsArrayBuffer$_(t), e = new Blob([ i ], {
                    type: "application/javascript"
                });
                return new Worker(URL.createObjectURL(e), s);
            }
            if ("playable-ad-single-file" === this._$_exportType$_) {
                const i = this._$_localFileBlobs$_[t];
                if (!i) throw new Error("missing script: " + t);
                return new Worker(URL.createObjectURL(i), s);
            }
            const i = new URL(t, location.href);
            if (location.origin !== i.origin) {
                const t = await fetch(i);
                if (!t.ok) throw new Error("failed to fetch worker script");
                const e = await t.blob();
                return new Worker(URL.createObjectURL(e), s);
            }
            return new Worker(i, s);
        }
        _$_GetWindowInnerWidth$_() {
            return Math.max(window.innerWidth, 1);
        }
        _$_GetWindowInnerHeight$_() {
            return Math.max(window.innerHeight, 1);
        }
        _$GetCssDisplayMode$_() {
            if (this._$IsAnyWebView2Wrapper$_()) return "standalone";
            const t = this._$GetExportType$_();
            return new Set([ "cordova", "nwjs", "macos-wkwebview", "linux-cef" ]).has(t) ? "standalone" : window.matchMedia("(display-mode: fullscreen)").matches ? "fullscreen" : window.matchMedia("(display-mode: standalone)").matches ? "standalone" : window.matchMedia("(display-mode: minimal-ui)").matches ? "minimal-ui" : navigator.standalone ? "standalone" : "browser";
        }
        _$_OnBeforeCreateRuntime$_() {
            this._$_RemoveLoadingMessage$_();
        }
        _$_RemoveLoadingMessage$_() {
            const t = window.cr_previewLoadingElem;
            t && (t.parentElement.removeChild(t), window.cr_previewLoadingElem = null);
        }
        async _$_OnCreateJobWorker$_(t) {
            const s = await this._$_jobScheduler$_._$_CreateJobWorker$_();
            return {
                outputPort: s,
                transferables: [ s ]
            };
        }
        _$_OnUpdateCanvasSize$_(t) {
            if (this._$IsExportingToVideo$_()) return;
            const s = t.styleWidth + "px", i = t.styleHeight + "px", e = t.marginLeft + "px", h = t.marginTop + "px";
            for (const {canvas: t, _$htmlWrap$_: n} of this._$_canvasLayers$_) t.style.width = s, 
            t.style.height = i, t.style.marginLeft = e, t.style.marginTop = h, n.style.width = s, 
            n.style.height = i, n.style.marginLeft = e, n.style.marginTop = h, this._$_isFirstSizeUpdate$_ && (t.style.display = "", 
            n.style.display = "");
            document.documentElement.style.setProperty("--construct-scale", t.displayScale), 
            this._$_isFirstSizeUpdate$_ = !1;
        }
        _OnSetHTMLLayerCount(t) {
            const s = t.count, i = t.layersDomState, e = t.immediate, h = t.styleWidth + "px", n = t.styleHeight + "px", o = t.marginLeft + "px", r = t.marginTop + "px", a = [], c = [];
            if (s < this._$_canvasLayers$_.length) for (;this._$_canvasLayers$_.length > s; ) {
                const {canvas: t, _$htmlWrap$_: s} = this._$_canvasLayers$_.pop();
                s.remove(), this._$_useWorker$_ && !e ? this._$_pendingRemoveElements$_.push(t) : t.remove();
            } else if (s > this._$_canvasLayers$_.length) for (let t = 0, i = s - this._$_canvasLayers$_.length; t < i; ++t) {
                const t = document.createElement("canvas");
                if (t.classList.add("c3overlay"), this._$_useWorker$_) {
                    const s = t.transferControlToOffscreen();
                    a.push(s), c.push(s);
                } else a.push(t);
                document.body.appendChild(t);
                const s = document.createElement("div");
                s.classList.add("c3htmlwrap", "c3overlay"), s.setAttribute("interactive", ""), document.body.appendChild(s), 
                t.style.width = h, t.style.height = n, t.style.marginLeft = o, t.style.marginTop = r, 
                s.style.width = h, s.style.height = n, s.style.marginLeft = o, s.style.marginTop = r, 
                this._$_runtimeDomHandler$_._$_AddDefaultCanvasEventHandlers$_(t), this._$_runtimeDomHandler$_._$_AddDefaultHTMLWrapEventHandlers$_(s), 
                this._$_canvasLayers$_.push({
                    canvas: t,
                    _$htmlWrap$_: s,
                    _$lastHtmlLayerDomState$_: {
                        isVisible: !0,
                        opacity: 1,
                        _$isInteractive$_: !0
                    }
                });
            }
            this._$_UpdateHTMLLayerDOMProperties$_(i);
            for (const t of this._$_domHandlers$_) t instanceof window._$DOMElementHandler$_ && t._$_OnHTMLLayersChanged$_();
            return this._$_UpdateHTMLElementsZOrder$_(), {
                addedCanvases: a,
                transferables: c
            };
        }
        _$_UpdateHTMLLayerDOMProperties$_(t) {
            for (let s = 0, i = Math.min(this._$_canvasLayers$_.length, t.length); s < i; ++s) {
                const {_$htmlWrap$_: i, _$lastHtmlLayerDomState$_: e} = this._$_canvasLayers$_[s], h = t[s], n = h.isVisible, o = h.opacity, r = h.isInteractive;
                n !== e.isVisible && (i.style.display = n ? "" : "none", e.isVisible = n), o !== e.opacity && (i.style.opacity = 1 === o ? "" : String(o), 
                e.opacity = o), r !== e._$isInteractive$_ && (i.style.pointerEvents = r ? "" : "none", 
                r ? i.setAttribute("interactive", "") : i.removeAttribute("interactive"), e._$isInteractive$_ = r);
            }
        }
        _$_OnCleanUpHTMLLayers$_() {
            for (const t of this._$_pendingRemoveElements$_) t.remove();
            this._$_pendingRemoveElements$_.length = 0;
        }
        _$_UpdateHTMLElementsZOrder$_() {
            this._$_pendingUpdateHTMLZOrder$_ || (this._$_pendingUpdateHTMLZOrder$_ = !0, this._$_AddRAFCallback$_(this._$_updateHTMLZOrderRAFCallback$_));
        }
        _$_DoUpdateHTMLElementsZOrder$_() {
            this._$_RemoveRAFCallback$_(this._$_updateHTMLZOrderRAFCallback$_), this._$_pendingUpdateHTMLZOrder$_ = !1;
            let t = [];
            for (const s of this._$_domHandlers$_) if (s instanceof window._$DOMElementHandler$_) {
                const i = s._$_GetAllElementStatesForZOrderUpdate$_();
                i && t.push(...i);
            }
            t.sort(((t, s) => {
                const i = t._$GetActualHTMLIndex$_(), e = s._$GetActualHTMLIndex$_();
                return i !== e ? i - e : t._$GetHTMLZIndex$_() - s._$GetHTMLZIndex$_();
            }));
            let s = 0, i = 0, e = 0, h = t.length;
            for (;e < h; ++e) {
                const h = t[e];
                h._$GetActualHTMLIndex$_() !== s && (this._$_DoUpdateHTMLElementsZOrderOnHTMLLayer$_(s, t.slice(i, e)), 
                s = h._$GetActualHTMLIndex$_(), i = e);
            }
            i < e && this._$_DoUpdateHTMLElementsZOrderOnHTMLLayer$_(s, t.slice(i, e));
        }
        _$_DoUpdateHTMLElementsZOrderOnHTMLLayer$_(t, s) {
            if (s.length <= 1) return;
            if (t >= this._$_canvasLayers$_.length) return;
            const i = s.map((t => t._$GetElement$_())), e = new Set(i), h = this._$GetHTMLWrapElement$_(t), n = Array.from(h.children).filter((t => e.has(t)));
            for (let t = 0, s = 0, e = i.length; t < e; ++t) {
                const e = i[t], o = n[s];
                e === o ? ++s : h.moveBefore ? h.moveBefore(e, o) : h.insertBefore(e, o);
            }
        }
        _$_GetLocalRuntime$_() {
            if (this._$_useWorker$_) throw new Error("not available in worker mode");
            return this._$_localRuntime$_;
        }
        _$PostToRuntimeComponent$_(t, s, i, e, h) {
            this._$_messageChannelPort$_.postMessage({
                type: "event",
                component: t,
                handler: s,
                dispatchOpts: e || null,
                data: i,
                responseId: null
            }, h);
        }
        _$PostToRuntimeComponentAsync$_(t, s, i, e, h) {
            const n = y++, o = new Promise(((t, s) => {
                m.set(n, {
                    resolve: t,
                    reject: s
                });
            }));
            return this._$_messageChannelPort$_.postMessage({
                type: "event",
                component: t,
                handler: s,
                dispatchOpts: e || null,
                data: i,
                responseId: n
            }, h), o;
        }
        _OnMessageFromRuntime(t) {
            const s = t.type;
            if ("event" === s) return this._$_OnEventFromRuntime$_(t);
            if ("result" === s) this._$_OnResultFromRuntime$_(t); else if ("runtime-ready" === s) this._$_OnRuntimeReady$_(); else if ("alert-error" === s) this._$_RemoveLoadingMessage$_(), 
            alert(t.message); else {
                if ("creating-runtime" !== s) throw new Error(`unknown message '${s}'`);
                this._$_OnBeforeCreateRuntime$_();
            }
        }
        _$_OnEventFromRuntime$_(t) {
            const s = t.component, i = t.handler, e = t.data, h = t.responseId, n = p.get(s);
            if (!n) return void console.warn(`[DOM] No event handlers for component '${s}'`);
            const o = n.get(i);
            if (!o) return void console.warn(`[DOM] No handler '${i}' for component '${s}'`);
            let r = null;
            try {
                r = o(e);
            } catch (t) {
                return console.error(`Exception in '${s}' handler '${i}':`, t), void (null !== h && this._$_PostResultToRuntime$_(h, !1, "" + t));
            }
            if (null === h) return r;
            r && r.then ? r.then((t => this._$_PostResultToRuntime$_(h, !0, t))).catch((t => {
                console.error(`Rejection from '${s}' handler '${i}':`, t), this._$_PostResultToRuntime$_(h, !1, "" + t);
            })) : this._$_PostResultToRuntime$_(h, !0, r);
        }
        _$_PostResultToRuntime$_(t, s, i) {
            let e;
            i && i.transferables && (e = i.transferables), this._$_messageChannelPort$_.postMessage({
                type: "result",
                responseId: t,
                isOk: s,
                result: i
            }, e);
        }
        _$_OnResultFromRuntime$_(t) {
            const s = t.responseId, i = t.isOk, e = t.result, h = m.get(s);
            i ? h.resolve(e) : h.reject(e), m.delete(s);
        }
        _$AddRuntimeComponentMessageHandler$_(t, s, i) {
            let e = p.get(t);
            if (e || (e = new Map, p.set(t, e)), e.has(s)) throw new Error(`[DOM] Component '${t}' already has handler '${s}'`);
            e.set(s, i);
        }
        static _$AddDOMHandlerClass$_(t) {
            if (f.includes(t)) throw new Error("DOM handler already added");
            f.push(t);
        }
        _$_FindRuntimeDOMHandler$_() {
            for (const t of this._$_domHandlers$_) if ("runtime" === t._$GetComponentID$_()) return void (this._$_runtimeDomHandler$_ = t);
            throw new Error("cannot find runtime DOM handler");
        }
        _$_OnMessageFromDebugger$_(t) {
            this._$PostToRuntimeComponent$_("debugger", "message", t);
        }
        _$_OnRuntimeReady$_() {
            for (const t of this._$_domHandlers$_) t._$Attach$_();
        }
        static _$IsDocumentFullscreen$_() {
            return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || _);
        }
        static _$_SetWrapperIsFullscreenFlag$_(t) {
            _ = !!t;
        }
        async _$GetRemotePreviewStatusInfo$_() {
            return await this._$PostToRuntimeComponentAsync$_("runtime", "get-remote-preview-status-info");
        }
        _$_AddRAFCallback$_(t) {
            this._$_rafCallbacks$_.add(t), this._$_RequestAnimationFrame$_();
        }
        _$_RemoveRAFCallback$_(t) {
            this._$_rafCallbacks$_.delete(t), 0 === this._$_rafCallbacks$_.size && this._$_CancelAnimationFrame$_();
        }
        _$_RequestAnimationFrame$_() {
            -1 === this._$_rafId$_ && this._$_rafCallbacks$_.size > 0 && (this._$_rafId$_ = requestAnimationFrame(this._$_rafFunc$_));
        }
        _$_CancelAnimationFrame$_() {
            -1 !== this._$_rafId$_ && (cancelAnimationFrame(this._$_rafId$_), this._$_rafId$_ = -1);
        }
        _$_OnRAFCallback$_() {
            this._$_rafId$_ = -1;
            for (const t of this._$_rafCallbacks$_) t();
            this._$_RequestAnimationFrame$_();
        }
        _$TryPlayMedia$_(t) {
            this._$_runtimeDomHandler$_._$TryPlayMedia$_(t);
        }
        _$RemovePendingPlay$_(t) {
            this._$_runtimeDomHandler$_._$RemovePendingPlay$_(t);
        }
        _$_PlayPendingMedia$_() {
            this._$_runtimeDomHandler$_._$_PlayPendingMedia$_();
        }
        _$SetSilent$_(t) {
            this._$_runtimeDomHandler$_._$SetSilent$_(t);
        }
        _$IsAudioFormatSupported$_(t) {
            return !!a[t];
        }
        _$SetIsExportingToVideo$_(t) {
            this._$_isExportingToVideo$_ = !0, this._$_exportToVideoDuration$_ = t;
        }
        _$IsExportingToVideo$_() {
            return this._$_isExportingToVideo$_;
        }
        _$GetExportToVideoDuration$_() {
            return this._$_exportToVideoDuration$_;
        }
        _$IsAbsoluteURL$_(t) {
            return /^(?:[a-z\-]+:)?\/\//.test(t) || "data:" === t.substr(0, 5) || "blob:" === t.substr(0, 5);
        }
        _$IsRelativeURL$_(t) {
            return !this._$IsAbsoluteURL$_(t);
        }
        async _$_MaybeGetPlatformSpecificScriptURL$_(t) {
            if ("cordova" === this._$_exportType$_ && (t.startsWith("file:") || this._$_isFileProtocol$_ && this._$IsRelativeURL$_(t))) {
                let s = t;
                s.startsWith(this._$_runtimeBaseUrl$_) && (s = s.substr(this._$_runtimeBaseUrl$_.length));
                const i = await this._$CordovaFetchLocalFileAsArrayBuffer$_(s), e = new Blob([ i ], {
                    type: "application/javascript"
                });
                return URL.createObjectURL(e);
            }
            if ("playable-ad-single-file" === this._$_exportType$_) {
                if (this._$_localFileStrings$_.hasOwnProperty(t)) return {
                    _$isStringSrc$_: !0,
                    _$str$_: this._$_localFileStrings$_[t]
                };
                if (this._$_localFileBlobs$_.hasOwnProperty(t)) return URL.createObjectURL(this._$_localFileBlobs$_[t]);
                throw new Error("missing script: " + t);
            }
            return t;
        }
        async _$_OnCordovaFetchLocalFile$_(t) {
            const s = t.filename;
            switch (t.as) {
              case "text":
                return await this._$CordovaFetchLocalFileAsText$_(s);

              case "buffer":
                return await this._$CordovaFetchLocalFileAsArrayBuffer$_(s);

              default:
                throw new Error("unsupported type");
            }
        }
        _$CordovaFetchLocalFile$_(t) {
            const s = window.cordova.file.applicationDirectory + "www/" + t;
            return new Promise(((t, i) => {
                window.resolveLocalFileSystemURL(s, (s => {
                    s.file(t, i);
                }), i);
            }));
        }
        async _$CordovaFetchLocalFileAsText$_(t) {
            const s = await this._$CordovaFetchLocalFile$_(t);
            return await c(s);
        }
        _$_CordovaMaybeStartNextArrayBufferRead$_() {
            if (!u.length) return;
            if (d >= w) return;
            d++;
            const t = u.shift();
            this._$_CordovaDoFetchLocalFileAsAsArrayBuffer$_(t.filename, t._$successCallback$_, t._$errorCallback$_);
        }
        _$CordovaFetchLocalFileAsArrayBuffer$_(t) {
            return new Promise(((s, i) => {
                u.push({
                    filename: t,
                    _$successCallback$_: t => {
                        d--, this._$_CordovaMaybeStartNextArrayBufferRead$_(), s(t);
                    },
                    _$errorCallback$_: t => {
                        d--, this._$_CordovaMaybeStartNextArrayBufferRead$_(), i(t);
                    }
                }), this._$_CordovaMaybeStartNextArrayBufferRead$_();
            }));
        }
        async _$_CordovaDoFetchLocalFileAsAsArrayBuffer$_(t, s, i) {
            try {
                const i = await this._$CordovaFetchLocalFile$_(t);
                s(await l(i));
            } catch (t) {
                i(t);
            }
        }
        _PlayableAdFetchBlob(t) {
            if (this._$_localFileBlobs$_.hasOwnProperty(t)) return this._$_localFileBlobs$_[t];
            throw new Error("missing file: " + t);
        }
        _$_GetPermissionAPI$_() {
            const t = window.cordova && window.cordova.plugins && window.cordova.plugins.permissions;
            if ("object" != typeof t) throw new Error("Permission API is not loaded");
            return t;
        }
        _$_MapPermissionID$_(t, s) {
            const i = t[s];
            if ("string" != typeof i) throw new Error("Invalid permission name");
            return i;
        }
        _$_HasPermission$_(t) {
            const s = this._$_GetPermissionAPI$_();
            return new Promise(((i, e) => s.checkPermission(this._$_MapPermissionID$_(s, t), (t => i(!!t.hasPermission)), e)));
        }
        _$_RequestPermission$_(t) {
            const s = this._$_GetPermissionAPI$_();
            return new Promise(((i, e) => s.requestPermission(this._$_MapPermissionID$_(s, t), (t => i(!!t.hasPermission)), e)));
        }
        async _$RequestPermissions$_(t) {
            if ("cordova" !== this._$GetExportType$_()) return !0;
            if (this._$IsiOSCordova$_()) return !0;
            for (const s of t) if (!await this._$_HasPermission$_(s) && !1 === await this._$_RequestPermission$_(s)) return !1;
            return !0;
        }
        async _$RequirePermissions$_(...t) {
            if (!1 === await this._$RequestPermissions$_(t)) throw new Error("Permission not granted");
        }
        _$_OnWrapperMessage$_(s, i) {
            if ("object" != typeof s || !s) return void console.warn("Unknown wrapper message: ", s);
            const e = s.type;
            if ("directory-handles" === e) this._$_directoryHandles$_ = i; else if ("wrapper-init-response" === e) this._$_wrapperInitResolve$_(s), 
            this._$_wrapperInitResolve$_ = null; else if ("fullscreen-change" === e) t._$_SetWrapperIsFullscreenFlag$_(s.isFullscreen), 
            this._$_runtimeDomHandler$_._$_OnFullscreenChange$_(); else if ("log-to-console" === e) switch (s.logType) {
              case "error":
                console.error(s.message);
                break;

              case "warning":
                console.warn(s.message);
                break;

              default:
                console.log(s.message);
            } else "extension-message" === e ? this._$PostToRuntimeComponent$_("runtime", "wrapper-extension-message", s) : console.warn("Unknown wrapper message: ", s);
        }
        _$_OnSendWrapperExtensionMessage$_(t) {
            this._$_SendWrapperMessage$_({
                type: "extension-message",
                componentId: t.componentId,
                messageId: t.messageId,
                params: t.params || [],
                asyncId: t.asyncId
            });
        }
        _$_SendWrapperMessage$_(t) {
            this._$IsAnyWebView2Wrapper$_() ? window.chrome.webview.postMessage(JSON.stringify(t)) : "macos-wkwebview" === this._$_exportType$_ ? window.webkit.messageHandlers.C3Wrapper.postMessage(JSON.stringify(t)) : "linux-cef" === this._$_exportType$_ && window.c3_linux_cef_sendmessage(JSON.stringify(t));
        }
        _$_SetupDesktopWrapperPolyfills$_() {
            window.moveTo = (t, s) => {
                this._$_SendWrapperMessage$_({
                    type: "set-window-position",
                    windowX: Math.ceil(t),
                    windowY: Math.ceil(s)
                });
            }, window.resizeTo = (t, s) => {
                this._$_SendWrapperMessage$_({
                    type: "set-window-size",
                    windowWidth: Math.ceil(t),
                    windowHeight: Math.ceil(s)
                });
            };
        }
        _$_InitWrapper$_() {
            return new Promise((t => {
                this._$_wrapperInitResolve$_ = t, this._$_SendWrapperMessage$_({
                    type: "wrapper-init"
                });
            }));
        }
        _$_GetDirectoryHandles$_() {
            return this._$_directoryHandles$_;
        }
        async _$_ConvertDataUrisToBlobs$_() {
            const t = [];
            for (const [s, i] of Object.entries(this._$_localFileBlobs$_)) t.push(this._$_ConvertDataUriToBlobs$_(s, i));
            await Promise.all(t);
        }
        async _$_ConvertDataUriToBlobs$_(t, s) {
            if ("object" == typeof s) this._$_localFileBlobs$_[t] = new Blob([ s.str ], {
                type: s.type
            }), this._$_localFileStrings$_[t] = s.str; else {
                let i = await this._$_FetchDataUri$_(s);
                i || (i = this._$_DataURIToBinaryBlobSync$_(s)), this._$_localFileBlobs$_[t] = i;
            }
        }
        async _$_FetchDataUri$_(t) {
            try {
                const s = await fetch(t);
                return await s.blob();
            } catch (t) {
                return console.warn("Failed to fetch a data: URI. Falling back to a slower workaround. This is probably because the Content Security Policy unnecessarily blocked it. Allow data: URIs in your CSP to avoid this.", t), 
                null;
            }
        }
        _$_DataURIToBinaryBlobSync$_(t) {
            const s = this._$_ParseDataURI$_(t);
            return this._$_BinaryStringToBlob$_(s.data, s._$mime_type$_);
        }
        _$_ParseDataURI$_(t) {
            const s = t.indexOf(",");
            if (s < 0) throw new URIError("expected comma in data: uri");
            const i = t.substring(5, s), e = t.substring(s + 1), h = i.split(";"), n = h[0] || "", o = h[1], r = h[2];
            let a;
            return a = "base64" === o || "base64" === r ? atob(e) : decodeURIComponent(e), {
                _$mime_type$_: n,
                data: a
            };
        }
        _$_BinaryStringToBlob$_(t, s) {
            let i, e, h = t.length, n = h >> 2, o = new Uint8Array(h), r = new Uint32Array(o.buffer, 0, n);
            for (i = 0, e = 0; i < n; ++i) r[i] = t.charCodeAt(e++) | t.charCodeAt(e++) << 8 | t.charCodeAt(e++) << 16 | t.charCodeAt(e++) << 24;
            let a = 3 & h;
            for (;a--; ) o[e] = t.charCodeAt(e), ++e;
            return new Blob([ o ], {
                type: s
            });
        }
    };
}

{
    const S = self._$RuntimeInterface$_;
    function k(t) {
        return t.sourceCapabilities && t.sourceCapabilities.firesTouchEvents || t.originalEvent && t.originalEvent.sourceCapabilities && t.originalEvent.sourceCapabilities.firesTouchEvents;
    }
    const P = new Map([ [ "OSLeft", "MetaLeft" ], [ "OSRight", "MetaRight" ] ]), M = {
        dispatchRuntimeEvent: !0,
        dispatchUserScriptEvent: !0
    }, R = {
        dispatchUserScriptEvent: !0
    }, O = {
        dispatchRuntimeEvent: !0
    };
    async function x(t) {
        const s = URL.createObjectURL(t);
        try {
            return await (i = s, new Promise(((t, s) => {
                const e = new Image;
                e.onload = () => t(e), e.onerror = t => s(t), e.src = i;
            })));
        } finally {
            URL.revokeObjectURL(s);
        }
        var i;
    }
    function C(t) {
        do {
            if (t.parentNode && t.hasAttribute("contenteditable")) return !0;
            t = t.parentNode;
        } while (t);
        return !1;
    }
    const T = new Set([ "input", "textarea", "datalist", "select" ]), I = new Set([ "canvas", "body", "html" ]);
    function A(t) {
        if (!t.target.tagName) return;
        const s = t.target.tagName.toLowerCase();
        I.has(s) && t.preventDefault();
    }
    function G(t) {
        t.target.tagName && t.target.classList.contains("c3htmlwrap") && t.preventDefault();
    }
    function E(t) {
        (t.metaKey || t.ctrlKey) && t.preventDefault();
    }
    self.C3_GetSvgImageSize = async function(t) {
        const s = await x(t);
        if (s.width > 0 && s.height > 0) return [ s.width, s.height ];
        {
            s.style.position = "absolute", s.style.left = "0px", s.style.top = "0px", s.style.visibility = "hidden", 
            document.body.appendChild(s);
            const t = s.getBoundingClientRect();
            return document.body.removeChild(s), [ t.width, t.height ];
        }
    }, self.C3_RasterSvgImageBlob = async function(t, s, i, e, h) {
        const n = await x(t), o = document.createElement("canvas");
        return o.width = e, o.height = h, o.getContext("2d").drawImage(n, 0, 0, s, i), o;
    };
    let L = !1;
    function D() {
        try {
            return window.parent && window.parent.document.hasFocus();
        } catch (t) {
            return !1;
        }
    }
    document.addEventListener("pause", (() => L = !0)), document.addEventListener("resume", (() => L = !1));
    const F = "runtime", U = class extends self._$DOMHandler$_ {
        constructor(t) {
            super(t, F), this._$_enableWindowResizeEvent$_ = !1, this._$_simulatedResizeTimerId$_ = -1, 
            this._$_targetOrientation$_ = "any", this._$_attachedDeviceOrientationEvent$_ = !1, 
            this._$_attachedDeviceMotionEvent$_ = !1, this._$_pageVisibilityIsHidden$_ = !1, 
            this._$_screenReaderTextWrap$_ = document.createElement("div"), this._$_screenReaderTextWrap$_.className = "c3-screen-reader-text", 
            this._$_screenReaderTextWrap$_.setAttribute("aria-live", "polite"), document.body.appendChild(this._$_screenReaderTextWrap$_), 
            this._$_debugHighlightElem$_ = null, this._$_isExportToVideo$_ = !1, this._$_exportVideoProgressMessage$_ = "", 
            this._$_exportVideoUpdateTimerId$_ = -1, this._$_enableAndroidVKDetection$_ = !1, 
            this._$_lastWindowWidth$_ = t._$_GetWindowInnerWidth$_(), this._$_lastWindowHeight$_ = t._$_GetWindowInnerHeight$_(), 
            this._$_virtualKeyboardHeight$_ = 0, this._$_vkTranslateYOffset$_ = 0, t._$AddRuntimeComponentMessageHandler$_("runtime", "invoke-download", (t => this._$_OnInvokeDownload$_(t))), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "load-webfonts", (t => this._$_OnLoadWebFonts$_(t))), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "raster-svg-image", (t => this._$_OnRasterSvgImage$_(t))), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "get-svg-image-size", (t => this._$_OnGetSvgImageSize$_(t))), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "set-target-orientation", (t => this._$_OnSetTargetOrientation$_(t))), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "register-sw", (() => this._$_OnRegisterSW$_())), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "post-to-debugger", (t => this._$_OnPostToDebugger$_(t))), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "go-to-script", (t => this._$_OnPostToDebugger$_(t))), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "before-start-ticking", (() => this._$_OnBeforeStartTicking$_())), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "debug-highlight", (t => this._$_OnDebugHighlight$_(t))), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "enable-device-orientation", (() => this._$_AttachDeviceOrientationEvent$_())), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "enable-device-motion", (() => this._$_AttachDeviceMotionEvent$_())), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "add-stylesheet", (t => this._$_OnAddStylesheet$_(t))), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "script-create-worker", (t => this._$_OnScriptCreateWorker$_(t))), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "alert", (t => this._$_OnAlert$_(t))), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "screen-reader-text", (t => this._$_OnScreenReaderTextEvent$_(t))), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "hide-cordova-splash", (() => this._$_OnHideCordovaSplash$_())), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "set-exporting-to-video", (t => this._$_SetExportingToVideo$_(t))), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "export-to-video-progress", (t => this._$_OnExportVideoProgress$_(t))), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "exported-to-video", (t => this._$_OnExportedToVideo$_(t))), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "exported-to-image-sequence", (t => this._$_OnExportedToImageSequence$_(t)));
            const s = new Set([ "input", "textarea", "datalist" ]);
            if (window.addEventListener("contextmenu", (t => {
                const i = t.target, e = i.tagName.toLowerCase();
                s.has(e) || C(i) || t.preventDefault();
            })), window.addEventListener("selectstart", A), window.addEventListener("gesturehold", A), 
            window.addEventListener("touchstart", A, {
                passive: !1
            }), window.addEventListener("pointerdown", A, {
                passive: !1
            }), this._$_mousePointerLastButtons$_ = 0, window.addEventListener("mousedown", (t => {
                1 === t.button && t.preventDefault();
            })), window.addEventListener("mousewheel", E, {
                passive: !1
            }), window.addEventListener("wheel", E, {
                passive: !1
            }), window.addEventListener("resize", (() => this._$_OnWindowResize$_())), window.addEventListener("fullscreenchange", (() => this._$_OnFullscreenChange$_())), 
            window.addEventListener("webkitfullscreenchange", (() => this._$_OnFullscreenChange$_())), 
            window.addEventListener("mozfullscreenchange", (() => this._$_OnFullscreenChange$_())), 
            window.addEventListener("fullscreenerror", (t => this._$_OnFullscreenError$_(t))), 
            window.addEventListener("webkitfullscreenerror", (t => this._$_OnFullscreenError$_(t))), 
            window.addEventListener("mozfullscreenerror", (t => this._$_OnFullscreenError$_(t))), 
            t._$IsiOSWebView$_()) {
                let t = 1 / 0;
                window.visualViewport.addEventListener("resize", (() => {
                    const s = window.visualViewport.height;
                    s > t && (document.scrollingElement.scrollTop = 0, document.scrollingElement.scrollLeft = 0), 
                    t = s;
                })), document.documentElement.setAttribute("ioswebview", "");
            }
            this._$_mediaPendingPlay$_ = new Set, this._$_mediaRemovedPendingPlay$_ = new WeakSet, 
            this._$_isSilent$_ = !1;
        }
        _$_AddDefaultCanvasEventHandlers$_(t) {
            t.addEventListener("selectstart", A), t.addEventListener("gesturehold", A), t.addEventListener("pointerdown", A);
        }
        _$_AddDefaultHTMLWrapEventHandlers$_(t) {
            t.addEventListener("selectstart", G), t.addEventListener("gesturehold", G), t.addEventListener("touchstart", G);
        }
        _$_OnBeforeStartTicking$_() {
            return self.setTimeout((() => {
                this._$_enableAndroidVKDetection$_ = !0;
            }), 1e3), "cordova" === this._$_iRuntime$_._$GetExportType$_() ? (document.addEventListener("pause", (() => this._$_OnVisibilityChange$_(!0))), 
            document.addEventListener("resume", (() => this._$_OnVisibilityChange$_(!1)))) : document.addEventListener("visibilitychange", (() => this._$_OnVisibilityChange$_("hidden" === document.visibilityState))), 
            this._$_pageVisibilityIsHidden$_ = !("hidden" !== document.visibilityState && !L), 
            {
                isSuspended: this._$_pageVisibilityIsHidden$_
            };
        }
        _$Attach$_() {
            window.addEventListener("focus", (() => this._$_PostRuntimeEvent$_("window-focus"))), 
            window.addEventListener("blur", (() => {
                this._$_PostRuntimeEvent$_("window-blur", {
                    parentHasFocus: D()
                }), this._$_mousePointerLastButtons$_ = 0;
            })), window.addEventListener("focusin", (t => {
                var s;
                s = t.target, (T.has(s.tagName.toLowerCase()) || C(s)) && this._$_PostRuntimeEvent$_("keyboard-blur");
            })), window.addEventListener("keydown", (t => this._$_OnKeyEvent$_("keydown", t))), 
            window.addEventListener("keyup", (t => this._$_OnKeyEvent$_("keyup", t))), window.addEventListener("mousedown", (t => this._$_OnMouseEvent$_("mousedown", t, R))), 
            window.addEventListener("mousemove", (t => this._$_OnMouseEvent$_("mousemove", t, R))), 
            window.addEventListener("mouseup", (t => this._$_OnMouseEvent$_("mouseup", t, R))), 
            window.addEventListener("dblclick", (t => this._$_OnMouseEvent$_("dblclick", t, M))), 
            window.addEventListener("wheel", (t => this._$_OnMouseWheelEvent$_("wheel", t, M))), 
            window.addEventListener("pointerdown", (t => {
                this._$_HandlePointerDownFocus$_(t), this._$_OnPointerEvent$_("pointerdown", t);
            })), this._$_iRuntime$_._$UsesWorker$_() && void 0 !== window.onpointerrawupdate && self === self.top ? window.addEventListener("pointerrawupdate", (t => this._$_OnPointerRawUpdate$_(t))) : window.addEventListener("pointermove", (t => this._$_OnPointerEvent$_("pointermove", t))), 
            window.addEventListener("pointerup", (t => this._$_OnPointerEvent$_("pointerup", t))), 
            window.addEventListener("pointercancel", (t => this._$_OnPointerEvent$_("pointercancel", t)));
            const t = () => this._$_PlayPendingMedia$_();
            window.addEventListener("pointerup", t, !0), window.addEventListener("touchend", t, !0), 
            window.addEventListener("click", t, !0), window.addEventListener("keydown", t, !0), 
            window.addEventListener("gamepadconnected", t, !0), this._$_iRuntime$_._$IsAndroid$_() && !this._$_iRuntime$_._$IsAndroidWebView$_() && navigator.virtualKeyboard && (navigator.virtualKeyboard.overlaysContent = !0, 
            navigator.virtualKeyboard.addEventListener("geometrychange", (() => {
                this._$_OnAndroidVirtualKeyboardChange$_(this._$_GetWindowInnerHeight$_(), navigator.virtualKeyboard.boundingRect.height);
            }))), this._$_iRuntime$_._$IsiOSWebView$_() && (document.scrollingElement.scrollTop = 0, 
            document.scrollingElement.scrollLeft = 0);
        }
        _$_OnAndroidVirtualKeyboardChange$_(t, s) {
            if (document.body.style.position = "", document.body.style.overflow = "", document.body.style.transform = "", 
            this._$_vkTranslateYOffset$_ = 0, s > 0) {
                const i = document.activeElement;
                if (i) {
                    const e = i.getBoundingClientRect();
                    let h = (e.top + e.bottom) / 2 - (t - s) / 2;
                    h > s && (h = s), h < 0 && (h = 0), h > 0 && (document.body.style.position = "absolute", 
                    document.body.style.overflow = "visible", document.body.style.transform = `translateY(${-h}px)`, 
                    this._$_vkTranslateYOffset$_ = h);
                }
            }
        }
        _$_PostRuntimeEvent$_(t, s) {
            this._$PostToRuntime$_(t, s || null, O);
        }
        _$_GetWindowInnerWidth$_() {
            return this._$_iRuntime$_._$_GetWindowInnerWidth$_();
        }
        _$_GetWindowInnerHeight$_() {
            return this._$_iRuntime$_._$_GetWindowInnerHeight$_();
        }
        _$_EnableWindowResizeEvent$_() {
            this._$_enableWindowResizeEvent$_ = !0, this._$_lastWindowWidth$_ = this._$_iRuntime$_._$_GetWindowInnerWidth$_(), 
            this._$_lastWindowHeight$_ = this._$_iRuntime$_._$_GetWindowInnerHeight$_();
        }
        _$_OnWindowResize$_() {
            if (this._$_isExportToVideo$_) return;
            if (!this._$_enableWindowResizeEvent$_) return;
            const t = this._$_GetWindowInnerWidth$_(), s = this._$_GetWindowInnerHeight$_();
            if (this._$_iRuntime$_._$IsAndroidWebView$_()) if (this._$_enableAndroidVKDetection$_) {
                if (this._$_iRuntime$_._$CanDoAndroidVirtualKeyboardDetection$_() && this._$_lastWindowWidth$_ === t && s < this._$_lastWindowHeight$_) return this._$_virtualKeyboardHeight$_ = this._$_lastWindowHeight$_ - s, 
                void this._$_OnAndroidVirtualKeyboardChange$_(this._$_lastWindowHeight$_, this._$_virtualKeyboardHeight$_);
                this._$_virtualKeyboardHeight$_ > 0 && (this._$_virtualKeyboardHeight$_ = 0, this._$_OnAndroidVirtualKeyboardChange$_(s, this._$_virtualKeyboardHeight$_)), 
                this._$_lastWindowWidth$_ = t, this._$_lastWindowHeight$_ = s;
            } else this._$_lastWindowWidth$_ = t, this._$_lastWindowHeight$_ = s;
            this._$PostToRuntime$_("window-resize", {
                innerWidth: t,
                innerHeight: s,
                devicePixelRatio: window.devicePixelRatio,
                isFullscreen: S._$IsDocumentFullscreen$_(),
                cssDisplayMode: this._$_iRuntime$_._$GetCssDisplayMode$_()
            }), this._$_iRuntime$_._$IsiOSWebView$_() && (-1 !== this._$_simulatedResizeTimerId$_ && clearTimeout(this._$_simulatedResizeTimerId$_), 
            this._$_OnSimulatedResize$_(t, s, 0));
        }
        _$_ScheduleSimulatedResize$_(t, s, i) {
            -1 !== this._$_simulatedResizeTimerId$_ && clearTimeout(this._$_simulatedResizeTimerId$_), 
            this._$_simulatedResizeTimerId$_ = setTimeout((() => this._$_OnSimulatedResize$_(t, s, i)), 48);
        }
        _$_OnSimulatedResize$_(t, s, i) {
            const e = this._$_GetWindowInnerWidth$_(), h = this._$_GetWindowInnerHeight$_();
            this._$_simulatedResizeTimerId$_ = -1, e != t || h != s ? this._$PostToRuntime$_("window-resize", {
                innerWidth: e,
                innerHeight: h,
                devicePixelRatio: window.devicePixelRatio,
                isFullscreen: S._$IsDocumentFullscreen$_(),
                cssDisplayMode: this._$_iRuntime$_._$GetCssDisplayMode$_()
            }) : i < 10 && this._$_ScheduleSimulatedResize$_(e, h, i + 1);
        }
        _$_OnSetTargetOrientation$_(t) {
            this._$_targetOrientation$_ = t.targetOrientation;
        }
        _$_TrySetTargetOrientation$_() {
            const t = this._$_targetOrientation$_;
            if (screen.orientation && screen.orientation.lock) screen.orientation.lock(t).catch((t => console.warn("[Construct] Failed to lock orientation: ", t))); else try {
                let s = !1;
                screen.lockOrientation ? s = screen.lockOrientation(t) : screen.webkitLockOrientation ? s = screen.webkitLockOrientation(t) : screen.mozLockOrientation ? s = screen.mozLockOrientation(t) : screen.msLockOrientation && (s = screen.msLockOrientation(t)), 
                s || console.warn("[Construct] Failed to lock orientation");
            } catch (t) {
                console.warn("[Construct] Failed to lock orientation: ", t);
            }
        }
        _$_OnFullscreenChange$_() {
            if (this._$_isExportToVideo$_) return;
            const t = S._$IsDocumentFullscreen$_();
            t && "any" !== this._$_targetOrientation$_ && this._$_TrySetTargetOrientation$_(), 
            this._$PostToRuntime$_("fullscreenchange", {
                isFullscreen: t,
                innerWidth: this._$_GetWindowInnerWidth$_(),
                innerHeight: this._$_GetWindowInnerHeight$_()
            });
        }
        _$_OnFullscreenError$_(t) {
            console.warn("[Construct] Fullscreen request failed: ", t), this._$PostToRuntime$_("fullscreenerror", {
                isFullscreen: S._$IsDocumentFullscreen$_(),
                innerWidth: this._$_GetWindowInnerWidth$_(),
                innerHeight: this._$_GetWindowInnerHeight$_()
            });
        }
        _$_OnVisibilityChange$_(t) {
            if (this._$_pageVisibilityIsHidden$_ !== t && (this._$_pageVisibilityIsHidden$_ = t, 
            t ? this._$_iRuntime$_._$_CancelAnimationFrame$_() : this._$_iRuntime$_._$_RequestAnimationFrame$_(), 
            this._$PostToRuntime$_("visibilitychange", {
                hidden: t
            }), !t && this._$_iRuntime$_._$IsiOSWebView$_())) {
                const t = () => {
                    document.scrollingElement.scrollTop = 0, document.scrollingElement.scrollLeft = 0;
                };
                setTimeout(t, 50), setTimeout(t, 100), setTimeout(t, 250), setTimeout(t, 500);
            }
        }
        _$_OnKeyEvent$_(t, s) {
            if (void 0 === s.key) return;
            if ("Backspace" === s.key && A(s), "nwjs" === this._$_iRuntime$_._$GetExportType$_() && "u" === s.key && (s.ctrlKey || s.metaKey) && s.preventDefault(), 
            this._$_isExportToVideo$_) return;
            const i = P.get(s.code) || s.code;
            this._$_PostToRuntimeMaybeSync$_(t, {
                code: i,
                key: s.key,
                which: s.which,
                repeat: s.repeat,
                altKey: s.altKey,
                ctrlKey: s.ctrlKey,
                metaKey: s.metaKey,
                shiftKey: s.shiftKey,
                timeStamp: s.timeStamp
            }, M);
        }
        _$_OnMouseWheelEvent$_(t, s, i) {
            this._$_isExportToVideo$_ || this._$PostToRuntime$_(t, {
                clientX: s.clientX,
                clientY: s.clientY + this._$_vkTranslateYOffset$_,
                pageX: s.pageX,
                pageY: s.pageY + this._$_vkTranslateYOffset$_,
                deltaX: s.deltaX,
                deltaY: s.deltaY,
                deltaZ: s.deltaZ,
                deltaMode: s.deltaMode,
                timeStamp: s.timeStamp
            }, i);
        }
        _$_OnMouseEvent$_(t, s, i) {
            this._$_isExportToVideo$_ || k(s) || this._$_PostToRuntimeMaybeSync$_(t, {
                button: s.button,
                buttons: s.buttons,
                clientX: s.clientX,
                clientY: s.clientY + this._$_vkTranslateYOffset$_,
                pageX: s.pageX,
                pageY: s.pageY + this._$_vkTranslateYOffset$_,
                movementX: s.movementX || 0,
                movementY: s.movementY || 0,
                timeStamp: s.timeStamp
            }, i);
        }
        _$_OnPointerEvent$_(t, s) {
            if (this._$_isExportToVideo$_) return;
            let i = 0;
            "mouse" === s.pointerType && (i = this._$_mousePointerLastButtons$_), this._$_PostToRuntimeMaybeSync$_(t, {
                pointerId: s.pointerId,
                pointerType: s.pointerType,
                button: s.button,
                buttons: s.buttons,
                lastButtons: i,
                clientX: s.clientX,
                clientY: s.clientY + this._$_vkTranslateYOffset$_,
                pageX: s.pageX,
                pageY: s.pageY + this._$_vkTranslateYOffset$_,
                movementX: s.movementX || 0,
                movementY: s.movementY || 0,
                width: s.width || 0,
                height: s.height || 0,
                pressure: s.pressure || 0,
                tangentialPressure: s.tangentialPressure || 0,
                tiltX: s.tiltX || 0,
                tiltY: s.tiltY || 0,
                twist: s.twist || 0,
                timeStamp: s.timeStamp
            }, M), "mouse" === s.pointerType && (this._$_mousePointerLastButtons$_ = s.buttons);
        }
        _$_OnPointerRawUpdate$_(t) {
            this._$_OnPointerEvent$_("pointermove", t);
        }
        _$_OnTouchEvent$_(t, s) {
            if (!this._$_isExportToVideo$_) for (let i = 0, e = s.changedTouches.length; i < e; ++i) {
                const e = s.changedTouches[i];
                this._$_PostToRuntimeMaybeSync$_(t, {
                    pointerId: e.identifier,
                    pointerType: "touch",
                    button: 0,
                    buttons: 0,
                    lastButtons: 0,
                    clientX: e.clientX,
                    clientY: e.clientY + this._$_vkTranslateYOffset$_,
                    pageX: e.pageX,
                    pageY: e.pageY + this._$_vkTranslateYOffset$_,
                    movementX: s.movementX || 0,
                    movementY: s.movementY || 0,
                    width: 2 * (e.radiusX || e.webkitRadiusX || 0),
                    height: 2 * (e.radiusY || e.webkitRadiusY || 0),
                    pressure: e.force || e.webkitForce || 0,
                    tangentialPressure: 0,
                    tiltX: 0,
                    tiltY: 0,
                    twist: e.rotationAngle || 0,
                    timeStamp: s.timeStamp
                }, M);
            }
        }
        _$_HandlePointerDownFocus$_(t) {
            window !== window.top && window.focus(), this._$_IsElementCanvasOrDocument$_(t.target) && document.activeElement && !this._$_IsElementCanvasOrDocument$_(document.activeElement) && document.activeElement.blur();
        }
        _$_IsElementCanvasOrDocument$_(t) {
            return !t || t === document || t === window || t === document.body || "canvas" === t.tagName.toLowerCase();
        }
        _$_AttachDeviceOrientationEvent$_() {
            this._$_attachedDeviceOrientationEvent$_ || (this._$_attachedDeviceOrientationEvent$_ = !0, 
            window.addEventListener("deviceorientation", (t => this._$_OnDeviceOrientation$_(t))), 
            window.addEventListener("deviceorientationabsolute", (t => this._$_OnDeviceOrientationAbsolute$_(t))));
        }
        _$_AttachDeviceMotionEvent$_() {
            this._$_attachedDeviceMotionEvent$_ || (this._$_attachedDeviceMotionEvent$_ = !0, 
            window.addEventListener("devicemotion", (t => this._$_OnDeviceMotion$_(t))));
        }
        _$_OnDeviceOrientation$_(t) {
            this._$_isExportToVideo$_ || this._$PostToRuntime$_("deviceorientation", {
                absolute: !!t.absolute,
                alpha: t.alpha || 0,
                beta: t.beta || 0,
                gamma: t.gamma || 0,
                timeStamp: t.timeStamp,
                webkitCompassHeading: t.webkitCompassHeading,
                webkitCompassAccuracy: t.webkitCompassAccuracy
            }, M);
        }
        _$_OnDeviceOrientationAbsolute$_(t) {
            this._$_isExportToVideo$_ || this._$PostToRuntime$_("deviceorientationabsolute", {
                absolute: !!t.absolute,
                alpha: t.alpha || 0,
                beta: t.beta || 0,
                gamma: t.gamma || 0,
                timeStamp: t.timeStamp
            }, M);
        }
        _$_OnDeviceMotion$_(t) {
            if (this._$_isExportToVideo$_) return;
            let s = null;
            const i = t.acceleration;
            i && (s = {
                x: i.x || 0,
                y: i.y || 0,
                z: i.z || 0
            });
            let e = null;
            const h = t.accelerationIncludingGravity;
            h && (e = {
                x: h.x || 0,
                y: h.y || 0,
                z: h.z || 0
            });
            let n = null;
            const o = t.rotationRate;
            o && (n = {
                alpha: o.alpha || 0,
                beta: o.beta || 0,
                gamma: o.gamma || 0
            }), this._$PostToRuntime$_("devicemotion", {
                acceleration: s,
                accelerationIncludingGravity: e,
                rotationRate: n,
                interval: t.interval,
                timeStamp: t.timeStamp
            }, M);
        }
        _$_OnInvokeDownload$_(t) {
            const s = t.url, i = t.filename, e = document.createElement("a"), h = document.body;
            e.textContent = i, e.href = s, e.download = i, h.appendChild(e), e.click(), h.removeChild(e);
        }
        async _$_OnLoadWebFonts$_(t) {
            const s = t.webfonts;
            await Promise.all(s.map((async t => {
                const s = new FontFace(t.name, `url('${t.url}')`);
                document.fonts.add(s), await s.load();
            })));
        }
        async _$_OnRasterSvgImage$_(t) {
            const s = t.blob, i = t.imageWidth, e = t.imageHeight, h = t.surfaceWidth, n = t.surfaceHeight, o = t.imageBitmapOpts, r = await self.C3_RasterSvgImageBlob(s, i, e, h, n);
            let a;
            return a = o ? await createImageBitmap(r, o) : await createImageBitmap(r), {
                imageBitmap: a,
                transferables: [ a ]
            };
        }
        async _$_OnGetSvgImageSize$_(t) {
            return await self.C3_GetSvgImageSize(t.blob);
        }
        async _$_OnAddStylesheet$_(t) {
            var s;
            await (s = t.url, new Promise(((t, i) => {
                const e = document.createElement("link");
                e.onload = () => t(e), e.onerror = t => i(t), e.rel = "stylesheet", e.href = s, 
                document.head.appendChild(e);
            })));
        }
        _$_PlayPendingMedia$_() {
            const t = [ ...this._$_mediaPendingPlay$_ ];
            if (this._$_mediaPendingPlay$_.clear(), !this._$_isSilent$_) for (const s of t) {
                const t = s.play();
                t && t.catch((t => {
                    this._$_mediaRemovedPendingPlay$_.has(s) || this._$_mediaPendingPlay$_.add(s);
                }));
            }
        }
        _$TryPlayMedia$_(t) {
            if ("function" != typeof t.play) throw new Error("missing play function");
            let s;
            this._$_mediaRemovedPendingPlay$_.delete(t);
            try {
                s = t.play();
            } catch (s) {
                return void this._$_mediaPendingPlay$_.add(t);
            }
            s && s.catch((s => {
                this._$_mediaRemovedPendingPlay$_.has(t) || this._$_mediaPendingPlay$_.add(t);
            }));
        }
        _$RemovePendingPlay$_(t) {
            this._$_mediaPendingPlay$_.delete(t), this._$_mediaRemovedPendingPlay$_.add(t);
        }
        _$SetSilent$_(t) {
            this._$_isSilent$_ = !!t;
        }
        _$_OnHideCordovaSplash$_() {
            navigator.splashscreen && navigator.splashscreen.hide && navigator.splashscreen.hide();
        }
        _$_OnDebugHighlight$_(t) {
            if (!t.show) return void (this._$_debugHighlightElem$_ && (this._$_debugHighlightElem$_.style.display = "none"));
            this._$_debugHighlightElem$_ || (this._$_debugHighlightElem$_ = document.createElement("div"), 
            this._$_debugHighlightElem$_.id = "inspectOutline", document.body.appendChild(this._$_debugHighlightElem$_));
            const s = this._$_debugHighlightElem$_;
            s.style.display = "", s.style.left = t.left - 1 + "px", s.style.top = t.top - 1 + "px", 
            s.style.width = t.width + 2 + "px", s.style.height = t.height + 2 + "px", s.textContent = t.name;
        }
        _$_OnRegisterSW$_() {
            window.C3_RegisterSW && window.C3_RegisterSW();
        }
        _$_OnPostToDebugger$_(t) {
            window.c3_postToMessagePort && (t.from = "runtime", window.c3_postToMessagePort(t));
        }
        _$_InvokeFunctionFromJS$_(t, s) {
            return this._$PostToRuntimeAsync$_("js-invoke-function", {
                name: t,
                params: s
            });
        }
        _$_OnScriptCreateWorker$_(t) {
            const s = t.url, i = t.opts, e = t.port2;
            new Worker(s, i).postMessage({
                type: "construct-worker-init",
                port2: e
            }, [ e ]);
        }
        _$_OnAlert$_(t) {
            alert(t.message);
        }
        _$_OnScreenReaderTextEvent$_(t) {
            const s = t.type;
            if ("create" === s) {
                const s = document.createElement("p");
                s.id = "c3-sr-" + t.id, s.textContent = t.text, this._$_screenReaderTextWrap$_.appendChild(s);
            } else if ("update" === s) {
                const s = document.getElementById("c3-sr-" + t.id);
                s ? s.textContent = t.text : console.warn(`[Construct] Missing screen reader text with id ${t.id}`);
            } else if ("release" === s) {
                const s = document.getElementById("c3-sr-" + t.id);
                s ? s.remove() : console.warn(`[Construct] Missing screen reader text with id ${t.id}`);
            } else console.warn(`[Construct] Unknown screen reader text update '${s}'`);
        }
        _$_SetExportingToVideo$_(t) {
            this._$_isExportToVideo$_ = !0;
            const s = document.createElement("h1");
            s.id = "exportToVideoMessage", s.textContent = t.message, document.body.prepend(s), 
            document.body.classList.add("exportingToVideo"), this._$GetRuntimeInterface$_()._$GetMainCanvas$_().style.display = "", 
            this._$_iRuntime$_._$SetIsExportingToVideo$_(t.duration);
        }
        _$_OnExportVideoProgress$_(t) {
            this._$_exportVideoProgressMessage$_ = t.message, -1 === this._$_exportVideoUpdateTimerId$_ && (this._$_exportVideoUpdateTimerId$_ = setTimeout((() => this._$_DoUpdateExportVideoProgressMessage$_()), 250));
        }
        _$_DoUpdateExportVideoProgressMessage$_() {
            this._$_exportVideoUpdateTimerId$_ = -1;
            const t = document.getElementById("exportToVideoMessage");
            t && (t.textContent = this._$_exportVideoProgressMessage$_);
        }
        _$_OnExportedToVideo$_(t) {
            window._$c3_postToMessagePort$_({
                type: "exported-video",
                arrayBuffer: t.arrayBuffer,
                contentType: t.contentType,
                time: t.time
            });
        }
        _$_OnExportedToImageSequence$_(t) {
            window._$c3_postToMessagePort$_({
                type: "exported-image-sequence",
                blobArr: t.blobArr,
                time: t.time,
                gif: t.gif
            });
        }
    };
    S._$AddDOMHandlerClass$_(U);
}

{
    const W = "dispatchworker.js", H = "jobworker.js";
    self._$JobSchedulerDOM$_ = class {
        constructor(t) {
            this._$_runtimeInterface$_ = t, this._$_maxNumWorkers$_ = Math.min(navigator.hardwareConcurrency || 2, 16), 
            this._$_dispatchWorker$_ = null, this._$_jobWorkers$_ = [], this._$_inputPort$_ = null, 
            this._$_outputPort$_ = null;
        }
        async _$Init$_() {
            if (this._$_hasInitialised$_) throw new Error("already initialised");
            this._$_hasInitialised$_ = !0;
            const t = this._$_runtimeInterface$_._$GetScriptFolder$_() + W;
            this._$_dispatchWorker$_ = await this._$_runtimeInterface$_._$CreateWorker$_(t, {
                name: "DispatchWorker"
            });
            const s = new MessageChannel;
            this._$_inputPort$_ = s.port1, this._$_dispatchWorker$_.postMessage({
                type: "_init",
                "in-port": s.port2
            }, [ s.port2 ]), this._$_outputPort$_ = await this._$_CreateJobWorker$_();
        }
        async _$_CreateJobWorker$_() {
            const t = this._$_jobWorkers$_.length, s = this._$_runtimeInterface$_._$GetScriptFolder$_() + H, i = await this._$_runtimeInterface$_._$CreateWorker$_(s, {
                name: "JobWorker" + t
            }), e = new MessageChannel, h = new MessageChannel;
            return this._$_dispatchWorker$_.postMessage({
                type: "_addJobWorker",
                port: e.port1
            }, [ e.port1 ]), i.postMessage({
                type: "init",
                number: t,
                "dispatch-port": e.port2,
                "output-port": h.port2
            }, [ e.port2, h.port2 ]), this._$_jobWorkers$_.push(i), h.port1;
        }
        _$GetPortData$_() {
            return {
                inputPort: this._$_inputPort$_,
                outputPort: this._$_outputPort$_,
                maxNumWorkers: this._$_maxNumWorkers$_
            };
        }
        _$GetPortTransferables$_() {
            return [ this._$_inputPort$_, this._$_outputPort$_ ];
        }
    };
}

{
    const B = "keyboard", V = class extends self._$DOMHandler$_ {
        constructor(t) {
            super(t, B), this._$_isKeyboardLockSupported$_ = !(!navigator.keyboard || !navigator.keyboard.lock), 
            this._$AddRuntimeMessageHandlers$_([ [ "init", () => this._$_OnInit$_() ], [ "lock-keyboard", t => this._$_OnLockKeyboard$_(t) ], [ "unlock-keyboard", () => this._$_OnUnlockKeyboard$_() ] ]);
        }
        _$_OnInit$_() {
            return {
                isKeyboardLockSupported: this._$_isKeyboardLockSupported$_
            };
        }
        async _$_OnLockKeyboard$_(t) {
            const s = t.keysArr;
            try {
                return 0 === s.length ? await navigator.keyboard.lock() : await navigator.keyboard.lock(s), 
                {
                    isOk: !0
                };
            } catch (t) {
                return console.error("Error locking keyboard:", t), {
                    isOk: !1
                };
            }
        }
        _$_OnUnlockKeyboard$_() {
            try {
                navigator.keyboard.unlock();
            } catch (t) {
                console.error("Error unlocking keyboard:", t);
            }
        }
    };
    self._$RuntimeInterface$_._$AddDOMHandlerClass$_(V);
}

{
    const j = "mouse", N = class extends self._$DOMHandler$_ {
        constructor(t) {
            super(t, j), this._$AddRuntimeMessageHandlers$_([ [ "cursor", t => this._$_OnChangeCursorStyle$_(t) ], [ "request-pointer-lock", t => this._$_OnRequestPointerLock$_(t) ], [ "release-pointer-lock", () => this._$_OnReleasePointerLock$_() ] ]), 
            document.addEventListener("pointerlockchange", (t => this._$_OnPointerLockChange$_())), 
            document.addEventListener("pointerlockerror", (t => this._$_OnPointerLockError$_()));
        }
        _$_OnChangeCursorStyle$_(t) {
            document.documentElement.style.cursor = t;
        }
        _$_OnRequestPointerLock$_(t) {
            this._$_iRuntime$_._$GetMainCanvas$_().requestPointerLock(t);
        }
        _$_OnReleasePointerLock$_() {
            document.exitPointerLock();
        }
        _$_OnPointerLockChange$_() {
            this._$PostToRuntime$_("pointer-lock-change", {
                "has-pointer-lock": !!document.pointerLockElement
            });
        }
        _$_OnPointerLockError$_() {
            this._$PostToRuntime$_("pointer-lock-error", {
                "has-pointer-lock": !!document.pointerLockElement
            });
        }
    };
    self._$RuntimeInterface$_._$AddDOMHandlerClass$_(N);
}

{
    const $ = 180 / Math.PI, z = "audio";
    self._$AudioDOMHandler$_ = class extends self._$DOMHandler$_ {
        constructor(t) {
            super(t, z), this._$_audioContext$_ = null, this._$_destinationNode$_ = null, this._$_hasUnblocked$_ = !1, 
            this._$_hasAttachedUnblockEvents$_ = !1, this._$_unblockFunc$_ = () => this._$_UnblockAudioContext$_(), 
            this._$_audioBuffers$_ = [], this._$_audioInstances$_ = [], this._$_lastAudioInstance$_ = null, 
            this._$_lastPlayedTags$_ = [], this._$_loadedAudioUrls$_ = new Set, this._$_lastTickCount$_ = -1, 
            this._$_pendingTags$_ = new Map, this._$_masterVolume$_ = 1, this._$_isSilent$_ = !1, 
            this._$_timeScaleMode$_ = 0, this._$_timeScale$_ = 1, this._$_gameTime$_ = 0, this._$_panningModel$_ = "HRTF", 
            this._$_distanceModel$_ = "inverse", this._$_refDistance$_ = 600, this._$_maxDistance$_ = 1e4, 
            this._$_rolloffFactor$_ = 1, this._$_lastListenerPos$_ = [ 0, 0, 0 ], this._$_lastListenerOrientation$_ = [ 0, 0, -1, 0, 1, 0 ], 
            this._$_playMusicAsSound$_ = !1, this._$_lastMusicBuffer$_ = null, this._$_effects$_ = new Map, 
            this._$_analysers$_ = new Set, this._$_isPendingPostFxState$_ = !1, this._$_hasStartedOfflineRender$_ = !1, 
            this._$_microphoneTag$_ = "", this._$_microphoneSource$_ = null, self.C3Audio_OnMicrophoneStream = (t, s) => this._$_OnMicrophoneStream$_(t, s), 
            this._$_destMediaStreamNode$_ = null, self.C3Audio_GetOutputStream = () => this._$_OnGetOutputStream$_(), 
            self.C3Audio_DOMInterface = this, this._$AddRuntimeMessageHandlers$_([ [ "create-audio-context", t => this._$_CreateAudioContext$_(t) ], [ "play", t => this._$_Play$_(t) ], [ "stop", t => this._$_Stop$_(t) ], [ "stop-all", () => this._$_StopAll$_() ], [ "set-paused", t => this._$_SetPaused$_(t) ], [ "set-volume", t => this._$_SetVolume$_(t) ], [ "fade-volume", t => this._$_FadeVolume$_(t) ], [ "set-master-volume", t => this._$_SetMasterVolume$_(t) ], [ "set-muted", t => this._$_SetMuted$_(t) ], [ "set-silent", t => this._$_SetSilent$_(t) ], [ "set-looping", t => this._$_SetLooping$_(t) ], [ "set-playback-rate", t => this._$_SetPlaybackRate$_(t) ], [ "set-stereo-pan", t => this._$_SetStereoPan$_(t) ], [ "seek", t => this._$_Seek$_(t) ], [ "preload", t => this._$_Preload$_(t) ], [ "unload", t => this._$_Unload$_(t) ], [ "unload-all", () => this._$_UnloadAll$_() ], [ "set-suspended", t => this._$_SetSuspended$_(t) ], [ "add-effect", t => this._$_AddEffect$_(t) ], [ "set-effect-param", t => this._$_SetEffectParam$_(t) ], [ "remove-effects", t => this._$_RemoveEffects$_(t) ], [ "tick", t => this._$_OnTick$_(t) ], [ "load-state", t => this._$_OnLoadState$_(t) ], [ "offline-render-audio", t => this._$_OnOfflineRenderAudio$_(t) ], [ "offline-render-finish", () => this._$_OnOfflineRenderFinish$_() ] ]);
        }
        async _$_CreateAudioContext$_(t) {
            if (t.usePlayMusicAsSoundWorkaround && (this._$_playMusicAsSound$_ = !0), this._$_timeScaleMode$_ = t.timeScaleMode, 
            this._$_panningModel$_ = [ "equalpower", "HRTF", "soundfield" ][t.panningModel], 
            this._$_distanceModel$_ = [ "linear", "inverse", "exponential" ][t.distanceModel], 
            this._$_refDistance$_ = t.refDistance, this._$_maxDistance$_ = t.maxDistance, this._$_rolloffFactor$_ = t.rolloffFactor, 
            this._$_iRuntime$_._$IsExportingToVideo$_()) {
                this._$_playMusicAsSound$_ = !0;
                const t = 48e3;
                this._$_audioContext$_ = new OfflineAudioContext({
                    numberOfChannels: 2,
                    sampleRate: t,
                    length: Math.ceil(this._$_iRuntime$_._$GetExportToVideoDuration$_() * t)
                });
            } else this._$_audioContext$_ = new AudioContext({
                latencyHint: t.latencyHint
            }), this._$_AttachUnblockEvents$_(), this._$_audioContext$_.onstatechange = () => {
                "running" !== this._$_audioContext$_.state && this._$_AttachUnblockEvents$_(), this._$PostToRuntime$_("audiocontext-state", {
                    audioContextState: this._$_audioContext$_.state
                });
            };
            this._$_destinationNode$_ = this._$_audioContext$_.createGain(), this._$_destinationNode$_.connect(this._$_audioContext$_.destination);
            const s = t.listenerPos;
            this._$_lastListenerPos$_[0] = s[0], this._$_lastListenerPos$_[1] = s[1], this._$_lastListenerPos$_[2] = s[2], 
            this._$_audioContext$_.listener.setPosition(s[0], s[1], s[2]), this._$_audioContext$_.listener.setOrientation(...this._$_lastListenerOrientation$_), 
            self.C3_GetAudioContextCurrentTime = () => this._$GetAudioCurrentTime$_();
            try {
                await Promise.all(t.preloadList.map((t => this._$_GetAudioBuffer$_(t.originalUrl, t.url, t.type, !1))));
            } catch (t) {
                console.error("[Construct] Preloading sounds failed: ", t);
            }
            return {
                sampleRate: this._$_audioContext$_.sampleRate,
                audioContextState: this._$_audioContext$_.state,
                outputLatency: this._$_audioContext$_.outputLatency || 0
            };
        }
        _$_AttachUnblockEvents$_() {
            this._$_hasAttachedUnblockEvents$_ || (this._$_hasUnblocked$_ = !1, window.addEventListener("pointerup", this._$_unblockFunc$_, !0), 
            window.addEventListener("touchend", this._$_unblockFunc$_, !0), window.addEventListener("click", this._$_unblockFunc$_, !0), 
            window.addEventListener("keydown", this._$_unblockFunc$_, !0), this._$_hasAttachedUnblockEvents$_ = !0);
        }
        _$_DetachUnblockEvents$_() {
            this._$_hasAttachedUnblockEvents$_ && (this._$_hasUnblocked$_ = !0, window.removeEventListener("pointerup", this._$_unblockFunc$_, !0), 
            window.removeEventListener("touchend", this._$_unblockFunc$_, !0), window.removeEventListener("click", this._$_unblockFunc$_, !0), 
            window.removeEventListener("keydown", this._$_unblockFunc$_, !0), this._$_hasAttachedUnblockEvents$_ = !1);
        }
        _$_UnblockAudioContext$_() {
            if (this._$_hasUnblocked$_) return;
            const t = this._$_audioContext$_;
            "suspended" === t.state && t.resume && t.resume();
            const s = t.createBuffer(1, 220, 22050), i = t.createBufferSource();
            i.buffer = s, i.connect(t.destination), i.start(0), "running" === t.state && this._$_DetachUnblockEvents$_();
        }
        _$_MatchTagLists$_(t, s) {
            for (const i of s) {
                let s = !1;
                for (const e of t) if (self._$AudioDOMHandler$_._$EqualsNoCase$_(e, i)) {
                    s = !0;
                    break;
                }
                if (!s) return !1;
            }
            return !0;
        }
        _$GetAudioContext$_() {
            return this._$_audioContext$_;
        }
        _$GetAudioCurrentTime$_() {
            return this._$_audioContext$_.currentTime;
        }
        _$GetDestinationNode$_() {
            return this._$_destinationNode$_;
        }
        GetAudioContextExtern() {
            return this._$GetAudioContext$_();
        }
        GetDestinationNodeExtern() {
            return this._$GetDestinationNode$_();
        }
        _$GetDestinationForTag$_(t) {
            const s = this._$_effects$_.get(t.toLowerCase());
            return s ? s[0]._$GetInputNode$_() : this._$GetDestinationNode$_();
        }
        _$AddEffectForTag$_(t, s) {
            t = t.toLowerCase();
            let i = this._$_effects$_.get(t);
            i || (i = [], this._$_effects$_.set(t, i)), s._$_SetIndex$_(i.length), s._$_SetTag$_(t), 
            i.push(s), this._$_ReconnectEffects$_(t);
        }
        _$_ReconnectEffects$_(t) {
            t = t.toLowerCase();
            let s = this._$GetDestinationNode$_();
            const i = this._$_effects$_.get(t);
            if (i && i.length) {
                s = i[0]._$GetInputNode$_();
                for (let t = 0, s = i.length; t < s; ++t) {
                    const e = i[t];
                    t + 1 === s ? e._$ConnectTo$_(this._$GetDestinationNode$_()) : e._$ConnectTo$_(i[t + 1]._$GetInputNode$_());
                }
            }
            for (const i of this._$audioInstancesByEffectTag$_(t)) i._$Reconnect$_(s);
            this._$_microphoneSource$_ && this._$_microphoneTag$_ === t && (this._$_microphoneSource$_.disconnect(), 
            this._$_microphoneSource$_.connect(s));
        }
        _$GetMasterVolume$_() {
            return this._$_masterVolume$_;
        }
        _$IsSilent$_() {
            return this._$_isSilent$_;
        }
        _$GetTimeScaleMode$_() {
            return this._$_timeScaleMode$_;
        }
        _$GetTimeScale$_() {
            return this._$_timeScale$_;
        }
        _$GetGameTime$_() {
            return this._$_gameTime$_;
        }
        _$IsPlayMusicAsSound$_() {
            return this._$_playMusicAsSound$_;
        }
        _$GetPanningModel$_() {
            return this._$_panningModel$_;
        }
        _$GetDistanceModel$_() {
            return this._$_distanceModel$_;
        }
        _$GetReferenceDistance$_() {
            return this._$_refDistance$_;
        }
        _$GetMaxDistance$_() {
            return this._$_maxDistance$_;
        }
        _$GetRolloffFactor$_() {
            return this._$_rolloffFactor$_;
        }
        _$TryPlayMedia$_(t) {
            this._$_iRuntime$_._$TryPlayMedia$_(t);
        }
        _$RemovePendingPlay$_(t) {
            this._$_iRuntime$_._$RemovePendingPlay$_(t);
        }
        _$ReleaseInstancesForBuffer$_(t) {
            let s = 0;
            for (let i = 0, e = this._$_audioInstances$_.length; i < e; ++i) {
                const e = this._$_audioInstances$_[i];
                this._$_audioInstances$_[s] = e, e._$GetBuffer$_() === t ? e._$Release$_() : ++s;
            }
            this._$_audioInstances$_.length = s;
        }
        _$ReleaseAllMusicBuffersExceptLast$_() {
            let t = 0;
            for (let s = 0, i = this._$_audioBuffers$_.length; s < i; ++s) {
                const i = this._$_audioBuffers$_[s];
                this._$_audioBuffers$_[t] = i, i._$IsMusic$_() && i !== this._$_lastMusicBuffer$_ ? i._$Release$_() : ++t;
            }
            this._$_audioBuffers$_.length = t;
        }
        * _$audioInstancesMatchingTags$_(t) {
            if (t.length > 0) for (const s of this._$_audioInstances$_) this._$_MatchTagLists$_(s._$GetTags$_(), t) && (yield s); else this._$_lastAudioInstance$_ && !this._$_lastAudioInstance$_._$HasEnded$_() && (yield this._$_lastAudioInstance$_);
        }
        * _$audioInstancesByEffectTag$_(t) {
            if (t) for (const s of this._$_audioInstances$_) self._$AudioDOMHandler$_._$EqualsNoCase$_(s._$GetEffectTag$_(), t) && (yield s); else this._$_lastAudioInstance$_ && !this._$_lastAudioInstance$_._$HasEnded$_() && (yield this._$_lastAudioInstance$_);
        }
        async _$_GetAudioBuffer$_(t, s, i, e, h) {
            for (const t of this._$_audioBuffers$_) if (t._$GetUrl$_() === s) return e && this._$_playMusicAsSound$_ && (this._$_lastMusicBuffer$_ = t), 
            await t._$Load$_(), t;
            if (h) return null;
            e && this._$_playMusicAsSound$_ && this._$ReleaseAllMusicBuffersExceptLast$_();
            const n = self._$C3AudioBuffer$_._$Create$_(this, t, s, i, e);
            return this._$_audioBuffers$_.push(n), e && this._$_playMusicAsSound$_ && (this._$_lastMusicBuffer$_ = n), 
            await n._$Load$_(), this._$_loadedAudioUrls$_.has(t) || (this._$PostToRuntime$_("buffer-metadata", {
                originalUrl: t,
                duration: n._$GetDuration$_()
            }), this._$_loadedAudioUrls$_.add(t)), n;
        }
        async _$_GetAudioInstance$_(t, s, i, e, h) {
            for (const t of this._$_audioInstances$_) if (t._$GetUrl$_() === s && (t._$CanBeRecycled$_() || h)) return h && this._$_playMusicAsSound$_ && (this._$_lastMusicBuffer$_ = t._$GetBuffer$_()), 
            t._$SetTags$_(e), t;
            const n = await this._$_GetAudioBuffer$_(t, s, i, h);
            if (n._$WasReleased$_()) throw new Error(`buffer '${t}' unloaded while loading`);
            const o = n._$CreateInstance$_(e);
            return this._$_audioInstances$_.push(o), o;
        }
        _$_AddPendingTags$_(t) {
            const s = t.join(" ");
            let i = this._$_pendingTags$_.get(s);
            if (!i) {
                let t = null;
                i = {
                    _$pendingCount$_: 0,
                    promise: new Promise((s => t = s)),
                    resolve: t
                }, this._$_pendingTags$_.set(s, i);
            }
            i._$pendingCount$_++;
        }
        _$_RemovePendingTags$_(t) {
            const s = t.join(" "), i = this._$_pendingTags$_.get(s);
            if (!i) throw new Error("expected pending tag");
            i._$pendingCount$_--, 0 === i._$pendingCount$_ && (i.resolve(), this._$_pendingTags$_.delete(s));
        }
        _$TagsReady$_(t) {
            const s = (0 === t.length ? this._$_lastPlayedTags$_ : t).join(" "), i = this._$_pendingTags$_.get(s);
            return i ? i.promise : Promise.resolve();
        }
        _$_MaybeStartTicking$_() {
            if (this._$_analysers$_.size > 0) this._$_StartTicking$_(); else for (const t of this._$_audioInstances$_) if (t._$IsActive$_()) return void this._$_StartTicking$_();
        }
        _$Tick$_() {
            for (const t of this._$_analysers$_) t._$Tick$_();
            const t = this._$GetAudioCurrentTime$_();
            for (const s of this._$_audioInstances$_) s._$Tick$_(t);
            const s = this._$_audioInstances$_.filter((t => t._$IsActive$_())).map((t => t._$GetState$_()));
            this._$PostToRuntime$_("state", {
                tickCount: this._$_lastTickCount$_,
                outputLatency: this._$_audioContext$_.outputLatency || 0,
                audioInstances: s,
                analysers: [ ...this._$_analysers$_ ].map((t => t._$GetData$_()))
            }), 0 === s.length && 0 === this._$_analysers$_.size && this._$_StopTicking$_();
        }
        _$PostTrigger$_(t, s, i) {
            this._$PostToRuntime$_("trigger", {
                type: t,
                tags: s,
                aiid: i
            });
        }
        async _$_Play$_(t) {
            const s = t.originalUrl, i = t.url, e = t.type, h = t.isMusic, n = t.tags, o = t.isLooping, r = t.vol, a = t.pos, c = t.panning, l = t.stereoPan;
            let u = t.off;
            if (u > 0 && !t.trueClock) if (this._$_audioContext$_.getOutputTimestamp) {
                const t = this._$_audioContext$_.getOutputTimestamp();
                u = u - t.performanceTime / 1e3 + t.contextTime;
            } else u = u - performance.now() / 1e3 + this._$_audioContext$_.currentTime;
            this._$_lastPlayedTags$_ = n.slice(0), this._$_AddPendingTags$_(n);
            try {
                this._$_lastAudioInstance$_ = await this._$_GetAudioInstance$_(s, i, e, n, h), c ? (this._$_lastAudioInstance$_._$SetPannerEnabled$_(!0), 
                this._$_lastAudioInstance$_._$SetPan$_(c.x, c.y, c.z, c.angle, c.innerAngle, c.outerAngle, c.outerGain), 
                c.hasOwnProperty("uid") && this._$_lastAudioInstance$_._$SetUID$_(c.uid)) : "number" == typeof l && 0 !== l ? (this._$_lastAudioInstance$_._$SetStereoPannerEnabled$_(!0), 
                this._$_lastAudioInstance$_._$SetStereoPan$_(l)) : (this._$_lastAudioInstance$_._$SetPannerEnabled$_(!1), 
                this._$_lastAudioInstance$_._$SetStereoPannerEnabled$_(!1)), this._$_lastAudioInstance$_.Play(o, r, a, u);
            } catch (t) {
                return void console.error("[Construct] Audio: error starting playback: ", t);
            } finally {
                this._$_RemovePendingTags$_(n);
            }
            this._$_StartTicking$_();
        }
        _$_Stop$_(t) {
            const s = t.tags;
            for (const t of this._$audioInstancesMatchingTags$_(s)) t._$Stop$_();
        }
        _$_StopAll$_() {
            for (const t of this._$_audioInstances$_) t._$Stop$_();
        }
        _$_SetPaused$_(t) {
            const s = t.tags, i = t.paused;
            for (const t of this._$audioInstancesMatchingTags$_(s)) i ? t._$Pause$_() : t._$Resume$_();
            this._$_MaybeStartTicking$_();
        }
        _$_SetVolume$_(t) {
            const s = t.tags, i = t.vol;
            for (const t of this._$audioInstancesMatchingTags$_(s)) t._$SetVolume$_(i);
        }
        _$_SetStereoPan$_(t) {
            const s = t.tags, i = t.p;
            for (const t of this._$audioInstancesMatchingTags$_(s)) t._$SetStereoPannerEnabled$_(!0), 
            t._$SetStereoPan$_(i);
        }
        async _$_FadeVolume$_(t) {
            const s = t.tags, i = t.vol, e = t.duration, h = t.stopOnEnd;
            await this._$TagsReady$_(s);
            for (const t of this._$audioInstancesMatchingTags$_(s)) t._$FadeVolume$_(i, e, h);
            this._$_MaybeStartTicking$_();
        }
        _$_SetMasterVolume$_(t) {
            this._$_masterVolume$_ = t.vol, this._$_destinationNode$_.gain.value = this._$_masterVolume$_;
        }
        _$_SetMuted$_(t) {
            const s = t.tags, i = t.isMuted;
            for (const t of this._$audioInstancesMatchingTags$_(s)) t._$SetMuted$_(i);
        }
        _$_SetSilent$_(t) {
            this._$_isSilent$_ = t.isSilent, this._$_iRuntime$_._$SetSilent$_(this._$_isSilent$_);
            for (const t of this._$_audioInstances$_) t._$_UpdateMuted$_();
        }
        _$_SetLooping$_(t) {
            const s = t.tags, i = t.isLooping;
            for (const t of this._$audioInstancesMatchingTags$_(s)) t._$SetLooping$_(i);
        }
        async _$_SetPlaybackRate$_(t) {
            const s = t.tags, i = t.rate;
            await this._$TagsReady$_(s);
            for (const t of this._$audioInstancesMatchingTags$_(s)) t._$SetPlaybackRate$_(i);
        }
        async _$_Seek$_(t) {
            const s = t.tags, i = t.pos;
            await this._$TagsReady$_(s);
            for (const t of this._$audioInstancesMatchingTags$_(s)) t._$Seek$_(i);
        }
        async _$_Preload$_(t) {
            const s = t.originalUrl, i = t.url, e = t.type, h = t.isMusic;
            try {
                await this._$_GetAudioInstance$_(s, i, e, "", h);
            } catch (t) {
                console.error("[Construct] Audio: error preloading: ", t);
            }
        }
        async _$_Unload$_(t) {
            const s = t.url, i = t.type, e = t.isMusic, h = await this._$_GetAudioBuffer$_("", s, i, e, !0);
            if (!h) return;
            h._$Release$_(), this._$_lastMusicBuffer$_ === h && (this._$_lastMusicBuffer$_ = null);
            const n = this._$_audioBuffers$_.indexOf(h);
            -1 !== n && this._$_audioBuffers$_.splice(n, 1);
        }
        _$_UnloadAll$_() {
            for (const t of this._$_audioBuffers$_) t._$Release$_(), this._$_lastMusicBuffer$_ === t && (this._$_lastMusicBuffer$_ = null);
            this._$_audioBuffers$_.length = 0;
        }
        _$_SetSuspended$_(t) {
            const s = t.isSuspended;
            !s && this._$_audioContext$_.resume && this._$_audioContext$_.resume();
            for (const t of this._$_audioInstances$_) t._$SetSuspended$_(s);
            s && this._$_audioContext$_.suspend && this._$_audioContext$_.suspend();
        }
        _$_OnTick$_(t) {
            if (this._$_timeScale$_ = t.timeScale, this._$_gameTime$_ = t.gameTime, this._$_lastTickCount$_ = t.tickCount, 
            0 !== this._$_timeScaleMode$_) for (const t of this._$_audioInstances$_) t._$_UpdatePlaybackRate$_();
            const s = t.listenerPos;
            !s || this._$_lastListenerPos$_[0] === s[0] && this._$_lastListenerPos$_[1] === s[1] && this._$_lastListenerPos$_[2] === s[2] || (this._$_lastListenerPos$_[0] = s[0], 
            this._$_lastListenerPos$_[1] = s[1], this._$_lastListenerPos$_[2] = s[2], this._$_audioContext$_.listener.setPosition(s[0], s[1], s[2]));
            const i = t.listenerOrientation;
            if (i && (this._$_lastListenerOrientation$_[0] !== i[0] || this._$_lastListenerOrientation$_[1] !== i[1] || this._$_lastListenerOrientation$_[2] !== i[2] || this._$_lastListenerOrientation$_[3] !== i[3] || this._$_lastListenerOrientation$_[4] !== i[4] || this._$_lastListenerOrientation$_[5] !== i[5])) {
                for (let t = 0; t < 6; ++t) this._$_lastListenerOrientation$_[t] = i[t];
                this._$_audioContext$_.listener.setOrientation(...this._$_lastListenerOrientation$_);
            }
            for (const s of t.instPans) {
                const t = s.uid;
                for (const i of this._$_audioInstances$_) i._$GetUID$_() === t && i._$SetPanXYZA$_(s.x, s.y, s.z, s.angle);
            }
        }
        async _$_AddEffect$_(t) {
            const s = t.type, i = t.hasOwnProperty("tags") ? t.tags : [ t.tag ], e = t.params;
            let h, n;
            if ("convolution" === s) try {
                n = await this._$_GetAudioBuffer$_(t.bufferOriginalUrl, t.bufferUrl, t.bufferType, !1);
            } catch (t) {
                return void console.log("[Construct] Audio: error loading convolution: ", t);
            }
            for (const o of i) {
                if ("filter" === s) h = new self._$C3AudioFilterFX$_(this, ...e); else if ("delay" === s) h = new self._$C3AudioDelayFX$_(this, ...e); else if ("convolution" === s) h = new self._$C3AudioConvolveFX$_(this, n._$GetAudioBuffer$_(), ...e), 
                h._$_SetBufferInfo$_(t.bufferOriginalUrl, t.bufferUrl, t.bufferType); else if ("flanger" === s) h = new self._$C3AudioFlangerFX$_(this, ...e); else if ("phaser" === s) h = new self._$C3AudioPhaserFX$_(this, ...e); else if ("gain" === s) h = new self._$C3AudioGainFX$_(this, ...e); else if ("stereopan" === s) h = new self._$C3AudioStereoPanFX$_(this, ...e); else if ("tremolo" === s) h = new self._$C3AudioTremoloFX$_(this, ...e); else if ("ringmod" === s) h = new self._$C3AudioRingModFX$_(this, ...e); else if ("distortion" === s) h = new self._$C3AudioDistortionFX$_(this, ...e); else if ("compressor" === s) h = new self._$C3AudioCompressorFX$_(this, ...e); else {
                    if ("analyser" !== s) throw new Error("invalid effect type");
                    h = new self._$C3AudioAnalyserFX$_(this, ...e);
                }
                this._$AddEffectForTag$_(o, h);
            }
            this._$_PostUpdatedFxState$_();
        }
        _$_SetEffectParam$_(t) {
            const s = t.tags, i = t.index, e = t.param, h = t.value, n = t.ramp, o = t.time;
            for (const t of s) {
                const s = this._$_effects$_.get(t.toLowerCase());
                !s || i < 0 || i >= s.length || s[i]._$SetParam$_(e, h, n, o);
            }
            this._$_PostUpdatedFxState$_();
        }
        _$_RemoveEffects$_(t) {
            const s = t.tags;
            for (const t of s) {
                const s = t.toLowerCase(), i = this._$_effects$_.get(s);
                if (!i || !i.length) return;
                for (const t of i) t._$Release$_();
                this._$_effects$_.delete(s), this._$_ReconnectEffects$_(s);
            }
        }
        _$_AddAnalyser$_(t) {
            this._$_analysers$_.add(t), this._$_MaybeStartTicking$_();
        }
        _$_RemoveAnalyser$_(t) {
            this._$_analysers$_.delete(t);
        }
        _$_PostUpdatedFxState$_() {
            this._$_isPendingPostFxState$_ || (this._$_isPendingPostFxState$_ = !0, Promise.resolve().then((() => this._$_DoPostUpdatedFxState$_())));
        }
        _$_DoPostUpdatedFxState$_() {
            const t = {};
            for (const [s, i] of this._$_effects$_) t[s] = i.map((t => t._$GetState$_()));
            this._$PostToRuntime$_("fxstate", {
                fxstate: t
            }), this._$_isPendingPostFxState$_ = !1;
        }
        async _$_OnLoadState$_(t) {
            const s = t.saveLoadMode;
            if (3 !== s) {
                const t = [];
                for (const i of this._$_audioInstances$_) i._$IsMusic$_() && 1 === s || !i._$IsMusic$_() && 2 === s ? t.push(i) : i._$Release$_();
                this._$_audioInstances$_ = t;
            }
            for (const t of this._$_effects$_.values()) for (const s of t) s._$Release$_();
            this._$_effects$_.clear(), this._$_timeScale$_ = t.timeScale, this._$_gameTime$_ = t.gameTime;
            const i = t.listenerPos;
            this._$_lastListenerPos$_[0] = i[0], this._$_lastListenerPos$_[1] = i[1], this._$_lastListenerPos$_[2] = i[2], 
            this._$_audioContext$_.listener.setPosition(i[0], i[1], i[2]);
            const e = t.listenerOrientation;
            if (Array.isArray(e)) {
                for (let t = 0; t < 6; ++t) this._$_lastListenerOrientation$_[t] = e[t];
                this._$_audioContext$_.listener.setOrientation(...this._$_lastListenerOrientation$_);
            }
            this._$_isSilent$_ = t.isSilent, this._$_iRuntime$_._$SetSilent$_(this._$_isSilent$_), 
            this._$_masterVolume$_ = t.masterVolume, this._$_destinationNode$_.gain.value = this._$_masterVolume$_;
            const h = [];
            for (const s of Object.values(t.effects)) h.push(Promise.all(s.map((t => this._$_AddEffect$_(t)))));
            await Promise.all(h), await Promise.all(t.playing.map((t => this._$_LoadAudioInstance$_(t, s)))), 
            this._$_MaybeStartTicking$_();
        }
        async _$_LoadAudioInstance$_(t, s) {
            if (3 === s) return;
            const i = t.bufferOriginalUrl, e = t.bufferUrl, h = t.bufferType, n = t.isMusic, o = t.tags, r = t.isLooping, a = t.volume, c = t.playbackTime;
            if (n && 1 === s) return;
            if (!n && 2 === s) return;
            let l = null;
            try {
                l = await this._$_GetAudioInstance$_(i, e, h, o, n);
            } catch (t) {
                return void console.error("[Construct] Audio: error loading audio state: ", t);
            }
            l._$LoadPanState$_(t.pan), l._$LoadStereoPanState$_(t.stereoPan), l.Play(r, a, c, 0), 
            t.isPlaying || l._$Pause$_(), l._$_LoadAdditionalState$_(t);
        }
        _$_OnMicrophoneStream$_(t, s) {
            this._$_microphoneSource$_ && this._$_microphoneSource$_.disconnect(), this._$_microphoneTag$_ = s.toLowerCase(), 
            this._$_microphoneSource$_ = this._$_audioContext$_.createMediaStreamSource(t), 
            this._$_microphoneSource$_.connect(this._$GetDestinationForTag$_(this._$_microphoneTag$_));
        }
        _$_OnGetOutputStream$_() {
            return this._$_destMediaStreamNode$_ || (this._$_destMediaStreamNode$_ = this._$_audioContext$_.createMediaStreamDestination(), 
            this._$_destinationNode$_.connect(this._$_destMediaStreamNode$_)), this._$_destMediaStreamNode$_.stream;
        }
        async _$_OnOfflineRenderAudio$_(t) {
            try {
                const s = t.time, i = this._$_audioContext$_.suspend(s);
                this._$_hasStartedOfflineRender$_ ? this._$_audioContext$_.resume() : (this._$_audioContext$_.startRendering().then((t => this._$_OnOfflineRenderCompleted$_(t))).catch((t => this._$_OnOfflineRenderError$_(t))), 
                this._$_hasStartedOfflineRender$_ = !0), await i;
            } catch (t) {
                this._$_OnOfflineRenderError$_(t);
            }
        }
        _$_OnOfflineRenderFinish$_() {
            this._$_audioContext$_.resume();
        }
        _$_OnOfflineRenderCompleted$_(t) {
            const s = [];
            for (let i = 0, e = t.numberOfChannels; i < e; ++i) {
                const e = t.getChannelData(i);
                s.push(e.buffer);
            }
            this._$_iRuntime$_._$PostToRuntimeComponent$_("runtime", "offline-audio-render-completed", {
                duration: t.duration,
                length: t.length,
                numberOfChannels: t.numberOfChannels,
                sampleRate: t.sampleRate,
                channelData: s
            }, null, s);
        }
        _$_OnOfflineRenderError$_(t) {
            console.error("[Audio] Offline rendering error: ", t);
        }
        static _$EqualsNoCase$_(t, s) {
            return t === s || t.normalize().toLowerCase() === s.normalize().toLowerCase();
        }
        static _$ToDegrees$_(t) {
            return t * $;
        }
        static _$DbToLinearNoCap$_(t) {
            return Math.pow(10, t / 20);
        }
        static _$DbToLinear$_(t) {
            return Math.max(Math.min(self._$AudioDOMHandler$_._$DbToLinearNoCap$_(t), 1), 0);
        }
        static _$LinearToDbNoCap$_(t) {
            return Math.log(t) / Math.log(10) * 20;
        }
        static _$LinearToDb$_(t) {
            return self._$AudioDOMHandler$_._$LinearToDbNoCap$_(Math.max(Math.min(t, 1), 0));
        }
        static _$e4$_(t, s) {
            return 1 - Math.exp(-s * t);
        }
    }, self._$RuntimeInterface$_._$AddDOMHandlerClass$_(self._$AudioDOMHandler$_);
}

self._$C3AudioBuffer$_ = class {
    constructor(t, s, i, e, h) {
        this._$_audioDomHandler$_ = t, this._$_originalUrl$_ = s, this._$_url$_ = i, this._$_type$_ = e, 
        this._$_isMusic$_ = h, this._$_api$_ = "", this._$_loadState$_ = "not-loaded", this._$_loadPromise$_ = null;
    }
    _$Release$_() {
        this._$_loadState$_ = "not-loaded", this._$_audioDomHandler$_ = null, this._$_loadPromise$_ = null;
    }
    _$WasReleased$_() {
        return !this._$_audioDomHandler$_;
    }
    static _$Create$_(t, s, i, e, h) {
        return !h || t._$IsPlayMusicAsSound$_() ? new self._$C3WebAudioBuffer$_(t, s, i, e, h) : new self._$C3Html5AudioBuffer$_(t, s, i, e, h);
    }
    _$CreateInstance$_(t) {
        return "html5" === this._$_api$_ ? new self._$C3Html5AudioInstance$_(this._$_audioDomHandler$_, this, t) : new self._$C3WebAudioInstance$_(this._$_audioDomHandler$_, this, t);
    }
    _$_Load$_() {}
    _$Load$_() {
        return this._$_loadPromise$_ || (this._$_loadPromise$_ = this._$_Load$_()), this._$_loadPromise$_;
    }
    _$IsLoaded$_() {}
    _$IsLoadedAndDecoded$_() {}
    _$HasFailedToLoad$_() {
        return "failed" === this._$_loadState$_;
    }
    _$GetAudioContext$_() {
        return this._$_audioDomHandler$_._$GetAudioContext$_();
    }
    _$GetApi$_() {
        return this._$_api$_;
    }
    _$GetOriginalUrl$_() {
        return this._$_originalUrl$_;
    }
    _$GetUrl$_() {
        return this._$_url$_;
    }
    _$GetContentType$_() {
        return this._$_type$_;
    }
    _$IsMusic$_() {
        return this._$_isMusic$_;
    }
    _$GetDuration$_() {}
}, self._$C3Html5AudioBuffer$_ = class extends self._$C3AudioBuffer$_ {
    constructor(t, s, i, e, h) {
        super(t, s, i, e, h), this._$_api$_ = "html5", this._$_audioElem$_ = new Audio, 
        this._$_audioElem$_.crossOrigin = "anonymous", this._$_audioElem$_.autoplay = !1, 
        this._$_audioElem$_.preload = "auto", this._$_loadResolve$_ = null, this._$_loadReject$_ = null, 
        this._$_reachedCanPlayThrough$_ = !1, this._$_audioElem$_.addEventListener("canplaythrough", (() => this._$_reachedCanPlayThrough$_ = !0)), 
        this._$_outNode$_ = this._$GetAudioContext$_().createGain(), this._$_mediaSourceNode$_ = null, 
        this._$_audioElem$_.addEventListener("canplay", (() => {
            this._$_loadResolve$_ && (this._$_loadState$_ = "loaded", this._$_loadResolve$_(), 
            this._$_loadResolve$_ = null, this._$_loadReject$_ = null), !this._$_mediaSourceNode$_ && this._$_audioElem$_ && (this._$_mediaSourceNode$_ = this._$GetAudioContext$_().createMediaElementSource(this._$_audioElem$_), 
            this._$_mediaSourceNode$_.connect(this._$_outNode$_));
        })), this.onended = null, this._$_audioElem$_.addEventListener("ended", (() => {
            this.onended && this.onended();
        })), this._$_audioElem$_.addEventListener("error", (t => this._$_OnError$_(t)));
    }
    _$Release$_() {
        this._$_audioDomHandler$_._$ReleaseInstancesForBuffer$_(this), this._$_outNode$_.disconnect(), 
        this._$_outNode$_ = null, this._$_mediaSourceNode$_.disconnect(), this._$_mediaSourceNode$_ = null, 
        this._$_audioElem$_ && !this._$_audioElem$_.paused && this._$_audioElem$_.pause(), 
        this.onended = null, this._$_audioElem$_ = null, super._$Release$_();
    }
    _$_Load$_() {
        return this._$_loadState$_ = "loading", new Promise(((t, s) => {
            this._$_loadResolve$_ = t, this._$_loadReject$_ = s, this._$_audioElem$_.src = this._$_url$_;
        }));
    }
    _$_OnError$_(t) {
        console.error(`[Construct] Audio '${this._$_url$_}' error: `, t), this._$_loadReject$_ && (this._$_loadState$_ = "failed", 
        this._$_loadReject$_(t), this._$_loadResolve$_ = null, this._$_loadReject$_ = null);
    }
    _$IsLoaded$_() {
        const t = this._$_audioElem$_.readyState >= 4;
        return t && (this._$_reachedCanPlayThrough$_ = !0), t || this._$_reachedCanPlayThrough$_;
    }
    _$IsLoadedAndDecoded$_() {
        return this._$IsLoaded$_();
    }
    _$GetAudioElement$_() {
        return this._$_audioElem$_;
    }
    _$GetOutputNode$_() {
        return this._$_outNode$_;
    }
    _$GetDuration$_() {
        return this._$_audioElem$_.duration;
    }
}, self._$C3WebAudioBuffer$_ = class extends self._$C3AudioBuffer$_ {
    constructor(t, s, i, e, h) {
        super(t, s, i, e, h), this._$_api$_ = "webaudio", this._$_audioData$_ = null, this._$_audioBuffer$_ = null;
    }
    _$Release$_() {
        this._$_audioDomHandler$_._$ReleaseInstancesForBuffer$_(this), this._$_audioData$_ = null, 
        this._$_audioBuffer$_ = null, super._$Release$_();
    }
    async _$_Fetch$_() {
        if (this._$_audioData$_) return this._$_audioData$_;
        const t = this._$_audioDomHandler$_._$GetRuntimeInterface$_();
        if ("cordova" === t._$GetExportType$_() && t._$IsRelativeURL$_(this._$_url$_) && t._$IsFileProtocol$_()) this._$_audioData$_ = await t._$CordovaFetchLocalFileAsArrayBuffer$_(this._$_url$_); else if ("playable-ad-single-file" === t._$GetExportType$_() && t._$IsRelativeURL$_(this._$_url$_)) {
            const s = t._PlayableAdFetchBlob(this._$_url$_);
            this._$_audioData$_ = await s.arrayBuffer();
        } else {
            const t = await fetch(this._$_url$_);
            if (!t.ok) throw new Error(`error fetching audio data: ${t.status} ${t.statusText}`);
            this._$_audioData$_ = await t.arrayBuffer();
        }
    }
    async _$_Decode$_() {
        if (this._$_audioBuffer$_) return this._$_audioBuffer$_;
        const t = this._$_audioDomHandler$_._$GetAudioContext$_();
        this._$_audioBuffer$_ = await t.decodeAudioData(this._$_audioData$_), this._$_audioData$_ = null;
    }
    async _$_Load$_() {
        try {
            if (this._$_loadState$_ = "loading", await this._$_Fetch$_(), this._$WasReleased$_()) return;
            await this._$_Decode$_(), this._$_loadState$_ = "loaded";
        } catch (t) {
            this._$_loadState$_ = "failed", console.error(`[Construct] Failed to load audio '${this._$_url$_}': `, t);
        }
    }
    _$IsLoaded$_() {
        return !(!this._$_audioData$_ && !this._$_audioBuffer$_);
    }
    _$IsLoadedAndDecoded$_() {
        return !!this._$_audioBuffer$_;
    }
    _$GetAudioBuffer$_() {
        return this._$_audioBuffer$_;
    }
    _$GetDuration$_() {
        return this._$_audioBuffer$_ ? this._$_audioBuffer$_.duration : 0;
    }
};

{
    let Y = 0;
    self._$C3AudioInstance$_ = class {
        constructor(t, s, i) {
            this._$_audioDomHandler$_ = t, this._$_buffer$_ = s, this._$_tags$_ = i, this._$_aiId$_ = Y++, 
            this._$_gainNode$_ = this._$GetAudioContext$_().createGain(), this._$_gainNode$_.connect(this._$GetDestinationNode$_()), 
            this._$_pannerNode$_ = null, this._$_isPannerEnabled$_ = !1, this._$_pannerPosition$_ = [ 0, 0, 0 ], 
            this._$_pannerOrientation$_ = [ 0, 0, 0 ], this._$_pannerConeParams$_ = [ 0, 0, 0 ], 
            this._$_stereoPannerNode$_ = null, this._$_isStereoPannerEnabled$_ = !1, this._$_stereoPan$_ = 0, 
            this._$_isStopped$_ = !0, this._$_isPaused$_ = !1, this._$_resumeMe$_ = !1, this._$_isLooping$_ = !1, 
            this._$_volume$_ = 1, this._$_isMuted$_ = !1, this._$_playbackRate$_ = 1;
            const e = this._$_audioDomHandler$_._$GetTimeScaleMode$_();
            this._$_isTimescaled$_ = 1 === e && !this._$IsMusic$_() || 2 === e, this._$_instUid$_ = -1, 
            this._$_fadeEndTime$_ = -1, this._$_stopOnFadeEnd$_ = !1;
        }
        _$Release$_() {
            this._$_audioDomHandler$_ = null, this._$_buffer$_ = null, this._$_pannerNode$_ && (this._$_pannerNode$_.disconnect(), 
            this._$_pannerNode$_ = null), this._$_stereoPannerNode$_ && (this._$_stereoPannerNode$_.disconnect(), 
            this._$_stereoPannerNode$_ = null), this._$_gainNode$_.disconnect(), this._$_gainNode$_ = null;
        }
        _$GetAudioContext$_() {
            return this._$_audioDomHandler$_._$GetAudioContext$_();
        }
        _$SetTags$_(t) {
            this._$_tags$_ = t;
        }
        _$GetTags$_() {
            return this._$_tags$_;
        }
        _$GetEffectTag$_() {
            return this._$_tags$_.length > 0 ? this._$_tags$_[0] : "";
        }
        _$GetDestinationNode$_() {
            return this._$_audioDomHandler$_._$GetDestinationForTag$_(this._$GetEffectTag$_());
        }
        _$GetCurrentTime$_() {
            return this._$_isTimescaled$_ ? this._$_audioDomHandler$_._$GetGameTime$_() : performance.now() / 1e3;
        }
        _$GetOriginalUrl$_() {
            return this._$_buffer$_._$GetOriginalUrl$_();
        }
        _$GetUrl$_() {
            return this._$_buffer$_._$GetUrl$_();
        }
        _$GetContentType$_() {
            return this._$_buffer$_._$GetContentType$_();
        }
        _$GetBuffer$_() {
            return this._$_buffer$_;
        }
        _$IsMusic$_() {
            return this._$_buffer$_._$IsMusic$_();
        }
        _$GetAiId$_() {
            return this._$_aiId$_;
        }
        _$HasEnded$_() {}
        _$CanBeRecycled$_() {}
        IsPlaying() {
            return !this._$_isStopped$_ && !this._$_isPaused$_ && !this._$HasEnded$_();
        }
        _$IsActive$_() {
            return !this._$_isStopped$_ && !this._$HasEnded$_();
        }
        _$GetPlaybackTime$_() {}
        _$GetDuration$_(t) {
            let s = this._$_buffer$_._$GetDuration$_();
            return t && (s /= this._$_playbackRate$_ || .001), s;
        }
        Play(t, s, i, e) {}
        _$Stop$_() {}
        _$Pause$_() {}
        _$IsPaused$_() {
            return this._$_isPaused$_;
        }
        _$Resume$_() {}
        _$SetVolume$_(t) {
            this._$_volume$_ = t, this._$_gainNode$_.gain.cancelScheduledValues(0), this._$_fadeEndTime$_ = -1, 
            this._$_gainNode$_.gain.value = this._$GetOutputVolume$_();
        }
        _$FadeVolume$_(t, s, i) {
            if (this._$IsMuted$_()) return;
            const e = this._$_gainNode$_.gain;
            e.cancelScheduledValues(0);
            const h = this._$_audioDomHandler$_._$GetAudioCurrentTime$_(), n = h + s;
            e.setValueAtTime(e.value, h), e.linearRampToValueAtTime(t, n), this._$_volume$_ = t, 
            this._$_fadeEndTime$_ = n, this._$_stopOnFadeEnd$_ = i;
        }
        _$_UpdateVolume$_() {
            this._$SetVolume$_(this._$_volume$_);
        }
        _$Tick$_(t) {
            -1 !== this._$_fadeEndTime$_ && t >= this._$_fadeEndTime$_ && (this._$_fadeEndTime$_ = -1, 
            this._$_stopOnFadeEnd$_ && this._$Stop$_(), this._$_audioDomHandler$_._$PostTrigger$_("fade-ended", this._$_tags$_, this._$_aiId$_));
        }
        _$GetOutputVolume$_() {
            const t = this._$_volume$_;
            return isFinite(t) ? t : 0;
        }
        _$SetMuted$_(t) {
            t = !!t, this._$_isMuted$_ !== t && (this._$_isMuted$_ = t, this._$_UpdateMuted$_());
        }
        _$IsMuted$_() {
            return this._$_isMuted$_;
        }
        _$IsSilent$_() {
            return this._$_audioDomHandler$_._$IsSilent$_();
        }
        _$_UpdateMuted$_() {}
        _$SetLooping$_(t) {}
        _$IsLooping$_() {
            return this._$_isLooping$_;
        }
        _$SetPlaybackRate$_(t) {
            this._$_playbackRate$_ !== t && (this._$_playbackRate$_ = t, this._$_UpdatePlaybackRate$_());
        }
        _$_UpdatePlaybackRate$_() {}
        _$GetPlaybackRate$_() {
            return this._$_playbackRate$_;
        }
        _$Seek$_(t) {}
        _$SetSuspended$_(t) {}
        _$SetPannerEnabled$_(t) {
            t = !!t, this._$_isPannerEnabled$_ !== t && (this._$_isPannerEnabled$_ = t, this._$_isPannerEnabled$_ ? (this._$SetStereoPannerEnabled$_(!1), 
            this._$_pannerNode$_ || (this._$_pannerNode$_ = this._$GetAudioContext$_().createPanner(), 
            this._$_pannerNode$_.panningModel = this._$_audioDomHandler$_._$GetPanningModel$_(), 
            this._$_pannerNode$_.distanceModel = this._$_audioDomHandler$_._$GetDistanceModel$_(), 
            this._$_pannerNode$_.refDistance = this._$_audioDomHandler$_._$GetReferenceDistance$_(), 
            this._$_pannerNode$_.maxDistance = this._$_audioDomHandler$_._$GetMaxDistance$_(), 
            this._$_pannerNode$_.rolloffFactor = this._$_audioDomHandler$_._$GetRolloffFactor$_()), 
            this._$_gainNode$_.disconnect(), this._$_gainNode$_.connect(this._$_pannerNode$_), 
            this._$_pannerNode$_.connect(this._$GetDestinationNode$_())) : (this._$_pannerNode$_.disconnect(), 
            this._$_gainNode$_.disconnect(), this._$_gainNode$_.connect(this._$GetDestinationNode$_())));
        }
        _$SetPan$_(t, s, i, e, h, n, o) {
            if (!this._$_isPannerEnabled$_) return;
            this._$SetPanXYZA$_(t, s, i, e);
            const r = self._$AudioDOMHandler$_._$ToDegrees$_;
            this._$_pannerConeParams$_[0] !== r(h) && (this._$_pannerConeParams$_[0] = r(h), 
            this._$_pannerNode$_.coneInnerAngle = r(h)), this._$_pannerConeParams$_[1] !== r(n) && (this._$_pannerConeParams$_[1] = r(n), 
            this._$_pannerNode$_.coneOuterAngle = r(n)), this._$_pannerConeParams$_[2] !== o && (this._$_pannerConeParams$_[2] = o, 
            this._$_pannerNode$_.coneOuterGain = o);
        }
        _$SetPanXYZA$_(t, s, i, e) {
            if (!this._$_isPannerEnabled$_) return;
            const h = this._$_pannerPosition$_, n = this._$_pannerOrientation$_, o = Math.cos(e), r = Math.sin(e);
            h[0] === t && h[1] === s && h[2] === i || (h[0] = t, h[1] = s, h[2] = i, this._$_pannerNode$_.setPosition(...h)), 
            n[0] === o && n[1] === r && 0 === n[2] || (n[0] = o, n[1] = r, n[2] = 0, this._$_pannerNode$_.setOrientation(...n));
        }
        _$SetStereoPannerEnabled$_(t) {
            t = !!t, this._$_isStereoPannerEnabled$_ !== t && (this._$_isStereoPannerEnabled$_ = t, 
            this._$_isStereoPannerEnabled$_ ? (this._$SetPannerEnabled$_(!1), this._$_stereoPannerNode$_ = this._$GetAudioContext$_().createStereoPanner(), 
            this._$_gainNode$_.disconnect(), this._$_gainNode$_.connect(this._$_stereoPannerNode$_), 
            this._$_stereoPannerNode$_.connect(this._$GetDestinationNode$_())) : (this._$_stereoPannerNode$_.disconnect(), 
            this._$_stereoPannerNode$_ = null, this._$_gainNode$_.disconnect(), this._$_gainNode$_.connect(this._$GetDestinationNode$_())));
        }
        _$SetStereoPan$_(t) {
            this._$_isStereoPannerEnabled$_ && this._$_stereoPan$_ !== t && (this._$_stereoPannerNode$_.pan.value = t, 
            this._$_stereoPan$_ = t);
        }
        _$SetUID$_(t) {
            this._$_instUid$_ = t;
        }
        _$GetUID$_() {
            return this._$_instUid$_;
        }
        _$GetResumePosition$_() {}
        _$Reconnect$_(t) {
            const s = this._$_stereoPannerNode$_ || this._$_pannerNode$_ || this._$_gainNode$_;
            s.disconnect(), s.connect(t);
        }
        _$GetState$_() {
            return {
                aiid: this._$GetAiId$_(),
                tags: this._$_tags$_,
                duration: this._$GetDuration$_(),
                volume: -1 === this._$_fadeEndTime$_ ? this._$_volume$_ : this._$_gainNode$_.gain.value,
                isPlaying: this.IsPlaying(),
                playbackTime: this._$GetPlaybackTime$_(),
                playbackRate: this._$GetPlaybackRate$_(),
                uid: this._$_instUid$_,
                bufferOriginalUrl: this._$GetOriginalUrl$_(),
                bufferUrl: "",
                bufferType: this._$GetContentType$_(),
                isMusic: this._$IsMusic$_(),
                isLooping: this._$IsLooping$_(),
                isMuted: this._$IsMuted$_(),
                resumePosition: this._$GetResumePosition$_(),
                pan: this._$GetPanState$_(),
                stereoPan: this._$GetStereoPanState$_()
            };
        }
        _$_LoadAdditionalState$_(t) {
            this._$SetPlaybackRate$_(t.playbackRate), this._$SetMuted$_(t.isMuted);
        }
        _$GetPanState$_() {
            if (!this._$_pannerNode$_) return null;
            const t = this._$_pannerNode$_;
            return {
                pos: this._$_pannerPosition$_,
                orient: this._$_pannerOrientation$_,
                cia: t.coneInnerAngle,
                coa: t.coneOuterAngle,
                cog: t.coneOuterGain,
                uid: this._$_instUid$_
            };
        }
        _$LoadPanState$_(t) {
            if (!t) return void this._$SetPannerEnabled$_(!1);
            this._$SetPannerEnabled$_(!0);
            const s = this._$_pannerNode$_, i = t.pos;
            this._$_pannerPosition$_[0] = i[0], this._$_pannerPosition$_[1] = i[1], this._$_pannerPosition$_[2] = i[2];
            const e = t.orient;
            this._$_pannerOrientation$_[0] = e[0], this._$_pannerOrientation$_[1] = e[1], this._$_pannerOrientation$_[2] = e[2], 
            s.setPosition(...this._$_pannerPosition$_), s.setOrientation(...this._$_pannerOrientation$_), 
            this._$_pannerConeParams$_[0] = t.cia, this._$_pannerConeParams$_[1] = t.coa, this._$_pannerConeParams$_[2] = t.cog, 
            s.coneInnerAngle = t.cia, s.coneOuterAngle = t.coa, s.coneOuterGain = t.cog, this._$_instUid$_ = t.uid;
        }
        _$GetStereoPanState$_() {
            return this._$_stereoPannerNode$_ ? this._$_stereoPan$_ : null;
        }
        _$LoadStereoPanState$_(t) {
            "number" == typeof t ? (this._$SetStereoPannerEnabled$_(!0), this._$SetStereoPan$_(t)) : this._$SetStereoPannerEnabled$_(!1);
        }
    };
}

self._$C3Html5AudioInstance$_ = class extends self._$C3AudioInstance$_ {
    constructor(t, s, i) {
        super(t, s, i), this._$_buffer$_._$GetOutputNode$_().connect(this._$_gainNode$_), 
        this._$_buffer$_.onended = () => this._$_OnEnded$_();
    }
    _$Release$_() {
        this._$Stop$_(), this._$_buffer$_._$GetOutputNode$_().disconnect(), super._$Release$_();
    }
    _$GetAudioElement$_() {
        return this._$_buffer$_._$GetAudioElement$_();
    }
    _$_OnEnded$_() {
        this._$_isStopped$_ = !0, this._$_instUid$_ = -1, this._$_audioDomHandler$_._$PostTrigger$_("ended", this._$_tags$_, this._$_aiId$_);
    }
    _$HasEnded$_() {
        return this._$GetAudioElement$_().ended;
    }
    _$CanBeRecycled$_() {
        return !!this._$_isStopped$_ || this._$HasEnded$_();
    }
    _$GetPlaybackTime$_() {
        let t = this._$GetAudioElement$_().currentTime;
        return this._$_isLooping$_ || (t = Math.min(t, this._$GetDuration$_())), t;
    }
    Play(t, s, i, e) {
        const h = this._$GetAudioElement$_();
        if (1 !== h.playbackRate && (h.playbackRate = 1), h.loop !== t && (h.loop = t), 
        this._$SetVolume$_(s), this._$_isMuted$_ = !1, h.muted && (h.muted = !1), h.currentTime !== i) try {
            h.currentTime = i;
        } catch (t) {
            console.warn(`[Construct] Exception seeking audio '${this._$_buffer$_._$GetUrl$_()}' to position '${i}': `, t);
        }
        this._$_audioDomHandler$_._$TryPlayMedia$_(h), this._$_isStopped$_ = !1, this._$_isPaused$_ = !1, 
        this._$_isLooping$_ = t, this._$_playbackRate$_ = 1;
    }
    _$Stop$_() {
        const t = this._$GetAudioElement$_();
        t.paused || t.pause(), this._$_audioDomHandler$_._$RemovePendingPlay$_(t), this._$_isStopped$_ = !0, 
        this._$_isPaused$_ = !1, this._$_instUid$_ = -1;
    }
    _$Pause$_() {
        if (this._$_isPaused$_ || this._$_isStopped$_ || this._$HasEnded$_()) return;
        const t = this._$GetAudioElement$_();
        t.paused || t.pause(), this._$_audioDomHandler$_._$RemovePendingPlay$_(t), this._$_isPaused$_ = !0;
    }
    _$Resume$_() {
        !this._$_isPaused$_ || this._$_isStopped$_ || this._$HasEnded$_() || (this._$_audioDomHandler$_._$TryPlayMedia$_(this._$GetAudioElement$_()), 
        this._$_isPaused$_ = !1);
    }
    _$_UpdateMuted$_() {
        this._$GetAudioElement$_().muted = this._$_isMuted$_ || this._$IsSilent$_();
    }
    _$SetLooping$_(t) {
        t = !!t, this._$_isLooping$_ !== t && (this._$_isLooping$_ = t, this._$GetAudioElement$_().loop = t);
    }
    _$_UpdatePlaybackRate$_() {
        let t = this._$_playbackRate$_;
        this._$_isTimescaled$_ && (t *= this._$_audioDomHandler$_._$GetTimeScale$_());
        try {
            this._$GetAudioElement$_().playbackRate = t;
        } catch (s) {
            console.warn(`[Construct] Unable to set playback rate '${t}':`, s);
        }
    }
    _$Seek$_(t) {
        if (!this._$_isStopped$_ && !this._$HasEnded$_()) try {
            this._$GetAudioElement$_().currentTime = t;
        } catch (s) {
            console.warn(`[Construct] Error seeking audio to '${t}': `, s);
        }
    }
    _$GetResumePosition$_() {
        return this._$GetPlaybackTime$_();
    }
    _$SetSuspended$_(t) {
        t ? this.IsPlaying() ? (this._$GetAudioElement$_().pause(), this._$_resumeMe$_ = !0) : this._$_resumeMe$_ = !1 : this._$_resumeMe$_ && (this._$_audioDomHandler$_._$TryPlayMedia$_(this._$GetAudioElement$_()), 
        this._$_resumeMe$_ = !1);
    }
}, self._$C3WebAudioInstance$_ = class extends self._$C3AudioInstance$_ {
    constructor(t, s, i) {
        super(t, s, i), this._$_bufferSource$_ = null, this._$_onended_handler$_ = t => this._$_OnEnded$_(t), 
        this._$_hasPlaybackEnded$_ = !0, this._$_activeSource$_ = null, this._$_playStartTime$_ = 0, 
        this._$_playFromSeekPos$_ = 0, this._$_resumePosition$_ = 0, this._$_muteVol$_ = 1;
    }
    _$Release$_() {
        this._$Stop$_(), this._$_ReleaseBufferSource$_(), this._$_onended_handler$_ = null, 
        super._$Release$_();
    }
    _$_ReleaseBufferSource$_() {
        this._$_bufferSource$_ && (this._$_bufferSource$_.onended = null, this._$_bufferSource$_.disconnect(), 
        this._$_bufferSource$_.buffer = null), this._$_bufferSource$_ = null, this._$_activeSource$_ = null;
    }
    _$_OnEnded$_(t) {
        this._$_isPaused$_ || this._$_resumeMe$_ || t.target === this._$_activeSource$_ && (this._$_hasPlaybackEnded$_ = !0, 
        this._$_isStopped$_ = !0, this._$_instUid$_ = -1, this._$_ReleaseBufferSource$_(), 
        this._$_audioDomHandler$_._$PostTrigger$_("ended", this._$_tags$_, this._$_aiId$_));
    }
    _$HasEnded$_() {
        return !(!this._$_isStopped$_ && this._$_bufferSource$_ && this._$_bufferSource$_.loop) && !this._$_isPaused$_ && this._$_hasPlaybackEnded$_;
    }
    _$CanBeRecycled$_() {
        return !(this._$_bufferSource$_ && !this._$_isStopped$_) || this._$HasEnded$_();
    }
    _$GetPlaybackTime$_() {
        let t = 0;
        return t = this._$_isPaused$_ ? this._$_resumePosition$_ : this._$_playFromSeekPos$_ + (this._$GetCurrentTime$_() - this._$_playStartTime$_) * this._$_playbackRate$_, 
        this._$_isLooping$_ || (t = Math.min(t, this._$GetDuration$_())), t;
    }
    Play(t, s, i, e) {
        this._$_isMuted$_ = !1, this._$_muteVol$_ = 1, this._$SetVolume$_(s), this._$_ReleaseBufferSource$_(), 
        this._$_bufferSource$_ = this._$GetAudioContext$_().createBufferSource(), this._$_bufferSource$_.buffer = this._$_buffer$_._$GetAudioBuffer$_(), 
        this._$_bufferSource$_.connect(this._$_gainNode$_), this._$_activeSource$_ = this._$_bufferSource$_, 
        this._$_bufferSource$_.onended = this._$_onended_handler$_, this._$_bufferSource$_.loop = t, 
        this._$_bufferSource$_.start(e, i), this._$_hasPlaybackEnded$_ = !1, this._$_isStopped$_ = !1, 
        this._$_isPaused$_ = !1, this._$_isLooping$_ = t, this._$_playbackRate$_ = 1, this._$_playStartTime$_ = this._$GetCurrentTime$_(), 
        this._$_playFromSeekPos$_ = i;
    }
    _$Stop$_() {
        if (this._$_bufferSource$_) try {
            this._$_bufferSource$_.stop(0);
        } catch (t) {}
        this._$_isStopped$_ = !0, this._$_isPaused$_ = !1, this._$_instUid$_ = -1;
    }
    _$Pause$_() {
        this._$_isPaused$_ || this._$_isStopped$_ || this._$HasEnded$_() || (this._$_resumePosition$_ = this._$GetPlaybackTime$_(), 
        this._$_isLooping$_ && (this._$_resumePosition$_ %= this._$GetDuration$_()), this._$_isPaused$_ = !0, 
        this._$_bufferSource$_.stop(0));
    }
    _$Resume$_() {
        !this._$_isPaused$_ || this._$_isStopped$_ || this._$HasEnded$_() || (this._$_ReleaseBufferSource$_(), 
        this._$_bufferSource$_ = this._$GetAudioContext$_().createBufferSource(), this._$_bufferSource$_.buffer = this._$_buffer$_._$GetAudioBuffer$_(), 
        this._$_bufferSource$_.connect(this._$_gainNode$_), this._$_activeSource$_ = this._$_bufferSource$_, 
        this._$_bufferSource$_.onended = this._$_onended_handler$_, this._$_bufferSource$_.loop = this._$_isLooping$_, 
        this._$_UpdateVolume$_(), this._$_UpdatePlaybackRate$_(), this._$_bufferSource$_.start(0, this._$_resumePosition$_), 
        this._$_playStartTime$_ = this._$GetCurrentTime$_(), this._$_playFromSeekPos$_ = this._$_resumePosition$_, 
        this._$_isPaused$_ = !1);
    }
    _$GetOutputVolume$_() {
        return super._$GetOutputVolume$_() * this._$_muteVol$_;
    }
    _$_UpdateMuted$_() {
        this._$_muteVol$_ = this._$_isMuted$_ || this._$IsSilent$_() ? 0 : 1, this._$_UpdateVolume$_();
    }
    _$SetLooping$_(t) {
        t = !!t, this._$_isLooping$_ !== t && (this._$_isLooping$_ = t, this._$_bufferSource$_ && (this._$_bufferSource$_.loop = t));
    }
    _$_UpdatePlaybackRate$_() {
        let t = this._$_playbackRate$_;
        this._$_isTimescaled$_ && (t *= this._$_audioDomHandler$_._$GetTimeScale$_()), this._$_bufferSource$_ && (this._$_bufferSource$_.playbackRate.value = t);
    }
    _$Seek$_(t) {
        this._$_isStopped$_ || this._$HasEnded$_() || (this._$_isPaused$_ ? this._$_resumePosition$_ = t : (this._$Pause$_(), 
        this._$_resumePosition$_ = t, this._$Resume$_()));
    }
    _$GetResumePosition$_() {
        return this._$_resumePosition$_;
    }
    _$SetSuspended$_(t) {
        t ? this.IsPlaying() ? (this._$_resumeMe$_ = !0, this._$_resumePosition$_ = this._$GetPlaybackTime$_(), 
        this._$_isLooping$_ && (this._$_resumePosition$_ %= this._$GetDuration$_()), this._$_bufferSource$_.stop(0)) : this._$_resumeMe$_ = !1 : this._$_resumeMe$_ && (this._$_ReleaseBufferSource$_(), 
        this._$_bufferSource$_ = this._$GetAudioContext$_().createBufferSource(), this._$_bufferSource$_.buffer = this._$_buffer$_._$GetAudioBuffer$_(), 
        this._$_bufferSource$_.connect(this._$_gainNode$_), this._$_activeSource$_ = this._$_bufferSource$_, 
        this._$_bufferSource$_.onended = this._$_onended_handler$_, this._$_bufferSource$_.loop = this._$_isLooping$_, 
        this._$_UpdateVolume$_(), this._$_UpdatePlaybackRate$_(), this._$_bufferSource$_.start(0, this._$_resumePosition$_), 
        this._$_playStartTime$_ = this._$GetCurrentTime$_(), this._$_playFromSeekPos$_ = this._$_resumePosition$_, 
        this._$_resumeMe$_ = !1);
    }
    _$_LoadAdditionalState$_(t) {
        super._$_LoadAdditionalState$_(t), this._$_resumePosition$_ = t.resumePosition;
    }
};

{
    class q {
        constructor(t) {
            this._$_audioDomHandler$_ = t, this._$_audioContext$_ = t._$GetAudioContext$_(), 
            this._$_index$_ = -1, this._$_tag$_ = "", this._$_type$_ = "", this._$_params$_ = null;
        }
        _$Release$_() {
            this._$_audioContext$_ = null;
        }
        _$_SetIndex$_(t) {
            this._$_index$_ = t;
        }
        _$GetIndex$_() {
            return this._$_index$_;
        }
        _$_SetTag$_(t) {
            this._$_tag$_ = t;
        }
        _$GetTag$_() {
            return this._$_tag$_;
        }
        _$CreateGain$_() {
            return this._$_audioContext$_.createGain();
        }
        _$GetInputNode$_() {}
        _$ConnectTo$_(t) {}
        _$SetAudioParam$_(t, s, i, e) {
            if (t.cancelScheduledValues(0), 0 === e) return void (t.value = s);
            const h = this._$_audioContext$_.currentTime;
            switch (e += h, i) {
              case 0:
                t.setValueAtTime(s, e);
                break;

              case 1:
                t.setValueAtTime(t.value, h), t.linearRampToValueAtTime(s, e);
                break;

              case 2:
                t.setValueAtTime(t.value, h), t.exponentialRampToValueAtTime(s, e);
            }
        }
        _$GetState$_() {
            return {
                type: this._$_type$_,
                tag: this._$_tag$_,
                params: this._$_params$_
            };
        }
    }
    self._$C3AudioFilterFX$_ = class extends q {
        constructor(t, s, i, e, h, n, o) {
            super(t), this._$_type$_ = "filter", this._$_params$_ = [ s, i, e, h, n, o ], this._$_inputNode$_ = this._$CreateGain$_(), 
            this._$_wetNode$_ = this._$CreateGain$_(), this._$_wetNode$_.gain.value = o, this._$_dryNode$_ = this._$CreateGain$_(), 
            this._$_dryNode$_.gain.value = 1 - o, this._$_filterNode$_ = this._$_audioContext$_.createBiquadFilter(), 
            this._$_filterNode$_.type = s, this._$_filterNode$_.frequency.value = i, this._$_filterNode$_.detune.value = e, 
            this._$_filterNode$_.Q.value = h, this._$_filterNode$_.gain.vlaue = n, this._$_inputNode$_.connect(this._$_filterNode$_), 
            this._$_inputNode$_.connect(this._$_dryNode$_), this._$_filterNode$_.connect(this._$_wetNode$_);
        }
        _$Release$_() {
            this._$_inputNode$_.disconnect(), this._$_filterNode$_.disconnect(), this._$_wetNode$_.disconnect(), 
            this._$_dryNode$_.disconnect(), super._$Release$_();
        }
        _$ConnectTo$_(t) {
            this._$_wetNode$_.disconnect(), this._$_wetNode$_.connect(t), this._$_dryNode$_.disconnect(), 
            this._$_dryNode$_.connect(t);
        }
        _$GetInputNode$_() {
            return this._$_inputNode$_;
        }
        _$SetParam$_(t, s, i, e) {
            switch (t) {
              case 0:
                s = Math.max(Math.min(s / 100, 1), 0), this._$_params$_[5] = s, this._$SetAudioParam$_(this._$_wetNode$_.gain, s, i, e), 
                this._$SetAudioParam$_(this._$_dryNode$_.gain, 1 - s, i, e);
                break;

              case 1:
                this._$_params$_[1] = s, this._$SetAudioParam$_(this._$_filterNode$_.frequency, s, i, e);
                break;

              case 2:
                this._$_params$_[2] = s, this._$SetAudioParam$_(this._$_filterNode$_.detune, s, i, e);
                break;

              case 3:
                this._$_params$_[3] = s, this._$SetAudioParam$_(this._$_filterNode$_.Q, s, i, e);
                break;

              case 4:
                this._$_params$_[4] = s, this._$SetAudioParam$_(this._$_filterNode$_.gain, s, i, e);
            }
        }
    }, self._$C3AudioDelayFX$_ = class extends q {
        constructor(t, s, i, e) {
            super(t), this._$_type$_ = "delay", this._$_params$_ = [ s, i, e ], this._$_inputNode$_ = this._$CreateGain$_(), 
            this._$_wetNode$_ = this._$CreateGain$_(), this._$_wetNode$_.gain.value = e, this._$_dryNode$_ = this._$CreateGain$_(), 
            this._$_dryNode$_.gain.value = 1 - e, this._$_mainNode$_ = this._$CreateGain$_(), 
            this._$_delayNode$_ = this._$_audioContext$_.createDelay(s), this._$_delayNode$_.delayTime.value = s, 
            this._$_delayGainNode$_ = this._$CreateGain$_(), this._$_delayGainNode$_.gain.value = i, 
            this._$_inputNode$_.connect(this._$_mainNode$_), this._$_inputNode$_.connect(this._$_dryNode$_), 
            this._$_mainNode$_.connect(this._$_wetNode$_), this._$_mainNode$_.connect(this._$_delayNode$_), 
            this._$_delayNode$_.connect(this._$_delayGainNode$_), this._$_delayGainNode$_.connect(this._$_mainNode$_);
        }
        _$Release$_() {
            this._$_inputNode$_.disconnect(), this._$_wetNode$_.disconnect(), this._$_dryNode$_.disconnect(), 
            this._$_mainNode$_.disconnect(), this._$_delayNode$_.disconnect(), this._$_delayGainNode$_.disconnect(), 
            super._$Release$_();
        }
        _$ConnectTo$_(t) {
            this._$_wetNode$_.disconnect(), this._$_wetNode$_.connect(t), this._$_dryNode$_.disconnect(), 
            this._$_dryNode$_.connect(t);
        }
        _$GetInputNode$_() {
            return this._$_inputNode$_;
        }
        _$SetParam$_(t, s, i, e) {
            const h = self._$AudioDOMHandler$_._$DbToLinear$_;
            switch (t) {
              case 0:
                s = Math.max(Math.min(s / 100, 1), 0), this._$_params$_[2] = s, this._$SetAudioParam$_(this._$_wetNode$_.gain, s, i, e), 
                this._$SetAudioParam$_(this._$_dryNode$_.gain, 1 - s, i, e);
                break;

              case 4:
                this._$_params$_[1] = h(s), this._$SetAudioParam$_(this._$_delayGainNode$_.gain, h(s), i, e);
                break;

              case 5:
                this._$_params$_[0] = s, this._$SetAudioParam$_(this._$_delayNode$_.delayTime, s, i, e);
            }
        }
    }, self._$C3AudioConvolveFX$_ = class extends q {
        constructor(t, s, i, e) {
            super(t), this._$_type$_ = "convolution", this._$_params$_ = [ i, e ], this._$_bufferOriginalUrl$_ = "", 
            this._$_bufferUrl$_ = "", this._$_bufferType$_ = "", this._$_inputNode$_ = this._$CreateGain$_(), 
            this._$_wetNode$_ = this._$CreateGain$_(), this._$_wetNode$_.gain.value = e, this._$_dryNode$_ = this._$CreateGain$_(), 
            this._$_dryNode$_.gain.value = 1 - e, this._$_convolveNode$_ = this._$_audioContext$_.createConvolver(), 
            this._$_convolveNode$_.normalize = i, this._$_convolveNode$_.buffer = s, this._$_inputNode$_.connect(this._$_convolveNode$_), 
            this._$_inputNode$_.connect(this._$_dryNode$_), this._$_convolveNode$_.connect(this._$_wetNode$_);
        }
        _$Release$_() {
            this._$_inputNode$_.disconnect(), this._$_convolveNode$_.disconnect(), this._$_wetNode$_.disconnect(), 
            this._$_dryNode$_.disconnect(), super._$Release$_();
        }
        _$ConnectTo$_(t) {
            this._$_wetNode$_.disconnect(), this._$_wetNode$_.connect(t), this._$_dryNode$_.disconnect(), 
            this._$_dryNode$_.connect(t);
        }
        _$GetInputNode$_() {
            return this._$_inputNode$_;
        }
        _$SetParam$_(t, s, i, e) {
            0 === t && (s = Math.max(Math.min(s / 100, 1), 0), this._$_params$_[1] = s, this._$SetAudioParam$_(this._$_wetNode$_.gain, s, i, e), 
            this._$SetAudioParam$_(this._$_dryNode$_.gain, 1 - s, i, e));
        }
        _$_SetBufferInfo$_(t, s, i) {
            this._$_bufferOriginalUrl$_ = t, this._$_bufferUrl$_ = s, this._$_bufferType$_ = i;
        }
        _$GetState$_() {
            const t = super._$GetState$_();
            return t.bufferOriginalUrl = this._$_bufferOriginalUrl$_, t.bufferUrl = "", t.bufferType = this._$_bufferType$_, 
            t;
        }
    }, self._$C3AudioFlangerFX$_ = class extends q {
        constructor(t, s, i, e, h, n) {
            super(t), this._$_type$_ = "flanger", this._$_params$_ = [ s, i, e, h, n ], this._$_inputNode$_ = this._$CreateGain$_(), 
            this._$_dryNode$_ = this._$CreateGain$_(), this._$_dryNode$_.gain.value = 1 - n / 2, 
            this._$_wetNode$_ = this._$CreateGain$_(), this._$_wetNode$_.gain.value = n / 2, 
            this._$_feedbackNode$_ = this._$CreateGain$_(), this._$_feedbackNode$_.gain.value = h, 
            this._$_delayNode$_ = this._$_audioContext$_.createDelay(s + i), this._$_delayNode$_.delayTime.value = s, 
            this._$_oscNode$_ = this._$_audioContext$_.createOscillator(), this._$_oscNode$_.frequency.value = e, 
            this._$_oscGainNode$_ = this._$CreateGain$_(), this._$_oscGainNode$_.gain.value = i, 
            this._$_inputNode$_.connect(this._$_delayNode$_), this._$_inputNode$_.connect(this._$_dryNode$_), 
            this._$_delayNode$_.connect(this._$_wetNode$_), this._$_delayNode$_.connect(this._$_feedbackNode$_), 
            this._$_feedbackNode$_.connect(this._$_delayNode$_), this._$_oscNode$_.connect(this._$_oscGainNode$_), 
            this._$_oscGainNode$_.connect(this._$_delayNode$_.delayTime), this._$_oscNode$_.start(0);
        }
        _$Release$_() {
            this._$_oscNode$_.stop(0), this._$_inputNode$_.disconnect(), this._$_delayNode$_.disconnect(), 
            this._$_oscNode$_.disconnect(), this._$_oscGainNode$_.disconnect(), this._$_dryNode$_.disconnect(), 
            this._$_wetNode$_.disconnect(), this._$_feedbackNode$_.disconnect(), super._$Release$_();
        }
        _$ConnectTo$_(t) {
            this._$_wetNode$_.disconnect(), this._$_wetNode$_.connect(t), this._$_dryNode$_.disconnect(), 
            this._$_dryNode$_.connect(t);
        }
        _$GetInputNode$_() {
            return this._$_inputNode$_;
        }
        _$SetParam$_(t, s, i, e) {
            switch (t) {
              case 0:
                s = Math.max(Math.min(s / 100, 1), 0), this._$_params$_[4] = s, this._$SetAudioParam$_(this._$_wetNode$_.gain, s / 2, i, e), 
                this._$SetAudioParam$_(this._$_dryNode$_.gain, 1 - s / 2, i, e);
                break;

              case 6:
                this._$_params$_[1] = s / 1e3, this._$SetAudioParam$_(this._$_oscGainNode$_.gain, s / 1e3, i, e);
                break;

              case 7:
                this._$_params$_[2] = s, this._$SetAudioParam$_(this._$_oscNode$_.frequency, s, i, e);
                break;

              case 8:
                this._$_params$_[3] = s / 100, this._$SetAudioParam$_(this._$_feedbackNode$_.gain, s / 100, i, e);
            }
        }
    }, self._$C3AudioPhaserFX$_ = class extends q {
        constructor(t, s, i, e, h, n, o) {
            super(t), this._$_type$_ = "phaser", this._$_params$_ = [ s, i, e, h, n, o ], this._$_inputNode$_ = this._$CreateGain$_(), 
            this._$_dryNode$_ = this._$CreateGain$_(), this._$_dryNode$_.gain.value = 1 - o / 2, 
            this._$_wetNode$_ = this._$CreateGain$_(), this._$_wetNode$_.gain.value = o / 2, 
            this._$_filterNode$_ = this._$_audioContext$_.createBiquadFilter(), this._$_filterNode$_.type = "allpass", 
            this._$_filterNode$_.frequency.value = s, this._$_filterNode$_.detune.value = i, 
            this._$_filterNode$_.Q.value = e, this._$_oscNode$_ = this._$_audioContext$_.createOscillator(), 
            this._$_oscNode$_.frequency.value = n, this._$_oscGainNode$_ = this._$CreateGain$_(), 
            this._$_oscGainNode$_.gain.value = h, this._$_inputNode$_.connect(this._$_filterNode$_), 
            this._$_inputNode$_.connect(this._$_dryNode$_), this._$_filterNode$_.connect(this._$_wetNode$_), 
            this._$_oscNode$_.connect(this._$_oscGainNode$_), this._$_oscGainNode$_.connect(this._$_filterNode$_.frequency), 
            this._$_oscNode$_.start(0);
        }
        _$Release$_() {
            this._$_oscNode$_.stop(0), this._$_inputNode$_.disconnect(), this._$_filterNode$_.disconnect(), 
            this._$_oscNode$_.disconnect(), this._$_oscGainNode$_.disconnect(), this._$_dryNode$_.disconnect(), 
            this._$_wetNode$_.disconnect(), super._$Release$_();
        }
        _$ConnectTo$_(t) {
            this._$_wetNode$_.disconnect(), this._$_wetNode$_.connect(t), this._$_dryNode$_.disconnect(), 
            this._$_dryNode$_.connect(t);
        }
        _$GetInputNode$_() {
            return this._$_inputNode$_;
        }
        _$SetParam$_(t, s, i, e) {
            switch (t) {
              case 0:
                s = Math.max(Math.min(s / 100, 1), 0), this._$_params$_[5] = s, this._$SetAudioParam$_(this._$_wetNode$_.gain, s / 2, i, e), 
                this._$SetAudioParam$_(this._$_dryNode$_.gain, 1 - s / 2, i, e);
                break;

              case 1:
                this._$_params$_[0] = s, this._$SetAudioParam$_(this._$_filterNode$_.frequency, s, i, e);
                break;

              case 2:
                this._$_params$_[1] = s, this._$SetAudioParam$_(this._$_filterNode$_.detune, s, i, e);
                break;

              case 3:
                this._$_params$_[2] = s, this._$SetAudioParam$_(this._$_filterNode$_.Q, s, i, e);
                break;

              case 6:
                this._$_params$_[3] = s, this._$SetAudioParam$_(this._$_oscGainNode$_.gain, s, i, e);
                break;

              case 7:
                this._$_params$_[4] = s, this._$SetAudioParam$_(this._$_oscNode$_.frequency, s, i, e);
            }
        }
    }, self._$C3AudioGainFX$_ = class extends q {
        constructor(t, s) {
            super(t), this._$_type$_ = "gain", this._$_params$_ = [ s ], this._$_node$_ = this._$CreateGain$_(), 
            this._$_node$_.gain.value = s;
        }
        _$Release$_() {
            this._$_node$_.disconnect(), super._$Release$_();
        }
        _$ConnectTo$_(t) {
            this._$_node$_.disconnect(), this._$_node$_.connect(t);
        }
        _$GetInputNode$_() {
            return this._$_node$_;
        }
        _$SetParam$_(t, s, i, e) {
            const h = self._$AudioDOMHandler$_._$DbToLinear$_;
            4 === t && (this._$_params$_[0] = h(s), this._$SetAudioParam$_(this._$_node$_.gain, h(s), i, e));
        }
    }, self._$C3AudioStereoPanFX$_ = class extends q {
        constructor(t, s) {
            super(t), this._$_type$_ = "stereopan", this._$_params$_ = [ s ], this._$_node$_ = this._$_audioContext$_.createStereoPanner(), 
            this._$_node$_.pan.value = s;
        }
        _$Release$_() {
            this._$_node$_.disconnect(), super._$Release$_();
        }
        _$ConnectTo$_(t) {
            this._$_node$_.disconnect(), this._$_node$_.connect(t);
        }
        _$GetInputNode$_() {
            return this._$_node$_;
        }
        _$SetParam$_(t, s, i, e) {
            s = Math.min(Math.max(s / 100, -1), 1), 9 === t && (this._$_params$_[0] = s, this._$SetAudioParam$_(this._$_node$_.pan, s, i, e));
        }
    }, self._$C3AudioTremoloFX$_ = class extends q {
        constructor(t, s, i) {
            super(t), this._$_type$_ = "tremolo", this._$_params$_ = [ s, i ], this._$_node$_ = this._$CreateGain$_(), 
            this._$_node$_.gain.value = 1 - i / 2, this._$_oscNode$_ = this._$_audioContext$_.createOscillator(), 
            this._$_oscNode$_.frequency.value = s, this._$_oscGainNode$_ = this._$CreateGain$_(), 
            this._$_oscGainNode$_.gain.value = i / 2, this._$_oscNode$_.connect(this._$_oscGainNode$_), 
            this._$_oscGainNode$_.connect(this._$_node$_.gain), this._$_oscNode$_.start(0);
        }
        _$Release$_() {
            this._$_oscNode$_.stop(0), this._$_oscNode$_.disconnect(), this._$_oscGainNode$_.disconnect(), 
            this._$_node$_.disconnect(), super._$Release$_();
        }
        _$ConnectTo$_(t) {
            this._$_node$_.disconnect(), this._$_node$_.connect(t);
        }
        _$GetInputNode$_() {
            return this._$_node$_;
        }
        _$SetParam$_(t, s, i, e) {
            switch (t) {
              case 0:
                s = Math.max(Math.min(s / 100, 1), 0), this._$_params$_[1] = s, this._$SetAudioParam$_(this._$_node$_.gain, 1 - s / 2, i, e), 
                this._$SetAudioParam$_(this._$_oscGainNode$_.gain, s / 2, i, e);
                break;

              case 7:
                this._$_params$_[0] = s, this._$SetAudioParam$_(this._$_oscNode$_.frequency, s, i, e);
            }
        }
    }, self._$C3AudioRingModFX$_ = class extends q {
        constructor(t, s, i) {
            super(t), this._$_type$_ = "ringmod", this._$_params$_ = [ s, i ], this._$_inputNode$_ = this._$CreateGain$_(), 
            this._$_wetNode$_ = this._$CreateGain$_(), this._$_wetNode$_.gain.value = i, this._$_dryNode$_ = this._$CreateGain$_(), 
            this._$_dryNode$_.gain.value = 1 - i, this._$_ringNode$_ = this._$CreateGain$_(), 
            this._$_ringNode$_.gain.value = 0, this._$_oscNode$_ = this._$_audioContext$_.createOscillator(), 
            this._$_oscNode$_.frequency.value = s, this._$_oscNode$_.connect(this._$_ringNode$_.gain), 
            this._$_oscNode$_.start(0), this._$_inputNode$_.connect(this._$_ringNode$_), this._$_inputNode$_.connect(this._$_dryNode$_), 
            this._$_ringNode$_.connect(this._$_wetNode$_);
        }
        _$Release$_() {
            this._$_oscNode$_.stop(0), this._$_oscNode$_.disconnect(), this._$_ringNode$_.disconnect(), 
            this._$_inputNode$_.disconnect(), this._$_wetNode$_.disconnect(), this._$_dryNode$_.disconnect(), 
            super._$Release$_();
        }
        _$ConnectTo$_(t) {
            this._$_wetNode$_.disconnect(), this._$_wetNode$_.connect(t), this._$_dryNode$_.disconnect(), 
            this._$_dryNode$_.connect(t);
        }
        _$GetInputNode$_() {
            return this._$_inputNode$_;
        }
        _$SetParam$_(t, s, i, e) {
            switch (t) {
              case 0:
                s = Math.max(Math.min(s / 100, 1), 0), this._$_params$_[1] = s, this._$SetAudioParam$_(this._$_wetNode$_.gain, s, i, e), 
                this._$SetAudioParam$_(this._$_dryNode$_.gain, 1 - s, i, e);
                break;

              case 7:
                this._$_params$_[0] = s, this._$SetAudioParam$_(this._$_oscNode$_.frequency, s, i, e);
            }
        }
    }, self._$C3AudioDistortionFX$_ = class extends q {
        constructor(t, s, i, e, h, n) {
            super(t), this._$_type$_ = "distortion", this._$_params$_ = [ s, i, e, h, n ], this._$_inputNode$_ = this._$CreateGain$_(), 
            this._$_preGain$_ = this._$CreateGain$_(), this._$_postGain$_ = this._$CreateGain$_(), 
            this._$_SetDrive$_(e, h), this._$_wetNode$_ = this._$CreateGain$_(), this._$_wetNode$_.gain.value = n, 
            this._$_dryNode$_ = this._$CreateGain$_(), this._$_dryNode$_.gain.value = 1 - n, 
            this._$_waveShaper$_ = this._$_audioContext$_.createWaveShaper(), this._$_curve$_ = new Float32Array(65536), 
            this._$_GenerateColortouchCurve$_(s, i), this._$_waveShaper$_.curve = this._$_curve$_, 
            this._$_inputNode$_.connect(this._$_preGain$_), this._$_inputNode$_.connect(this._$_dryNode$_), 
            this._$_preGain$_.connect(this._$_waveShaper$_), this._$_waveShaper$_.connect(this._$_postGain$_), 
            this._$_postGain$_.connect(this._$_wetNode$_);
        }
        _$Release$_() {
            this._$_inputNode$_.disconnect(), this._$_preGain$_.disconnect(), this._$_waveShaper$_.disconnect(), 
            this._$_postGain$_.disconnect(), this._$_wetNode$_.disconnect(), this._$_dryNode$_.disconnect(), 
            super._$Release$_();
        }
        _$_SetDrive$_(t, s) {
            t < .01 && (t = .01), this._$_preGain$_.gain.value = t, this._$_postGain$_.gain.value = Math.pow(1 / t, .6) * s;
        }
        _$_GenerateColortouchCurve$_(t, s) {
            const i = 32768;
            for (let e = 0; e < i; ++e) {
                let h = e / i;
                h = this._$_Shape$_(h, t, s), this._$_curve$_[i + e] = h, this._$_curve$_[i - e - 1] = -h;
            }
        }
        _$_Shape$_(t, s, i) {
            const e = 1.05 * i * s - s, h = t < 0 ? -1 : 1, n = t < 0 ? -t : t;
            let o = n < s ? n : s + e * self._$AudioDOMHandler$_._$e4$_(n - s, 1 / e);
            return o *= h, o;
        }
        _$ConnectTo$_(t) {
            this._$_wetNode$_.disconnect(), this._$_wetNode$_.connect(t), this._$_dryNode$_.disconnect(), 
            this._$_dryNode$_.connect(t);
        }
        _$GetInputNode$_() {
            return this._$_inputNode$_;
        }
        _$SetParam$_(t, s, i, e) {
            0 === t && (s = Math.max(Math.min(s / 100, 1), 0), this._$_params$_[4] = s, this._$SetAudioParam$_(this._$_wetNode$_.gain, s, i, e), 
            this._$SetAudioParam$_(this._$_dryNode$_.gain, 1 - s, i, e));
        }
    }, self._$C3AudioCompressorFX$_ = class extends q {
        constructor(t, s, i, e, h, n) {
            super(t), this._$_type$_ = "compressor", this._$_params$_ = [ s, i, e, h, n ], this._$_node$_ = this._$_audioContext$_.createDynamicsCompressor(), 
            this._$_node$_.threshold.value = s, this._$_node$_.knee.value = i, this._$_node$_.ratio.value = e, 
            this._$_node$_.attack.value = h, this._$_node$_.release.value = n;
        }
        _$Release$_() {
            this._$_node$_.disconnect(), super._$Release$_();
        }
        _$ConnectTo$_(t) {
            this._$_node$_.disconnect(), this._$_node$_.connect(t);
        }
        _$GetInputNode$_() {
            return this._$_node$_;
        }
        _$SetParam$_(t, s, i, e) {}
    }, self._$C3AudioAnalyserFX$_ = class extends q {
        constructor(t, s, i) {
            super(t), this._$_type$_ = "analyser", this._$_params$_ = [ s, i ], this._$_node$_ = this._$_audioContext$_.createAnalyser(), 
            this._$_node$_.fftSize = s, this._$_node$_.smoothingTimeConstant = i, this._$_freqBins$_ = new Float32Array(this._$_node$_.frequencyBinCount), 
            this._$_signal$_ = new Uint8Array(s), this._$_peak$_ = 0, this._$_rms$_ = 0, this._$_audioDomHandler$_._$_AddAnalyser$_(this);
        }
        _$Release$_() {
            this._$_audioDomHandler$_._$_RemoveAnalyser$_(this), this._$_node$_.disconnect(), 
            super._$Release$_();
        }
        _$Tick$_() {
            this._$_node$_.getFloatFrequencyData(this._$_freqBins$_), this._$_node$_.getByteTimeDomainData(this._$_signal$_);
            const t = this._$_node$_.fftSize;
            this._$_peak$_ = 0;
            let s = 0;
            for (let i = 0; i < t; ++i) {
                let t = (this._$_signal$_[i] - 128) / 128;
                t < 0 && (t = -t), this._$_peak$_ < t && (this._$_peak$_ = t), s += t * t;
            }
            const i = self._$AudioDOMHandler$_._$LinearToDb$_;
            this._$_peak$_ = i(this._$_peak$_), this._$_rms$_ = i(Math.sqrt(s / t));
        }
        _$ConnectTo$_(t) {
            this._$_node$_.disconnect(), this._$_node$_.connect(t);
        }
        _$GetInputNode$_() {
            return this._$_node$_;
        }
        _$SetParam$_(t, s, i, e) {}
        _$GetData$_() {
            return {
                tag: this._$GetTag$_(),
                index: this._$GetIndex$_(),
                peak: this._$_peak$_,
                rms: this._$_rms$_,
                binCount: this._$_node$_.frequencyBinCount,
                freqBins: this._$_freqBins$_
            };
        }
    };
}

if (window.C3_Is_Supported) {
    const X = !1;
    window.c3_runtimeInterface = new self._$RuntimeInterface$_({
        _$useWorker$_: X,
        _$workerMainUrl$_: "workermain.js",
        _$runtimeScriptList$_: [ "scripts/c3main.js" ],
        _$scriptFolder$_: "scripts/",
        _$exportType$_: "html5"
    });
}